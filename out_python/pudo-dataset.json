{
    "repository": "pudo/dataset",
    "clone_url": "https://github.com/pudo/dataset.git",
    "timestamp": "2023-05-29T14:46:23.426556Z",
    "clone_success": true,
    "number of actions": 1,
    "number_of_test_actions": 1,
    "actions_successful": false,
    "actions_stdout": "[build/python] \ud83d\ude80  Start image=crawlergpt:latest\n[build/python]   \ud83d\udc33  docker pull image=crawlergpt:latest platform= username= forcePull=false\n[build/python]   \ud83d\udc33  docker create image=crawlergpt:latest platform= entrypoint=[\"tail\" \"-f\" \"/dev/null\"] cmd=[]\n[build/python]   \ud83d\udc33  docker run image=crawlergpt:latest platform= entrypoint=[\"tail\" \"-f\" \"/dev/null\"] cmd=[]\n[build/python]   \ud83d\udc33  docker exec cmd=[chown -R 1012:1000 /tmp/de65f406-fe28-11ed-a890-af2cc187fc11/pudo-dataset] user=0 workdir=\n[build/python]   \u2601  git clone 'https://github.com/actions/setup-python' # ref=v1\n[build/python]   \u2601  git clone 'https://github.com/pypa/gh-action-pypi-publish' # ref=master\n[build/python] \u2b50 Run Main actions/checkout@v1\n[build/python]   \u2705  Success - Main actions/checkout@v1\n[build/python] \u2b50 Run Main Show ref\n[build/python]   \ud83d\udc33  docker exec cmd=[bash --noprofile --norc -e -o pipefail /var/run/act/workflow/1] user= workdir=\n[build/python]   | refs/heads/master\n[build/python]   \u2705  Success - Main Show ref\n[build/python] \u2b50 Run Main Set up Python\n[build/python]   \ud83d\udc33  docker cp src=/home/andre-silva/.cache/act/actions-setup-python@v1/ dst=/var/run/act/actions/actions-setup-python@v1/\n[build/python]   \ud83d\udc33  docker exec cmd=[chown -R 1012:1000 /var/run/act/actions/actions-setup-python@v1/] user=0 workdir=\n[build/python]   \ud83d\udc33  docker exec cmd=[node /var/run/act/actions/actions-setup-python@v1/dist/index.js] user= workdir=\n[build/python]   \ud83d\udcac  ::debug::Semantic version spec of 3.x is 3.x\n[build/python]   \ud83d\udcac  ::debug::isExplicit: \n[build/python]   \ud83d\udcac  ::debug::explicit? false\n[build/python]   \ud83d\udcac  ::debug::isExplicit: 2.7.18\n[build/python]   \ud83d\udcac  ::debug::explicit? true\n[build/python]   \ud83d\udcac  ::debug::isExplicit: 3.5.10\n[build/python]   \ud83d\udcac  ::debug::explicit? true\n[build/python]   \ud83d\udcac  ::debug::isExplicit: 3.6.14\n[build/python]   \ud83d\udcac  ::debug::explicit? true\n[build/python]   \ud83d\udcac  ::debug::isExplicit: 3.7.11\n[build/python]   \ud83d\udcac  ::debug::explicit? true\n[build/python]   \ud83d\udcac  ::debug::isExplicit: 3.8.11\n[build/python]   \ud83d\udcac  ::debug::explicit? true\n[build/python]   \ud83d\udcac  ::debug::isExplicit: 3.9.6\n[build/python]   \ud83d\udcac  ::debug::explicit? true\n[build/python]   \ud83d\udcac  ::debug::evaluating 6 versions\n[build/python]   \ud83d\udcac  ::debug::matched: 3.9.6\n[build/python]   \ud83d\udcac  ::debug::checking cache: /opt/hostedtoolcache/Python/3.9.6/x64\n[build/python]   \ud83d\udcac  ::debug::Found tool in cache Python 3.9.6 x64\n[build/python]   | Successfully setup CPython (3.9.6)\n[build/python]   \u2753 add-matcher /run/act/actions/actions-setup-python@v1/.github/python.json\n[build/python]   \u2705  Success - Main Set up Python\n[build/python]   \u2699  ::set-env:: pythonLocation=/opt/hostedtoolcache/Python/3.9.6/x64\n[build/python]   \u2699  ::set-output:: python-version=3.9.6\n[build/python]   \u2699  ::add-path:: /opt/hostedtoolcache/Python/3.9.6/x64\n[build/python]   \u2699  ::add-path:: /opt/hostedtoolcache/Python/3.9.6/x64/bin\n[build/python] \u2b50 Run Main Install dependencies\n[build/python]   \ud83d\udc33  docker exec cmd=[bash --noprofile --norc -e -o pipefail /var/run/act/workflow/3] user= workdir=\n[build/python]   | W: An error occurred during the signature verification. The repository is not updated and the previous index files will be used. GPG error: http://dl.google.com/linux/chrome/deb stable InRelease: The following signatures couldn't be verified because the public key is not available: NO_PUBKEY 4EB27DB2A3B88B8B\n[build/python]   | W: Failed to fetch http://dl.google.com/linux/chrome/deb/dists/stable/InRelease  The following signatures couldn't be verified because the public key is not available: NO_PUBKEY 4EB27DB2A3B88B8B\n[build/python]   | W: Some index files failed to download. They have been ignored, or old ones used instead.\n[build/python]   | Obtaining file:///tmp/de65f406-fe28-11ed-a890-af2cc187fc11/pudo-dataset\n[build/python]   | Collecting sqlalchemy<2.0.0,>=1.3.2\n[build/python]   |   Downloading SQLAlchemy-1.4.48-cp39-cp39-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl (1.6 MB)\n[build/python]   | Collecting alembic>=0.6.2\n[build/python]   |   Downloading alembic-1.11.1-py3-none-any.whl (224 kB)\n[build/python]   | Collecting banal>=1.0.1\n[build/python]   |   Downloading banal-1.0.6-py2.py3-none-any.whl (6.1 kB)\n[build/python]   | Requirement already satisfied: pip in /opt/hostedtoolcache/Python/3.9.6/x64/lib/python3.9/site-packages (from dataset==1.6.0) (21.2.4)\n[build/python]   | Collecting pytest\n[build/python]   |   Downloading pytest-7.3.1-py3-none-any.whl (320 kB)\n[build/python]   | Collecting wheel\n[build/python]   |   Downloading wheel-0.40.0-py3-none-any.whl (64 kB)\n[build/python]   | Collecting flake8\n[build/python]   |   Downloading flake8-6.0.0-py2.py3-none-any.whl (57 kB)\n[build/python]   | Collecting coverage\n[build/python]   |   Downloading coverage-7.2.6-cp39-cp39-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl (228 kB)\n[build/python]   | Collecting psycopg2-binary\n[build/python]   |   Downloading psycopg2_binary-2.9.6-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (3.0 MB)\n[build/python]   | Collecting PyMySQL\n[build/python]   |   Downloading PyMySQL-1.0.3-py3-none-any.whl (43 kB)\n[build/python]   | Collecting cryptography\n[build/python]   |   Downloading cryptography-40.0.2-cp36-abi3-manylinux_2_28_x86_64.whl (3.7 MB)\n[build/python]   | Collecting Mako\n[build/python]   |   Downloading Mako-1.2.4-py3-none-any.whl (78 kB)\n[build/python]   | Collecting typing-extensions>=4\n[build/python]   |   Downloading typing_extensions-4.6.2-py3-none-any.whl (31 kB)\n[build/python]   | Collecting greenlet!=0.4.17\n[build/python]   |   Downloading greenlet-2.0.2-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (610 kB)\n[build/python]   | Collecting cffi>=1.12\n[build/python]   |   Downloading cffi-1.15.1-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (441 kB)\n[build/python]   | Collecting pycparser\n[build/python]   |   Downloading pycparser-2.21-py2.py3-none-any.whl (118 kB)\n[build/python]   | Collecting mccabe<0.8.0,>=0.7.0\n[build/python]   |   Downloading mccabe-0.7.0-py2.py3-none-any.whl (7.3 kB)\n[build/python]   | Collecting pyflakes<3.1.0,>=3.0.0\n[build/python]   |   Downloading pyflakes-3.0.1-py2.py3-none-any.whl (62 kB)\n[build/python]   | Collecting pycodestyle<2.11.0,>=2.10.0\n[build/python]   |   Downloading pycodestyle-2.10.0-py2.py3-none-any.whl (41 kB)\n[build/python]   | Collecting MarkupSafe>=0.9.2\n[build/python]   |   Downloading MarkupSafe-2.1.2-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (25 kB)\n[build/python]   | Collecting tomli>=1.0.0\n[build/python]   |   Downloading tomli-2.0.1-py3-none-any.whl (12 kB)\n[build/python]   | Collecting exceptiongroup>=1.0.0rc8\n[build/python]   |   Downloading exceptiongroup-1.1.1-py3-none-any.whl (14 kB)\n[build/python]   | Collecting pluggy<2.0,>=0.12\n[build/python]   |   Downloading pluggy-1.0.0-py2.py3-none-any.whl (13 kB)\n[build/python]   | Collecting iniconfig\n[build/python]   |   Downloading iniconfig-2.0.0-py3-none-any.whl (5.9 kB)\n[build/python]   | Collecting packaging\n[build/python]   |   Downloading packaging-23.1-py3-none-any.whl (48 kB)\n[build/python]   | Installing collected packages: MarkupSafe, greenlet, typing-extensions, sqlalchemy, pycparser, Mako, tomli, pyflakes, pycodestyle, pluggy, packaging, mccabe, iniconfig, exceptiongroup, cffi, banal, alembic, wheel, pytest, PyMySQL, psycopg2-binary, flake8, dataset, cryptography, coverage\n[build/python]   |   Running setup.py develop for dataset\n[build/python]   | Successfully installed Mako-1.2.4 MarkupSafe-2.1.2 PyMySQL-1.0.3 alembic-1.11.1 banal-1.0.6 cffi-1.15.1 coverage-7.2.6 cryptography-40.0.2 dataset-1.6.0 exceptiongroup-1.1.1 flake8-6.0.0 greenlet-2.0.2 iniconfig-2.0.0 mccabe-0.7.0 packaging-23.1 pluggy-1.0.0 psycopg2-binary-2.9.6 pycodestyle-2.10.0 pycparser-2.21 pyflakes-3.0.1 pytest-7.3.1 sqlalchemy-1.4.48 tomli-2.0.1 typing-extensions-4.6.2 wheel-0.40.0\n[build/python]   | WARNING: You are using pip version 21.2.4; however, version 23.1.2 is available.\n[build/python]   | You should consider upgrading via the '/opt/hostedtoolcache/Python/3.9.6/x64/bin/python -m pip install --upgrade pip' command.\n[build/python]   \u2705  Success - Main Install dependencies\n[build/python] \u2b50 Run Main Run SQLite tests\n[build/python]   \ud83d\udc33  docker exec cmd=[bash --noprofile --norc -e -o pipefail /var/run/act/workflow/4] user= workdir=\n[build/python]   | pytest\n[build/python]   | ============================= test session starts ==============================\n[build/python]   | platform linux -- Python 3.9.6, pytest-7.3.1, pluggy-1.0.0\n[build/python]   | rootdir: /tmp/de65f406-fe28-11ed-a890-af2cc187fc11/pudo-dataset\n[build/python]   | collected 59 items\n[build/python]   | \n[build/python]   | test/test_dataset.py ......................F......F......F...........F.. [ 86%]\n[build/python]   | .F......                                                                 [100%]\n[build/python]   | \n[build/python]   | =================================== FAILURES ===================================\n[build/python]   | _______________________ TableTestCase.test_create_column _______________________\n[build/python]   | \n[build/python]   | self = <test.test_dataset.TableTestCase testMethod=test_create_column>\n[build/python]   | \n[build/python]   |     def test_create_column(self):\n[build/python]   |         tbl = self.tbl\n[build/python]   |         flt = self.db.types.float\n[build/python]   | >       tbl.create_column(\"foo\", flt)\n[build/python]   | \n[build/python]   | test/test_dataset.py:505: \n[build/python]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[build/python]   | dataset/table.py:478: in create_column\n[build/python]   |     self._sync_table((Column(name, type, **kwargs),))\n[build/python]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[build/python]   | \n[build/python]   | self = <Table(weather)>, columns = (Column('foo', Float(), table=None),)\n[build/python]   | \n[build/python]   |     def _sync_table(self, columns):\n[build/python]   |         \"\"\"Lazy load, create or adapt the table structure in the database.\"\"\"\n[build/python]   |         if self._table is None:\n[build/python]   |             # Load an existing table from the database.\n[build/python]   |             self._reflect_table()\n[build/python]   |         if self._table is None:\n[build/python]   |             # Create the table with an initial set of columns.\n[build/python]   |             if not self._auto_create:\n[build/python]   |                 raise DatasetException(\"Table does not exist: %s\" % self.name)\n[build/python]   |             # Keep the lock scope small because this is run very often.\n[build/python]   |             with self.db.lock:\n[build/python]   |                 self._threading_warn()\n[build/python]   |                 self._table = SQLATable(\n[build/python]   |                     self.name, self.db.metadata, schema=self.db.schema\n[build/python]   |                 )\n[build/python]   |                 if self._primary_id is not False:\n[build/python]   |                     # This can go wrong on DBMS like MySQL and SQLite where\n[build/python]   |                     # tables cannot have no columns.\n[build/python]   |                     column = Column(\n[build/python]   |                         self._primary_id,\n[build/python]   |                         self._primary_type,\n[build/python]   |                         primary_key=True,\n[build/python]   |                         autoincrement=self._primary_increment,\n[build/python]   |                     )\n[build/python]   |                     self._table.append_column(column)\n[build/python]   |                 for column in columns:\n[build/python]   |                     if not column.name == self._primary_id:\n[build/python]   |                         self._table.append_column(column)\n[build/python]   |                 self._table.create(self.db.executable, checkfirst=True)\n[build/python]   |                 self._columns = None\n[build/python]   |         elif len(columns):\n[build/python]   |             with self.db.lock:\n[build/python]   |                 self._reflect_table()\n[build/python]   |                 self._threading_warn()\n[build/python]   |                 for column in columns:\n[build/python]   |                     if not self.has_column(column.name):\n[build/python]   | >                       self.db.op.add_column(self.name, column, self.db.schema)\n[build/python]   | E                       TypeError: add_column() takes 3 positional arguments but 4 were given\n[build/python]   | \n[build/python]   | dataset/table.py:356: TypeError\n[build/python]   | _______________________ TableTestCase.test_ensure_column _______________________\n[build/python]   | \n[build/python]   | self = <test.test_dataset.TableTestCase testMethod=test_ensure_column>\n[build/python]   | \n[build/python]   |     def test_ensure_column(self):\n[build/python]   |         tbl = self.tbl\n[build/python]   |         flt = self.db.types.float\n[build/python]   | >       tbl.create_column_by_example(\"foo\", 0.1)\n[build/python]   | \n[build/python]   | test/test_dataset.py:513: \n[build/python]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[build/python]   | dataset/table.py:493: in create_column_by_example\n[build/python]   |     self.create_column(name, type_)\n[build/python]   | dataset/table.py:478: in create_column\n[build/python]   |     self._sync_table((Column(name, type, **kwargs),))\n[build/python]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[build/python]   | \n[build/python]   | self = <Table(weather)>, columns = (Column('foo', Float(), table=None),)\n[build/python]   | \n[build/python]   |     def _sync_table(self, columns):\n[build/python]   |         \"\"\"Lazy load, create or adapt the table structure in the database.\"\"\"\n[build/python]   |         if self._table is None:\n[build/python]   |             # Load an existing table from the database.\n[build/python]   |             self._reflect_table()\n[build/python]   |         if self._table is None:\n[build/python]   |             # Create the table with an initial set of columns.\n[build/python]   |             if not self._auto_create:\n[build/python]   |                 raise DatasetException(\"Table does not exist: %s\" % self.name)\n[build/python]   |             # Keep the lock scope small because this is run very often.\n[build/python]   |             with self.db.lock:\n[build/python]   |                 self._threading_warn()\n[build/python]   |                 self._table = SQLATable(\n[build/python]   |                     self.name, self.db.metadata, schema=self.db.schema\n[build/python]   |                 )\n[build/python]   |                 if self._primary_id is not False:\n[build/python]   |                     # This can go wrong on DBMS like MySQL and SQLite where\n[build/python]   |                     # tables cannot have no columns.\n[build/python]   |                     column = Column(\n[build/python]   |                         self._primary_id,\n[build/python]   |                         self._primary_type,\n[build/python]   |                         primary_key=True,\n[build/python]   |                         autoincrement=self._primary_increment,\n[build/python]   |                     )\n[build/python]   |                     self._table.append_column(column)\n[build/python]   |                 for column in columns:\n[build/python]   |                     if not column.name == self._primary_id:\n[build/python]   |                         self._table.append_column(column)\n[build/python]   |                 self._table.create(self.db.executable, checkfirst=True)\n[build/python]   |                 self._columns = None\n[build/python]   |         elif len(columns):\n[build/python]   |             with self.db.lock:\n[build/python]   |                 self._reflect_table()\n[build/python]   |                 self._threading_warn()\n[build/python]   |                 for column in columns:\n[build/python]   |                     if not self.has_column(column.name):\n[build/python]   | >                       self.db.op.add_column(self.name, column, self.db.schema)\n[build/python]   | E                       TypeError: add_column() takes 3 positional arguments but 4 were given\n[build/python]   | \n[build/python]   | dataset/table.py:356: TypeError\n[build/python]   | ________________________ TableTestCase.test_insert_json ________________________\n[build/python]   | \n[build/python]   | self = <test.test_dataset.TableTestCase testMethod=test_insert_json>\n[build/python]   | \n[build/python]   |     def test_insert_json(self):\n[build/python]   | >       last_id = self.tbl.insert(\n[build/python]   |             {\n[build/python]   |                 \"date\": datetime(2011, 1, 2),\n[build/python]   |                 \"temperature\": -10,\n[build/python]   |                 \"place\": \"Berlin\",\n[build/python]   |                 \"info\": {\n[build/python]   |                     \"currency\": \"EUR\",\n[build/python]   |                     \"language\": \"German\",\n[build/python]   |                     \"population\": 3292365,\n[build/python]   |                 },\n[build/python]   |             }\n[build/python]   |         )\n[build/python]   | \n[build/python]   | test/test_dataset.py:191: \n[build/python]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[build/python]   | dataset/table.py:118: in insert\n[build/python]   |     row = self._sync_columns(row, ensure, types=types)\n[build/python]   | dataset/table.py:381: in _sync_columns\n[build/python]   |     self._sync_table(sync_columns.values())\n[build/python]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[build/python]   | \n[build/python]   | self = <Table(weather)>\n[build/python]   | columns = dict_values([Column('info', JSON(), table=None)])\n[build/python]   | \n[build/python]   |     def _sync_table(self, columns):\n[build/python]   |         \"\"\"Lazy load, create or adapt the table structure in the database.\"\"\"\n[build/python]   |         if self._table is None:\n[build/python]   |             # Load an existing table from the database.\n[build/python]   |             self._reflect_table()\n[build/python]   |         if self._table is None:\n[build/python]   |             # Create the table with an initial set of columns.\n[build/python]   |             if not self._auto_create:\n[build/python]   |                 raise DatasetException(\"Table does not exist: %s\" % self.name)\n[build/python]   |             # Keep the lock scope small because this is run very often.\n[build/python]   |             with self.db.lock:\n[build/python]   |                 self._threading_warn()\n[build/python]   |                 self._table = SQLATable(\n[build/python]   |                     self.name, self.db.metadata, schema=self.db.schema\n[build/python]   |                 )\n[build/python]   |                 if self._primary_id is not False:\n[build/python]   |                     # This can go wrong on DBMS like MySQL and SQLite where\n[build/python]   |                     # tables cannot have no columns.\n[build/python]   |                     column = Column(\n[build/python]   |                         self._primary_id,\n[build/python]   |                         self._primary_type,\n[build/python]   |                         primary_key=True,\n[build/python]   |                         autoincrement=self._primary_increment,\n[build/python]   |                     )\n[build/python]   |                     self._table.append_column(column)\n[build/python]   |                 for column in columns:\n[build/python]   |                     if not column.name == self._primary_id:\n[build/python]   |                         self._table.append_column(column)\n[build/python]   |                 self._table.create(self.db.executable, checkfirst=True)\n[build/python]   |                 self._columns = None\n[build/python]   |         elif len(columns):\n[build/python]   |             with self.db.lock:\n[build/python]   |                 self._reflect_table()\n[build/python]   |                 self._threading_warn()\n[build/python]   |                 for column in columns:\n[build/python]   |                     if not self.has_column(column.name):\n[build/python]   | >                       self.db.op.add_column(self.name, column, self.db.schema)\n[build/python]   | E                       TypeError: add_column() takes 3 positional arguments but 4 were given\n[build/python]   | \n[build/python]   | dataset/table.py:356: TypeError\n[build/python]   | _____________________ TableTestCase.test_update_while_iter _____________________\n[build/python]   | \n[build/python]   | self = <test.test_dataset.TableTestCase testMethod=test_update_while_iter>\n[build/python]   | \n[build/python]   |     def test_update_while_iter(self):\n[build/python]   |         for row in self.tbl:\n[build/python]   |             row[\"foo\"] = \"bar\"\n[build/python]   | >           self.tbl.update(row, [\"place\", \"date\"])\n[build/python]   | \n[build/python]   | test/test_dataset.py:243: \n[build/python]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[build/python]   | dataset/table.py:204: in update\n[build/python]   |     row = self._sync_columns(row, ensure, types=types)\n[build/python]   | dataset/table.py:381: in _sync_columns\n[build/python]   |     self._sync_table(sync_columns.values())\n[build/python]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[build/python]   | \n[build/python]   | self = <Table(weather)>\n[build/python]   | columns = dict_values([Column('foo', UnicodeText(), table=None)])\n[build/python]   | \n[build/python]   |     def _sync_table(self, columns):\n[build/python]   |         \"\"\"Lazy load, create or adapt the table structure in the database.\"\"\"\n[build/python]   |         if self._table is None:\n[build/python]   |             # Load an existing table from the database.\n[build/python]   |             self._reflect_table()\n[build/python]   |         if self._table is None:\n[build/python]   |             # Create the table with an initial set of columns.\n[build/python]   |             if not self._auto_create:\n[build/python]   |                 raise DatasetException(\"Table does not exist: %s\" % self.name)\n[build/python]   |             # Keep the lock scope small because this is run very often.\n[build/python]   |             with self.db.lock:\n[build/python]   |                 self._threading_warn()\n[build/python]   |                 self._table = SQLATable(\n[build/python]   |                     self.name, self.db.metadata, schema=self.db.schema\n[build/python]   |                 )\n[build/python]   |                 if self._primary_id is not False:\n[build/python]   |                     # This can go wrong on DBMS like MySQL and SQLite where\n[build/python]   |                     # tables cannot have no columns.\n[build/python]   |                     column = Column(\n[build/python]   |                         self._primary_id,\n[build/python]   |                         self._primary_type,\n[build/python]   |                         primary_key=True,\n[build/python]   |                         autoincrement=self._primary_increment,\n[build/python]   |                     )\n[build/python]   |                     self._table.append_column(column)\n[build/python]   |                 for column in columns:\n[build/python]   |                     if not column.name == self._primary_id:\n[build/python]   |                         self._table.append_column(column)\n[build/python]   |                 self._table.create(self.db.executable, checkfirst=True)\n[build/python]   |                 self._columns = None\n[build/python]   |         elif len(columns):\n[build/python]   |             with self.db.lock:\n[build/python]   |                 self._reflect_table()\n[build/python]   |                 self._threading_warn()\n[build/python]   |                 for column in columns:\n[build/python]   |                     if not self.has_column(column.name):\n[build/python]   | >                       self.db.op.add_column(self.name, column, self.db.schema)\n[build/python]   | E                       TypeError: add_column() takes 3 positional arguments but 4 were given\n[build/python]   | \n[build/python]   | dataset/table.py:356: TypeError\n[build/python]   | ________________________ TableTestCase.test_upsert_many ________________________\n[build/python]   | \n[build/python]   | self = <test.test_dataset.TableTestCase testMethod=test_upsert_many>\n[build/python]   | \n[build/python]   |     def test_upsert_many(self):\n[build/python]   |         # Also tests updating on records with different attributes\n[build/python]   |         tbl = self.db[\"upsert_many_test\"]\n[build/python]   |     \n[build/python]   |         W = 100\n[build/python]   | >       tbl.upsert_many([dict(age=10), dict(weight=W)], \"id\")\n[build/python]   | \n[build/python]   | test/test_dataset.py:449: \n[build/python]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[build/python]   | dataset/table.py:280: in upsert_many\n[build/python]   |     self.upsert(row, keys, ensure=ensure, types=types)\n[build/python]   | dataset/table.py:261: in upsert\n[build/python]   |     row = self._sync_columns(row, ensure, types=types)\n[build/python]   | dataset/table.py:381: in _sync_columns\n[build/python]   |     self._sync_table(sync_columns.values())\n[build/python]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[build/python]   | \n[build/python]   | self = <Table(upsert_many_test)>\n[build/python]   | columns = dict_values([Column('weight', BigInteger(), table=None)])\n[build/python]   | \n[build/python]   |     def _sync_table(self, columns):\n[build/python]   |         \"\"\"Lazy load, create or adapt the table structure in the database.\"\"\"\n[build/python]   |         if self._table is None:\n[build/python]   |             # Load an existing table from the database.\n[build/python]   |             self._reflect_table()\n[build/python]   |         if self._table is None:\n[build/python]   |             # Create the table with an initial set of columns.\n[build/python]   |             if not self._auto_create:\n[build/python]   |                 raise DatasetException(\"Table does not exist: %s\" % self.name)\n[build/python]   |             # Keep the lock scope small because this is run very often.\n[build/python]   |             with self.db.lock:\n[build/python]   |                 self._threading_warn()\n[build/python]   |                 self._table = SQLATable(\n[build/python]   |                     self.name, self.db.metadata, schema=self.db.schema\n[build/python]   |                 )\n[build/python]   |                 if self._primary_id is not False:\n[build/python]   |                     # This can go wrong on DBMS like MySQL and SQLite where\n[build/python]   |                     # tables cannot have no columns.\n[build/python]   |                     column = Column(\n[build/python]   |                         self._primary_id,\n[build/python]   |                         self._primary_type,\n[build/python]   |                         primary_key=True,\n[build/python]   |                         autoincrement=self._primary_increment,\n[build/python]   |                     )\n[build/python]   |                     self._table.append_column(column)\n[build/python]   |                 for column in columns:\n[build/python]   |                     if not column.name == self._primary_id:\n[build/python]   |                         self._table.append_column(column)\n[build/python]   |                 self._table.create(self.db.executable, checkfirst=True)\n[build/python]   |                 self._columns = None\n[build/python]   |         elif len(columns):\n[build/python]   |             with self.db.lock:\n[build/python]   |                 self._reflect_table()\n[build/python]   |                 self._threading_warn()\n[build/python]   |                 for column in columns:\n[build/python]   |                     if not self.has_column(column.name):\n[build/python]   | >                       self.db.op.add_column(self.name, column, self.db.schema)\n[build/python]   | E                       TypeError: add_column() takes 3 positional arguments but 4 were given\n[build/python]   | \n[build/python]   | dataset/table.py:356: TypeError\n[build/python]   | =============================== warnings summary ===============================\n[build/python]   | test/test_dataset.py::DatabaseTestCase::test_contains\n[build/python]   |   /tmp/de65f406-fe28-11ed-a890-af2cc187fc11/pudo-dataset/dataset/database.py:109: RemovedIn20Warning: Deprecated API features detected! These feature(s) are not compatible with SQLAlchemy 2.0. To prevent incompatible upgrades prior to updating applications, ensure requirements files are pinned to \"sqlalchemy<2.0\". Set environment variable SQLALCHEMY_WARN_20=1 to show all deprecation warnings.  Set environment variable SQLALCHEMY_SILENCE_UBER_WARNING=1 to silence this message. (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)\n[build/python]   |     return MetaData(schema=self.schema, bind=self.executable)\n[build/python]   | \n[build/python]   | -- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html\n[build/python]   | =========================== short test summary info ============================\n[build/python]   | FAILED test/test_dataset.py::TableTestCase::test_create_column - TypeError: add_column() takes 3 positional arguments but 4 were given\n[build/python]   | FAILED test/test_dataset.py::TableTestCase::test_ensure_column - TypeError: add_column() takes 3 positional arguments but 4 were given\n[build/python]   | FAILED test/test_dataset.py::TableTestCase::test_insert_json - TypeError: add_column() takes 3 positional arguments but 4 were given\n[build/python]   | FAILED test/test_dataset.py::TableTestCase::test_update_while_iter - TypeError: add_column() takes 3 positional arguments but 4 were given\n[build/python]   | FAILED test/test_dataset.py::TableTestCase::test_upsert_many - TypeError: add_column() takes 3 positional arguments but 4 were given\n[build/python]   | =================== 5 failed, 54 passed, 1 warning in 2.38s ====================\n[build/python]   | make: *** [Makefile:6: test] Error 1\n[build/python]   \u274c  Failure - Main Run SQLite tests\n[build/python] exitcode '2': failure\n[build/python] \ud83c\udfc1  Job failed\n",
    "actions_stderr": "Error: Job 'python' failed\n"
}