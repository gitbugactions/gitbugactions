{
    "repository": "HybridRobotics/car-racing",
    "clone_url": "https://github.com/HybridRobotics/car-racing.git",
    "timestamp": "2023-05-29T16:21:52.715378Z",
    "clone_success": true,
    "number of actions": 1,
    "number_of_test_actions": 1,
    "actions_successful": false,
    "actions_stdout": "[Tests/test] \ud83d\ude80  Start image=crawlergpt:latest\n[Tests/test]   \ud83d\udc33  docker pull image=crawlergpt:latest platform= username= forcePull=false\n[Tests/test]   \ud83d\udc33  docker create image=crawlergpt:latest platform= entrypoint=[\"tail\" \"-f\" \"/dev/null\"] cmd=[]\n[Tests/test]   \ud83d\udc33  docker run image=crawlergpt:latest platform= entrypoint=[\"tail\" \"-f\" \"/dev/null\"] cmd=[]\n[Tests/test]   \ud83d\udc33  docker exec cmd=[chown -R 1012:1000 /tmp/de65f406-fe28-11ed-a890-af2cc187fc11/HybridRobotics-car-racing] user=0 workdir=\n[Tests/test]   \u2601  git clone 'https://github.com/actions/setup-python' # ref=v3\n[Tests/test] \ud83e\uddea  Matrix: map[os:ubuntu-latest python-version:3.6]\n[Tests/test] \u2b50 Run Main actions/checkout@v3\n[Tests/test]   \u2705  Success - Main actions/checkout@v3\n[Tests/test] \u2b50 Run Main Set up Python 3.6\n[Tests/test]   \ud83d\udc33  docker cp src=/home/andre-silva/.cache/act/actions-setup-python@v3/ dst=/var/run/act/actions/actions-setup-python@v3/\n[Tests/test]   \ud83d\udc33  docker exec cmd=[chown -R 1012:1000 /var/run/act/actions/actions-setup-python@v3/] user=0 workdir=\n[Tests/test]   \ud83d\udc33  docker exec cmd=[node /var/run/act/actions/actions-setup-python@v3/dist/setup/index.js] user= workdir=\n[Tests/test]   \ud83d\udcac  ::debug::Semantic version spec of 3.6 is 3.6\n[Tests/test]   \ud83d\udcac  ::debug::isExplicit: \n[Tests/test]   \ud83d\udcac  ::debug::explicit? false\n[Tests/test]   \ud83d\udcac  ::debug::isExplicit: 2.7.18\n[Tests/test]   \ud83d\udcac  ::debug::explicit? true\n[Tests/test]   \ud83d\udcac  ::debug::isExplicit: 3.5.10\n[Tests/test]   \ud83d\udcac  ::debug::explicit? true\n[Tests/test]   \ud83d\udcac  ::debug::isExplicit: 3.6.14\n[Tests/test]   \ud83d\udcac  ::debug::explicit? true\n[Tests/test]   \ud83d\udcac  ::debug::isExplicit: 3.7.11\n[Tests/test]   \ud83d\udcac  ::debug::explicit? true\n[Tests/test]   \ud83d\udcac  ::debug::isExplicit: 3.8.11\n[Tests/test]   \ud83d\udcac  ::debug::explicit? true\n[Tests/test]   \ud83d\udcac  ::debug::isExplicit: 3.9.6\n[Tests/test]   \ud83d\udcac  ::debug::explicit? true\n[Tests/test]   \ud83d\udcac  ::debug::evaluating 6 versions\n[Tests/test]   \ud83d\udcac  ::debug::matched: 3.6.14\n[Tests/test]   \ud83d\udcac  ::debug::checking cache: /opt/hostedtoolcache/Python/3.6.14/x64\n[Tests/test]   \ud83d\udcac  ::debug::Found tool in cache Python 3.6.14 x64\n[Tests/test]   | Successfully setup CPython (3.6.14)\n[Tests/test]   \u2753 add-matcher /run/act/actions/actions-setup-python@v3/.github/python.json\n[Tests/test]   \u2705  Success - Main Set up Python 3.6\n[Tests/test]   \u2699  ::set-env:: pythonLocation=/opt/hostedtoolcache/Python/3.6.14/x64\n[Tests/test]   \u2699  ::set-env:: LD_LIBRARY_PATH=/opt/hostedtoolcache/Python/3.6.14/x64/lib\n[Tests/test]   \u2699  ::set-output:: python-version=3.6.14\n[Tests/test]   \u2699  ::add-path:: /opt/hostedtoolcache/Python/3.6.14/x64\n[Tests/test]   \u2699  ::add-path:: /opt/hostedtoolcache/Python/3.6.14/x64/bin\n[Tests/test] \u2b50 Run Main Install dependencies\n[Tests/test]   \ud83d\udc33  docker exec cmd=[bash --noprofile --norc -e -o pipefail /var/run/act/workflow/2] user= workdir=\n[Tests/test]   | Requirement already satisfied: pip in /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/site-packages (21.2.4)\n[Tests/test]   | Collecting pip\n[Tests/test]   |   Downloading pip-21.3.1-py3-none-any.whl (1.7 MB)\n[Tests/test]   | Collecting install\n[Tests/test]   |   Downloading install-1.3.5-py3-none-any.whl (3.2 kB)\n[Tests/test]   | Collecting pre-commit\n[Tests/test]   |   Downloading pre_commit-2.17.0-py2.py3-none-any.whl (195 kB)\n[Tests/test]   | Collecting black\n[Tests/test]   |   Downloading black-22.8.0-cp36-cp36m-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (1.4 MB)\n[Tests/test]   | Collecting numpy\n[Tests/test]   |   Downloading numpy-1.19.5-cp36-cp36m-manylinux2010_x86_64.whl (14.8 MB)\n[Tests/test]   | Collecting sympy\n[Tests/test]   |   Downloading sympy-1.9-py3-none-any.whl (6.2 MB)\n[Tests/test]   | Collecting matplotlib\n[Tests/test]   |   Downloading matplotlib-3.3.4-cp36-cp36m-manylinux1_x86_64.whl (11.5 MB)\n[Tests/test]   | Collecting casadi\n[Tests/test]   |   Downloading casadi-3.6.3-cp36-none-manylinux2014_x86_64.whl (67.5 MB)\n[Tests/test]   | Collecting cvxopt\n[Tests/test]   |   Downloading cvxopt-1.3.1-cp36-cp36m-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (13.6 MB)\n[Tests/test]   | Collecting pathos\n[Tests/test]   |   Downloading pathos-0.2.8-py2.py3-none-any.whl (81 kB)\n[Tests/test]   | Collecting flake8==3.9.2\n[Tests/test]   |   Downloading flake8-3.9.2-py2.py3-none-any.whl (73 kB)\n[Tests/test]   | Collecting tox==3.24.3\n[Tests/test]   |   Downloading tox-3.24.3-py2.py3-none-any.whl (85 kB)\n[Tests/test]   | Collecting pytest==6.2.5\n[Tests/test]   |   Downloading pytest-6.2.5-py3-none-any.whl (280 kB)\n[Tests/test]   | Collecting pytest-cov==2.12.1\n[Tests/test]   |   Downloading pytest_cov-2.12.1-py2.py3-none-any.whl (20 kB)\n[Tests/test]   | Collecting mypy==0.910\n[Tests/test]   |   Downloading mypy-0.910-cp36-cp36m-manylinux2010_x86_64.whl (21.2 MB)\n[Tests/test]   | Collecting scipy\n[Tests/test]   |   Downloading scipy-1.5.4-cp36-cp36m-manylinux1_x86_64.whl (25.9 MB)\n[Tests/test]   | Collecting pycodestyle<2.8.0,>=2.7.0\n[Tests/test]   |   Downloading pycodestyle-2.7.0-py2.py3-none-any.whl (41 kB)\n[Tests/test]   | Collecting pyflakes<2.4.0,>=2.3.0\n[Tests/test]   |   Downloading pyflakes-2.3.1-py2.py3-none-any.whl (68 kB)\n[Tests/test]   | Collecting importlib-metadata\n[Tests/test]   |   Downloading importlib_metadata-4.8.3-py3-none-any.whl (17 kB)\n[Tests/test]   | Collecting mccabe<0.7.0,>=0.6.0\n[Tests/test]   |   Downloading mccabe-0.6.1-py2.py3-none-any.whl (8.6 kB)\n[Tests/test]   | Collecting toml>=0.9.4\n[Tests/test]   |   Downloading toml-0.10.2-py2.py3-none-any.whl (16 kB)\n[Tests/test]   | Collecting py>=1.4.17\n[Tests/test]   |   Downloading py-1.11.0-py2.py3-none-any.whl (98 kB)\n[Tests/test]   | Collecting packaging>=14\n[Tests/test]   |   Downloading packaging-21.3-py3-none-any.whl (40 kB)\n[Tests/test]   | Collecting six>=1.14.0\n[Tests/test]   |   Downloading six-1.16.0-py2.py3-none-any.whl (11 kB)\n[Tests/test]   | Collecting filelock>=3.0.0\n[Tests/test]   |   Downloading filelock-3.4.1-py3-none-any.whl (9.9 kB)\n[Tests/test]   | Collecting virtualenv!=20.0.0,!=20.0.1,!=20.0.2,!=20.0.3,!=20.0.4,!=20.0.5,!=20.0.6,!=20.0.7,>=16.0.0\n[Tests/test]   |   Downloading virtualenv-20.17.1-py3-none-any.whl (8.8 MB)\n[Tests/test]   | Collecting pluggy>=0.12.0\n[Tests/test]   |   Downloading pluggy-1.0.0-py2.py3-none-any.whl (13 kB)\n[Tests/test]   | Collecting iniconfig\n[Tests/test]   |   Downloading iniconfig-1.1.1-py2.py3-none-any.whl (5.0 kB)\n[Tests/test]   | Collecting attrs>=19.2.0\n[Tests/test]   |   Downloading attrs-22.2.0-py3-none-any.whl (60 kB)\n[Tests/test]   | Collecting coverage>=5.2.1\n[Tests/test]   |   Downloading coverage-6.2-cp36-cp36m-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_12_x86_64.manylinux2010_x86_64.whl (212 kB)\n[Tests/test]   | Collecting typed-ast<1.5.0,>=1.4.0\n[Tests/test]   |   Downloading typed_ast-1.4.3-cp36-cp36m-manylinux1_x86_64.whl (743 kB)\n[Tests/test]   | Collecting typing-extensions>=3.7.4\n[Tests/test]   |   Downloading typing_extensions-4.1.1-py3-none-any.whl (26 kB)\n[Tests/test]   | Collecting mypy-extensions<0.5.0,>=0.4.3\n[Tests/test]   |   Downloading mypy_extensions-0.4.4.tar.gz (4.2 kB)\n[Tests/test]   | Collecting pyyaml>=5.1\n[Tests/test]   |   Downloading PyYAML-6.0-cp36-cp36m-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_12_x86_64.manylinux2010_x86_64.whl (603 kB)\n[Tests/test]   | Collecting importlib-resources<5.3\n[Tests/test]   |   Downloading importlib_resources-5.2.3-py3-none-any.whl (27 kB)\n[Tests/test]   | Collecting nodeenv>=0.11.1\n[Tests/test]   |   Downloading nodeenv-1.6.0-py2.py3-none-any.whl (21 kB)\n[Tests/test]   | Collecting identify>=1.0.0\n[Tests/test]   |   Downloading identify-2.4.4-py2.py3-none-any.whl (98 kB)\n[Tests/test]   | Collecting cfgv>=2.0.0\n[Tests/test]   |   Downloading cfgv-3.3.1-py2.py3-none-any.whl (7.3 kB)\n[Tests/test]   | Collecting pathspec>=0.9.0\n[Tests/test]   |   Downloading pathspec-0.9.0-py2.py3-none-any.whl (31 kB)\n[Tests/test]   | Collecting click>=8.0.0\n[Tests/test]   |   Downloading click-8.0.4-py3-none-any.whl (97 kB)\n[Tests/test]   | Collecting platformdirs>=2\n[Tests/test]   |   Downloading platformdirs-2.4.0-py3-none-any.whl (14 kB)\n[Tests/test]   | Collecting tomli>=1.1.0\n[Tests/test]   |   Downloading tomli-1.2.3-py3-none-any.whl (12 kB)\n[Tests/test]   | Collecting dataclasses>=0.6\n[Tests/test]   |   Downloading dataclasses-0.8-py3-none-any.whl (19 kB)\n[Tests/test]   | Collecting mpmath>=0.19\n[Tests/test]   |   Downloading mpmath-1.3.0-py3-none-any.whl (536 kB)\n[Tests/test]   | Collecting cycler>=0.10\n[Tests/test]   |   Downloading cycler-0.11.0-py3-none-any.whl (6.4 kB)\n[Tests/test]   | Collecting python-dateutil>=2.1\n[Tests/test]   |   Downloading python_dateutil-2.8.2-py2.py3-none-any.whl (247 kB)\n[Tests/test]   | Collecting pillow>=6.2.0\n[Tests/test]   |   Downloading Pillow-8.4.0-cp36-cp36m-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (3.1 MB)\n[Tests/test]   | Collecting kiwisolver>=1.0.1\n[Tests/test]   |   Downloading kiwisolver-1.3.1-cp36-cp36m-manylinux1_x86_64.whl (1.1 MB)\n[Tests/test]   | Collecting pyparsing!=2.0.4,!=2.1.2,!=2.1.6,>=2.0.3\n[Tests/test]   |   Downloading pyparsing-3.0.9-py3-none-any.whl (98 kB)\n[Tests/test]   | Collecting ppft>=1.6.6.4\n[Tests/test]   |   Downloading ppft-1.6.6.4-py3-none-any.whl (65 kB)\n[Tests/test]   | Collecting pox>=0.3.0\n[Tests/test]   |   Downloading pox-0.3.0-py2.py3-none-any.whl (30 kB)\n[Tests/test]   | Collecting multiprocess>=0.70.12\n[Tests/test]   |   Downloading multiprocess-0.70.12.2-py36-none-any.whl (106 kB)\n[Tests/test]   | Collecting dill>=0.3.4\n[Tests/test]   |   Downloading dill-0.3.4-py2.py3-none-any.whl (86 kB)\n[Tests/test]   | Collecting zipp>=0.5\n[Tests/test]   |   Downloading zipp-3.6.0-py3-none-any.whl (5.3 kB)\n[Tests/test]   | Collecting distlib<1,>=0.3.6\n[Tests/test]   |   Downloading distlib-0.3.6-py2.py3-none-any.whl (468 kB)\n[Tests/test]   | Collecting virtualenv!=20.0.0,!=20.0.1,!=20.0.2,!=20.0.3,!=20.0.4,!=20.0.5,!=20.0.6,!=20.0.7,>=16.0.0\n[Tests/test]   |   Downloading virtualenv-20.17.0-py3-none-any.whl (8.8 MB)\n[Tests/test]   |   Downloading virtualenv-20.16.7-py3-none-any.whl (8.8 MB)\n[Tests/test]   |   Downloading virtualenv-20.16.6-py3-none-any.whl (8.8 MB)\n[Tests/test]   |   Downloading virtualenv-20.16.5-py3-none-any.whl (8.8 MB)\n[Tests/test]   |   Downloading virtualenv-20.16.4-py3-none-any.whl (8.8 MB)\n[Tests/test]   |   Downloading virtualenv-20.16.3-py2.py3-none-any.whl (8.8 MB)\n[Tests/test]   |   Downloading virtualenv-20.16.2-py2.py3-none-any.whl (8.8 MB)\n[Tests/test]   | Using legacy 'setup.py install' for mypy-extensions, since package 'wheel' is not installed.\n[Tests/test]   | Installing collected packages: zipp, typing-extensions, pyparsing, importlib-metadata, toml, six, py, pluggy, platformdirs, packaging, iniconfig, importlib-resources, filelock, distlib, dill, attrs, virtualenv, typed-ast, tomli, pyyaml, python-dateutil, pytest, pyflakes, pycodestyle, ppft, pox, pillow, pathspec, numpy, nodeenv, mypy-extensions, multiprocess, mpmath, mccabe, kiwisolver, identify, dataclasses, cycler, coverage, click, cfgv, tox, sympy, scipy, pytest-cov, pre-commit, pip, pathos, mypy, matplotlib, install, flake8, cvxopt, casadi, black\n[Tests/test]   |     Running setup.py install for mypy-extensions: started\n[Tests/test]   |     Running setup.py install for mypy-extensions: finished with status 'done'\n[Tests/test]   |   Attempting uninstall: pip\n[Tests/test]   |     Found existing installation: pip 21.2.4\n[Tests/test]   |     Uninstalling pip-21.2.4:\n[Tests/test]   |       Successfully uninstalled pip-21.2.4\n[Tests/test]   | Successfully installed attrs-22.2.0 black-22.8.0 casadi-3.6.3 cfgv-3.3.1 click-8.0.4 coverage-6.2 cvxopt-1.3.1 cycler-0.11.0 dataclasses-0.8 dill-0.3.4 distlib-0.3.6 filelock-3.4.1 flake8-3.9.2 identify-2.4.4 importlib-metadata-4.8.3 importlib-resources-5.2.3 iniconfig-1.1.1 install-1.3.5 kiwisolver-1.3.1 matplotlib-3.3.4 mccabe-0.6.1 mpmath-1.3.0 multiprocess-0.70.12.2 mypy-0.910 mypy-extensions-0.4.4 nodeenv-1.6.0 numpy-1.19.5 packaging-21.3 pathos-0.2.8 pathspec-0.9.0 pillow-8.4.0 pip-21.3.1 platformdirs-2.4.0 pluggy-1.0.0 pox-0.3.0 ppft-1.6.6.4 pre-commit-2.17.0 py-1.11.0 pycodestyle-2.7.0 pyflakes-2.3.1 pyparsing-3.0.9 pytest-6.2.5 pytest-cov-2.12.1 python-dateutil-2.8.2 pyyaml-6.0 scipy-1.5.4 six-1.16.0 sympy-1.9 toml-0.10.2 tomli-1.2.3 tox-3.24.3 typed-ast-1.4.3 typing-extensions-4.1.1 virtualenv-20.16.2 zipp-3.6.0\n[Tests/test]   \u2705  Success - Main Install dependencies\n[Tests/test] \u2b50 Run Main Install package\n[Tests/test]   \ud83d\udc33  docker exec cmd=[bash --noprofile --norc -e -o pipefail /var/run/act/workflow/3] user= workdir=\n[Tests/test]   | Obtaining file:///tmp/de65f406-fe28-11ed-a890-af2cc187fc11/HybridRobotics-car-racing\n[Tests/test]   |   Installing build dependencies: started\n[Tests/test]   |   Installing build dependencies: finished with status 'done'\n[Tests/test]   |   Checking if build backend supports build_editable: started\n[Tests/test]   |   Checking if build backend supports build_editable: finished with status 'done'\n[Tests/test]   |   Getting requirements to build wheel: started\n[Tests/test]   |   Getting requirements to build wheel: finished with status 'done'\n[Tests/test]   |   Preparing metadata (pyproject.toml): started\n[Tests/test]   |   Preparing metadata (pyproject.toml): finished with status 'done'\n[Tests/test]   | Collecting requests>=2\n[Tests/test]   |   Downloading requests-2.27.1-py2.py3-none-any.whl (63 kB)\n[Tests/test]   | Collecting certifi>=2017.4.17\n[Tests/test]   |   Downloading certifi-2023.5.7-py3-none-any.whl (156 kB)\n[Tests/test]   | Collecting charset-normalizer~=2.0.0\n[Tests/test]   |   Downloading charset_normalizer-2.0.12-py3-none-any.whl (39 kB)\n[Tests/test]   | Collecting urllib3<1.27,>=1.21.1\n[Tests/test]   |   Downloading urllib3-1.26.16-py2.py3-none-any.whl (143 kB)\n[Tests/test]   | Collecting idna<4,>=2.5\n[Tests/test]   |   Downloading idna-3.4-py3-none-any.whl (61 kB)\n[Tests/test]   | Installing collected packages: urllib3, idna, charset-normalizer, certifi, requests, car-racing\n[Tests/test]   |   Running setup.py develop for car-racing\n[Tests/test]   | Successfully installed car-racing-0.0.0 certifi-2023.5.7 charset-normalizer-2.0.12 idna-3.4 requests-2.27.1 urllib3-1.26.16\n[Tests/test]   \u2705  Success - Main Install package\n[Tests/test] \u2b50 Run Main Test mpc/pid controller wit pytest\n[Tests/test]   \ud83d\udc33  docker exec cmd=[bash --noprofile --norc -e -o pipefail /var/run/act/workflow/4] user= workdir=\n[Tests/test]   | ============================= test session starts ==============================\n[Tests/test]   | platform linux -- Python 3.6.14, pytest-6.2.5, py-1.11.0, pluggy-1.0.0\n[Tests/test]   | rootdir: /tmp/de65f406-fe28-11ed-a890-af2cc187fc11/HybridRobotics-car-racing, configfile: pyproject.toml\n[Tests/test]   | plugins: cov-2.12.1\n[Tests/test]   | collected 1 item\n[Tests/test]   | \n[Tests/test]   | tests/auto_control_test.py .                                             [100%]\n[Tests/test]   | \n[Tests/test]   | =============================== warnings summary ===============================\n[Tests/test]   | car_racing/racing/offboard.py:176\n[Tests/test]   |   /tmp/de65f406-fe28-11ed-a890-af2cc187fc11/HybridRobotics-car-racing/car_racing/racing/offboard.py:176: DeprecationWarning: invalid escape sequence \\p\n[Tests/test]   |     axs[2].set_ylabel(\"$e_{\\psi}$ [rad]\", fontsize=14)\n[Tests/test]   | \n[Tests/test]   | tests/auto_control_test.py: 11532 warnings\n[Tests/test]   |   /tmp/de65f406-fe28-11ed-a890-af2cc187fc11/HybridRobotics-car-racing/car_racing/utils/racing_env.py:25: DeprecationWarning: np.asscalar(a) is deprecated since NumPy v1.16, use a.item() instead\n[Tests/test]   |     i = np.asscalar(np.where(np.squeeze(index))[0][0])\n[Tests/test]   | \n[Tests/test]   | -- Docs: https://docs.pytest.org/en/stable/warnings.html\n[Tests/test]   | \n[Tests/test]   | ---------- coverage: platform linux, python 3.6.14-final-0 -----------\n[Tests/test]   | Name                             Stmts   Miss  Cover\n[Tests/test]   | ----------------------------------------------------\n[Tests/test]   | tests/__init__.py                    0      0   100%\n[Tests/test]   | tests/auto_control_test.py          34      0   100%\n[Tests/test]   | tests/auto_mpccbf_test.py           41     41     0%\n[Tests/test]   | tests/auto_racing_game_test.py     100    100     0%\n[Tests/test]   | ----------------------------------------------------\n[Tests/test]   | TOTAL                              175    141    19%\n[Tests/test]   | \n[Tests/test]   | ====================== 1 passed, 11533 warnings in 31.99s ======================\n[Tests/test]   \u2705  Success - Main Test mpc/pid controller wit pytest\n[Tests/test] \u2b50 Run Main Test mpc-cbf controller wit pytest\n[Tests/test]   \ud83d\udc33  docker exec cmd=[bash --noprofile --norc -e -o pipefail /var/run/act/workflow/5] user= workdir=\n[Tests/test]   | ============================= test session starts ==============================\n[Tests/test]   | platform linux -- Python 3.6.14, pytest-6.2.5, py-1.11.0, pluggy-1.0.0\n[Tests/test]   | rootdir: /tmp/de65f406-fe28-11ed-a890-af2cc187fc11/HybridRobotics-car-racing, configfile: pyproject.toml\n[Tests/test]   | plugins: cov-2.12.1\n[Tests/test]   | collected 1 item\n[Tests/test]   | \n[Tests/test]   | tests/auto_mpccbf_test.py .                                              [100%]\n[Tests/test]   | \n[Tests/test]   | =============================== warnings summary ===============================\n[Tests/test]   | tests/auto_mpccbf_test.py: 21134 warnings\n[Tests/test]   |   /tmp/de65f406-fe28-11ed-a890-af2cc187fc11/HybridRobotics-car-racing/car_racing/utils/racing_env.py:25: DeprecationWarning: np.asscalar(a) is deprecated since NumPy v1.16, use a.item() instead\n[Tests/test]   |     i = np.asscalar(np.where(np.squeeze(index))[0][0])\n[Tests/test]   | \n[Tests/test]   | tests/auto_mpccbf_test.py: 9602 warnings\n[Tests/test]   |   /tmp/de65f406-fe28-11ed-a890-af2cc187fc11/HybridRobotics-car-racing/car_racing/utils/racing_env.py:86: DeprecationWarning: np.asscalar(a) is deprecated since NumPy v1.16, use a.item() instead\n[Tests/test]   |     i = np.asscalar(np.where(np.squeeze(index))[0][0])\n[Tests/test]   | \n[Tests/test]   | -- Docs: https://docs.pytest.org/en/stable/warnings.html\n[Tests/test]   | \n[Tests/test]   | ---------- coverage: platform linux, python 3.6.14-final-0 -----------\n[Tests/test]   | Name                             Stmts   Miss  Cover\n[Tests/test]   | ----------------------------------------------------\n[Tests/test]   | tests/__init__.py                    0      0   100%\n[Tests/test]   | tests/auto_control_test.py          34     34     0%\n[Tests/test]   | tests/auto_mpccbf_test.py           41      0   100%\n[Tests/test]   | tests/auto_racing_game_test.py     100    100     0%\n[Tests/test]   | ----------------------------------------------------\n[Tests/test]   | TOTAL                              175    134    23%\n[Tests/test]   | \n[Tests/test]   | ================ 1 passed, 30736 warnings in 146.67s (0:02:26) =================\n[Tests/test]   \u2705  Success - Main Test mpc-cbf controller wit pytest\n[Tests/test] \u2b50 Run Main Test racing game controller wit pytest\n[Tests/test]   \ud83d\udc33  docker exec cmd=[bash --noprofile --norc -e -o pipefail /var/run/act/workflow/6] user= workdir=\n[Tests/test]   | ============================= test session starts ==============================\n[Tests/test]   | platform linux -- Python 3.6.14, pytest-6.2.5, py-1.11.0, pluggy-1.0.0\n[Tests/test]   | rootdir: /tmp/de65f406-fe28-11ed-a890-af2cc187fc11/HybridRobotics-car-racing, configfile: pyproject.toml\n[Tests/test]   | plugins: cov-2.12.1\n[Tests/test]   | collected 1 item\n[Tests/test]   | \n[Tests/test]   | tests/auto_racing_game_test.py F                                         [100%]\n[Tests/test]   | \n[Tests/test]   | =================================== FAILURES ===================================\n[Tests/test]   | _____________________________ test_racing_overtake _____________________________\n[Tests/test]   | \n[Tests/test]   | W = {'beta': [], 'd': <0x1 matrix, tc='d'>, 'di': <0x1 matrix, tc='d'>, 'r': [], ...}\n[Tests/test]   | H = <5x5 matrix, tc='d'>, Df = None\n[Tests/test]   | \n[Tests/test]   |     def factor(W, H = None, Df = None):\n[Tests/test]   |     \n[Tests/test]   |         if F['firstcall']:\n[Tests/test]   |             if type(G) is matrix:\n[Tests/test]   |                 F['Gs'] = matrix(0.0, G.size)\n[Tests/test]   |             else:\n[Tests/test]   |                 F['Gs'] = spmatrix(0.0, G.I, G.J, G.size)\n[Tests/test]   |             if mnl:\n[Tests/test]   |                 if type(Df) is matrix:\n[Tests/test]   |                     F['Dfs'] = matrix(0.0, Df.size)\n[Tests/test]   |                 else:\n[Tests/test]   |                     F['Dfs'] = spmatrix(0.0, Df.I, Df.J, Df.size)\n[Tests/test]   |             if (mnl and type(Df) is matrix) or type(G) is matrix or \\\n[Tests/test]   |                 type(H) is matrix:\n[Tests/test]   |                 F['S'] = matrix(0.0, (n,n))\n[Tests/test]   |                 F['K'] = matrix(0.0, (p,p))\n[Tests/test]   |             else:\n[Tests/test]   |                 F['S'] = spmatrix([], [], [], (n,n), 'd')\n[Tests/test]   |                 F['Sf'] = None\n[Tests/test]   |                 if type(A) is matrix:\n[Tests/test]   |                     F['K'] = matrix(0.0, (p,p))\n[Tests/test]   |                 else:\n[Tests/test]   |                     F['K'] = spmatrix([], [], [], (p,p), 'd')\n[Tests/test]   |     \n[Tests/test]   |         # Dfs = Wnl^{-1} * Df\n[Tests/test]   |         if mnl: base.gemm(spmatrix(W['dnli'], list(range(mnl)),\n[Tests/test]   |             list(range(mnl))), Df, F['Dfs'], partial = True)\n[Tests/test]   |     \n[Tests/test]   |         # Gs = Wl^{-1} * G.\n[Tests/test]   |         base.gemm(spmatrix(W['di'], list(range(ml)), list(range(ml))),\n[Tests/test]   |             G, F['Gs'], partial = True)\n[Tests/test]   |     \n[Tests/test]   |         if F['firstcall']:\n[Tests/test]   |             base.syrk(F['Gs'], F['S'], trans = 'T')\n[Tests/test]   |             if mnl:\n[Tests/test]   |                 base.syrk(F['Dfs'], F['S'], trans = 'T', beta = 1.0)\n[Tests/test]   |             if H is not None:\n[Tests/test]   |                 F['S'] += H\n[Tests/test]   |             try:\n[Tests/test]   |                 if type(F['S']) is matrix:\n[Tests/test]   | >                   lapack.potrf(F['S'])\n[Tests/test]   | E                   ArithmeticError: 1\n[Tests/test]   | \n[Tests/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/site-packages/cvxopt/misc.py:1429: ArithmeticError\n[Tests/test]   | \n[Tests/test]   | During handling of the above exception, another exception occurred:\n[Tests/test]   | \n[Tests/test]   | P = <5x5 matrix, tc='d'>, q = <5x1 matrix, tc='d'>\n[Tests/test]   | G = <0x5 sparse matrix, tc='d', nnz=0>, h = <0x1 matrix, tc='d'>\n[Tests/test]   | dims = {'l': 0, 'q': [], 's': []}, A = <0x5 sparse matrix, tc='d', nnz=0>\n[Tests/test]   | b = <0x1 matrix, tc='d'>, initvals = None\n[Tests/test]   | kktsolver = <function coneqp.<locals>.kktsolver at 0x7f99247086a8>\n[Tests/test]   | xnewcopy = <class 'cvxopt.base.matrix'>, xdot = <built-in function dot>\n[Tests/test]   | xaxpy = <built-in function axpy>, xscal = <built-in function scal>\n[Tests/test]   | ynewcopy = <class 'cvxopt.base.matrix'>, ydot = <built-in function dot>\n[Tests/test]   | yaxpy = <built-in function axpy>, yscal = <built-in function scal>\n[Tests/test]   | kwargs = {'options': {}}, spmatrix = <class 'cvxopt.base.spmatrix'>, STEP = 0.99\n[Tests/test]   | EXPON = 3, options = {}, KKTREG = None, correction = True, MAXITERS = 100\n[Tests/test]   | \n[Tests/test]   |     def coneqp(P, q, G = None, h = None, dims = None, A = None, b = None,\n[Tests/test]   |         initvals = None, kktsolver = None, xnewcopy = None, xdot = None,\n[Tests/test]   |         xaxpy = None, xscal = None, ynewcopy = None, ydot = None, yaxpy = None,\n[Tests/test]   |         yscal = None, **kwargs):\n[Tests/test]   |         \"\"\"\n[Tests/test]   |     \n[Tests/test]   |         Solves a pair of primal and dual convex quadratic cone programs\n[Tests/test]   |     \n[Tests/test]   |             minimize    (1/2)*x'*P*x + q'*x\n[Tests/test]   |             subject to  G*x + s = h\n[Tests/test]   |                         A*x = b\n[Tests/test]   |                         s >= 0\n[Tests/test]   |     \n[Tests/test]   |             maximize    -(1/2)*(q + G'*z + A'*y)' * pinv(P) * (q + G'*z + A'*y)\n[Tests/test]   |                         - h'*z - b'*y\n[Tests/test]   |             subject to  q + G'*z + A'*y in range(P)\n[Tests/test]   |                         z >= 0.\n[Tests/test]   |     \n[Tests/test]   |         The inequalities are with respect to a cone C defined as the Cartesian\n[Tests/test]   |         product of N + M + 1 cones:\n[Tests/test]   |     \n[Tests/test]   |             C = C_0 x C_1 x .... x C_N x C_{N+1} x ... x C_{N+M}.\n[Tests/test]   |     \n[Tests/test]   |         The first cone C_0 is the nonnegative orthant of dimension ml.\n[Tests/test]   |         The next N cones are 2nd order cones of dimension mq[0], ..., mq[N-1].\n[Tests/test]   |         The second order cone of dimension m is defined as\n[Tests/test]   |     \n[Tests/test]   |             { (u0, u1) in R x R^{m-1} | u0 >= ||u1||_2 }.\n[Tests/test]   |     \n[Tests/test]   |         The next M cones are positive semidefinite cones of order ms[0], ...,\n[Tests/test]   |         ms[M-1] >= 0.\n[Tests/test]   |     \n[Tests/test]   |     \n[Tests/test]   |         Input arguments (basic usage).\n[Tests/test]   |     \n[Tests/test]   |             P is a dense or sparse 'd' matrix of size (n,n) with the lower\n[Tests/test]   |             triangular part of the Hessian of the objective stored in the\n[Tests/test]   |             lower triangle.  Must be positive semidefinite.\n[Tests/test]   |     \n[Tests/test]   |             q is a dense 'd' matrix of size (n,1).\n[Tests/test]   |     \n[Tests/test]   |             dims is a dictionary with the dimensions of the components of C.\n[Tests/test]   |             It has three fields.\n[Tests/test]   |             - dims['l'] = ml, the dimension of the nonnegative orthant C_0.\n[Tests/test]   |               (ml >= 0.)\n[Tests/test]   |             - dims['q'] = mq = [ mq[0], mq[1], ..., mq[N-1] ], a list of N\n[Tests/test]   |               integers with the dimensions of the second order cones\n[Tests/test]   |               C_1, ..., C_N.  (N >= 0 and mq[k] >= 1.)\n[Tests/test]   |             - dims['s'] = ms = [ ms[0], ms[1], ..., ms[M-1] ], a list of M\n[Tests/test]   |               integers with the orders of the semidefinite cones\n[Tests/test]   |               C_{N+1}, ..., C_{N+M}.  (M >= 0 and ms[k] >= 0.)\n[Tests/test]   |             The default value of dims = {'l': G.size[0], 'q': [], 's': []}.\n[Tests/test]   |     \n[Tests/test]   |             G is a dense or sparse 'd' matrix of size (K,n), where\n[Tests/test]   |     \n[Tests/test]   |                 K = ml + mq[0] + ... + mq[N-1] + ms[0]**2 + ... + ms[M-1]**2.\n[Tests/test]   |     \n[Tests/test]   |             Each column of G describes a vector\n[Tests/test]   |     \n[Tests/test]   |                 v = ( v_0, v_1, ..., v_N, vec(v_{N+1}), ..., vec(v_{N+M}) )\n[Tests/test]   |     \n[Tests/test]   |             in V = R^ml x R^mq[0] x ... x R^mq[N-1] x S^ms[0] x ... x S^ms[M-1]\n[Tests/test]   |             stored as a column vector\n[Tests/test]   |     \n[Tests/test]   |                 [ v_0; v_1; ...; v_N; vec(v_{N+1}); ...; vec(v_{N+M}) ].\n[Tests/test]   |     \n[Tests/test]   |             Here, if u is a symmetric matrix of order m, then vec(u) is the\n[Tests/test]   |             matrix u stored in column major order as a vector of length m**2.\n[Tests/test]   |             We use BLAS unpacked 'L' storage, i.e., the entries in vec(u)\n[Tests/test]   |             corresponding to the strictly upper triangular entries of u are\n[Tests/test]   |             not referenced.\n[Tests/test]   |     \n[Tests/test]   |             h is a dense 'd' matrix of size (K,1), representing a vector in V,\n[Tests/test]   |             in the same format as the columns of G.\n[Tests/test]   |     \n[Tests/test]   |             A is a dense or sparse 'd' matrix of size (p,n).   The default\n[Tests/test]   |             value is a sparse 'd' matrix of size (0,n).\n[Tests/test]   |     \n[Tests/test]   |             b is a dense 'd' matrix of size (p,1).  The default value is a\n[Tests/test]   |             dense 'd' matrix of size (0,1).\n[Tests/test]   |     \n[Tests/test]   |             initvals is a dictionary with optional primal and dual starting\n[Tests/test]   |             points initvals['x'], initvals['s'], initvals['y'], initvals['z'].\n[Tests/test]   |             - initvals['x'] is a dense 'd' matrix of size (n,1).\n[Tests/test]   |             - initvals['s'] is a dense 'd' matrix of size (K,1), representing\n[Tests/test]   |               a vector that is strictly positive with respect to the cone C.\n[Tests/test]   |             - initvals['y'] is a dense 'd' matrix of size (p,1).\n[Tests/test]   |             - initvals['z'] is a dense 'd' matrix of size (K,1), representing\n[Tests/test]   |               a vector that is strictly positive with respect to the cone C.\n[Tests/test]   |             A default initialization is used for the variables that are not\n[Tests/test]   |             specified in initvals.\n[Tests/test]   |     \n[Tests/test]   |             It is assumed that rank(A) = p and rank([P; A; G]) = n.\n[Tests/test]   |     \n[Tests/test]   |             The other arguments are normally not needed.  They make it possible\n[Tests/test]   |             to exploit certain types of structure, as described below.\n[Tests/test]   |     \n[Tests/test]   |     \n[Tests/test]   |         Output arguments.\n[Tests/test]   |     \n[Tests/test]   |             Returns a dictionary with keys 'status', 'x', 's', 'z', 'y',\n[Tests/test]   |             'primal objective', 'dual objective', 'gap', 'relative gap',\n[Tests/test]   |             'primal infeasibility', 'dual infeasibility', 'primal slack',\n[Tests/test]   |             'dual slack', 'iterations'.\n[Tests/test]   |     \n[Tests/test]   |             The 'status' field has values 'optimal' or 'unknown'.  'iterations'\n[Tests/test]   |             is the number of iterations taken.\n[Tests/test]   |     \n[Tests/test]   |             If the status is 'optimal', 'x', 's', 'y', 'z' are an approximate\n[Tests/test]   |             solution of the primal and dual optimality conditions\n[Tests/test]   |     \n[Tests/test]   |                   G*x + s = h,  A*x = b\n[Tests/test]   |                   P*x + G'*z + A'*y + q = 0\n[Tests/test]   |                   s >= 0,  z >= 0\n[Tests/test]   |                   s'*z = 0.\n[Tests/test]   |     \n[Tests/test]   |             If the status is 'unknown', 'x', 'y', 's', 'z' are the last\n[Tests/test]   |             iterates before termination.  These satisfy s > 0 and z > 0,\n[Tests/test]   |             but are not necessarily feasible.\n[Tests/test]   |     \n[Tests/test]   |             The values of the other fields are defined as follows.\n[Tests/test]   |     \n[Tests/test]   |             - 'primal objective': the primal objective (1/2)*x'*P*x + q'*x.\n[Tests/test]   |     \n[Tests/test]   |             - 'dual objective': the dual objective\n[Tests/test]   |     \n[Tests/test]   |                   L(x,y,z) = (1/2)*x'*P*x + q'*x + z'*(G*x - h) + y'*(A*x-b).\n[Tests/test]   |     \n[Tests/test]   |             - 'gap': the duality gap s'*z.\n[Tests/test]   |     \n[Tests/test]   |             - 'relative gap': the relative gap, defined as\n[Tests/test]   |     \n[Tests/test]   |                   gap / -primal objective\n[Tests/test]   |     \n[Tests/test]   |               if the primal objective is negative,\n[Tests/test]   |     \n[Tests/test]   |                   gap / dual objective\n[Tests/test]   |     \n[Tests/test]   |               if the dual objective is positive, and None otherwise.\n[Tests/test]   |     \n[Tests/test]   |             - 'primal infeasibility': the residual in the primal constraints,\n[Tests/test]   |               defined as the maximum of the residual in the inequalities\n[Tests/test]   |     \n[Tests/test]   |                   || G*x + s - h || / max(1, ||h||)\n[Tests/test]   |     \n[Tests/test]   |               and the residual in the equalities\n[Tests/test]   |     \n[Tests/test]   |                   || A*x - b || / max(1, ||b||).\n[Tests/test]   |     \n[Tests/test]   |     \n[Tests/test]   |             - 'dual infeasibility': the residual in the dual constraints,\n[Tests/test]   |               defined as\n[Tests/test]   |     \n[Tests/test]   |                   || P*x + G'*z + A'*y + q || / max(1, ||q||).\n[Tests/test]   |     \n[Tests/test]   |     \n[Tests/test]   |             - 'primal slack': the smallest primal slack, sup {t | s >= t*e },\n[Tests/test]   |                where\n[Tests/test]   |     \n[Tests/test]   |                   e = ( e_0, e_1, ..., e_N, e_{N+1}, ..., e_{M+N} )\n[Tests/test]   |     \n[Tests/test]   |               is the identity vector in C.  e_0 is an ml-vector of ones,\n[Tests/test]   |               e_k, k = 1,..., N, is the unit vector (1,0,...,0) of length\n[Tests/test]   |               mq[k], and e_k = vec(I) where I is the identity matrix of order\n[Tests/test]   |               ms[k].\n[Tests/test]   |     \n[Tests/test]   |             - 'dual slack': the smallest dual slack, sup {t | z >= t*e }.\n[Tests/test]   |     \n[Tests/test]   |             If the exit status is 'optimal', then the primal and dual\n[Tests/test]   |             infeasibilities are guaranteed to be less than\n[Tests/test]   |             solvers.options['feastol'] (default 1e-7).  The gap is less than\n[Tests/test]   |             solvers.options['abstol'] (default 1e-7) or the relative gap is\n[Tests/test]   |             less than solvers.options['reltol'] (default 1e-6).\n[Tests/test]   |     \n[Tests/test]   |             Termination with status 'unknown' indicates that the algorithm\n[Tests/test]   |             failed to find a solution that satisfies the specified tolerances.\n[Tests/test]   |             In some cases, the returned solution may be fairly accurate.  If\n[Tests/test]   |             the primal and dual infeasibilities, the gap, and the relative gap\n[Tests/test]   |             are small, then x, y, s, z are close to optimal.\n[Tests/test]   |     \n[Tests/test]   |     \n[Tests/test]   |         Advanced usage.\n[Tests/test]   |     \n[Tests/test]   |             Three mechanisms are provided to express problem structure.\n[Tests/test]   |     \n[Tests/test]   |             1.  The user can provide a customized routine for solving linear\n[Tests/test]   |             equations (`KKT systems')\n[Tests/test]   |     \n[Tests/test]   |                 [ P   A'  G'    ] [ ux ]   [ bx ]\n[Tests/test]   |                 [ A   0   0     ] [ uy ] = [ by ].\n[Tests/test]   |                 [ G   0   -W'*W ] [ uz ]   [ bz ]\n[Tests/test]   |     \n[Tests/test]   |             W is a scaling matrix, a block diagonal mapping\n[Tests/test]   |     \n[Tests/test]   |                W*u = ( W0*u_0, ..., W_{N+M}*u_{N+M} )\n[Tests/test]   |     \n[Tests/test]   |             defined as follows.\n[Tests/test]   |     \n[Tests/test]   |             - For the 'l' block (W_0):\n[Tests/test]   |     \n[Tests/test]   |                   W_0 = diag(d),\n[Tests/test]   |     \n[Tests/test]   |               with d a positive vector of length ml.\n[Tests/test]   |     \n[Tests/test]   |             - For the 'q' blocks (W_{k+1}, k = 0, ..., N-1):\n[Tests/test]   |     \n[Tests/test]   |                   W_{k+1} = beta_k * ( 2 * v_k * v_k' - J )\n[Tests/test]   |     \n[Tests/test]   |               where beta_k is a positive scalar, v_k is a vector in R^mq[k]\n[Tests/test]   |               with v_k[0] > 0 and v_k'*J*v_k = 1, and J = [1, 0; 0, -I].\n[Tests/test]   |     \n[Tests/test]   |             - For the 's' blocks (W_{k+N}, k = 0, ..., M-1):\n[Tests/test]   |     \n[Tests/test]   |                   W_k * u = vec(r_k' * mat(u) * r_k)\n[Tests/test]   |     \n[Tests/test]   |               where r_k is a nonsingular matrix of order ms[k], and mat(x) is\n[Tests/test]   |               the inverse of the vec operation.\n[Tests/test]   |     \n[Tests/test]   |             The optional argument kktsolver is a Python function that will be\n[Tests/test]   |             called as g = kktsolver(W).  W is a dictionary that contains\n[Tests/test]   |             the parameters of the scaling:\n[Tests/test]   |     \n[Tests/test]   |             - W['d'] is a positive 'd' matrix of size (ml,1).\n[Tests/test]   |             - W['di'] is a positive 'd' matrix with the elementwise inverse of\n[Tests/test]   |               W['d'].\n[Tests/test]   |             - W['beta'] is a list [ beta_0, ..., beta_{N-1} ]\n[Tests/test]   |             - W['v'] is a list [ v_0, ..., v_{N-1} ]\n[Tests/test]   |             - W['r'] is a list [ r_0, ..., r_{M-1} ]\n[Tests/test]   |             - W['rti'] is a list [ rti_0, ..., rti_{M-1} ], with rti_k the\n[Tests/test]   |               inverse of the transpose of r_k.\n[Tests/test]   |     \n[Tests/test]   |             The call g = kktsolver(W) should return a function g that solves\n[Tests/test]   |             the KKT system by g(x, y, z).  On entry, x, y, z contain the\n[Tests/test]   |             righthand side bx, by, bz.  On exit, they contain the solution,\n[Tests/test]   |             with uz scaled, the argument z contains W*uz.  In other words,\n[Tests/test]   |             on exit x, y, z are the solution of\n[Tests/test]   |     \n[Tests/test]   |                 [ P   A'  G'*W^{-1} ] [ ux ]   [ bx ]\n[Tests/test]   |                 [ A   0   0         ] [ uy ] = [ by ].\n[Tests/test]   |                 [ G   0   -W'       ] [ uz ]   [ bz ]\n[Tests/test]   |     \n[Tests/test]   |     \n[Tests/test]   |             2.  The linear operators P*u, G*u and A*u can be specified\n[Tests/test]   |             by providing Python functions instead of matrices.  This can only\n[Tests/test]   |             be done in combination with 1. above, i.e., it requires the\n[Tests/test]   |             kktsolver argument.\n[Tests/test]   |     \n[Tests/test]   |             If P is a function, the call P(u, v, alpha, beta) should evaluate\n[Tests/test]   |             the matrix-vectors product\n[Tests/test]   |     \n[Tests/test]   |                 v := alpha * P * u + beta * v.\n[Tests/test]   |     \n[Tests/test]   |             The arguments u and v are required.  The other arguments have\n[Tests/test]   |             default values alpha = 1.0, beta = 0.0.\n[Tests/test]   |     \n[Tests/test]   |             If G is a function, the call G(u, v, alpha, beta, trans) should\n[Tests/test]   |             evaluate the matrix-vector products\n[Tests/test]   |     \n[Tests/test]   |                 v := alpha * G * u + beta * v  if trans is 'N'\n[Tests/test]   |                 v := alpha * G' * u + beta * v  if trans is 'T'.\n[Tests/test]   |     \n[Tests/test]   |             The arguments u and v are required.  The other arguments have\n[Tests/test]   |             default values alpha = 1.0, beta = 0.0, trans = 'N'.\n[Tests/test]   |     \n[Tests/test]   |             If A is a function, the call A(u, v, alpha, beta, trans) should\n[Tests/test]   |             evaluate the matrix-vectors products\n[Tests/test]   |     \n[Tests/test]   |                 v := alpha * A * u + beta * v if trans is 'N'\n[Tests/test]   |                 v := alpha * A' * u + beta * v if trans is 'T'.\n[Tests/test]   |     \n[Tests/test]   |             The arguments u and v are required.  The other arguments\n[Tests/test]   |             have default values alpha = 1.0, beta = 0.0, trans = 'N'.\n[Tests/test]   |     \n[Tests/test]   |     \n[Tests/test]   |             3.  Instead of using the default representation of the primal\n[Tests/test]   |             variable x and the dual variable y as one-column 'd' matrices,\n[Tests/test]   |             we can represent these variables and the corresponding parameters\n[Tests/test]   |             q and b by arbitrary Python objects (matrices, lists, dictionaries,\n[Tests/test]   |             etc).  This can only be done in combination with 1. and 2. above,\n[Tests/test]   |             i.e., it requires a user-provided KKT solver and an operator\n[Tests/test]   |             description of the linear mappings.   It also requires the\n[Tests/test]   |             arguments xnewcopy, xdot, xscal, xaxpy, ynewcopy, ydot, yscal,\n[Tests/test]   |             yaxpy.  These arguments are functions defined as follows.\n[Tests/test]   |     \n[Tests/test]   |             If X is the vector space of primal variables x, then:\n[Tests/test]   |             - xnewcopy(u) creates a new copy of the vector u in X.\n[Tests/test]   |             - xdot(u, v) returns the inner product of two vectors u and v in X.\n[Tests/test]   |             - xscal(alpha, u) computes u := alpha*u, where alpha is a scalar\n[Tests/test]   |               and u is a vector in X.\n[Tests/test]   |             - xaxpy(u, v, alpha = 1.0) computes v := alpha*u + v for a scalar\n[Tests/test]   |               alpha and two vectors u and v in X.\n[Tests/test]   |             If this option is used, the argument q must be in the same format\n[Tests/test]   |             as x, the argument P must be a Python function, the arguments A\n[Tests/test]   |             and G must be Python functions or None, and the argument\n[Tests/test]   |             kktsolver is required.\n[Tests/test]   |     \n[Tests/test]   |             If Y is the vector space of primal variables y:\n[Tests/test]   |             - ynewcopy(u) creates a new copy of the vector u in Y.\n[Tests/test]   |             - ydot(u, v) returns the inner product of two vectors u and v in Y.\n[Tests/test]   |             - yscal(alpha, u) computes u := alpha*u, where alpha is a scalar\n[Tests/test]   |               and u is a vector in Y.\n[Tests/test]   |             - yaxpy(u, v, alpha = 1.0) computes v := alpha*u + v for a scalar\n[Tests/test]   |               alpha and two vectors u and v in Y.\n[Tests/test]   |             If this option is used, the argument b must be in the same format\n[Tests/test]   |             as y, the argument A must be a Python function or None, and the\n[Tests/test]   |             argument kktsolver is required.\n[Tests/test]   |     \n[Tests/test]   |     \n[Tests/test]   |         Control parameters.\n[Tests/test]   |     \n[Tests/test]   |            The following control parameters can be modified by adding an\n[Tests/test]   |            entry to the dictionary options.\n[Tests/test]   |     \n[Tests/test]   |            options['show_progress'] True/False (default: True)\n[Tests/test]   |            options['maxiters'] positive integer (default: 100)\n[Tests/test]   |            options['refinement'] nonnegative integer (default: 0 for problems\n[Tests/test]   |                with no second-order cone and matrix inequality constraints;\n[Tests/test]   |                1 otherwise)\n[Tests/test]   |            options['abstol'] scalar (default: 1e-7)\n[Tests/test]   |            options['reltol'] scalar (default: 1e-6)\n[Tests/test]   |            options['feastol'] scalar (default: 1e-7).\n[Tests/test]   |     \n[Tests/test]   |         \"\"\"\n[Tests/test]   |         import math\n[Tests/test]   |         from cvxopt import base, blas, misc\n[Tests/test]   |         from cvxopt.base import matrix, spmatrix\n[Tests/test]   |     \n[Tests/test]   |         STEP = 0.99\n[Tests/test]   |         EXPON = 3\n[Tests/test]   |     \n[Tests/test]   |         options = kwargs.get('options',globals()['options'])\n[Tests/test]   |     \n[Tests/test]   |         DEBUG = options.get('debug',False)\n[Tests/test]   |     \n[Tests/test]   |         KKTREG = options.get('kktreg',None)\n[Tests/test]   |         if KKTREG is None:\n[Tests/test]   |             pass\n[Tests/test]   |         elif not isinstance(KKTREG,(float,int,long)) or KKTREG < 0.0:\n[Tests/test]   |             raise ValueError(\"options['kktreg'] must be a nonnegative scalar\")\n[Tests/test]   |     \n[Tests/test]   |         # Use Mehrotra correction or not.\n[Tests/test]   |         correction = options.get('use_correction', True)\n[Tests/test]   |     \n[Tests/test]   |         MAXITERS = options.get('maxiters',100)\n[Tests/test]   |         if not isinstance(MAXITERS,(int,long)) or MAXITERS < 1:\n[Tests/test]   |             raise ValueError(\"options['maxiters'] must be a positive integer\")\n[Tests/test]   |     \n[Tests/test]   |         ABSTOL = options.get('abstol',1e-7)\n[Tests/test]   |         if not isinstance(ABSTOL,(float,int,long)):\n[Tests/test]   |             raise ValueError(\"options['abstol'] must be a scalar\")\n[Tests/test]   |     \n[Tests/test]   |         RELTOL = options.get('reltol',1e-6)\n[Tests/test]   |         if not isinstance(RELTOL,(float,int,long)):\n[Tests/test]   |             raise ValueError(\"options['reltol'] must be a scalar\")\n[Tests/test]   |     \n[Tests/test]   |         if RELTOL <= 0.0 and ABSTOL <= 0.0 :\n[Tests/test]   |             raise ValueError(\"at least one of options['reltol'] and \" \\\n[Tests/test]   |                 \"options['abstol'] must be positive\")\n[Tests/test]   |     \n[Tests/test]   |         FEASTOL = options.get('feastol',1e-7)\n[Tests/test]   |         if not isinstance(FEASTOL,(float,int,long)) or FEASTOL <= 0.0:\n[Tests/test]   |             raise ValueError(\"options['feastol'] must be a positive scalar\")\n[Tests/test]   |     \n[Tests/test]   |         show_progress = options.get('show_progress',True)\n[Tests/test]   |     \n[Tests/test]   |         if kktsolver is None:\n[Tests/test]   |             if dims and (dims['q'] or dims['s']):\n[Tests/test]   |                 kktsolver = 'chol'\n[Tests/test]   |             else:\n[Tests/test]   |                 kktsolver = 'chol2'\n[Tests/test]   |         defaultsolvers = ('ldl', 'ldl2', 'chol', 'chol2')\n[Tests/test]   |         if isinstance(kktsolver,str) and kktsolver not in defaultsolvers:\n[Tests/test]   |             raise ValueError(\"'%s' is not a valid value for kktsolver\" \\\n[Tests/test]   |                 %kktsolver)\n[Tests/test]   |     \n[Tests/test]   |         # Argument error checking depends on level of customization.\n[Tests/test]   |         customkkt = not isinstance(kktsolver,str)\n[Tests/test]   |         matrixP = isinstance(P, (matrix, spmatrix))\n[Tests/test]   |         matrixG = isinstance(G, (matrix, spmatrix))\n[Tests/test]   |         matrixA = isinstance(A, (matrix, spmatrix))\n[Tests/test]   |         if (not matrixP or (not matrixG and G is not None) or\n[Tests/test]   |             (not matrixA and A is not None)) and not customkkt:\n[Tests/test]   |             raise ValueError(\"use of function valued P, G, A requires a \"\\\n[Tests/test]   |                 \"user-provided kktsolver\")\n[Tests/test]   |         customx = (xnewcopy != None or xdot != None or xaxpy != None or\n[Tests/test]   |             xscal != None)\n[Tests/test]   |         if customx and (matrixP or matrixG or matrixA or not customkkt):\n[Tests/test]   |             raise ValueError(\"use of non-vector type for x requires \"\\\n[Tests/test]   |                 \"function valued P, G, A and user-provided kktsolver\")\n[Tests/test]   |         customy = (ynewcopy != None or ydot != None or yaxpy != None or\n[Tests/test]   |             yscal != None)\n[Tests/test]   |         if customy and (matrixA or not customkkt):\n[Tests/test]   |             raise ValueError(\"use of non vector type for y requires \"\\\n[Tests/test]   |                 \"function valued A and user-provided kktsolver\")\n[Tests/test]   |     \n[Tests/test]   |     \n[Tests/test]   |         if not customx and (not isinstance(q,matrix) or q.typecode != 'd' or q.size[1] != 1):\n[Tests/test]   |             raise TypeError(\"'q' must be a 'd' matrix with one column\")\n[Tests/test]   |     \n[Tests/test]   |         if matrixP:\n[Tests/test]   |             if P.typecode != 'd' or P.size != (q.size[0], q.size[0]):\n[Tests/test]   |                 raise TypeError(\"'P' must be a 'd' matrix of size (%d, %d)\"\\\n[Tests/test]   |                     %(q.size[0], q.size[0]))\n[Tests/test]   |             def fP(x, y, alpha = 1.0, beta = 0.0):\n[Tests/test]   |                 base.symv(P, x, y, alpha = alpha, beta = beta)\n[Tests/test]   |         else:\n[Tests/test]   |             fP = P\n[Tests/test]   |     \n[Tests/test]   |     \n[Tests/test]   |         if h is None: h = matrix(0.0, (0,1))\n[Tests/test]   |         if not isinstance(h, matrix) or h.typecode != 'd' or h.size[1] != 1:\n[Tests/test]   |             raise TypeError(\"'h' must be a 'd' matrix with one column\")\n[Tests/test]   |     \n[Tests/test]   |         if not dims: dims = {'l': h.size[0], 'q': [], 's': []}\n[Tests/test]   |         if not isinstance(dims['l'],(int,long)) or dims['l'] < 0:\n[Tests/test]   |             raise TypeError(\"'dims['l']' must be a nonnegative integer\")\n[Tests/test]   |         if [ k for k in dims['q'] if not isinstance(k,(int,long)) or k < 1 ]:\n[Tests/test]   |             raise TypeError(\"'dims['q']' must be a list of positive integers\")\n[Tests/test]   |         if [ k for k in dims['s'] if not isinstance(k,(int,long)) or k < 0 ]:\n[Tests/test]   |             raise TypeError(\"'dims['s']' must be a list of nonnegative \" \\\n[Tests/test]   |                 \"integers\")\n[Tests/test]   |     \n[Tests/test]   |         try: refinement = options['refinement']\n[Tests/test]   |         except KeyError:\n[Tests/test]   |             if dims['q'] or dims['s']: refinement = 1\n[Tests/test]   |             else: refinement = 0\n[Tests/test]   |         else:\n[Tests/test]   |             if not isinstance(refinement,(int,long)) or refinement < 0:\n[Tests/test]   |                 raise ValueError(\"options['refinement'] must be a \"\\\n[Tests/test]   |                     \"nonnegative integer\")\n[Tests/test]   |     \n[Tests/test]   |     \n[Tests/test]   |         cdim = dims['l'] + sum(dims['q']) + sum([ k**2 for k in dims['s'] ])\n[Tests/test]   |         if h.size[0] != cdim:\n[Tests/test]   |             raise TypeError(\"'h' must be a 'd' matrix of size (%d,1)\" %cdim)\n[Tests/test]   |     \n[Tests/test]   |         # Data for kth 'q' constraint are found in rows indq[k]:indq[k+1] of G.\n[Tests/test]   |         indq = [ dims['l'] ]\n[Tests/test]   |         for k in dims['q']:  indq = indq + [ indq[-1] + k ]\n[Tests/test]   |     \n[Tests/test]   |         # Data for kth 's' constraint are found in rows inds[k]:inds[k+1] of G.\n[Tests/test]   |         inds = [ indq[-1] ]\n[Tests/test]   |         for k in dims['s']:  inds = inds + [ inds[-1] + k**2 ]\n[Tests/test]   |     \n[Tests/test]   |         if G is None:\n[Tests/test]   |             if customx:\n[Tests/test]   |                 def G(x, y, trans = 'N', alpha = 1.0, beta = 0.0):\n[Tests/test]   |                     if trans == 'N': pass\n[Tests/test]   |                     else: xscal(beta, y)\n[Tests/test]   |             else:\n[Tests/test]   |                 G = spmatrix([], [], [], (0, q.size[0]))\n[Tests/test]   |                 matrixG = True\n[Tests/test]   |         if matrixG:\n[Tests/test]   |             if G.typecode != 'd' or G.size != (cdim, q.size[0]):\n[Tests/test]   |                 raise TypeError(\"'G' must be a 'd' matrix of size (%d, %d)\"\\\n[Tests/test]   |                     %(cdim, q.size[0]))\n[Tests/test]   |             def fG(x, y, trans = 'N', alpha = 1.0, beta = 0.0):\n[Tests/test]   |                 misc.sgemv(G, x, y, dims, trans = trans, alpha = alpha,\n[Tests/test]   |                     beta = beta)\n[Tests/test]   |         else:\n[Tests/test]   |             fG = G\n[Tests/test]   |     \n[Tests/test]   |     \n[Tests/test]   |         if A is None:\n[Tests/test]   |             if customx or customy:\n[Tests/test]   |                 def A(x, y, trans = 'N', alpha = 1.0, beta = 0.0):\n[Tests/test]   |                     if trans == 'N': pass\n[Tests/test]   |                     else: xscal(beta, y)\n[Tests/test]   |             else:\n[Tests/test]   |                 A = spmatrix([], [], [], (0, q.size[0]))\n[Tests/test]   |                 matrixA = True\n[Tests/test]   |         if matrixA:\n[Tests/test]   |             if A.typecode != 'd' or A.size[1] != q.size[0]:\n[Tests/test]   |                 raise TypeError(\"'A' must be a 'd' matrix with %d columns\" \\\n[Tests/test]   |                     %q.size[0])\n[Tests/test]   |             def fA(x, y, trans = 'N', alpha = 1.0, beta = 0.0):\n[Tests/test]   |                 base.gemv(A, x, y, trans = trans, alpha = alpha, beta = beta)\n[Tests/test]   |         else:\n[Tests/test]   |             fA = A\n[Tests/test]   |         if not customy:\n[Tests/test]   |             if b is None: b = matrix(0.0, (0,1))\n[Tests/test]   |             if not isinstance(b, matrix) or b.typecode != 'd' or b.size[1] != 1:\n[Tests/test]   |                 raise TypeError(\"'b' must be a 'd' matrix with one column\")\n[Tests/test]   |             if matrixA and b.size[0] != A.size[0]:\n[Tests/test]   |                 raise TypeError(\"'b' must have length %d\" %A.size[0])\n[Tests/test]   |         if b is None and customy:\n[Tests/test]   |             raise ValueEror(\"use of non-vector type for y requires b\")\n[Tests/test]   |     \n[Tests/test]   |     \n[Tests/test]   |         ws3, wz3 = matrix(0.0, (cdim,1 )), matrix(0.0, (cdim,1 ))\n[Tests/test]   |         def res(ux, uy, uz, us, vx, vy, vz, vs, W, lmbda):\n[Tests/test]   |     \n[Tests/test]   |             # Evaluates residual in Newton equations:\n[Tests/test]   |             #\n[Tests/test]   |             #      [ vx ]    [ vx ]   [ 0     ]   [ P  A'  G' ]   [ ux        ]\n[Tests/test]   |             #      [ vy ] := [ vy ] - [ 0     ] - [ A  0   0  ] * [ uy        ]\n[Tests/test]   |             #      [ vz ]    [ vz ]   [ W'*us ]   [ G  0   0  ]   [ W^{-1}*uz ]\n[Tests/test]   |             #\n[Tests/test]   |             #      vs := vs - lmbda o (uz + us).\n[Tests/test]   |     \n[Tests/test]   |             # vx := vx - P*ux - A'*uy - G'*W^{-1}*uz\n[Tests/test]   |             fP(ux, vx, alpha = -1.0, beta = 1.0)\n[Tests/test]   |             fA(uy, vx, alpha = -1.0, beta = 1.0, trans = 'T')\n[Tests/test]   |             blas.copy(uz, wz3)\n[Tests/test]   |             misc.scale(wz3, W, inverse = 'I')\n[Tests/test]   |             fG(wz3, vx, alpha = -1.0, beta = 1.0, trans = 'T')\n[Tests/test]   |     \n[Tests/test]   |             # vy := vy - A*ux\n[Tests/test]   |             fA(ux, vy, alpha = -1.0, beta = 1.0)\n[Tests/test]   |     \n[Tests/test]   |             # vz := vz - G*ux - W'*us\n[Tests/test]   |             fG(ux, vz, alpha = -1.0, beta = 1.0)\n[Tests/test]   |             blas.copy(us, ws3)\n[Tests/test]   |             misc.scale(ws3, W, trans = 'T')\n[Tests/test]   |             blas.axpy(ws3, vz, alpha = -1.0)\n[Tests/test]   |     \n[Tests/test]   |             # vs := vs - lmbda o (uz + us)\n[Tests/test]   |             blas.copy(us, ws3)\n[Tests/test]   |             blas.axpy(uz, ws3)\n[Tests/test]   |             misc.sprod(ws3, lmbda, dims, diag = 'D')\n[Tests/test]   |             blas.axpy(ws3, vs, alpha = -1.0)\n[Tests/test]   |     \n[Tests/test]   |     \n[Tests/test]   |         # kktsolver(W) returns a routine for solving\n[Tests/test]   |         #\n[Tests/test]   |         #     [ P   A'  G'*W^{-1} ] [ ux ]   [ bx ]\n[Tests/test]   |         #     [ A   0   0         ] [ uy ] = [ by ].\n[Tests/test]   |         #     [ G   0   -W'       ] [ uz ]   [ bz ]\n[Tests/test]   |     \n[Tests/test]   |         if kktsolver in defaultsolvers:\n[Tests/test]   |              if KKTREG is None and b.size[0] > q.size[0]:\n[Tests/test]   |                  raise ValueError(\"Rank(A) < p or Rank([P; G; A]) < n\")\n[Tests/test]   |              if kktsolver == 'ldl':\n[Tests/test]   |                  factor = misc.kkt_ldl(G, dims, A, kktreg = KKTREG)\n[Tests/test]   |              elif kktsolver == 'ldl2':\n[Tests/test]   |                  factor = misc.kkt_ldl2(G, dims, A)\n[Tests/test]   |              elif kktsolver == 'chol':\n[Tests/test]   |                  factor = misc.kkt_chol(G, dims, A)\n[Tests/test]   |              else:\n[Tests/test]   |                  factor = misc.kkt_chol2(G, dims, A)\n[Tests/test]   |              def kktsolver(W):\n[Tests/test]   |                  return factor(W, P)\n[Tests/test]   |     \n[Tests/test]   |         if xnewcopy is None: xnewcopy = matrix\n[Tests/test]   |         if xdot is None: xdot = blas.dot\n[Tests/test]   |         if xaxpy is None: xaxpy = blas.axpy\n[Tests/test]   |         if xscal is None: xscal = blas.scal\n[Tests/test]   |         def xcopy(x, y):\n[Tests/test]   |             xscal(0.0, y)\n[Tests/test]   |             xaxpy(x, y)\n[Tests/test]   |         if ynewcopy is None: ynewcopy = matrix\n[Tests/test]   |         if ydot is None: ydot = blas.dot\n[Tests/test]   |         if yaxpy is None: yaxpy = blas.axpy\n[Tests/test]   |         if yscal is None: yscal = blas.scal\n[Tests/test]   |         def ycopy(x, y):\n[Tests/test]   |             yscal(0.0, y)\n[Tests/test]   |             yaxpy(x, y)\n[Tests/test]   |     \n[Tests/test]   |         resx0 = max(1.0, math.sqrt(xdot(q,q)))\n[Tests/test]   |         resy0 = max(1.0, math.sqrt(ydot(b,b)))\n[Tests/test]   |         resz0 = max(1.0, misc.snrm2(h, dims))\n[Tests/test]   |     \n[Tests/test]   |         if cdim == 0:\n[Tests/test]   |     \n[Tests/test]   |             # Solve\n[Tests/test]   |             #\n[Tests/test]   |             #     [ P  A' ] [ x ]   [ -q ]\n[Tests/test]   |             #     [       ] [   ] = [    ].\n[Tests/test]   |             #     [ A  0  ] [ y ]   [  b ]\n[Tests/test]   |     \n[Tests/test]   |             try: f3 = kktsolver({'d': matrix(0.0, (0,1)), 'di':\n[Tests/test]   | >               matrix(0.0, (0,1)), 'beta': [], 'v': [], 'r': [], 'rti': []})\n[Tests/test]   | \n[Tests/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/site-packages/cvxopt/coneprog.py:2011: \n[Tests/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Tests/test]   | \n[Tests/test]   | W = {'beta': [], 'd': <0x1 matrix, tc='d'>, 'di': <0x1 matrix, tc='d'>, 'r': [], ...}\n[Tests/test]   | \n[Tests/test]   |     def kktsolver(W):\n[Tests/test]   | >       return factor(W, P)\n[Tests/test]   | \n[Tests/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/site-packages/cvxopt/coneprog.py:1981: \n[Tests/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Tests/test]   | \n[Tests/test]   | W = {'beta': [], 'd': <0x1 matrix, tc='d'>, 'di': <0x1 matrix, tc='d'>, 'r': [], ...}\n[Tests/test]   | H = <5x5 matrix, tc='d'>, Df = None\n[Tests/test]   | \n[Tests/test]   |     def factor(W, H = None, Df = None):\n[Tests/test]   |     \n[Tests/test]   |         if F['firstcall']:\n[Tests/test]   |             if type(G) is matrix:\n[Tests/test]   |                 F['Gs'] = matrix(0.0, G.size)\n[Tests/test]   |             else:\n[Tests/test]   |                 F['Gs'] = spmatrix(0.0, G.I, G.J, G.size)\n[Tests/test]   |             if mnl:\n[Tests/test]   |                 if type(Df) is matrix:\n[Tests/test]   |                     F['Dfs'] = matrix(0.0, Df.size)\n[Tests/test]   |                 else:\n[Tests/test]   |                     F['Dfs'] = spmatrix(0.0, Df.I, Df.J, Df.size)\n[Tests/test]   |             if (mnl and type(Df) is matrix) or type(G) is matrix or \\\n[Tests/test]   |                 type(H) is matrix:\n[Tests/test]   |                 F['S'] = matrix(0.0, (n,n))\n[Tests/test]   |                 F['K'] = matrix(0.0, (p,p))\n[Tests/test]   |             else:\n[Tests/test]   |                 F['S'] = spmatrix([], [], [], (n,n), 'd')\n[Tests/test]   |                 F['Sf'] = None\n[Tests/test]   |                 if type(A) is matrix:\n[Tests/test]   |                     F['K'] = matrix(0.0, (p,p))\n[Tests/test]   |                 else:\n[Tests/test]   |                     F['K'] = spmatrix([], [], [], (p,p), 'd')\n[Tests/test]   |     \n[Tests/test]   |         # Dfs = Wnl^{-1} * Df\n[Tests/test]   |         if mnl: base.gemm(spmatrix(W['dnli'], list(range(mnl)),\n[Tests/test]   |             list(range(mnl))), Df, F['Dfs'], partial = True)\n[Tests/test]   |     \n[Tests/test]   |         # Gs = Wl^{-1} * G.\n[Tests/test]   |         base.gemm(spmatrix(W['di'], list(range(ml)), list(range(ml))),\n[Tests/test]   |             G, F['Gs'], partial = True)\n[Tests/test]   |     \n[Tests/test]   |         if F['firstcall']:\n[Tests/test]   |             base.syrk(F['Gs'], F['S'], trans = 'T')\n[Tests/test]   |             if mnl:\n[Tests/test]   |                 base.syrk(F['Dfs'], F['S'], trans = 'T', beta = 1.0)\n[Tests/test]   |             if H is not None:\n[Tests/test]   |                 F['S'] += H\n[Tests/test]   |             try:\n[Tests/test]   |                 if type(F['S']) is matrix:\n[Tests/test]   |                     lapack.potrf(F['S'])\n[Tests/test]   |                 else:\n[Tests/test]   |                     F['Sf'] = cholmod.symbolic(F['S'])\n[Tests/test]   |                     cholmod.numeric(F['S'], F['Sf'])\n[Tests/test]   |             except ArithmeticError:\n[Tests/test]   |                 F['singular'] = True\n[Tests/test]   |                 if type(A) is matrix and type(F['S']) is spmatrix:\n[Tests/test]   |                     F['S'] = matrix(0.0, (n,n))\n[Tests/test]   |                 base.syrk(F['Gs'], F['S'], trans = 'T')\n[Tests/test]   |                 if mnl:\n[Tests/test]   |                     base.syrk(F['Dfs'], F['S'], trans = 'T', beta = 1.0)\n[Tests/test]   |                 base.syrk(A, F['S'], trans = 'T', beta = 1.0)\n[Tests/test]   |                 if H is not None:\n[Tests/test]   |                     F['S'] += H\n[Tests/test]   |                 if type(F['S']) is matrix:\n[Tests/test]   | >                   lapack.potrf(F['S'])\n[Tests/test]   | E                   ArithmeticError: 1\n[Tests/test]   | \n[Tests/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/site-packages/cvxopt/misc.py:1444: ArithmeticError\n[Tests/test]   | \n[Tests/test]   | During handling of the above exception, another exception occurred:\n[Tests/test]   | \n[Tests/test]   |     def test_racing_overtake():\n[Tests/test]   |         track_spec = np.genfromtxt(\"data/track_layout/l_shape.csv\", delimiter=\",\")\n[Tests/test]   |         track = racing_env.ClosedTrack(track_spec, track_width=1.0)\n[Tests/test]   |         lap_number = 4\n[Tests/test]   |         opti_traj_xcurv = np.genfromtxt(\n[Tests/test]   |             \"data/optimal_traj/xcurv_l_shape.csv\", delimiter=\",\"\n[Tests/test]   |         )\n[Tests/test]   |         opti_traj_xglob = np.genfromtxt(\n[Tests/test]   |             \"data/optimal_traj/xglob_l_shape.csv\", delimiter=\",\"\n[Tests/test]   |         )\n[Tests/test]   |         track = racing_env.ClosedTrack(track_spec, track_width=1.0)\n[Tests/test]   |         num_veh = 2\n[Tests/test]   |         alpha = 0.8\n[Tests/test]   |         timestep = 1.0 / 10.0\n[Tests/test]   |         ego, pid_controller, mpc_lti_controller = set_up_ego(timestep, track)\n[Tests/test]   |         ego.set_zero_noise()\n[Tests/test]   |         # lmpc controller\n[Tests/test]   |         lmpc_controller, time_lmpc = set_up_lmpc(\n[Tests/test]   |             timestep,\n[Tests/test]   |             track,\n[Tests/test]   |             lap_number,\n[Tests/test]   |             alpha,\n[Tests/test]   |             opti_traj_xcurv,\n[Tests/test]   |             opti_traj_xglob,\n[Tests/test]   |             ego.system_param\n[Tests/test]   |         )\n[Tests/test]   |         simulator = offboard.CarRacingSim()\n[Tests/test]   |         simulator.set_timestep(timestep)\n[Tests/test]   |         simulator.set_track(track)\n[Tests/test]   |         simulator.add_vehicle(ego)\n[Tests/test]   |         simulator.set_opti_traj(opti_traj_xglob)\n[Tests/test]   |         t_symbol = sp.symbols(\"t\")\n[Tests/test]   |         vehicles = set_up_other_vehicles(track, num_veh)\n[Tests/test]   |         pid_controller.set_racing_sim(simulator)\n[Tests/test]   |         mpc_lti_controller.set_racing_sim(simulator)\n[Tests/test]   |         lmpc_controller.set_racing_sim(simulator)\n[Tests/test]   |         lmpc_controller.set_vehicles_track()\n[Tests/test]   |         for iter in range(lap_number):\n[Tests/test]   |             if iter == 0:\n[Tests/test]   |                 simulator.sim(sim_time=90, one_lap=True, one_lap_name=\"ego\")\n[Tests/test]   |             elif iter == 1:\n[Tests/test]   |                 ego.set_ctrl_policy(mpc_lti_controller)\n[Tests/test]   |                 simulator.sim(\n[Tests/test]   |                     sim_time=90,\n[Tests/test]   |                     one_lap=True,\n[Tests/test]   |                     one_lap_name=\"ego\",\n[Tests/test]   |                 )\n[Tests/test]   |             elif iter == 2:\n[Tests/test]   |                 lmpc_controller.add_trajectory(\n[Tests/test]   |                     ego,\n[Tests/test]   |                     0,\n[Tests/test]   |                 )\n[Tests/test]   |                 lmpc_controller.add_trajectory(\n[Tests/test]   |                     ego,\n[Tests/test]   |                     1,\n[Tests/test]   |                 )\n[Tests/test]   |                 # change the controller to lmpc controller\n[Tests/test]   |                 ego.set_ctrl_policy(lmpc_controller)\n[Tests/test]   | >               simulator.sim(sim_time=time_lmpc, one_lap=True, one_lap_name=\"ego\")\n[Tests/test]   | \n[Tests/test]   | tests/auto_racing_game_test.py:69: \n[Tests/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Tests/test]   | car_racing/racing/offboard.py:127: in sim\n[Tests/test]   |     self.vehicles[name].forward_one_step(self.vehicles[name].realtime_flag)\n[Tests/test]   | car_racing/utils/base.py:788: in forward_one_step\n[Tests/test]   |     self.calc_ctrl_input()\n[Tests/test]   | car_racing/utils/base.py:777: in calc_ctrl_input\n[Tests/test]   |     self.ctrl_policy.calc_input()\n[Tests/test]   | car_racing/utils/base.py:459: in calc_input\n[Tests/test]   |     matrix_Atv, matrix_Btv, matrix_Ctv, _ = self.estimate_ABC()\n[Tests/test]   | car_racing/utils/base.py:616: in estimate_ABC\n[Tests/test]   |     i,\n[Tests/test]   | car_racing/control/lmpc_helper.py:101: in regression_and_linearization\n[Tests/test]   |     ) = lmpc_loc_lin_reg(Q_vx, b, state_features, input_features, qp)\n[Tests/test]   | car_racing/control/lmpc_helper.py:360: in lmpc_loc_lin_reg\n[Tests/test]   |     res_cons = qp(Q, b)  # This is ordered as [A B C]\n[Tests/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/site-packages/cvxopt/coneprog.py:4485: in qp\n[Tests/test]   |     return coneqp(P, q, G, h, None, A,  b, initvals, kktsolver = kktsolver, options = options)\n[Tests/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Tests/test]   | \n[Tests/test]   | P = <5x5 matrix, tc='d'>, q = <5x1 matrix, tc='d'>\n[Tests/test]   | G = <0x5 sparse matrix, tc='d', nnz=0>, h = <0x1 matrix, tc='d'>\n[Tests/test]   | dims = {'l': 0, 'q': [], 's': []}, A = <0x5 sparse matrix, tc='d', nnz=0>\n[Tests/test]   | b = <0x1 matrix, tc='d'>, initvals = None\n[Tests/test]   | kktsolver = <function coneqp.<locals>.kktsolver at 0x7f99247086a8>\n[Tests/test]   | xnewcopy = <class 'cvxopt.base.matrix'>, xdot = <built-in function dot>\n[Tests/test]   | xaxpy = <built-in function axpy>, xscal = <built-in function scal>\n[Tests/test]   | ynewcopy = <class 'cvxopt.base.matrix'>, ydot = <built-in function dot>\n[Tests/test]   | yaxpy = <built-in function axpy>, yscal = <built-in function scal>\n[Tests/test]   | kwargs = {'options': {}}, spmatrix = <class 'cvxopt.base.spmatrix'>, STEP = 0.99\n[Tests/test]   | EXPON = 3, options = {}, KKTREG = None, correction = True, MAXITERS = 100\n[Tests/test]   | \n[Tests/test]   |     def coneqp(P, q, G = None, h = None, dims = None, A = None, b = None,\n[Tests/test]   |         initvals = None, kktsolver = None, xnewcopy = None, xdot = None,\n[Tests/test]   |         xaxpy = None, xscal = None, ynewcopy = None, ydot = None, yaxpy = None,\n[Tests/test]   |         yscal = None, **kwargs):\n[Tests/test]   |         \"\"\"\n[Tests/test]   |     \n[Tests/test]   |         Solves a pair of primal and dual convex quadratic cone programs\n[Tests/test]   |     \n[Tests/test]   |             minimize    (1/2)*x'*P*x + q'*x\n[Tests/test]   |             subject to  G*x + s = h\n[Tests/test]   |                         A*x = b\n[Tests/test]   |                         s >= 0\n[Tests/test]   |     \n[Tests/test]   |             maximize    -(1/2)*(q + G'*z + A'*y)' * pinv(P) * (q + G'*z + A'*y)\n[Tests/test]   |                         - h'*z - b'*y\n[Tests/test]   |             subject to  q + G'*z + A'*y in range(P)\n[Tests/test]   |                         z >= 0.\n[Tests/test]   |     \n[Tests/test]   |         The inequalities are with respect to a cone C defined as the Cartesian\n[Tests/test]   |         product of N + M + 1 cones:\n[Tests/test]   |     \n[Tests/test]   |             C = C_0 x C_1 x .... x C_N x C_{N+1} x ... x C_{N+M}.\n[Tests/test]   |     \n[Tests/test]   |         The first cone C_0 is the nonnegative orthant of dimension ml.\n[Tests/test]   |         The next N cones are 2nd order cones of dimension mq[0], ..., mq[N-1].\n[Tests/test]   |         The second order cone of dimension m is defined as\n[Tests/test]   |     \n[Tests/test]   |             { (u0, u1) in R x R^{m-1} | u0 >= ||u1||_2 }.\n[Tests/test]   |     \n[Tests/test]   |         The next M cones are positive semidefinite cones of order ms[0], ...,\n[Tests/test]   |         ms[M-1] >= 0.\n[Tests/test]   |     \n[Tests/test]   |     \n[Tests/test]   |         Input arguments (basic usage).\n[Tests/test]   |     \n[Tests/test]   |             P is a dense or sparse 'd' matrix of size (n,n) with the lower\n[Tests/test]   |             triangular part of the Hessian of the objective stored in the\n[Tests/test]   |             lower triangle.  Must be positive semidefinite.\n[Tests/test]   |     \n[Tests/test]   |             q is a dense 'd' matrix of size (n,1).\n[Tests/test]   |     \n[Tests/test]   |             dims is a dictionary with the dimensions of the components of C.\n[Tests/test]   |             It has three fields.\n[Tests/test]   |             - dims['l'] = ml, the dimension of the nonnegative orthant C_0.\n[Tests/test]   |               (ml >= 0.)\n[Tests/test]   |             - dims['q'] = mq = [ mq[0], mq[1], ..., mq[N-1] ], a list of N\n[Tests/test]   |               integers with the dimensions of the second order cones\n[Tests/test]   |               C_1, ..., C_N.  (N >= 0 and mq[k] >= 1.)\n[Tests/test]   |             - dims['s'] = ms = [ ms[0], ms[1], ..., ms[M-1] ], a list of M\n[Tests/test]   |               integers with the orders of the semidefinite cones\n[Tests/test]   |               C_{N+1}, ..., C_{N+M}.  (M >= 0 and ms[k] >= 0.)\n[Tests/test]   |             The default value of dims = {'l': G.size[0], 'q': [], 's': []}.\n[Tests/test]   |     \n[Tests/test]   |             G is a dense or sparse 'd' matrix of size (K,n), where\n[Tests/test]   |     \n[Tests/test]   |                 K = ml + mq[0] + ... + mq[N-1] + ms[0]**2 + ... + ms[M-1]**2.\n[Tests/test]   |     \n[Tests/test]   |             Each column of G describes a vector\n[Tests/test]   |     \n[Tests/test]   |                 v = ( v_0, v_1, ..., v_N, vec(v_{N+1}), ..., vec(v_{N+M}) )\n[Tests/test]   |     \n[Tests/test]   |             in V = R^ml x R^mq[0] x ... x R^mq[N-1] x S^ms[0] x ... x S^ms[M-1]\n[Tests/test]   |             stored as a column vector\n[Tests/test]   |     \n[Tests/test]   |                 [ v_0; v_1; ...; v_N; vec(v_{N+1}); ...; vec(v_{N+M}) ].\n[Tests/test]   |     \n[Tests/test]   |             Here, if u is a symmetric matrix of order m, then vec(u) is the\n[Tests/test]   |             matrix u stored in column major order as a vector of length m**2.\n[Tests/test]   |             We use BLAS unpacked 'L' storage, i.e., the entries in vec(u)\n[Tests/test]   |             corresponding to the strictly upper triangular entries of u are\n[Tests/test]   |             not referenced.\n[Tests/test]   |     \n[Tests/test]   |             h is a dense 'd' matrix of size (K,1), representing a vector in V,\n[Tests/test]   |             in the same format as the columns of G.\n[Tests/test]   |     \n[Tests/test]   |             A is a dense or sparse 'd' matrix of size (p,n).   The default\n[Tests/test]   |             value is a sparse 'd' matrix of size (0,n).\n[Tests/test]   |     \n[Tests/test]   |             b is a dense 'd' matrix of size (p,1).  The default value is a\n[Tests/test]   |             dense 'd' matrix of size (0,1).\n[Tests/test]   |     \n[Tests/test]   |             initvals is a dictionary with optional primal and dual starting\n[Tests/test]   |             points initvals['x'], initvals['s'], initvals['y'], initvals['z'].\n[Tests/test]   |             - initvals['x'] is a dense 'd' matrix of size (n,1).\n[Tests/test]   |             - initvals['s'] is a dense 'd' matrix of size (K,1), representing\n[Tests/test]   |               a vector that is strictly positive with respect to the cone C.\n[Tests/test]   |             - initvals['y'] is a dense 'd' matrix of size (p,1).\n[Tests/test]   |             - initvals['z'] is a dense 'd' matrix of size (K,1), representing\n[Tests/test]   |               a vector that is strictly positive with respect to the cone C.\n[Tests/test]   |             A default initialization is used for the variables that are not\n[Tests/test]   |             specified in initvals.\n[Tests/test]   |     \n[Tests/test]   |             It is assumed that rank(A) = p and rank([P; A; G]) = n.\n[Tests/test]   |     \n[Tests/test]   |             The other arguments are normally not needed.  They make it possible\n[Tests/test]   |             to exploit certain types of structure, as described below.\n[Tests/test]   |     \n[Tests/test]   |     \n[Tests/test]   |         Output arguments.\n[Tests/test]   |     \n[Tests/test]   |             Returns a dictionary with keys 'status', 'x', 's', 'z', 'y',\n[Tests/test]   |             'primal objective', 'dual objective', 'gap', 'relative gap',\n[Tests/test]   |             'primal infeasibility', 'dual infeasibility', 'primal slack',\n[Tests/test]   |             'dual slack', 'iterations'.\n[Tests/test]   |     \n[Tests/test]   |             The 'status' field has values 'optimal' or 'unknown'.  'iterations'\n[Tests/test]   |             is the number of iterations taken.\n[Tests/test]   |     \n[Tests/test]   |             If the status is 'optimal', 'x', 's', 'y', 'z' are an approximate\n[Tests/test]   |             solution of the primal and dual optimality conditions\n[Tests/test]   |     \n[Tests/test]   |                   G*x + s = h,  A*x = b\n[Tests/test]   |                   P*x + G'*z + A'*y + q = 0\n[Tests/test]   |                   s >= 0,  z >= 0\n[Tests/test]   |                   s'*z = 0.\n[Tests/test]   |     \n[Tests/test]   |             If the status is 'unknown', 'x', 'y', 's', 'z' are the last\n[Tests/test]   |             iterates before termination.  These satisfy s > 0 and z > 0,\n[Tests/test]   |             but are not necessarily feasible.\n[Tests/test]   |     \n[Tests/test]   |             The values of the other fields are defined as follows.\n[Tests/test]   |     \n[Tests/test]   |             - 'primal objective': the primal objective (1/2)*x'*P*x + q'*x.\n[Tests/test]   |     \n[Tests/test]   |             - 'dual objective': the dual objective\n[Tests/test]   |     \n[Tests/test]   |                   L(x,y,z) = (1/2)*x'*P*x + q'*x + z'*(G*x - h) + y'*(A*x-b).\n[Tests/test]   |     \n[Tests/test]   |             - 'gap': the duality gap s'*z.\n[Tests/test]   |     \n[Tests/test]   |             - 'relative gap': the relative gap, defined as\n[Tests/test]   |     \n[Tests/test]   |                   gap / -primal objective\n[Tests/test]   |     \n[Tests/test]   |               if the primal objective is negative,\n[Tests/test]   |     \n[Tests/test]   |                   gap / dual objective\n[Tests/test]   |     \n[Tests/test]   |               if the dual objective is positive, and None otherwise.\n[Tests/test]   |     \n[Tests/test]   |             - 'primal infeasibility': the residual in the primal constraints,\n[Tests/test]   |               defined as the maximum of the residual in the inequalities\n[Tests/test]   |     \n[Tests/test]   |                   || G*x + s - h || / max(1, ||h||)\n[Tests/test]   |     \n[Tests/test]   |               and the residual in the equalities\n[Tests/test]   |     \n[Tests/test]   |                   || A*x - b || / max(1, ||b||).\n[Tests/test]   |     \n[Tests/test]   |     \n[Tests/test]   |             - 'dual infeasibility': the residual in the dual constraints,\n[Tests/test]   |               defined as\n[Tests/test]   |     \n[Tests/test]   |                   || P*x + G'*z + A'*y + q || / max(1, ||q||).\n[Tests/test]   |     \n[Tests/test]   |     \n[Tests/test]   |             - 'primal slack': the smallest primal slack, sup {t | s >= t*e },\n[Tests/test]   |                where\n[Tests/test]   |     \n[Tests/test]   |                   e = ( e_0, e_1, ..., e_N, e_{N+1}, ..., e_{M+N} )\n[Tests/test]   |     \n[Tests/test]   |               is the identity vector in C.  e_0 is an ml-vector of ones,\n[Tests/test]   |               e_k, k = 1,..., N, is the unit vector (1,0,...,0) of length\n[Tests/test]   |               mq[k], and e_k = vec(I) where I is the identity matrix of order\n[Tests/test]   |               ms[k].\n[Tests/test]   |     \n[Tests/test]   |             - 'dual slack': the smallest dual slack, sup {t | z >= t*e }.\n[Tests/test]   |     \n[Tests/test]   |             If the exit status is 'optimal', then the primal and dual\n[Tests/test]   |             infeasibilities are guaranteed to be less than\n[Tests/test]   |             solvers.options['feastol'] (default 1e-7).  The gap is less than\n[Tests/test]   |             solvers.options['abstol'] (default 1e-7) or the relative gap is\n[Tests/test]   |             less than solvers.options['reltol'] (default 1e-6).\n[Tests/test]   |     \n[Tests/test]   |             Termination with status 'unknown' indicates that the algorithm\n[Tests/test]   |             failed to find a solution that satisfies the specified tolerances.\n[Tests/test]   |             In some cases, the returned solution may be fairly accurate.  If\n[Tests/test]   |             the primal and dual infeasibilities, the gap, and the relative gap\n[Tests/test]   |             are small, then x, y, s, z are close to optimal.\n[Tests/test]   |     \n[Tests/test]   |     \n[Tests/test]   |         Advanced usage.\n[Tests/test]   |     \n[Tests/test]   |             Three mechanisms are provided to express problem structure.\n[Tests/test]   |     \n[Tests/test]   |             1.  The user can provide a customized routine for solving linear\n[Tests/test]   |             equations (`KKT systems')\n[Tests/test]   |     \n[Tests/test]   |                 [ P   A'  G'    ] [ ux ]   [ bx ]\n[Tests/test]   |                 [ A   0   0     ] [ uy ] = [ by ].\n[Tests/test]   |                 [ G   0   -W'*W ] [ uz ]   [ bz ]\n[Tests/test]   |     \n[Tests/test]   |             W is a scaling matrix, a block diagonal mapping\n[Tests/test]   |     \n[Tests/test]   |                W*u = ( W0*u_0, ..., W_{N+M}*u_{N+M} )\n[Tests/test]   |     \n[Tests/test]   |             defined as follows.\n[Tests/test]   |     \n[Tests/test]   |             - For the 'l' block (W_0):\n[Tests/test]   |     \n[Tests/test]   |                   W_0 = diag(d),\n[Tests/test]   |     \n[Tests/test]   |               with d a positive vector of length ml.\n[Tests/test]   |     \n[Tests/test]   |             - For the 'q' blocks (W_{k+1}, k = 0, ..., N-1):\n[Tests/test]   |     \n[Tests/test]   |                   W_{k+1} = beta_k * ( 2 * v_k * v_k' - J )\n[Tests/test]   |     \n[Tests/test]   |               where beta_k is a positive scalar, v_k is a vector in R^mq[k]\n[Tests/test]   |               with v_k[0] > 0 and v_k'*J*v_k = 1, and J = [1, 0; 0, -I].\n[Tests/test]   |     \n[Tests/test]   |             - For the 's' blocks (W_{k+N}, k = 0, ..., M-1):\n[Tests/test]   |     \n[Tests/test]   |                   W_k * u = vec(r_k' * mat(u) * r_k)\n[Tests/test]   |     \n[Tests/test]   |               where r_k is a nonsingular matrix of order ms[k], and mat(x) is\n[Tests/test]   |               the inverse of the vec operation.\n[Tests/test]   |     \n[Tests/test]   |             The optional argument kktsolver is a Python function that will be\n[Tests/test]   |             called as g = kktsolver(W).  W is a dictionary that contains\n[Tests/test]   |             the parameters of the scaling:\n[Tests/test]   |     \n[Tests/test]   |             - W['d'] is a positive 'd' matrix of size (ml,1).\n[Tests/test]   |             - W['di'] is a positive 'd' matrix with the elementwise inverse of\n[Tests/test]   |               W['d'].\n[Tests/test]   |             - W['beta'] is a list [ beta_0, ..., beta_{N-1} ]\n[Tests/test]   |             - W['v'] is a list [ v_0, ..., v_{N-1} ]\n[Tests/test]   |             - W['r'] is a list [ r_0, ..., r_{M-1} ]\n[Tests/test]   |             - W['rti'] is a list [ rti_0, ..., rti_{M-1} ], with rti_k the\n[Tests/test]   |               inverse of the transpose of r_k.\n[Tests/test]   |     \n[Tests/test]   |             The call g = kktsolver(W) should return a function g that solves\n[Tests/test]   |             the KKT system by g(x, y, z).  On entry, x, y, z contain the\n[Tests/test]   |             righthand side bx, by, bz.  On exit, they contain the solution,\n[Tests/test]   |             with uz scaled, the argument z contains W*uz.  In other words,\n[Tests/test]   |             on exit x, y, z are the solution of\n[Tests/test]   |     \n[Tests/test]   |                 [ P   A'  G'*W^{-1} ] [ ux ]   [ bx ]\n[Tests/test]   |                 [ A   0   0         ] [ uy ] = [ by ].\n[Tests/test]   |                 [ G   0   -W'       ] [ uz ]   [ bz ]\n[Tests/test]   |     \n[Tests/test]   |     \n[Tests/test]   |             2.  The linear operators P*u, G*u and A*u can be specified\n[Tests/test]   |             by providing Python functions instead of matrices.  This can only\n[Tests/test]   |             be done in combination with 1. above, i.e., it requires the\n[Tests/test]   |             kktsolver argument.\n[Tests/test]   |     \n[Tests/test]   |             If P is a function, the call P(u, v, alpha, beta) should evaluate\n[Tests/test]   |             the matrix-vectors product\n[Tests/test]   |     \n[Tests/test]   |                 v := alpha * P * u + beta * v.\n[Tests/test]   |     \n[Tests/test]   |             The arguments u and v are required.  The other arguments have\n[Tests/test]   |             default values alpha = 1.0, beta = 0.0.\n[Tests/test]   |     \n[Tests/test]   |             If G is a function, the call G(u, v, alpha, beta, trans) should\n[Tests/test]   |             evaluate the matrix-vector products\n[Tests/test]   |     \n[Tests/test]   |                 v := alpha * G * u + beta * v  if trans is 'N'\n[Tests/test]   |                 v := alpha * G' * u + beta * v  if trans is 'T'.\n[Tests/test]   |     \n[Tests/test]   |             The arguments u and v are required.  The other arguments have\n[Tests/test]   |             default values alpha = 1.0, beta = 0.0, trans = 'N'.\n[Tests/test]   |     \n[Tests/test]   |             If A is a function, the call A(u, v, alpha, beta, trans) should\n[Tests/test]   |             evaluate the matrix-vectors products\n[Tests/test]   |     \n[Tests/test]   |                 v := alpha * A * u + beta * v if trans is 'N'\n[Tests/test]   |                 v := alpha * A' * u + beta * v if trans is 'T'.\n[Tests/test]   |     \n[Tests/test]   |             The arguments u and v are required.  The other arguments\n[Tests/test]   |             have default values alpha = 1.0, beta = 0.0, trans = 'N'.\n[Tests/test]   |     \n[Tests/test]   |     \n[Tests/test]   |             3.  Instead of using the default representation of the primal\n[Tests/test]   |             variable x and the dual variable y as one-column 'd' matrices,\n[Tests/test]   |             we can represent these variables and the corresponding parameters\n[Tests/test]   |             q and b by arbitrary Python objects (matrices, lists, dictionaries,\n[Tests/test]   |             etc).  This can only be done in combination with 1. and 2. above,\n[Tests/test]   |             i.e., it requires a user-provided KKT solver and an operator\n[Tests/test]   |             description of the linear mappings.   It also requires the\n[Tests/test]   |             arguments xnewcopy, xdot, xscal, xaxpy, ynewcopy, ydot, yscal,\n[Tests/test]   |             yaxpy.  These arguments are functions defined as follows.\n[Tests/test]   |     \n[Tests/test]   |             If X is the vector space of primal variables x, then:\n[Tests/test]   |             - xnewcopy(u) creates a new copy of the vector u in X.\n[Tests/test]   |             - xdot(u, v) returns the inner product of two vectors u and v in X.\n[Tests/test]   |             - xscal(alpha, u) computes u := alpha*u, where alpha is a scalar\n[Tests/test]   |               and u is a vector in X.\n[Tests/test]   |             - xaxpy(u, v, alpha = 1.0) computes v := alpha*u + v for a scalar\n[Tests/test]   |               alpha and two vectors u and v in X.\n[Tests/test]   |             If this option is used, the argument q must be in the same format\n[Tests/test]   |             as x, the argument P must be a Python function, the arguments A\n[Tests/test]   |             and G must be Python functions or None, and the argument\n[Tests/test]   |             kktsolver is required.\n[Tests/test]   |     \n[Tests/test]   |             If Y is the vector space of primal variables y:\n[Tests/test]   |             - ynewcopy(u) creates a new copy of the vector u in Y.\n[Tests/test]   |             - ydot(u, v) returns the inner product of two vectors u and v in Y.\n[Tests/test]   |             - yscal(alpha, u) computes u := alpha*u, where alpha is a scalar\n[Tests/test]   |               and u is a vector in Y.\n[Tests/test]   |             - yaxpy(u, v, alpha = 1.0) computes v := alpha*u + v for a scalar\n[Tests/test]   |               alpha and two vectors u and v in Y.\n[Tests/test]   |             If this option is used, the argument b must be in the same format\n[Tests/test]   |             as y, the argument A must be a Python function or None, and the\n[Tests/test]   |             argument kktsolver is required.\n[Tests/test]   |     \n[Tests/test]   |     \n[Tests/test]   |         Control parameters.\n[Tests/test]   |     \n[Tests/test]   |            The following control parameters can be modified by adding an\n[Tests/test]   |            entry to the dictionary options.\n[Tests/test]   |     \n[Tests/test]   |            options['show_progress'] True/False (default: True)\n[Tests/test]   |            options['maxiters'] positive integer (default: 100)\n[Tests/test]   |            options['refinement'] nonnegative integer (default: 0 for problems\n[Tests/test]   |                with no second-order cone and matrix inequality constraints;\n[Tests/test]   |                1 otherwise)\n[Tests/test]   |            options['abstol'] scalar (default: 1e-7)\n[Tests/test]   |            options['reltol'] scalar (default: 1e-6)\n[Tests/test]   |            options['feastol'] scalar (default: 1e-7).\n[Tests/test]   |     \n[Tests/test]   |         \"\"\"\n[Tests/test]   |         import math\n[Tests/test]   |         from cvxopt import base, blas, misc\n[Tests/test]   |         from cvxopt.base import matrix, spmatrix\n[Tests/test]   |     \n[Tests/test]   |         STEP = 0.99\n[Tests/test]   |         EXPON = 3\n[Tests/test]   |     \n[Tests/test]   |         options = kwargs.get('options',globals()['options'])\n[Tests/test]   |     \n[Tests/test]   |         DEBUG = options.get('debug',False)\n[Tests/test]   |     \n[Tests/test]   |         KKTREG = options.get('kktreg',None)\n[Tests/test]   |         if KKTREG is None:\n[Tests/test]   |             pass\n[Tests/test]   |         elif not isinstance(KKTREG,(float,int,long)) or KKTREG < 0.0:\n[Tests/test]   |             raise ValueError(\"options['kktreg'] must be a nonnegative scalar\")\n[Tests/test]   |     \n[Tests/test]   |         # Use Mehrotra correction or not.\n[Tests/test]   |         correction = options.get('use_correction', True)\n[Tests/test]   |     \n[Tests/test]   |         MAXITERS = options.get('maxiters',100)\n[Tests/test]   |         if not isinstance(MAXITERS,(int,long)) or MAXITERS < 1:\n[Tests/test]   |             raise ValueError(\"options['maxiters'] must be a positive integer\")\n[Tests/test]   |     \n[Tests/test]   |         ABSTOL = options.get('abstol',1e-7)\n[Tests/test]   |         if not isinstance(ABSTOL,(float,int,long)):\n[Tests/test]   |             raise ValueError(\"options['abstol'] must be a scalar\")\n[Tests/test]   |     \n[Tests/test]   |         RELTOL = options.get('reltol',1e-6)\n[Tests/test]   |         if not isinstance(RELTOL,(float,int,long)):\n[Tests/test]   |             raise ValueError(\"options['reltol'] must be a scalar\")\n[Tests/test]   |     \n[Tests/test]   |         if RELTOL <= 0.0 and ABSTOL <= 0.0 :\n[Tests/test]   |             raise ValueError(\"at least one of options['reltol'] and \" \\\n[Tests/test]   |                 \"options['abstol'] must be positive\")\n[Tests/test]   |     \n[Tests/test]   |         FEASTOL = options.get('feastol',1e-7)\n[Tests/test]   |         if not isinstance(FEASTOL,(float,int,long)) or FEASTOL <= 0.0:\n[Tests/test]   |             raise ValueError(\"options['feastol'] must be a positive scalar\")\n[Tests/test]   |     \n[Tests/test]   |         show_progress = options.get('show_progress',True)\n[Tests/test]   |     \n[Tests/test]   |         if kktsolver is None:\n[Tests/test]   |             if dims and (dims['q'] or dims['s']):\n[Tests/test]   |                 kktsolver = 'chol'\n[Tests/test]   |             else:\n[Tests/test]   |                 kktsolver = 'chol2'\n[Tests/test]   |         defaultsolvers = ('ldl', 'ldl2', 'chol', 'chol2')\n[Tests/test]   |         if isinstance(kktsolver,str) and kktsolver not in defaultsolvers:\n[Tests/test]   |             raise ValueError(\"'%s' is not a valid value for kktsolver\" \\\n[Tests/test]   |                 %kktsolver)\n[Tests/test]   |     \n[Tests/test]   |         # Argument error checking depends on level of customization.\n[Tests/test]   |         customkkt = not isinstance(kktsolver,str)\n[Tests/test]   |         matrixP = isinstance(P, (matrix, spmatrix))\n[Tests/test]   |         matrixG = isinstance(G, (matrix, spmatrix))\n[Tests/test]   |         matrixA = isinstance(A, (matrix, spmatrix))\n[Tests/test]   |         if (not matrixP or (not matrixG and G is not None) or\n[Tests/test]   |             (not matrixA and A is not None)) and not customkkt:\n[Tests/test]   |             raise ValueError(\"use of function valued P, G, A requires a \"\\\n[Tests/test]   |                 \"user-provided kktsolver\")\n[Tests/test]   |         customx = (xnewcopy != None or xdot != None or xaxpy != None or\n[Tests/test]   |             xscal != None)\n[Tests/test]   |         if customx and (matrixP or matrixG or matrixA or not customkkt):\n[Tests/test]   |             raise ValueError(\"use of non-vector type for x requires \"\\\n[Tests/test]   |                 \"function valued P, G, A and user-provided kktsolver\")\n[Tests/test]   |         customy = (ynewcopy != None or ydot != None or yaxpy != None or\n[Tests/test]   |             yscal != None)\n[Tests/test]   |         if customy and (matrixA or not customkkt):\n[Tests/test]   |             raise ValueError(\"use of non vector type for y requires \"\\\n[Tests/test]   |                 \"function valued A and user-provided kktsolver\")\n[Tests/test]   |     \n[Tests/test]   |     \n[Tests/test]   |         if not customx and (not isinstance(q,matrix) or q.typecode != 'd' or q.size[1] != 1):\n[Tests/test]   |             raise TypeError(\"'q' must be a 'd' matrix with one column\")\n[Tests/test]   |     \n[Tests/test]   |         if matrixP:\n[Tests/test]   |             if P.typecode != 'd' or P.size != (q.size[0], q.size[0]):\n[Tests/test]   |                 raise TypeError(\"'P' must be a 'd' matrix of size (%d, %d)\"\\\n[Tests/test]   |                     %(q.size[0], q.size[0]))\n[Tests/test]   |             def fP(x, y, alpha = 1.0, beta = 0.0):\n[Tests/test]   |                 base.symv(P, x, y, alpha = alpha, beta = beta)\n[Tests/test]   |         else:\n[Tests/test]   |             fP = P\n[Tests/test]   |     \n[Tests/test]   |     \n[Tests/test]   |         if h is None: h = matrix(0.0, (0,1))\n[Tests/test]   |         if not isinstance(h, matrix) or h.typecode != 'd' or h.size[1] != 1:\n[Tests/test]   |             raise TypeError(\"'h' must be a 'd' matrix with one column\")\n[Tests/test]   |     \n[Tests/test]   |         if not dims: dims = {'l': h.size[0], 'q': [], 's': []}\n[Tests/test]   |         if not isinstance(dims['l'],(int,long)) or dims['l'] < 0:\n[Tests/test]   |             raise TypeError(\"'dims['l']' must be a nonnegative integer\")\n[Tests/test]   |         if [ k for k in dims['q'] if not isinstance(k,(int,long)) or k < 1 ]:\n[Tests/test]   |             raise TypeError(\"'dims['q']' must be a list of positive integers\")\n[Tests/test]   |         if [ k for k in dims['s'] if not isinstance(k,(int,long)) or k < 0 ]:\n[Tests/test]   |             raise TypeError(\"'dims['s']' must be a list of nonnegative \" \\\n[Tests/test]   |                 \"integers\")\n[Tests/test]   |     \n[Tests/test]   |         try: refinement = options['refinement']\n[Tests/test]   |         except KeyError:\n[Tests/test]   |             if dims['q'] or dims['s']: refinement = 1\n[Tests/test]   |             else: refinement = 0\n[Tests/test]   |         else:\n[Tests/test]   |             if not isinstance(refinement,(int,long)) or refinement < 0:\n[Tests/test]   |                 raise ValueError(\"options['refinement'] must be a \"\\\n[Tests/test]   |                     \"nonnegative integer\")\n[Tests/test]   |     \n[Tests/test]   |     \n[Tests/test]   |         cdim = dims['l'] + sum(dims['q']) + sum([ k**2 for k in dims['s'] ])\n[Tests/test]   |         if h.size[0] != cdim:\n[Tests/test]   |             raise TypeError(\"'h' must be a 'd' matrix of size (%d,1)\" %cdim)\n[Tests/test]   |     \n[Tests/test]   |         # Data for kth 'q' constraint are found in rows indq[k]:indq[k+1] of G.\n[Tests/test]   |         indq = [ dims['l'] ]\n[Tests/test]   |         for k in dims['q']:  indq = indq + [ indq[-1] + k ]\n[Tests/test]   |     \n[Tests/test]   |         # Data for kth 's' constraint are found in rows inds[k]:inds[k+1] of G.\n[Tests/test]   |         inds = [ indq[-1] ]\n[Tests/test]   |         for k in dims['s']:  inds = inds + [ inds[-1] + k**2 ]\n[Tests/test]   |     \n[Tests/test]   |         if G is None:\n[Tests/test]   |             if customx:\n[Tests/test]   |                 def G(x, y, trans = 'N', alpha = 1.0, beta = 0.0):\n[Tests/test]   |                     if trans == 'N': pass\n[Tests/test]   |                     else: xscal(beta, y)\n[Tests/test]   |             else:\n[Tests/test]   |                 G = spmatrix([], [], [], (0, q.size[0]))\n[Tests/test]   |                 matrixG = True\n[Tests/test]   |         if matrixG:\n[Tests/test]   |             if G.typecode != 'd' or G.size != (cdim, q.size[0]):\n[Tests/test]   |                 raise TypeError(\"'G' must be a 'd' matrix of size (%d, %d)\"\\\n[Tests/test]   |                     %(cdim, q.size[0]))\n[Tests/test]   |             def fG(x, y, trans = 'N', alpha = 1.0, beta = 0.0):\n[Tests/test]   |                 misc.sgemv(G, x, y, dims, trans = trans, alpha = alpha,\n[Tests/test]   |                     beta = beta)\n[Tests/test]   |         else:\n[Tests/test]   |             fG = G\n[Tests/test]   |     \n[Tests/test]   |     \n[Tests/test]   |         if A is None:\n[Tests/test]   |             if customx or customy:\n[Tests/test]   |                 def A(x, y, trans = 'N', alpha = 1.0, beta = 0.0):\n[Tests/test]   |                     if trans == 'N': pass\n[Tests/test]   |                     else: xscal(beta, y)\n[Tests/test]   |             else:\n[Tests/test]   |                 A = spmatrix([], [], [], (0, q.size[0]))\n[Tests/test]   |                 matrixA = True\n[Tests/test]   |         if matrixA:\n[Tests/test]   |             if A.typecode != 'd' or A.size[1] != q.size[0]:\n[Tests/test]   |                 raise TypeError(\"'A' must be a 'd' matrix with %d columns\" \\\n[Tests/test]   |                     %q.size[0])\n[Tests/test]   |             def fA(x, y, trans = 'N', alpha = 1.0, beta = 0.0):\n[Tests/test]   |                 base.gemv(A, x, y, trans = trans, alpha = alpha, beta = beta)\n[Tests/test]   |         else:\n[Tests/test]   |             fA = A\n[Tests/test]   |         if not customy:\n[Tests/test]   |             if b is None: b = matrix(0.0, (0,1))\n[Tests/test]   |             if not isinstance(b, matrix) or b.typecode != 'd' or b.size[1] != 1:\n[Tests/test]   |                 raise TypeError(\"'b' must be a 'd' matrix with one column\")\n[Tests/test]   |             if matrixA and b.size[0] != A.size[0]:\n[Tests/test]   |                 raise TypeError(\"'b' must have length %d\" %A.size[0])\n[Tests/test]   |         if b is None and customy:\n[Tests/test]   |             raise ValueEror(\"use of non-vector type for y requires b\")\n[Tests/test]   |     \n[Tests/test]   |     \n[Tests/test]   |         ws3, wz3 = matrix(0.0, (cdim,1 )), matrix(0.0, (cdim,1 ))\n[Tests/test]   |         def res(ux, uy, uz, us, vx, vy, vz, vs, W, lmbda):\n[Tests/test]   |     \n[Tests/test]   |             # Evaluates residual in Newton equations:\n[Tests/test]   |             #\n[Tests/test]   |             #      [ vx ]    [ vx ]   [ 0     ]   [ P  A'  G' ]   [ ux        ]\n[Tests/test]   |             #      [ vy ] := [ vy ] - [ 0     ] - [ A  0   0  ] * [ uy        ]\n[Tests/test]   |             #      [ vz ]    [ vz ]   [ W'*us ]   [ G  0   0  ]   [ W^{-1}*uz ]\n[Tests/test]   |             #\n[Tests/test]   |             #      vs := vs - lmbda o (uz + us).\n[Tests/test]   |     \n[Tests/test]   |             # vx := vx - P*ux - A'*uy - G'*W^{-1}*uz\n[Tests/test]   |             fP(ux, vx, alpha = -1.0, beta = 1.0)\n[Tests/test]   |             fA(uy, vx, alpha = -1.0, beta = 1.0, trans = 'T')\n[Tests/test]   |             blas.copy(uz, wz3)\n[Tests/test]   |             misc.scale(wz3, W, inverse = 'I')\n[Tests/test]   |             fG(wz3, vx, alpha = -1.0, beta = 1.0, trans = 'T')\n[Tests/test]   |     \n[Tests/test]   |             # vy := vy - A*ux\n[Tests/test]   |             fA(ux, vy, alpha = -1.0, beta = 1.0)\n[Tests/test]   |     \n[Tests/test]   |             # vz := vz - G*ux - W'*us\n[Tests/test]   |             fG(ux, vz, alpha = -1.0, beta = 1.0)\n[Tests/test]   |             blas.copy(us, ws3)\n[Tests/test]   |             misc.scale(ws3, W, trans = 'T')\n[Tests/test]   |             blas.axpy(ws3, vz, alpha = -1.0)\n[Tests/test]   |     \n[Tests/test]   |             # vs := vs - lmbda o (uz + us)\n[Tests/test]   |             blas.copy(us, ws3)\n[Tests/test]   |             blas.axpy(uz, ws3)\n[Tests/test]   |             misc.sprod(ws3, lmbda, dims, diag = 'D')\n[Tests/test]   |             blas.axpy(ws3, vs, alpha = -1.0)\n[Tests/test]   |     \n[Tests/test]   |     \n[Tests/test]   |         # kktsolver(W) returns a routine for solving\n[Tests/test]   |         #\n[Tests/test]   |         #     [ P   A'  G'*W^{-1} ] [ ux ]   [ bx ]\n[Tests/test]   |         #     [ A   0   0         ] [ uy ] = [ by ].\n[Tests/test]   |         #     [ G   0   -W'       ] [ uz ]   [ bz ]\n[Tests/test]   |     \n[Tests/test]   |         if kktsolver in defaultsolvers:\n[Tests/test]   |              if KKTREG is None and b.size[0] > q.size[0]:\n[Tests/test]   |                  raise ValueError(\"Rank(A) < p or Rank([P; G; A]) < n\")\n[Tests/test]   |              if kktsolver == 'ldl':\n[Tests/test]   |                  factor = misc.kkt_ldl(G, dims, A, kktreg = KKTREG)\n[Tests/test]   |              elif kktsolver == 'ldl2':\n[Tests/test]   |                  factor = misc.kkt_ldl2(G, dims, A)\n[Tests/test]   |              elif kktsolver == 'chol':\n[Tests/test]   |                  factor = misc.kkt_chol(G, dims, A)\n[Tests/test]   |              else:\n[Tests/test]   |                  factor = misc.kkt_chol2(G, dims, A)\n[Tests/test]   |              def kktsolver(W):\n[Tests/test]   |                  return factor(W, P)\n[Tests/test]   |     \n[Tests/test]   |         if xnewcopy is None: xnewcopy = matrix\n[Tests/test]   |         if xdot is None: xdot = blas.dot\n[Tests/test]   |         if xaxpy is None: xaxpy = blas.axpy\n[Tests/test]   |         if xscal is None: xscal = blas.scal\n[Tests/test]   |         def xcopy(x, y):\n[Tests/test]   |             xscal(0.0, y)\n[Tests/test]   |             xaxpy(x, y)\n[Tests/test]   |         if ynewcopy is None: ynewcopy = matrix\n[Tests/test]   |         if ydot is None: ydot = blas.dot\n[Tests/test]   |         if yaxpy is None: yaxpy = blas.axpy\n[Tests/test]   |         if yscal is None: yscal = blas.scal\n[Tests/test]   |         def ycopy(x, y):\n[Tests/test]   |             yscal(0.0, y)\n[Tests/test]   |             yaxpy(x, y)\n[Tests/test]   |     \n[Tests/test]   |         resx0 = max(1.0, math.sqrt(xdot(q,q)))\n[Tests/test]   |         resy0 = max(1.0, math.sqrt(ydot(b,b)))\n[Tests/test]   |         resz0 = max(1.0, misc.snrm2(h, dims))\n[Tests/test]   |     \n[Tests/test]   |         if cdim == 0:\n[Tests/test]   |     \n[Tests/test]   |             # Solve\n[Tests/test]   |             #\n[Tests/test]   |             #     [ P  A' ] [ x ]   [ -q ]\n[Tests/test]   |             #     [       ] [   ] = [    ].\n[Tests/test]   |             #     [ A  0  ] [ y ]   [  b ]\n[Tests/test]   |     \n[Tests/test]   |             try: f3 = kktsolver({'d': matrix(0.0, (0,1)), 'di':\n[Tests/test]   |                 matrix(0.0, (0,1)), 'beta': [], 'v': [], 'r': [], 'rti': []})\n[Tests/test]   |             except ArithmeticError:\n[Tests/test]   | >               raise ValueError(\"Rank(A) < p or Rank([P; A; G]) < n\")\n[Tests/test]   | E               ValueError: Rank(A) < p or Rank([P; A; G]) < n\n[Tests/test]   | \n[Tests/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/site-packages/cvxopt/coneprog.py:2013: ValueError\n[Tests/test]   | ----------------------------- Captured stdout call -----------------------------\n[Tests/test]   | solver time: 7.6e-05\n[Tests/test]   | solver time: 1.9e-05\n[Tests/test]   | solver time: 2.3e-05\n[Tests/test]   | solver time: 1.9e-05\n[Tests/test]   | solver time: 2.3e-05\n[Tests/test]   | solver time: 1.9e-05\n[Tests/test]   | solver time: 1.8e-05\n[Tests/test]   | solver time: 1.9e-05\n[Tests/test]   | solver time: 1.6e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.3e-05\n[Tests/test]   | solver time: 2e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 2.1e-05\n[Tests/test]   | solver time: 1.3e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.5e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.6e-05\n[Tests/test]   | solver time: 1.5e-05\n[Tests/test]   | solver time: 1.3e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.3e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.5e-05\n[Tests/test]   | solver time: 1.3e-05\n[Tests/test]   | solver time: 1.7e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.5e-05\n[Tests/test]   | solver time: 1.7e-05\n[Tests/test]   | solver time: 1.3e-05\n[Tests/test]   | solver time: 1.5e-05\n[Tests/test]   | solver time: 1.3e-05\n[Tests/test]   | solver time: 1.9e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.6e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.5e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.5e-05\n[Tests/test]   | solver time: 1.3e-05\n[Tests/test]   | solver time: 1.6e-05\n[Tests/test]   | solver time: 1.3e-05\n[Tests/test]   | solver time: 1.3e-05\n[Tests/test]   | solver time: 1.3e-05\n[Tests/test]   | solver time: 1.3e-05\n[Tests/test]   | solver time: 1.3e-05\n[Tests/test]   | solver time: 1.3e-05\n[Tests/test]   | solver time: 1.2e-05\n[Tests/test]   | solver time: 1.3e-05\n[Tests/test]   | solver time: 2.7e-05\n[Tests/test]   | solver time: 1.5e-05\n[Tests/test]   | solver time: 2e-05\n[Tests/test]   | solver time: 1.5e-05\n[Tests/test]   | solver time: 1.5e-05\n[Tests/test]   | solver time: 1.9e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.9e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.8e-05\n[Tests/test]   | solver time: 1.6e-05\n[Tests/test]   | solver time: 1.5e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.8e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.7e-05\n[Tests/test]   | solver time: 1.9e-05\n[Tests/test]   | solver time: 3.2e-05\n[Tests/test]   | solver time: 1.8e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.3e-05\n[Tests/test]   | solver time: 1.3e-05\n[Tests/test]   | solver time: 1.3e-05\n[Tests/test]   | solver time: 1.3e-05\n[Tests/test]   | solver time: 1.8e-05\n[Tests/test]   | solver time: 1.7e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.3e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.3e-05\n[Tests/test]   | solver time: 1.5e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.5e-05\n[Tests/test]   | solver time: 1.6e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.3e-05\n[Tests/test]   | solver time: 1.2e-05\n[Tests/test]   | solver time: 1.2e-05\n[Tests/test]   | solver time: 1.5e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.8e-05\n[Tests/test]   | solver time: 2e-05\n[Tests/test]   | solver time: 1.7e-05\n[Tests/test]   | solver time: 1.5e-05\n[Tests/test]   | solver time: 1.6e-05\n[Tests/test]   | solver time: 1.6e-05\n[Tests/test]   | solver time: 2.6e-05\n[Tests/test]   | solver time: 1.6e-05\n[Tests/test]   | solver time: 1.3e-05\n[Tests/test]   | solver time: 1.2e-05\n[Tests/test]   | solver time: 1.3e-05\n[Tests/test]   | solver time: 1.3e-05\n[Tests/test]   | solver time: 1.2e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.3e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.9e-05\n[Tests/test]   | solver time: 1.5e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.2e-05\n[Tests/test]   | solver time: 1.3e-05\n[Tests/test]   | solver time: 1.3e-05\n[Tests/test]   | solver time: 1.9e-05\n[Tests/test]   | solver time: 1.9e-05\n[Tests/test]   | solver time: 1.8e-05\n[Tests/test]   | solver time: 1.6e-05\n[Tests/test]   | solver time: 1.6e-05\n[Tests/test]   | solver time: 1.5e-05\n[Tests/test]   | solver time: 1.6e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.5e-05\n[Tests/test]   | solver time: 1.6e-05\n[Tests/test]   | solver time: 1.5e-05\n[Tests/test]   | solver time: 1.3e-05\n[Tests/test]   | solver time: 1.5e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.3e-05\n[Tests/test]   | solver time: 1.3e-05\n[Tests/test]   | solver time: 1.3e-05\n[Tests/test]   | solver time: 1.5e-05\n[Tests/test]   | solver time: 1.5e-05\n[Tests/test]   | solver time: 1.3e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.3e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.3e-05\n[Tests/test]   | solver time: 1.8e-05\n[Tests/test]   | solver time: 1.5e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.7e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.8e-05\n[Tests/test]   | solver time: 1.7e-05\n[Tests/test]   | solver time: 2.3e-05\n[Tests/test]   | solver time: 1.8e-05\n[Tests/test]   | solver time: 1.7e-05\n[Tests/test]   | solver time: 1.5e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.7e-05\n[Tests/test]   | solver time: 1.5e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.3e-05\n[Tests/test]   | solver time: 1.2e-05\n[Tests/test]   | solver time: 1.2e-05\n[Tests/test]   | solver time: 1.3e-05\n[Tests/test]   | solver time: 1.3e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.5e-05\n[Tests/test]   | solver time: 1.6e-05\n[Tests/test]   | solver time: 1.5e-05\n[Tests/test]   | solver time: 1.6e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.5e-05\n[Tests/test]   | solver time: 1.5e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.5e-05\n[Tests/test]   | solver time: 2.4e-05\n[Tests/test]   | solver time: 1.9e-05\n[Tests/test]   | solver time: 1.8e-05\n[Tests/test]   | solver time: 1.9e-05\n[Tests/test]   | solver time: 3.3e-05\n[Tests/test]   | solver time: 1.3e-05\n[Tests/test]   | solver time: 1.3e-05\n[Tests/test]   | solver time: 1.3e-05\n[Tests/test]   | solver time: 1.3e-05\n[Tests/test]   | solver time: 1.5e-05\n[Tests/test]   | solver time: 1.3e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.7e-05\n[Tests/test]   | solver time: 1.7e-05\n[Tests/test]   | solver time: 1.2e-05\n[Tests/test]   | solver time: 2e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.5e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.8e-05\n[Tests/test]   | solver time: 1.5e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.3e-05\n[Tests/test]   | solver time: 1.5e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.6e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.7e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.7e-05\n[Tests/test]   | solver time: 1.5e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.5e-05\n[Tests/test]   | solver time: 1.6e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.3e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 2.1e-05\n[Tests/test]   | solver time: 1.5e-05\n[Tests/test]   | solver time: 1.8e-05\n[Tests/test]   | solver time: 1.6e-05\n[Tests/test]   | solver time: 1.8e-05\n[Tests/test]   | solver time: 1.7e-05\n[Tests/test]   | solver time: 1.9e-05\n[Tests/test]   | solver time: 1.7e-05\n[Tests/test]   | solver time: 1.5e-05\n[Tests/test]   | solver time: 1.6e-05\n[Tests/test]   | solver time: 1.4e-05\n[Tests/test]   | solver time: 1.6e-05\n[Tests/test]   | solver time: 1.6e-05\n[Tests/test]   | solver time: 2.5e-05\n[Tests/test]   | solver time: 3.2e-05\n[Tests/test]   | solver time: 3.4e-05\n[Tests/test]   | solver time: 2.8e-05\n[Tests/test]   | solver time: 2e-05\n[Tests/test]   | solver time: 2.6e-05\n[Tests/test]   | solver time: 1.9e-05\n[Tests/test]   | solver time: 1.8e-05\n[Tests/test]   | solver time: 1.9e-05\n[Tests/test]   | solver time: 1.8e-05\n[Tests/test]   | solver time: 1.8e-05\n[Tests/test]   | solver time: 2.2e-05\n[Tests/test]   | solver time: 1.9e-05\n[Tests/test]   | solver time: 1.8e-05\n[Tests/test]   | solver time: 1.8e-05\n[Tests/test]   | solver time: 2.1e-05\n[Tests/test]   | solver time: 2.2e-05\n[Tests/test]   | solver time: 1.7e-05\n[Tests/test]   | solver time: 2.4e-05\n[Tests/test]   | solver time: 2.4e-05\n[Tests/test]   | solver time: 1.9e-05\n[Tests/test]   | solver time: 1.9e-05\n[Tests/test]   | solver time: 2e-05\n[Tests/test]   | solver time: 1.9e-05\n[Tests/test]   | solver time: 1.9e-05\n[Tests/test]   | solver time: 1.9e-05\n[Tests/test]   | solver time: 2.1e-05\n[Tests/test]   | solver time: 1.9e-05\n[Tests/test]   | solver time: 1.9e-05\n[Tests/test]   | solver time: 2e-05\n[Tests/test]   | solver time: 2.2e-05\n[Tests/test]   | solver time: 2e-05\n[Tests/test]   | solver time: 2.1e-05\n[Tests/test]   | solver time: 1.9e-05\n[Tests/test]   | solver time: 2.3e-05\n[Tests/test]   | solver time: 2.9e-05\n[Tests/test]   | solver time: 2.7e-05\n[Tests/test]   | solver time: 2.7e-05\n[Tests/test]   | solver time: 2.6e-05\n[Tests/test]   | solver time: 2.7e-05\n[Tests/test]   | solver time: 2.1e-05\n[Tests/test]   | solver time: 2.2e-05\n[Tests/test]   | solver time: 2.2e-05\n[Tests/test]   | solver time: 2.6e-05\n[Tests/test]   | solver time: 2.1e-05\n[Tests/test]   | solver time: 2.1e-05\n[Tests/test]   | solver time: 2.4e-05\n[Tests/test]   | solver time: 1.8e-05\n[Tests/test]   | lap completed\n[Tests/test]   | \n[Tests/test]   | ******************************************************************************\n[Tests/test]   | This program contains Ipopt, a library for large-scale nonlinear optimization.\n[Tests/test]   |  Ipopt is released as open source code under the Eclipse Public License (EPL).\n[Tests/test]   |          For more information visit https://github.com/coin-or/Ipopt\n[Tests/test]   | ******************************************************************************\n[Tests/test]   | \n[Tests/test]   | solver time: 0.364939\n[Tests/test]   | solver time: 0.065197\n[Tests/test]   | solver time: 0.060612\n[Tests/test]   | solver time: 0.050571\n[Tests/test]   | solver time: 0.0515\n[Tests/test]   | solver time: 0.050717\n[Tests/test]   | solver time: 0.050413\n[Tests/test]   | solver time: 0.049589\n[Tests/test]   | solver time: 0.049899\n[Tests/test]   | solver time: 0.050364\n[Tests/test]   | solver time: 0.049194\n[Tests/test]   | solver time: 0.049684\n[Tests/test]   | solver time: 0.049021\n[Tests/test]   | solver time: 0.049647\n[Tests/test]   | solver time: 0.049139\n[Tests/test]   | solver time: 0.050281\n[Tests/test]   | solver time: 0.048346\n[Tests/test]   | solver time: 0.04889\n[Tests/test]   | solver time: 0.048285\n[Tests/test]   | solver time: 0.04861\n[Tests/test]   | solver time: 0.048346\n[Tests/test]   | solver time: 0.048723\n[Tests/test]   | solver time: 0.048032\n[Tests/test]   | solver time: 0.050978\n[Tests/test]   | solver time: 0.050757\n[Tests/test]   | solver time: 0.055001\n[Tests/test]   | solver time: 0.100398\n[Tests/test]   | solver time: 0.095351\n[Tests/test]   | solver time: 0.098737\n[Tests/test]   | solver time: 0.117234\n[Tests/test]   | solver time: 0.101833\n[Tests/test]   | solver time: 0.076354\n[Tests/test]   | solver time: 0.073234\n[Tests/test]   | solver time: 0.102413\n[Tests/test]   | solver time: 0.098644\n[Tests/test]   | solver time: 0.110862\n[Tests/test]   | solver time: 0.110793\n[Tests/test]   | solver time: 0.118938\n[Tests/test]   | solver time: 0.095552\n[Tests/test]   | solver time: 0.080674\n[Tests/test]   | solver time: 0.077561\n[Tests/test]   | solver time: 0.072664\n[Tests/test]   | solver time: 0.065204\n[Tests/test]   | solver time: 0.073433\n[Tests/test]   | solver time: 0.062039\n[Tests/test]   | solver time: 0.058258\n[Tests/test]   | solver time: 0.052355\n[Tests/test]   | solver time: 0.048969\n[Tests/test]   | solver time: 0.04804\n[Tests/test]   | solver time: 0.048777\n[Tests/test]   | solver time: 0.05719\n[Tests/test]   | solver time: 0.057213\n[Tests/test]   | solver time: 0.057069\n[Tests/test]   | solver time: 0.057935\n[Tests/test]   | solver time: 0.070033\n[Tests/test]   | solver time: 0.105607\n[Tests/test]   | solver time: 0.105424\n[Tests/test]   | solver time: 0.105628\n[Tests/test]   | solver time: 0.102915\n[Tests/test]   | solver time: 0.085178\n[Tests/test]   | solver time: 0.07493\n[Tests/test]   | solver time: 0.065359\n[Tests/test]   | solver time: 0.104948\n[Tests/test]   | solver time: 0.120406\n[Tests/test]   | solver time: 0.097772\n[Tests/test]   | solver time: 0.101685\n[Tests/test]   | solver time: 0.119128\n[Tests/test]   | solver time: 0.06976\n[Tests/test]   | solver time: 0.069629\n[Tests/test]   | solver time: 0.073199\n[Tests/test]   | solver time: 0.080395\n[Tests/test]   | solver time: 0.0759\n[Tests/test]   | solver time: 0.072109\n[Tests/test]   | solver time: 0.076587\n[Tests/test]   | solver time: 0.0785\n[Tests/test]   | solver time: 0.077168\n[Tests/test]   | solver time: 0.070217\n[Tests/test]   | solver time: 0.073472\n[Tests/test]   | solver time: 0.070493\n[Tests/test]   | solver time: 0.069003\n[Tests/test]   | solver time: 0.066426\n[Tests/test]   | solver time: 0.067184\n[Tests/test]   | solver time: 0.061148\n[Tests/test]   | solver time: 0.061402\n[Tests/test]   | solver time: 0.054597\n[Tests/test]   | solver time: 0.051004\n[Tests/test]   | solver time: 0.051171\n[Tests/test]   | solver time: 0.053731\n[Tests/test]   | solver time: 0.052235\n[Tests/test]   | solver time: 0.051731\n[Tests/test]   | solver time: 0.061205\n[Tests/test]   | solver time: 0.050983\n[Tests/test]   | solver time: 0.050419\n[Tests/test]   | solver time: 0.049564\n[Tests/test]   | solver time: 0.050879\n[Tests/test]   | solver time: 0.051382\n[Tests/test]   | solver time: 0.050792\n[Tests/test]   | solver time: 0.049803\n[Tests/test]   | solver time: 0.051799\n[Tests/test]   | solver time: 0.049694\n[Tests/test]   | solver time: 0.050572\n[Tests/test]   | solver time: 0.051192\n[Tests/test]   | solver time: 0.050272\n[Tests/test]   | solver time: 0.048897\n[Tests/test]   | solver time: 0.05045\n[Tests/test]   | solver time: 0.048973\n[Tests/test]   | solver time: 0.04941\n[Tests/test]   | solver time: 0.050267\n[Tests/test]   | solver time: 0.050635\n[Tests/test]   | solver time: 0.049066\n[Tests/test]   | solver time: 0.092128\n[Tests/test]   | solver time: 0.101328\n[Tests/test]   | solver time: 0.118681\n[Tests/test]   | solver time: 0.098236\n[Tests/test]   | solver time: 0.097465\n[Tests/test]   | solver time: 0.093582\n[Tests/test]   | solver time: 0.094605\n[Tests/test]   | solver time: 0.092425\n[Tests/test]   | solver time: 0.095042\n[Tests/test]   | solver time: 0.092898\n[Tests/test]   | solver time: 0.092875\n[Tests/test]   | solver time: 0.093298\n[Tests/test]   | solver time: 0.093004\n[Tests/test]   | solver time: 0.093029\n[Tests/test]   | solver time: 0.092705\n[Tests/test]   | solver time: 0.101516\n[Tests/test]   | solver time: 0.092865\n[Tests/test]   | solver time: 0.089056\n[Tests/test]   | solver time: 0.087236\n[Tests/test]   | solver time: 0.081443\n[Tests/test]   | solver time: 0.076217\n[Tests/test]   | solver time: 0.071769\n[Tests/test]   | solver time: 0.067408\n[Tests/test]   | solver time: 0.063473\n[Tests/test]   | solver time: 0.059759\n[Tests/test]   | solver time: 0.056831\n[Tests/test]   | solver time: 0.054435\n[Tests/test]   | solver time: 0.051511\n[Tests/test]   | solver time: 0.049705\n[Tests/test]   | solver time: 0.048816\n[Tests/test]   | solver time: 0.049328\n[Tests/test]   | solver time: 0.066912\n[Tests/test]   | solver time: 0.04927\n[Tests/test]   | solver time: 0.049792\n[Tests/test]   | solver time: 0.050044\n[Tests/test]   | solver time: 0.049738\n[Tests/test]   | solver time: 0.049694\n[Tests/test]   | solver time: 0.049717\n[Tests/test]   | solver time: 0.049446\n[Tests/test]   | solver time: 0.049048\n[Tests/test]   | solver time: 0.049561\n[Tests/test]   | solver time: 0.049399\n[Tests/test]   | solver time: 0.049219\n[Tests/test]   | solver time: 0.049524\n[Tests/test]   | solver time: 0.05026\n[Tests/test]   | solver time: 0.0558\n[Tests/test]   | solver time: 0.049855\n[Tests/test]   | solver time: 0.049225\n[Tests/test]   | solver time: 0.049358\n[Tests/test]   | solver time: 0.050424\n[Tests/test]   | solver time: 0.04946\n[Tests/test]   | solver time: 0.049155\n[Tests/test]   | solver time: 0.049805\n[Tests/test]   | solver time: 0.049794\n[Tests/test]   | solver time: 0.049816\n[Tests/test]   | solver time: 0.049291\n[Tests/test]   | solver time: 0.049148\n[Tests/test]   | solver time: 0.049424\n[Tests/test]   | solver time: 0.079038\n[Tests/test]   | solver time: 0.073521\n[Tests/test]   | solver time: 0.052932\n[Tests/test]   | solver time: 0.049202\n[Tests/test]   | solver time: 0.049014\n[Tests/test]   | solver time: 0.048635\n[Tests/test]   | solver time: 0.048451\n[Tests/test]   | solver time: 0.048423\n[Tests/test]   | solver time: 0.048854\n[Tests/test]   | solver time: 0.04855\n[Tests/test]   | solver time: 0.048651\n[Tests/test]   | solver time: 0.048533\n[Tests/test]   | solver time: 0.048711\n[Tests/test]   | solver time: 0.048747\n[Tests/test]   | solver time: 0.048818\n[Tests/test]   | solver time: 0.048464\n[Tests/test]   | solver time: 0.048895\n[Tests/test]   | solver time: 0.048537\n[Tests/test]   | solver time: 0.048724\n[Tests/test]   | solver time: 0.048701\n[Tests/test]   | solver time: 0.048816\n[Tests/test]   | solver time: 0.049401\n[Tests/test]   | solver time: 0.049664\n[Tests/test]   | solver time: 0.048751\n[Tests/test]   | solver time: 0.048843\n[Tests/test]   | solver time: 0.049698\n[Tests/test]   | solver time: 0.04954\n[Tests/test]   | solver time: 0.049021\n[Tests/test]   | solver time: 0.048726\n[Tests/test]   | solver time: 0.048776\n[Tests/test]   | solver time: 0.048821\n[Tests/test]   | solver time: 0.048638\n[Tests/test]   | solver time: 0.048982\n[Tests/test]   | solver time: 0.048295\n[Tests/test]   | solver time: 0.048962\n[Tests/test]   | solver time: 0.049057\n[Tests/test]   | solver time: 0.048902\n[Tests/test]   | solver time: 0.049234\n[Tests/test]   | solver time: 0.048494\n[Tests/test]   | solver time: 0.048628\n[Tests/test]   | solver time: 0.04849\n[Tests/test]   | solver time: 0.048246\n[Tests/test]   | solver time: 0.048511\n[Tests/test]   | solver time: 0.048694\n[Tests/test]   | solver time: 0.049407\n[Tests/test]   | solver time: 0.048527\n[Tests/test]   | solver time: 0.048609\n[Tests/test]   | solver time: 0.048621\n[Tests/test]   | solver time: 0.049115\n[Tests/test]   | solver time: 0.049022\n[Tests/test]   | solver time: 0.049104\n[Tests/test]   | solver time: 0.049574\n[Tests/test]   | solver time: 0.048938\n[Tests/test]   | solver time: 0.049742\n[Tests/test]   | solver time: 0.049625\n[Tests/test]   | solver time: 0.050719\n[Tests/test]   | solver time: 0.049812\n[Tests/test]   | solver time: 0.049732\n[Tests/test]   | solver time: 0.050014\n[Tests/test]   | solver time: 0.049295\n[Tests/test]   | solver time: 0.049914\n[Tests/test]   | solver time: 0.049412\n[Tests/test]   | solver time: 0.05005\n[Tests/test]   | solver time: 0.050157\n[Tests/test]   | solver time: 0.049794\n[Tests/test]   | solver time: 0.050543\n[Tests/test]   | solver time: 0.051182\n[Tests/test]   | solver time: 0.051155\n[Tests/test]   | solver time: 0.051735\n[Tests/test]   | solver time: 0.052723\n[Tests/test]   | solver time: 0.051933\n[Tests/test]   | solver time: 0.051277\n[Tests/test]   | solver time: 0.050734\n[Tests/test]   | solver time: 0.051576\n[Tests/test]   | solver time: 0.050555\n[Tests/test]   | solver time: 0.050283\n[Tests/test]   | solver time: 0.049028\n[Tests/test]   | solver time: 0.048938\n[Tests/test]   | solver time: 0.048714\n[Tests/test]   | solver time: 0.048595\n[Tests/test]   | solver time: 0.049294\n[Tests/test]   | solver time: 0.048676\n[Tests/test]   | solver time: 0.048879\n[Tests/test]   | solver time: 0.050463\n[Tests/test]   | solver time: 0.050707\n[Tests/test]   | solver time: 0.058349\n[Tests/test]   | solver time: 0.098389\n[Tests/test]   | solver time: 0.102153\n[Tests/test]   | solver time: 0.102455\n[Tests/test]   | solver time: 0.099038\n[Tests/test]   | solver time: 0.109063\n[Tests/test]   | solver time: 0.103045\n[Tests/test]   | lap completed\n[Tests/test]   | solver time: 0.152138\n[Tests/test]   | solver time: 0.16372\n[Tests/test]   | solver time: 0.154539\n[Tests/test]   | solver time: 0.146658\n[Tests/test]   | solver time: 0.153286\n[Tests/test]   | solver time: 0.135164\n[Tests/test]   | solver time: 0.109389\n[Tests/test]   | solver time: 0.095396\n[Tests/test]   | solver time: 0.137988\n[Tests/test]   | solver time: 0.158812\n[Tests/test]   | solver fail to find the solution, the non-converged solution is used\n[Tests/test]   | solver time: 0.235158\n[Tests/test]   | solver fail to find the solution, the non-converged solution is used\n[Tests/test]   | solver time: 0.356457\n[Tests/test]   | solver time: 0.170414\n[Tests/test]   | solver fail to find the solution, the non-converged solution is used\n[Tests/test]   | solver time: 0.444381\n[Tests/test]   | solver time: 0.142947\n[Tests/test]   | solver time: 0.152147\n[Tests/test]   | solver time: 0.157275\n[Tests/test]   | solver time: 0.149463\n[Tests/test]   | solver time: 0.122082\n[Tests/test]   | solver time: 0.115531\n[Tests/test]   | solver time: 0.164333\n[Tests/test]   | solver time: 0.165588\n[Tests/test]   | solver time: 0.190587\n[Tests/test]   | solver time: 0.154001\n[Tests/test]   | solver time: 0.149939\n[Tests/test]   | solver time: 0.152445\n[Tests/test]   | solver time: 0.167434\n[Tests/test]   | solver time: 0.156715\n[Tests/test]   | solver time: 0.157459\n[Tests/test]   | solver time: 0.173897\n[Tests/test]   | solver time: 0.151177\n[Tests/test]   | solver time: 0.16467\n[Tests/test]   | solver time: 0.172059\n[Tests/test]   | solver time: 0.143983\n[Tests/test]   | solver time: 0.131011\n[Tests/test]   | solver time: 0.119451\n[Tests/test]   | solver time: 0.108901\n[Tests/test]   | solver fail to find the solution, the non-converged solution is used\n[Tests/test]   | solver time: 0.256915\n[Tests/test]   | solver fail to find the solution, the non-converged solution is used\n[Tests/test]   | solver time: 0.177279\n[Tests/test]   | solver fail to find the solution, the non-converged solution is used\n[Tests/test]   | solver time: 0.196141\n[Tests/test]   | =============================== warnings summary ===============================\n[Tests/test]   | tests/auto_racing_game_test.py: 520 warnings\n[Tests/test]   |   /tmp/de65f406-fe28-11ed-a890-af2cc187fc11/HybridRobotics-car-racing/car_racing/utils/racing_env.py:25: DeprecationWarning: np.asscalar(a) is deprecated since NumPy v1.16, use a.item() instead\n[Tests/test]   |     i = np.asscalar(np.where(np.squeeze(index))[0][0])\n[Tests/test]   | \n[Tests/test]   | tests/auto_racing_game_test.py: 520 warnings\n[Tests/test]   |   /tmp/de65f406-fe28-11ed-a890-af2cc187fc11/HybridRobotics-car-racing/car_racing/utils/racing_env.py:86: DeprecationWarning: np.asscalar(a) is deprecated since NumPy v1.16, use a.item() instead\n[Tests/test]   |     i = np.asscalar(np.where(np.squeeze(index))[0][0])\n[Tests/test]   | \n[Tests/test]   | -- Docs: https://docs.pytest.org/en/stable/warnings.html\n[Tests/test]   | \n[Tests/test]   | ---------- coverage: platform linux, python 3.6.14-final-0 -----------\n[Tests/test]   | Name                             Stmts   Miss  Cover\n[Tests/test]   | ----------------------------------------------------\n[Tests/test]   | tests/__init__.py                    0      0   100%\n[Tests/test]   | tests/auto_control_test.py          34     34     0%\n[Tests/test]   | tests/auto_mpccbf_test.py           41     41     0%\n[Tests/test]   | tests/auto_racing_game_test.py     100     24    76%\n[Tests/test]   | ----------------------------------------------------\n[Tests/test]   | TOTAL                              175     99    43%\n[Tests/test]   | \n[Tests/test]   | =========================== short test summary info ============================\n[Tests/test]   | FAILED tests/auto_racing_game_test.py::test_racing_overtake - ValueError: Ran...\n[Tests/test]   | ====================== 1 failed, 1040 warnings in 36.34s =======================\n[Tests/test]   \u274c  Failure - Main Test racing game controller wit pytest\n[Tests/test] exitcode '1': failure\n[Tests/test] \ud83c\udfc1  Job failed\n",
    "actions_stderr": "Error: Job 'test' failed\n"
}