{
    "repository": "aio-libs/aiomcache",
    "clone_url": "https://github.com/aio-libs/aiomcache.git",
    "timestamp": "2023-05-29T15:18:29.638189Z",
    "clone_success": true,
    "number of actions": 3,
    "number_of_test_actions": 1,
    "actions_successful": false,
    "actions_stdout": "[CI/Linter] \ud83d\ude80  Start image=crawlergpt:latest\n[CI/Tests ] \ud83d\ude80  Start image=crawlergpt:latest\n[CI/Linter]   \ud83d\udc33  docker pull image=crawlergpt:latest platform= username= forcePull=false\n[CI/Tests ]   \ud83d\udc33  docker pull image=crawlergpt:latest platform= username= forcePull=false\n[CI/Tests ]   \ud83d\udc33  docker create image=crawlergpt:latest platform= entrypoint=[\"tail\" \"-f\" \"/dev/null\"] cmd=[]\n[CI/Linter]   \ud83d\udc33  docker create image=crawlergpt:latest platform= entrypoint=[\"tail\" \"-f\" \"/dev/null\"] cmd=[]\n[CI/Linter]   \ud83d\udc33  docker run image=crawlergpt:latest platform= entrypoint=[\"tail\" \"-f\" \"/dev/null\"] cmd=[]\n[CI/Tests ]   \ud83d\udc33  docker run image=crawlergpt:latest platform= entrypoint=[\"tail\" \"-f\" \"/dev/null\"] cmd=[]\n[CI/Linter]   \ud83d\udc33  docker exec cmd=[chown -R 1012:1000 /tmp/de65f406-fe28-11ed-a890-af2cc187fc11/aio-libs-aiomcache] user=0 workdir=\n[CI/Linter]   \u2601  git clone 'https://github.com/actions/setup-python' # ref=v2\n[CI/Linter] Unable to reset to 75f3110429a8c05be0e1bf360334e4cced2b63fa: malformed index signature file\n[CI/Tests ]   \ud83d\udc33  docker exec cmd=[chown -R 1012:1000 /tmp/de65f406-fe28-11ed-a890-af2cc187fc11/aio-libs-aiomcache] user=0 workdir=\n[CI/Linter] \ud83c\udfc1  Job succeeded\n[CI/Tests ]   \u2601  git clone 'https://github.com/actions/setup-python' # ref=v2\n[CI/Tests ]   \u2601  git clone 'https://github.com/jkeys089/actions-memcached' # ref=master\n[CI/Tests ]   \u2601  git clone 'https://github.com/codecov/codecov-action' # ref=v2\n[CI/Tests ] \ud83e\uddea  Matrix: map[python-version:3.7]\n[CI/Tests ] \u2b50 Run Main Checkout\n[CI/Tests ]   \u2705  Success - Main Checkout\n[CI/Tests ] \u2b50 Run Main Set up Python 3.7\n[CI/Tests ]   \ud83d\udc33  docker cp src=/home/andre-silva/.cache/act/actions-setup-python@v2/ dst=/var/run/act/actions/actions-setup-python@v2/\n[CI/Tests ]   \ud83d\udc33  docker exec cmd=[chown -R 1012:1000 /var/run/act/actions/actions-setup-python@v2/] user=0 workdir=\n[CI/Tests ]   \ud83d\udc33  docker exec cmd=[node /var/run/act/actions/actions-setup-python@v2/dist/setup/index.js] user= workdir=\n[CI/Tests ]   \ud83d\udcac  ::debug::Semantic version spec of 3.7 is 3.7\n[CI/Tests ]   \ud83d\udcac  ::debug::isExplicit: \n[CI/Tests ]   \ud83d\udcac  ::debug::explicit? false\n[CI/Tests ]   \ud83d\udcac  ::debug::isExplicit: 2.7.18\n[CI/Tests ]   \ud83d\udcac  ::debug::explicit? true\n[CI/Tests ]   \ud83d\udcac  ::debug::isExplicit: 3.5.10\n[CI/Tests ]   \ud83d\udcac  ::debug::explicit? true\n[CI/Tests ]   \ud83d\udcac  ::debug::isExplicit: 3.6.14\n[CI/Tests ]   \ud83d\udcac  ::debug::explicit? true\n[CI/Tests ]   \ud83d\udcac  ::debug::isExplicit: 3.7.11\n[CI/Tests ]   \ud83d\udcac  ::debug::explicit? true\n[CI/Tests ]   \ud83d\udcac  ::debug::isExplicit: 3.8.11\n[CI/Tests ]   \ud83d\udcac  ::debug::explicit? true\n[CI/Tests ]   \ud83d\udcac  ::debug::isExplicit: 3.9.6\n[CI/Tests ]   \ud83d\udcac  ::debug::explicit? true\n[CI/Tests ]   \ud83d\udcac  ::debug::evaluating 6 versions\n[CI/Tests ]   \ud83d\udcac  ::debug::matched: 3.7.11\n[CI/Tests ]   \ud83d\udcac  ::debug::checking cache: /opt/hostedtoolcache/Python/3.7.11/x64\n[CI/Tests ]   \ud83d\udcac  ::debug::Found tool in cache Python 3.7.11 x64\n[CI/Tests ]   | Successfully setup CPython (3.7.11)\n[CI/Tests ]   \u2753 add-matcher /run/act/actions/actions-setup-python@v2/.github/python.json\n[CI/Tests ]   \u2705  Success - Main Set up Python 3.7\n[CI/Tests ]   \u2699  ::set-env:: pythonLocation=/opt/hostedtoolcache/Python/3.7.11/x64\n[CI/Tests ]   \u2699  ::set-env:: LD_LIBRARY_PATH=/opt/hostedtoolcache/Python/3.7.11/x64/lib\n[CI/Tests ]   \u2699  ::set-output:: python-version=3.7.11\n[CI/Tests ]   \u2699  ::add-path:: /opt/hostedtoolcache/Python/3.7.11/x64\n[CI/Tests ]   \u2699  ::add-path:: /opt/hostedtoolcache/Python/3.7.11/x64/bin\n[CI/Tests ] \u2b50 Run Main Install system dependencies\n[CI/Tests ]   \ud83d\udc33  docker exec cmd=[bash --noprofile --norc -e -o pipefail /var/run/act/workflow/2] user= workdir=\n[CI/Tests ]   | Reading package lists...\n[CI/Tests ]   | Building dependency tree...\n[CI/Tests ]   | Reading state information...\n[CI/Tests ]   | The following additional packages will be installed:\n[CI/Tests ]   |   libhashkit-dev libhashkit2 libmemcachedutil2 libsasl2-dev\n[CI/Tests ]   | The following NEW packages will be installed:\n[CI/Tests ]   |   libhashkit-dev libhashkit2 libmemcached-dev libmemcachedutil2 libsasl2-dev\n[CI/Tests ]   | 0 upgraded, 5 newly installed, 0 to remove and 20 not upgraded.\n[CI/Tests ]   | Need to get 533 kB of archives.\n[CI/Tests ]   | After this operation, 2139 kB of additional disk space will be used.\n[CI/Tests ]   | Get:1 http://archive.ubuntu.com/ubuntu focal/main amd64 libhashkit2 amd64 1.0.18-4.2ubuntu2 [35.2 kB]\n[CI/Tests ]   | Get:2 http://archive.ubuntu.com/ubuntu focal/main amd64 libhashkit-dev amd64 1.0.18-4.2ubuntu2 [24.0 kB]\n[CI/Tests ]   | Get:3 http://archive.ubuntu.com/ubuntu focal/main amd64 libmemcachedutil2 amd64 1.0.18-4.2ubuntu2 [9644 B]\n[CI/Tests ]   | Get:4 http://archive.ubuntu.com/ubuntu focal/main amd64 libsasl2-dev amd64 2.1.27+dfsg-2 [225 kB]\n[CI/Tests ]   | Get:5 http://archive.ubuntu.com/ubuntu focal/main amd64 libmemcached-dev amd64 1.0.18-4.2ubuntu2 [239 kB]\n[CI/Tests ]   | Fetched 533 kB in 0s (1343 kB/s)\n[CI/Tests ]   | Selecting previously unselected package libhashkit2:amd64.\r\n[CI/Tests ]   | (Reading database ... \r(Reading database ... 5%\r(Reading database ... 10%\r(Reading database ... 15%\r(Reading database ... 20%\r(Reading database ... 25%\r(Reading database ... 30%\r(Reading database ... 35%\r(Reading database ... 40%\r(Reading database ... 45%\r(Reading database ... 50%\r(Reading database ... 55%\r(Reading database ... 60%\r(Reading database ... 65%\r(Reading database ... 70%\r(Reading database ... 75%\r(Reading database ... 80%\r(Reading database ... 85%\r(Reading database ... 90%\r(Reading database ... 95%\r(Reading database ... 100%\r(Reading database ... 193678 files and directories currently installed.)\r\n[CI/Tests ]   | Preparing to unpack .../libhashkit2_1.0.18-4.2ubuntu2_amd64.deb ...\r\n[CI/Tests ]   | Unpacking libhashkit2:amd64 (1.0.18-4.2ubuntu2) ...\r\n[CI/Tests ]   | Selecting previously unselected package libhashkit-dev:amd64.\r\n[CI/Tests ]   | Preparing to unpack .../libhashkit-dev_1.0.18-4.2ubuntu2_amd64.deb ...\r\n[CI/Tests ]   | Unpacking libhashkit-dev:amd64 (1.0.18-4.2ubuntu2) ...\r\n[CI/Tests ]   | Selecting previously unselected package libmemcachedutil2:amd64.\r\n[CI/Tests ]   | Preparing to unpack .../libmemcachedutil2_1.0.18-4.2ubuntu2_amd64.deb ...\r\n[CI/Tests ]   | Unpacking libmemcachedutil2:amd64 (1.0.18-4.2ubuntu2) ...\r\n[CI/Tests ]   | Selecting previously unselected package libsasl2-dev.\r\n[CI/Tests ]   | Preparing to unpack .../libsasl2-dev_2.1.27+dfsg-2_amd64.deb ...\r\n[CI/Tests ]   | Unpacking libsasl2-dev (2.1.27+dfsg-2) ...\r\n[CI/Tests ]   | Selecting previously unselected package libmemcached-dev:amd64.\r\n[CI/Tests ]   | Preparing to unpack .../libmemcached-dev_1.0.18-4.2ubuntu2_amd64.deb ...\r\n[CI/Tests ]   | Unpacking libmemcached-dev:amd64 (1.0.18-4.2ubuntu2) ...\r\n[CI/Tests ]   | Setting up libmemcachedutil2:amd64 (1.0.18-4.2ubuntu2) ...\r\n[CI/Tests ]   | Setting up libhashkit2:amd64 (1.0.18-4.2ubuntu2) ...\r\n[CI/Tests ]   | Setting up libsasl2-dev (2.1.27+dfsg-2) ...\r\n[CI/Tests ]   | Setting up libhashkit-dev:amd64 (1.0.18-4.2ubuntu2) ...\r\n[CI/Tests ]   | Setting up libmemcached-dev:amd64 (1.0.18-4.2ubuntu2) ...\r\n[CI/Tests ]   | Processing triggers for libc-bin (2.31-0ubuntu9.2) ...\r\n[CI/Tests ]   \u2705  Success - Main Install system dependencies\n[CI/Tests ] \u2b50 Run Main Install python dependencies\n[CI/Tests ]   \ud83d\udc33  docker exec cmd=[bash --noprofile --norc -e -o pipefail /var/run/act/workflow/3] user= workdir=\n[CI/Tests ]   | Requirement already satisfied: pip in /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/site-packages (21.2.4)\n[CI/Tests ]   | Collecting pip\n[CI/Tests ]   |   Downloading pip-23.1.2-py3-none-any.whl (2.1 MB)\n[CI/Tests ]   | Installing collected packages: pip\n[CI/Tests ]   |   Attempting uninstall: pip\n[CI/Tests ]   |     Found existing installation: pip 21.2.4\n[CI/Tests ]   |     Uninstalling pip-21.2.4:\n[CI/Tests ]   |       Successfully uninstalled pip-21.2.4\n[CI/Tests ]   | Successfully installed pip-23.1.2\n[CI/Tests ]   | Requirement already satisfied: setuptools in /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/site-packages (47.1.0)\n[CI/Tests ]   | Collecting setuptools\n[CI/Tests ]   |   Downloading setuptools-67.8.0-py3-none-any.whl (1.1 MB)\n[CI/Tests ]   |      \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 1.1/1.1 MB 16.7 MB/s eta 0:00:00\n[CI/Tests ]   | Installing collected packages: setuptools\n[CI/Tests ]   |   Attempting uninstall: setuptools\n[CI/Tests ]   |     Found existing installation: setuptools 47.1.0\n[CI/Tests ]   |     Uninstalling setuptools-47.1.0:\n[CI/Tests ]   |       Successfully uninstalled setuptools-47.1.0\n[CI/Tests ]   | Successfully installed setuptools-67.8.0\n[CI/Tests ]   | \n[CI/Tests ]   | [notice] A new release of pip is available: 20.1.1 -> 23.1.2\n[CI/Tests ]   | [notice] To update, run: pip install --upgrade pip\n[CI/Tests ]   | Collecting docker-py==1.10.6 (from -r requirements.txt (line 1))\n[CI/Tests ]   |   Downloading docker_py-1.10.6-py2.py3-none-any.whl (50 kB)\n[CI/Tests ]   |      \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 50.0/50.0 kB 1.9 MB/s eta 0:00:00\n[CI/Tests ]   | Collecting pytest==7.3.0 (from -r requirements.txt (line 2))\n[CI/Tests ]   |   Downloading pytest-7.3.0-py3-none-any.whl (320 kB)\n[CI/Tests ]   |      \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 320.5/320.5 kB 5.2 MB/s eta 0:00:00\n[CI/Tests ]   | Collecting pytest-asyncio==0.21.0 (from -r requirements.txt (line 3))\n[CI/Tests ]   |   Downloading pytest_asyncio-0.21.0-py3-none-any.whl (13 kB)\n[CI/Tests ]   | Collecting pytest-cov==4.1.0 (from -r requirements.txt (line 4))\n[CI/Tests ]   |   Downloading pytest_cov-4.1.0-py3-none-any.whl (21 kB)\n[CI/Tests ]   | Collecting python-memcached==1.59 (from -r requirements.txt (line 5))\n[CI/Tests ]   |   Downloading python_memcached-1.59-py2.py3-none-any.whl (16 kB)\n[CI/Tests ]   | Collecting typing_extensions==4.4.0 (from -r requirements.txt (line 6))\n[CI/Tests ]   |   Downloading typing_extensions-4.4.0-py3-none-any.whl (26 kB)\n[CI/Tests ]   | Collecting docker-pycreds>=0.2.1 (from docker-py==1.10.6->-r requirements.txt (line 1))\n[CI/Tests ]   |   Downloading docker_pycreds-0.4.0-py2.py3-none-any.whl (9.0 kB)\n[CI/Tests ]   | Collecting requests!=2.11.0,>=2.5.2 (from docker-py==1.10.6->-r requirements.txt (line 1))\n[CI/Tests ]   |   Downloading requests-2.31.0-py3-none-any.whl (62 kB)\n[CI/Tests ]   |      \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 62.6/62.6 kB 7.8 MB/s eta 0:00:00\n[CI/Tests ]   | Collecting six>=1.4.0 (from docker-py==1.10.6->-r requirements.txt (line 1))\n[CI/Tests ]   |   Downloading six-1.16.0-py2.py3-none-any.whl (11 kB)\n[CI/Tests ]   | Collecting websocket-client>=0.32.0 (from docker-py==1.10.6->-r requirements.txt (line 1))\n[CI/Tests ]   |   Downloading websocket_client-1.5.2-py3-none-any.whl (56 kB)\n[CI/Tests ]   |      \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 56.6/56.6 kB 677.1 kB/s eta 0:00:00\n[CI/Tests ]   | Collecting iniconfig (from pytest==7.3.0->-r requirements.txt (line 2))\n[CI/Tests ]   |   Downloading iniconfig-2.0.0-py3-none-any.whl (5.9 kB)\n[CI/Tests ]   | Collecting packaging (from pytest==7.3.0->-r requirements.txt (line 2))\n[CI/Tests ]   |   Downloading packaging-23.1-py3-none-any.whl (48 kB)\n[CI/Tests ]   |      \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 48.9/48.9 kB 1.2 MB/s eta 0:00:00\n[CI/Tests ]   | Collecting pluggy<2.0,>=0.12 (from pytest==7.3.0->-r requirements.txt (line 2))\n[CI/Tests ]   |   Downloading pluggy-1.0.0-py2.py3-none-any.whl (13 kB)\n[CI/Tests ]   | Collecting exceptiongroup>=1.0.0rc8 (from pytest==7.3.0->-r requirements.txt (line 2))\n[CI/Tests ]   |   Downloading exceptiongroup-1.1.1-py3-none-any.whl (14 kB)\n[CI/Tests ]   | Collecting tomli>=1.0.0 (from pytest==7.3.0->-r requirements.txt (line 2))\n[CI/Tests ]   |   Downloading tomli-2.0.1-py3-none-any.whl (12 kB)\n[CI/Tests ]   | Collecting importlib-metadata>=0.12 (from pytest==7.3.0->-r requirements.txt (line 2))\n[CI/Tests ]   |   Downloading importlib_metadata-6.6.0-py3-none-any.whl (22 kB)\n[CI/Tests ]   | Collecting coverage[toml]>=5.2.1 (from pytest-cov==4.1.0->-r requirements.txt (line 4))\n[CI/Tests ]   |   Downloading coverage-7.2.6-cp37-cp37m-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl (225 kB)\n[CI/Tests ]   |      \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 225.5/225.5 kB 18.9 MB/s eta 0:00:00\n[CI/Tests ]   | Collecting zipp>=0.5 (from importlib-metadata>=0.12->pytest==7.3.0->-r requirements.txt (line 2))\n[CI/Tests ]   |   Downloading zipp-3.15.0-py3-none-any.whl (6.8 kB)\n[CI/Tests ]   | Collecting charset-normalizer<4,>=2 (from requests!=2.11.0,>=2.5.2->docker-py==1.10.6->-r requirements.txt (line 1))\n[CI/Tests ]   |   Downloading charset_normalizer-3.1.0-cp37-cp37m-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (171 kB)\n[CI/Tests ]   |      \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 171.0/171.0 kB 6.8 MB/s eta 0:00:00\n[CI/Tests ]   | Collecting idna<4,>=2.5 (from requests!=2.11.0,>=2.5.2->docker-py==1.10.6->-r requirements.txt (line 1))\n[CI/Tests ]   |   Downloading idna-3.4-py3-none-any.whl (61 kB)\n[CI/Tests ]   |      \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 61.5/61.5 kB 1.7 MB/s eta 0:00:00\n[CI/Tests ]   | Collecting urllib3<3,>=1.21.1 (from requests!=2.11.0,>=2.5.2->docker-py==1.10.6->-r requirements.txt (line 1))\n[CI/Tests ]   |   Downloading urllib3-2.0.2-py3-none-any.whl (123 kB)\n[CI/Tests ]   |      \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 123.2/123.2 kB 11.9 MB/s eta 0:00:00\n[CI/Tests ]   | Collecting certifi>=2017.4.17 (from requests!=2.11.0,>=2.5.2->docker-py==1.10.6->-r requirements.txt (line 1))\n[CI/Tests ]   |   Downloading certifi-2023.5.7-py3-none-any.whl (156 kB)\n[CI/Tests ]   |      \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 157.0/157.0 kB 2.4 MB/s eta 0:00:00\n[CI/Tests ]   | Installing collected packages: zipp, websocket-client, urllib3, typing_extensions, tomli, six, packaging, iniconfig, idna, exceptiongroup, coverage, charset-normalizer, certifi, requests, python-memcached, importlib-metadata, docker-pycreds, pluggy, docker-py, pytest, pytest-cov, pytest-asyncio\n[CI/Tests ]   | Successfully installed certifi-2023.5.7 charset-normalizer-3.1.0 coverage-7.2.6 docker-py-1.10.6 docker-pycreds-0.4.0 exceptiongroup-1.1.1 idna-3.4 importlib-metadata-6.6.0 iniconfig-2.0.0 packaging-23.1 pluggy-1.0.0 pytest-7.3.0 pytest-asyncio-0.21.0 pytest-cov-4.1.0 python-memcached-1.59 requests-2.31.0 six-1.16.0 tomli-2.0.1 typing_extensions-4.4.0 urllib3-2.0.2 websocket-client-1.5.2 zipp-3.15.0\n[CI/Tests ]   | \n[CI/Tests ]   | [notice] A new release of pip is available: 20.1.1 -> 23.1.2\n[CI/Tests ]   | [notice] To update, run: pip install --upgrade pip\n[CI/Tests ]   | Collecting codecov\n[CI/Tests ]   |   Downloading codecov-2.1.13-py2.py3-none-any.whl (16 kB)\n[CI/Tests ]   | Requirement already satisfied: requests>=2.7.9 in /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/site-packages (from codecov) (2.31.0)\n[CI/Tests ]   | Requirement already satisfied: coverage in /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/site-packages (from codecov) (7.2.6)\n[CI/Tests ]   | Requirement already satisfied: charset-normalizer<4,>=2 in /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/site-packages (from requests>=2.7.9->codecov) (3.1.0)\n[CI/Tests ]   | Requirement already satisfied: idna<4,>=2.5 in /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/site-packages (from requests>=2.7.9->codecov) (3.4)\n[CI/Tests ]   | Requirement already satisfied: urllib3<3,>=1.21.1 in /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/site-packages (from requests>=2.7.9->codecov) (2.0.2)\n[CI/Tests ]   | Requirement already satisfied: certifi>=2017.4.17 in /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/site-packages (from requests>=2.7.9->codecov) (2023.5.7)\n[CI/Tests ]   | Installing collected packages: codecov\n[CI/Tests ]   | Successfully installed codecov-2.1.13\n[CI/Tests ]   | \n[CI/Tests ]   | [notice] A new release of pip is available: 20.1.1 -> 23.1.2\n[CI/Tests ]   | [notice] To update, run: pip install --upgrade pip\n[CI/Tests ]   \u2705  Success - Main Install python dependencies\n[CI/Tests ] \u2b50 Run Main Run memcached service\n[CI/Tests ]   \ud83d\udc33  docker build -t act-jkeys089-actions-memcached-master-dockeraction:latest /home/andre-silva/.cache/act/jkeys089-actions-memcached@master/\n[CI/Tests ]   \ud83d\udc33  docker pull image=act-jkeys089-actions-memcached-master-dockeraction:latest platform= username= forcePull=false\n[CI/Tests ]   \ud83d\udc33  docker create image=act-jkeys089-actions-memcached-master-dockeraction:latest platform= entrypoint=[] cmd=[]\n[CI/Tests ]   \ud83d\udc33  docker run image=act-jkeys089-actions-memcached-master-dockeraction:latest platform= entrypoint=[] cmd=[]\n[CI/Tests ]   \u2705  Success - Main Run memcached service\n[CI/Tests ] \u2b50 Run Main Run tests\n[CI/Tests ]   \ud83d\udc33  docker exec cmd=[bash --noprofile --norc -e -o pipefail /var/run/act/workflow/5] user= workdir=\n[CI/Tests ]   | ============================= test session starts ==============================\n[CI/Tests ]   | platform linux -- Python 3.7.11, pytest-7.3.0, pluggy-1.0.0 -- /opt/hostedtoolcache/Python/3.7.11/x64/bin/python\n[CI/Tests ]   | cachedir: .pytest_cache\n[CI/Tests ]   | rootdir: /tmp/de65f406-fe28-11ed-a890-af2cc187fc11/aio-libs-aiomcache\n[CI/Tests ]   | configfile: pytest.ini\n[CI/Tests ]   | testpaths: tests/\n[CI/Tests ]   | plugins: cov-4.1.0, asyncio-0.21.0\n[CI/Tests ]   | asyncio: mode=auto\n[CI/Tests ]   | collecting ... collected 67 items\n[CI/Tests ]   | \n[CI/Tests ]   | tests/commands_test.py::test_valid_key[key] PASSED                       [  1%]\n[CI/Tests ]   | tests/commands_test.py::test_valid_key[123] PASSED                       [  2%]\n[CI/Tests ]   | tests/commands_test.py::test_valid_key[!@#] PASSED                       [  4%]\n[CI/Tests ]   | tests/commands_test.py::test_valid_key[\\xe4\\xb8\\xad\\xe6\\x96\\x87] PASSED  [  5%]\n[CI/Tests ]   | tests/commands_test.py::test_valid_key[\\xe3\\x81\\x93\\xe3\\x82\\x93\\xe3\\x81\\xab\\xe3\\x81\\xa1\\xe3\\x81\\xaf] PASSED [  7%]\n[CI/Tests ]   | tests/commands_test.py::test_valid_key[\\xec\\x95\\x88\\xeb\\x85\\x95\\xed\\x95\\x98\\xec\\x84\\xb8\\xec\\x9a\\x94] PASSED [  8%]\n[CI/Tests ]   | tests/commands_test.py::test_invalid_key[foo bar] PASSED                 [ 10%]\n[CI/Tests ]   | tests/commands_test.py::test_invalid_key[foo\\t] PASSED                   [ 11%]\n[CI/Tests ]   | tests/commands_test.py::test_invalid_key[\\nbar] PASSED                   [ 13%]\n[CI/Tests ]   | tests/commands_test.py::test_invalid_key[foo \\rbar] PASSED               [ 14%]\n[CI/Tests ]   | tests/commands_test.py::test_invalid_key[\\x18\\x0e] PASSED                [ 16%]\n[CI/Tests ]   | tests/commands_test.py::test_invalid_key[ `] PASSED                      [ 17%]\n[CI/Tests ]   | tests/commands_test.py::test_invalid_key[0\\x00] PASSED                   [ 19%]\n[CI/Tests ]   | tests/commands_test.py::test_invalid_key[ \\x01] PASSED                   [ 20%]\n[CI/Tests ]   | tests/commands_test.py::test_invalid_key[foo\\x00bar] PASSED              [ 22%]\n[CI/Tests ]   | tests/commands_test.py::test_invalid_key[\\x1f] PASSED                    [ 23%]\n[CI/Tests ]   | tests/commands_test.py::test_invalid_key[\\x7f] PASSED                    [ 25%]\n[CI/Tests ]   | tests/commands_test.py::test_invalid_key[\\xc2\\x80] PASSED                [ 26%]\n[CI/Tests ]   | tests/commands_test.py::test_invalid_key[\\xc2\\x9f] PASSED                [ 28%]\n[CI/Tests ]   | tests/commands_test.py::test_version FAILED                              [ 29%]\n[CI/Tests ]   | tests/commands_test.py::test_flush_all FAILED                            [ 31%]\n[CI/Tests ]   | tests/commands_test.py::test_set_get FAILED                              [ 32%]\n[CI/Tests ]   | tests/commands_test.py::test_gets FAILED                                 [ 34%]\n[CI/Tests ]   | tests/commands_test.py::test_multi_get FAILED                            [ 35%]\n[CI/Tests ]   | tests/commands_test.py::test_multi_get_doubling_keys FAILED              [ 37%]\n[CI/Tests ]   | tests/commands_test.py::test_set_expire FAILED                           [ 38%]\n[CI/Tests ]   | tests/commands_test.py::test_set_errors FAILED                           [ 40%]\n[CI/Tests ]   | tests/commands_test.py::test_gets_cas FAILED                             [ 41%]\n[CI/Tests ]   | tests/commands_test.py::test_cas_missing FAILED                          [ 43%]\n[CI/Tests ]   | tests/commands_test.py::test_add FAILED                                  [ 44%]\n[CI/Tests ]   | tests/commands_test.py::test_replace FAILED                              [ 46%]\n[CI/Tests ]   | tests/commands_test.py::test_append FAILED                               [ 47%]\n[CI/Tests ]   | tests/commands_test.py::test_prepend FAILED                              [ 49%]\n[CI/Tests ]   | tests/commands_test.py::test_delete FAILED                               [ 50%]\n[CI/Tests ]   | tests/commands_test.py::test_delete_key_not_exists FAILED                [ 52%]\n[CI/Tests ]   | tests/commands_test.py::test_incr FAILED                                 [ 53%]\n[CI/Tests ]   | tests/commands_test.py::test_incr_errors FAILED                          [ 55%]\n[CI/Tests ]   | tests/commands_test.py::test_decr FAILED                                 [ 56%]\n[CI/Tests ]   | tests/commands_test.py::test_decr_errors FAILED                          [ 58%]\n[CI/Tests ]   | tests/commands_test.py::test_stats FAILED                                [ 59%]\n[CI/Tests ]   | tests/commands_test.py::test_touch FAILED                                [ 61%]\n[CI/Tests ]   | tests/commands_test.py::test_close PASSED                                [ 62%]\n[CI/Tests ]   | tests/commands_test.py::test_flag_helper[key] FAILED                     [ 64%]\n[CI/Tests ]   | tests/commands_test.py::test_flag_helper[bkey] FAILED                    [ 65%]\n[CI/Tests ]   | tests/commands_test.py::test_flag_helper[False] FAILED                   [ 67%]\n[CI/Tests ]   | tests/commands_test.py::test_flag_helper[1] FAILED                       [ 68%]\n[CI/Tests ]   | tests/commands_test.py::test_flag_helper[None] FAILED                    [ 70%]\n[CI/Tests ]   | tests/commands_test.py::test_flag_helper[0.5] FAILED                     [ 71%]\n[CI/Tests ]   | tests/commands_test.py::test_flag_helper[value6] FAILED                  [ 73%]\n[CI/Tests ]   | tests/commands_test.py::test_flag_helper[value7] FAILED                  [ 74%]\n[CI/Tests ]   | tests/commands_test.py::test_flag_helper[value8] FAILED                  [ 76%]\n[CI/Tests ]   | tests/commands_test.py::test_flag_helper[!@#] FAILED                     [ 77%]\n[CI/Tests ]   | tests/commands_test.py::test_flag_helper[\\xec\\x95\\x88\\xeb\\x85\\x95\\xed\\x95\\x98\\xec\\x84\\xb8\\xec\\x9a\\x94] FAILED [ 79%]\n[CI/Tests ]   | tests/commands_test.py::test_objects_not_supported_without_flag_handler FAILED [ 80%]\n[CI/Tests ]   | tests/commands_test.py::test_flag_handler_invoked_only_when_expected FAILED [ 82%]\n[CI/Tests ]   | tests/conn_args_test.py::test_params_forwarded_from_client SKIPPED (...) [ 83%]\n[CI/Tests ]   | tests/conn_args_test.py::test_ssl_client_fails_against_plaintext_server FAILED [ 85%]\n[CI/Tests ]   | tests/pool_test.py::test_pool_creation PASSED                            [ 86%]\n[CI/Tests ]   | tests/pool_test.py::test_pool_acquire_release FAILED                     [ 88%]\n[CI/Tests ]   | tests/pool_test.py::test_pool_acquire_release2 FAILED                    [ 89%]\n[CI/Tests ]   | tests/pool_test.py::test_pool_clear FAILED                               [ 91%]\n[CI/Tests ]   | tests/pool_test.py::test_acquire_dont_create_new_connection_if_have_conn_in_pool FAILED [ 92%]\n[CI/Tests ]   | tests/pool_test.py::test_acquire_limit_maxsize FAILED                    [ 94%]\n[CI/Tests ]   | tests/pool_test.py::test_acquire_task_cancellation FAILED                [ 95%]\n[CI/Tests ]   | tests/pool_test.py::test_maxsize_greater_than_minsize FAILED             [ 97%]\n[CI/Tests ]   | tests/pool_test.py::test_0_minsize FAILED                                [ 98%]\n[CI/Tests ]   | tests/pool_test.py::test_bad_connection PASSED                           [100%]\n[CI/Tests ]   | \n[CI/Tests ]   | =================================== FAILURES ===================================\n[CI/Tests ]   | _________________________________ test_version _________________________________\n[CI/Tests ]   | \n[CI/Tests ]   | mcache = <aiomcache.client.Client object at 0x7f8a7ede6390>\n[CI/Tests ]   | \n[CI/Tests ]   |     async def test_version(mcache: Client) -> None:\n[CI/Tests ]   | >       version = await mcache.version()\n[CI/Tests ]   | \n[CI/Tests ]   | mcache     = <aiomcache.client.Client object at 0x7f8a7ede6390>\n[CI/Tests ]   | \n[CI/Tests ]   | tests/commands_test.py:49: \n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | aiomcache/client.py:40: in wrapper\n[CI/Tests ]   |     conn = await self._pool.acquire()\n[CI/Tests ]   |         args       = ()\n[CI/Tests ]   |         func       = <function FlagClient.version at 0x7f8a7edf9b00>\n[CI/Tests ]   |         kwargs     = {}\n[CI/Tests ]   |         self       = <aiomcache.client.Client object at 0x7f8a7ede6390>\n[CI/Tests ]   | aiomcache/pool.py:40: in acquire\n[CI/Tests ]   |     _conn = await self._create_new_conn()\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ede6a50>\n[CI/Tests ]   | aiomcache/pool.py:71: in _create_new_conn\n[CI/Tests ]   |     self._host, self._port, **self.conn_args)\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ede6a50>\n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/streams.py:77: in open_connection\n[CI/Tests ]   |     lambda: protocol, host, port, **kwds)\n[CI/Tests ]   |         host       = 'localhost'\n[CI/Tests ]   |         kwds       = {}\n[CI/Tests ]   |         limit      = 65536\n[CI/Tests ]   |         loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   |         port       = 11211\n[CI/Tests ]   |         protocol   = <asyncio.streams.StreamReaderProtocol object at 0x7f8a7ede6910>\n[CI/Tests ]   |         reader     = <StreamReader>\n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | \n[CI/Tests ]   | self = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ec4eb00>\n[CI/Tests ]   | host = 'localhost', port = 11211\n[CI/Tests ]   | \n[CI/Tests ]   |     async def create_connection(\n[CI/Tests ]   |             self, protocol_factory, host=None, port=None,\n[CI/Tests ]   |             *, ssl=None, family=0,\n[CI/Tests ]   |             proto=0, flags=0, sock=None,\n[CI/Tests ]   |             local_addr=None, server_hostname=None,\n[CI/Tests ]   |             ssl_handshake_timeout=None):\n[CI/Tests ]   |         \"\"\"Connect to a TCP server.\n[CI/Tests ]   |     \n[CI/Tests ]   |         Create a streaming transport connection to a given Internet host and\n[CI/Tests ]   |         port: socket family AF_INET or socket.AF_INET6 depending on host (or\n[CI/Tests ]   |         family if specified), socket type SOCK_STREAM. protocol_factory must be\n[CI/Tests ]   |         a callable returning a protocol instance.\n[CI/Tests ]   |     \n[CI/Tests ]   |         This method is a coroutine which will try to establish the connection\n[CI/Tests ]   |         in the background.  When successful, the coroutine returns a\n[CI/Tests ]   |         (transport, protocol) pair.\n[CI/Tests ]   |         \"\"\"\n[CI/Tests ]   |         if server_hostname is not None and not ssl:\n[CI/Tests ]   |             raise ValueError('server_hostname is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if server_hostname is None and ssl:\n[CI/Tests ]   |             # Use host as default for server_hostname.  It is an error\n[CI/Tests ]   |             # if host is empty or not set, e.g. when an\n[CI/Tests ]   |             # already-connected socket was passed or when only a port\n[CI/Tests ]   |             # is given.  To avoid this error, you can pass\n[CI/Tests ]   |             # server_hostname='' -- this will bypass the hostname\n[CI/Tests ]   |             # check.  (This also means that if host is a numeric\n[CI/Tests ]   |             # IP/IPv6 address, we will attempt to verify that exact\n[CI/Tests ]   |             # address; this will probably fail, but it is possible to\n[CI/Tests ]   |             # create a certificate for a specific IP address, so we\n[CI/Tests ]   |             # don't judge it here.)\n[CI/Tests ]   |             if not host:\n[CI/Tests ]   |                 raise ValueError('You must set server_hostname '\n[CI/Tests ]   |                                  'when using ssl without a host')\n[CI/Tests ]   |             server_hostname = host\n[CI/Tests ]   |     \n[CI/Tests ]   |         if ssl_handshake_timeout is not None and not ssl:\n[CI/Tests ]   |             raise ValueError(\n[CI/Tests ]   |                 'ssl_handshake_timeout is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if host is not None or port is not None:\n[CI/Tests ]   |             if sock is not None:\n[CI/Tests ]   |                 raise ValueError(\n[CI/Tests ]   |                     'host/port and sock can not be specified at the same time')\n[CI/Tests ]   |     \n[CI/Tests ]   |             infos = await self._ensure_resolved(\n[CI/Tests ]   |                 (host, port), family=family,\n[CI/Tests ]   |                 type=socket.SOCK_STREAM, proto=proto, flags=flags, loop=self)\n[CI/Tests ]   |             if not infos:\n[CI/Tests ]   |                 raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             if local_addr is not None:\n[CI/Tests ]   |                 laddr_infos = await self._ensure_resolved(\n[CI/Tests ]   |                     local_addr, family=family,\n[CI/Tests ]   |                     type=socket.SOCK_STREAM, proto=proto,\n[CI/Tests ]   |                     flags=flags, loop=self)\n[CI/Tests ]   |                 if not laddr_infos:\n[CI/Tests ]   |                     raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             exceptions = []\n[CI/Tests ]   |             for family, type, proto, cname, address in infos:\n[CI/Tests ]   |                 try:\n[CI/Tests ]   |                     sock = socket.socket(family=family, type=type, proto=proto)\n[CI/Tests ]   |                     sock.setblocking(False)\n[CI/Tests ]   |                     if local_addr is not None:\n[CI/Tests ]   |                         for _, _, _, _, laddr in laddr_infos:\n[CI/Tests ]   |                             try:\n[CI/Tests ]   |                                 sock.bind(laddr)\n[CI/Tests ]   |                                 break\n[CI/Tests ]   |                             except OSError as exc:\n[CI/Tests ]   |                                 msg = (\n[CI/Tests ]   |                                     f'error while attempting to bind on '\n[CI/Tests ]   |                                     f'address {laddr!r}: '\n[CI/Tests ]   |                                     f'{exc.strerror.lower()}'\n[CI/Tests ]   |                                 )\n[CI/Tests ]   |                                 exc = OSError(exc.errno, msg)\n[CI/Tests ]   |                                 exceptions.append(exc)\n[CI/Tests ]   |                         else:\n[CI/Tests ]   |                             sock.close()\n[CI/Tests ]   |                             sock = None\n[CI/Tests ]   |                             continue\n[CI/Tests ]   |                     if self._debug:\n[CI/Tests ]   |                         logger.debug(\"connect %r to %r\", sock, address)\n[CI/Tests ]   |                     await self.sock_connect(sock, address)\n[CI/Tests ]   |                 except OSError as exc:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     exceptions.append(exc)\n[CI/Tests ]   |                 except:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     raise\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     break\n[CI/Tests ]   |             else:\n[CI/Tests ]   |                 if len(exceptions) == 1:\n[CI/Tests ]   |                     raise exceptions[0]\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     # If they all have the same str(), raise one.\n[CI/Tests ]   |                     model = str(exceptions[0])\n[CI/Tests ]   |                     if all(str(exc) == model for exc in exceptions):\n[CI/Tests ]   |                         raise exceptions[0]\n[CI/Tests ]   |                     # Raise a combined exception so the user can see all\n[CI/Tests ]   |                     # the various error messages.\n[CI/Tests ]   |                     raise OSError('Multiple exceptions: {}'.format(\n[CI/Tests ]   | >                       ', '.join(str(exc) for exc in exceptions)))\n[CI/Tests ]   | E                   OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | \n[CI/Tests ]   | address    = ('::1', 11211, 0, 0)\n[CI/Tests ]   | cname      = ''\n[CI/Tests ]   | exceptions = [ConnectionRefusedError(111, \"Connect call failed ('127.0.0.1', 11211)\"), OSError(99, 'Cannot assign requested address')]\n[CI/Tests ]   | family     = <AddressFamily.AF_INET6: 10>\n[CI/Tests ]   | flags      = 0\n[CI/Tests ]   | host       = 'localhost'\n[CI/Tests ]   | infos      = [(<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('127.0.0.1', 11211)), (<AddressFamily.AF_INET6: 10>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('::1', 11211, 0, 0))]\n[CI/Tests ]   | local_addr = None\n[CI/Tests ]   | model      = \"[Errno 111] Connect call failed ('127.0.0.1', 11211)\"\n[CI/Tests ]   | port       = 11211\n[CI/Tests ]   | proto      = 6\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ec4eb00>\n[CI/Tests ]   | self       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | server_hostname = None\n[CI/Tests ]   | sock       = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6>\n[CI/Tests ]   | ssl        = None\n[CI/Tests ]   | ssl_handshake_timeout = None\n[CI/Tests ]   | type       = <SocketKind.SOCK_STREAM: 1>\n[CI/Tests ]   | \n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/base_events.py:971: OSError\n[CI/Tests ]   | ________________________________ test_flush_all ________________________________\n[CI/Tests ]   | \n[CI/Tests ]   | mcache = <aiomcache.client.Client object at 0x7f8a7ebd31d0>\n[CI/Tests ]   | \n[CI/Tests ]   |     async def test_flush_all(mcache: Client) -> None:\n[CI/Tests ]   |         key, value = b'key:flush_all', b'flush_all_value'\n[CI/Tests ]   | >       await mcache.set(key, value)\n[CI/Tests ]   | \n[CI/Tests ]   | key        = b'key:flush_all'\n[CI/Tests ]   | mcache     = <aiomcache.client.Client object at 0x7f8a7ebd31d0>\n[CI/Tests ]   | value      = b'flush_all_value'\n[CI/Tests ]   | \n[CI/Tests ]   | tests/commands_test.py:66: \n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | aiomcache/client.py:40: in wrapper\n[CI/Tests ]   |     conn = await self._pool.acquire()\n[CI/Tests ]   |         args       = (b'key:flush_all', b'flush_all_value')\n[CI/Tests ]   |         func       = <function FlagClient.set at 0x7f8a7edf9050>\n[CI/Tests ]   |         kwargs     = {}\n[CI/Tests ]   |         self       = <aiomcache.client.Client object at 0x7f8a7ebd31d0>\n[CI/Tests ]   | aiomcache/pool.py:40: in acquire\n[CI/Tests ]   |     _conn = await self._create_new_conn()\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ebd3610>\n[CI/Tests ]   | aiomcache/pool.py:71: in _create_new_conn\n[CI/Tests ]   |     self._host, self._port, **self.conn_args)\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ebd3610>\n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/streams.py:77: in open_connection\n[CI/Tests ]   |     lambda: protocol, host, port, **kwds)\n[CI/Tests ]   |         host       = 'localhost'\n[CI/Tests ]   |         kwds       = {}\n[CI/Tests ]   |         limit      = 65536\n[CI/Tests ]   |         loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   |         port       = 11211\n[CI/Tests ]   |         protocol   = <asyncio.streams.StreamReaderProtocol object at 0x7f8a7ebd3890>\n[CI/Tests ]   |         reader     = <StreamReader>\n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | \n[CI/Tests ]   | self = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ed28320>\n[CI/Tests ]   | host = 'localhost', port = 11211\n[CI/Tests ]   | \n[CI/Tests ]   |     async def create_connection(\n[CI/Tests ]   |             self, protocol_factory, host=None, port=None,\n[CI/Tests ]   |             *, ssl=None, family=0,\n[CI/Tests ]   |             proto=0, flags=0, sock=None,\n[CI/Tests ]   |             local_addr=None, server_hostname=None,\n[CI/Tests ]   |             ssl_handshake_timeout=None):\n[CI/Tests ]   |         \"\"\"Connect to a TCP server.\n[CI/Tests ]   |     \n[CI/Tests ]   |         Create a streaming transport connection to a given Internet host and\n[CI/Tests ]   |         port: socket family AF_INET or socket.AF_INET6 depending on host (or\n[CI/Tests ]   |         family if specified), socket type SOCK_STREAM. protocol_factory must be\n[CI/Tests ]   |         a callable returning a protocol instance.\n[CI/Tests ]   |     \n[CI/Tests ]   |         This method is a coroutine which will try to establish the connection\n[CI/Tests ]   |         in the background.  When successful, the coroutine returns a\n[CI/Tests ]   |         (transport, protocol) pair.\n[CI/Tests ]   |         \"\"\"\n[CI/Tests ]   |         if server_hostname is not None and not ssl:\n[CI/Tests ]   |             raise ValueError('server_hostname is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if server_hostname is None and ssl:\n[CI/Tests ]   |             # Use host as default for server_hostname.  It is an error\n[CI/Tests ]   |             # if host is empty or not set, e.g. when an\n[CI/Tests ]   |             # already-connected socket was passed or when only a port\n[CI/Tests ]   |             # is given.  To avoid this error, you can pass\n[CI/Tests ]   |             # server_hostname='' -- this will bypass the hostname\n[CI/Tests ]   |             # check.  (This also means that if host is a numeric\n[CI/Tests ]   |             # IP/IPv6 address, we will attempt to verify that exact\n[CI/Tests ]   |             # address; this will probably fail, but it is possible to\n[CI/Tests ]   |             # create a certificate for a specific IP address, so we\n[CI/Tests ]   |             # don't judge it here.)\n[CI/Tests ]   |             if not host:\n[CI/Tests ]   |                 raise ValueError('You must set server_hostname '\n[CI/Tests ]   |                                  'when using ssl without a host')\n[CI/Tests ]   |             server_hostname = host\n[CI/Tests ]   |     \n[CI/Tests ]   |         if ssl_handshake_timeout is not None and not ssl:\n[CI/Tests ]   |             raise ValueError(\n[CI/Tests ]   |                 'ssl_handshake_timeout is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if host is not None or port is not None:\n[CI/Tests ]   |             if sock is not None:\n[CI/Tests ]   |                 raise ValueError(\n[CI/Tests ]   |                     'host/port and sock can not be specified at the same time')\n[CI/Tests ]   |     \n[CI/Tests ]   |             infos = await self._ensure_resolved(\n[CI/Tests ]   |                 (host, port), family=family,\n[CI/Tests ]   |                 type=socket.SOCK_STREAM, proto=proto, flags=flags, loop=self)\n[CI/Tests ]   |             if not infos:\n[CI/Tests ]   |                 raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             if local_addr is not None:\n[CI/Tests ]   |                 laddr_infos = await self._ensure_resolved(\n[CI/Tests ]   |                     local_addr, family=family,\n[CI/Tests ]   |                     type=socket.SOCK_STREAM, proto=proto,\n[CI/Tests ]   |                     flags=flags, loop=self)\n[CI/Tests ]   |                 if not laddr_infos:\n[CI/Tests ]   |                     raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             exceptions = []\n[CI/Tests ]   |             for family, type, proto, cname, address in infos:\n[CI/Tests ]   |                 try:\n[CI/Tests ]   |                     sock = socket.socket(family=family, type=type, proto=proto)\n[CI/Tests ]   |                     sock.setblocking(False)\n[CI/Tests ]   |                     if local_addr is not None:\n[CI/Tests ]   |                         for _, _, _, _, laddr in laddr_infos:\n[CI/Tests ]   |                             try:\n[CI/Tests ]   |                                 sock.bind(laddr)\n[CI/Tests ]   |                                 break\n[CI/Tests ]   |                             except OSError as exc:\n[CI/Tests ]   |                                 msg = (\n[CI/Tests ]   |                                     f'error while attempting to bind on '\n[CI/Tests ]   |                                     f'address {laddr!r}: '\n[CI/Tests ]   |                                     f'{exc.strerror.lower()}'\n[CI/Tests ]   |                                 )\n[CI/Tests ]   |                                 exc = OSError(exc.errno, msg)\n[CI/Tests ]   |                                 exceptions.append(exc)\n[CI/Tests ]   |                         else:\n[CI/Tests ]   |                             sock.close()\n[CI/Tests ]   |                             sock = None\n[CI/Tests ]   |                             continue\n[CI/Tests ]   |                     if self._debug:\n[CI/Tests ]   |                         logger.debug(\"connect %r to %r\", sock, address)\n[CI/Tests ]   |                     await self.sock_connect(sock, address)\n[CI/Tests ]   |                 except OSError as exc:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     exceptions.append(exc)\n[CI/Tests ]   |                 except:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     raise\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     break\n[CI/Tests ]   |             else:\n[CI/Tests ]   |                 if len(exceptions) == 1:\n[CI/Tests ]   |                     raise exceptions[0]\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     # If they all have the same str(), raise one.\n[CI/Tests ]   |                     model = str(exceptions[0])\n[CI/Tests ]   |                     if all(str(exc) == model for exc in exceptions):\n[CI/Tests ]   |                         raise exceptions[0]\n[CI/Tests ]   |                     # Raise a combined exception so the user can see all\n[CI/Tests ]   |                     # the various error messages.\n[CI/Tests ]   |                     raise OSError('Multiple exceptions: {}'.format(\n[CI/Tests ]   | >                       ', '.join(str(exc) for exc in exceptions)))\n[CI/Tests ]   | E                   OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | \n[CI/Tests ]   | address    = ('::1', 11211, 0, 0)\n[CI/Tests ]   | cname      = ''\n[CI/Tests ]   | exceptions = [ConnectionRefusedError(111, \"Connect call failed ('127.0.0.1', 11211)\"), OSError(99, 'Cannot assign requested address')]\n[CI/Tests ]   | family     = <AddressFamily.AF_INET6: 10>\n[CI/Tests ]   | flags      = 0\n[CI/Tests ]   | host       = 'localhost'\n[CI/Tests ]   | infos      = [(<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('127.0.0.1', 11211)), (<AddressFamily.AF_INET6: 10>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('::1', 11211, 0, 0))]\n[CI/Tests ]   | local_addr = None\n[CI/Tests ]   | model      = \"[Errno 111] Connect call failed ('127.0.0.1', 11211)\"\n[CI/Tests ]   | port       = 11211\n[CI/Tests ]   | proto      = 6\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ed28320>\n[CI/Tests ]   | self       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | server_hostname = None\n[CI/Tests ]   | sock       = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6>\n[CI/Tests ]   | ssl        = None\n[CI/Tests ]   | ssl_handshake_timeout = None\n[CI/Tests ]   | type       = <SocketKind.SOCK_STREAM: 1>\n[CI/Tests ]   | \n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/base_events.py:971: OSError\n[CI/Tests ]   | _________________________________ test_set_get _________________________________\n[CI/Tests ]   | \n[CI/Tests ]   | mcache = <aiomcache.client.Client object at 0x7f8a7ebd3510>\n[CI/Tests ]   | \n[CI/Tests ]   |     async def test_set_get(mcache: Client) -> None:\n[CI/Tests ]   |         key, value = b'key:set', b'1'\n[CI/Tests ]   | >       await mcache.set(key, value)\n[CI/Tests ]   | \n[CI/Tests ]   | key        = b'key:set'\n[CI/Tests ]   | mcache     = <aiomcache.client.Client object at 0x7f8a7ebd3510>\n[CI/Tests ]   | value      = b'1'\n[CI/Tests ]   | \n[CI/Tests ]   | tests/commands_test.py:86: \n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | aiomcache/client.py:40: in wrapper\n[CI/Tests ]   |     conn = await self._pool.acquire()\n[CI/Tests ]   |         args       = (b'key:set', b'1')\n[CI/Tests ]   |         func       = <function FlagClient.set at 0x7f8a7edf9050>\n[CI/Tests ]   |         kwargs     = {}\n[CI/Tests ]   |         self       = <aiomcache.client.Client object at 0x7f8a7ebd3510>\n[CI/Tests ]   | aiomcache/pool.py:40: in acquire\n[CI/Tests ]   |     _conn = await self._create_new_conn()\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ebd3550>\n[CI/Tests ]   | aiomcache/pool.py:71: in _create_new_conn\n[CI/Tests ]   |     self._host, self._port, **self.conn_args)\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ebd3550>\n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/streams.py:77: in open_connection\n[CI/Tests ]   |     lambda: protocol, host, port, **kwds)\n[CI/Tests ]   |         host       = 'localhost'\n[CI/Tests ]   |         kwds       = {}\n[CI/Tests ]   |         limit      = 65536\n[CI/Tests ]   |         loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   |         port       = 11211\n[CI/Tests ]   |         protocol   = <asyncio.streams.StreamReaderProtocol object at 0x7f8a7ec11390>\n[CI/Tests ]   |         reader     = <StreamReader>\n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | \n[CI/Tests ]   | self = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ed28170>\n[CI/Tests ]   | host = 'localhost', port = 11211\n[CI/Tests ]   | \n[CI/Tests ]   |     async def create_connection(\n[CI/Tests ]   |             self, protocol_factory, host=None, port=None,\n[CI/Tests ]   |             *, ssl=None, family=0,\n[CI/Tests ]   |             proto=0, flags=0, sock=None,\n[CI/Tests ]   |             local_addr=None, server_hostname=None,\n[CI/Tests ]   |             ssl_handshake_timeout=None):\n[CI/Tests ]   |         \"\"\"Connect to a TCP server.\n[CI/Tests ]   |     \n[CI/Tests ]   |         Create a streaming transport connection to a given Internet host and\n[CI/Tests ]   |         port: socket family AF_INET or socket.AF_INET6 depending on host (or\n[CI/Tests ]   |         family if specified), socket type SOCK_STREAM. protocol_factory must be\n[CI/Tests ]   |         a callable returning a protocol instance.\n[CI/Tests ]   |     \n[CI/Tests ]   |         This method is a coroutine which will try to establish the connection\n[CI/Tests ]   |         in the background.  When successful, the coroutine returns a\n[CI/Tests ]   |         (transport, protocol) pair.\n[CI/Tests ]   |         \"\"\"\n[CI/Tests ]   |         if server_hostname is not None and not ssl:\n[CI/Tests ]   |             raise ValueError('server_hostname is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if server_hostname is None and ssl:\n[CI/Tests ]   |             # Use host as default for server_hostname.  It is an error\n[CI/Tests ]   |             # if host is empty or not set, e.g. when an\n[CI/Tests ]   |             # already-connected socket was passed or when only a port\n[CI/Tests ]   |             # is given.  To avoid this error, you can pass\n[CI/Tests ]   |             # server_hostname='' -- this will bypass the hostname\n[CI/Tests ]   |             # check.  (This also means that if host is a numeric\n[CI/Tests ]   |             # IP/IPv6 address, we will attempt to verify that exact\n[CI/Tests ]   |             # address; this will probably fail, but it is possible to\n[CI/Tests ]   |             # create a certificate for a specific IP address, so we\n[CI/Tests ]   |             # don't judge it here.)\n[CI/Tests ]   |             if not host:\n[CI/Tests ]   |                 raise ValueError('You must set server_hostname '\n[CI/Tests ]   |                                  'when using ssl without a host')\n[CI/Tests ]   |             server_hostname = host\n[CI/Tests ]   |     \n[CI/Tests ]   |         if ssl_handshake_timeout is not None and not ssl:\n[CI/Tests ]   |             raise ValueError(\n[CI/Tests ]   |                 'ssl_handshake_timeout is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if host is not None or port is not None:\n[CI/Tests ]   |             if sock is not None:\n[CI/Tests ]   |                 raise ValueError(\n[CI/Tests ]   |                     'host/port and sock can not be specified at the same time')\n[CI/Tests ]   |     \n[CI/Tests ]   |             infos = await self._ensure_resolved(\n[CI/Tests ]   |                 (host, port), family=family,\n[CI/Tests ]   |                 type=socket.SOCK_STREAM, proto=proto, flags=flags, loop=self)\n[CI/Tests ]   |             if not infos:\n[CI/Tests ]   |                 raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             if local_addr is not None:\n[CI/Tests ]   |                 laddr_infos = await self._ensure_resolved(\n[CI/Tests ]   |                     local_addr, family=family,\n[CI/Tests ]   |                     type=socket.SOCK_STREAM, proto=proto,\n[CI/Tests ]   |                     flags=flags, loop=self)\n[CI/Tests ]   |                 if not laddr_infos:\n[CI/Tests ]   |                     raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             exceptions = []\n[CI/Tests ]   |             for family, type, proto, cname, address in infos:\n[CI/Tests ]   |                 try:\n[CI/Tests ]   |                     sock = socket.socket(family=family, type=type, proto=proto)\n[CI/Tests ]   |                     sock.setblocking(False)\n[CI/Tests ]   |                     if local_addr is not None:\n[CI/Tests ]   |                         for _, _, _, _, laddr in laddr_infos:\n[CI/Tests ]   |                             try:\n[CI/Tests ]   |                                 sock.bind(laddr)\n[CI/Tests ]   |                                 break\n[CI/Tests ]   |                             except OSError as exc:\n[CI/Tests ]   |                                 msg = (\n[CI/Tests ]   |                                     f'error while attempting to bind on '\n[CI/Tests ]   |                                     f'address {laddr!r}: '\n[CI/Tests ]   |                                     f'{exc.strerror.lower()}'\n[CI/Tests ]   |                                 )\n[CI/Tests ]   |                                 exc = OSError(exc.errno, msg)\n[CI/Tests ]   |                                 exceptions.append(exc)\n[CI/Tests ]   |                         else:\n[CI/Tests ]   |                             sock.close()\n[CI/Tests ]   |                             sock = None\n[CI/Tests ]   |                             continue\n[CI/Tests ]   |                     if self._debug:\n[CI/Tests ]   |                         logger.debug(\"connect %r to %r\", sock, address)\n[CI/Tests ]   |                     await self.sock_connect(sock, address)\n[CI/Tests ]   |                 except OSError as exc:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     exceptions.append(exc)\n[CI/Tests ]   |                 except:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     raise\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     break\n[CI/Tests ]   |             else:\n[CI/Tests ]   |                 if len(exceptions) == 1:\n[CI/Tests ]   |                     raise exceptions[0]\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     # If they all have the same str(), raise one.\n[CI/Tests ]   |                     model = str(exceptions[0])\n[CI/Tests ]   |                     if all(str(exc) == model for exc in exceptions):\n[CI/Tests ]   |                         raise exceptions[0]\n[CI/Tests ]   |                     # Raise a combined exception so the user can see all\n[CI/Tests ]   |                     # the various error messages.\n[CI/Tests ]   |                     raise OSError('Multiple exceptions: {}'.format(\n[CI/Tests ]   | >                       ', '.join(str(exc) for exc in exceptions)))\n[CI/Tests ]   | E                   OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | \n[CI/Tests ]   | address    = ('::1', 11211, 0, 0)\n[CI/Tests ]   | cname      = ''\n[CI/Tests ]   | exceptions = [ConnectionRefusedError(111, \"Connect call failed ('127.0.0.1', 11211)\"), OSError(99, 'Cannot assign requested address')]\n[CI/Tests ]   | family     = <AddressFamily.AF_INET6: 10>\n[CI/Tests ]   | flags      = 0\n[CI/Tests ]   | host       = 'localhost'\n[CI/Tests ]   | infos      = [(<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('127.0.0.1', 11211)), (<AddressFamily.AF_INET6: 10>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('::1', 11211, 0, 0))]\n[CI/Tests ]   | local_addr = None\n[CI/Tests ]   | model      = \"[Errno 111] Connect call failed ('127.0.0.1', 11211)\"\n[CI/Tests ]   | port       = 11211\n[CI/Tests ]   | proto      = 6\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ed28170>\n[CI/Tests ]   | self       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | server_hostname = None\n[CI/Tests ]   | sock       = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6>\n[CI/Tests ]   | ssl        = None\n[CI/Tests ]   | ssl_handshake_timeout = None\n[CI/Tests ]   | type       = <SocketKind.SOCK_STREAM: 1>\n[CI/Tests ]   | \n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/base_events.py:971: OSError\n[CI/Tests ]   | __________________________________ test_gets ___________________________________\n[CI/Tests ]   | \n[CI/Tests ]   | mcache = <aiomcache.client.Client object at 0x7f8a7eb966d0>\n[CI/Tests ]   | \n[CI/Tests ]   |     async def test_gets(mcache: Client) -> None:\n[CI/Tests ]   |         key, value = b'key:set', b'1'\n[CI/Tests ]   | >       await mcache.set(key, value)\n[CI/Tests ]   | \n[CI/Tests ]   | key        = b'key:set'\n[CI/Tests ]   | mcache     = <aiomcache.client.Client object at 0x7f8a7eb966d0>\n[CI/Tests ]   | value      = b'1'\n[CI/Tests ]   | \n[CI/Tests ]   | tests/commands_test.py:104: \n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | aiomcache/client.py:40: in wrapper\n[CI/Tests ]   |     conn = await self._pool.acquire()\n[CI/Tests ]   |         args       = (b'key:set', b'1')\n[CI/Tests ]   |         func       = <function FlagClient.set at 0x7f8a7edf9050>\n[CI/Tests ]   |         kwargs     = {}\n[CI/Tests ]   |         self       = <aiomcache.client.Client object at 0x7f8a7eb966d0>\n[CI/Tests ]   | aiomcache/pool.py:40: in acquire\n[CI/Tests ]   |     _conn = await self._create_new_conn()\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7eb96750>\n[CI/Tests ]   | aiomcache/pool.py:71: in _create_new_conn\n[CI/Tests ]   |     self._host, self._port, **self.conn_args)\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7eb96750>\n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/streams.py:77: in open_connection\n[CI/Tests ]   |     lambda: protocol, host, port, **kwds)\n[CI/Tests ]   |         host       = 'localhost'\n[CI/Tests ]   |         kwds       = {}\n[CI/Tests ]   |         limit      = 65536\n[CI/Tests ]   |         loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   |         port       = 11211\n[CI/Tests ]   |         protocol   = <asyncio.streams.StreamReaderProtocol object at 0x7f8a7eb969d0>\n[CI/Tests ]   |         reader     = <StreamReader>\n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | \n[CI/Tests ]   | self = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ed28dd0>\n[CI/Tests ]   | host = 'localhost', port = 11211\n[CI/Tests ]   | \n[CI/Tests ]   |     async def create_connection(\n[CI/Tests ]   |             self, protocol_factory, host=None, port=None,\n[CI/Tests ]   |             *, ssl=None, family=0,\n[CI/Tests ]   |             proto=0, flags=0, sock=None,\n[CI/Tests ]   |             local_addr=None, server_hostname=None,\n[CI/Tests ]   |             ssl_handshake_timeout=None):\n[CI/Tests ]   |         \"\"\"Connect to a TCP server.\n[CI/Tests ]   |     \n[CI/Tests ]   |         Create a streaming transport connection to a given Internet host and\n[CI/Tests ]   |         port: socket family AF_INET or socket.AF_INET6 depending on host (or\n[CI/Tests ]   |         family if specified), socket type SOCK_STREAM. protocol_factory must be\n[CI/Tests ]   |         a callable returning a protocol instance.\n[CI/Tests ]   |     \n[CI/Tests ]   |         This method is a coroutine which will try to establish the connection\n[CI/Tests ]   |         in the background.  When successful, the coroutine returns a\n[CI/Tests ]   |         (transport, protocol) pair.\n[CI/Tests ]   |         \"\"\"\n[CI/Tests ]   |         if server_hostname is not None and not ssl:\n[CI/Tests ]   |             raise ValueError('server_hostname is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if server_hostname is None and ssl:\n[CI/Tests ]   |             # Use host as default for server_hostname.  It is an error\n[CI/Tests ]   |             # if host is empty or not set, e.g. when an\n[CI/Tests ]   |             # already-connected socket was passed or when only a port\n[CI/Tests ]   |             # is given.  To avoid this error, you can pass\n[CI/Tests ]   |             # server_hostname='' -- this will bypass the hostname\n[CI/Tests ]   |             # check.  (This also means that if host is a numeric\n[CI/Tests ]   |             # IP/IPv6 address, we will attempt to verify that exact\n[CI/Tests ]   |             # address; this will probably fail, but it is possible to\n[CI/Tests ]   |             # create a certificate for a specific IP address, so we\n[CI/Tests ]   |             # don't judge it here.)\n[CI/Tests ]   |             if not host:\n[CI/Tests ]   |                 raise ValueError('You must set server_hostname '\n[CI/Tests ]   |                                  'when using ssl without a host')\n[CI/Tests ]   |             server_hostname = host\n[CI/Tests ]   |     \n[CI/Tests ]   |         if ssl_handshake_timeout is not None and not ssl:\n[CI/Tests ]   |             raise ValueError(\n[CI/Tests ]   |                 'ssl_handshake_timeout is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if host is not None or port is not None:\n[CI/Tests ]   |             if sock is not None:\n[CI/Tests ]   |                 raise ValueError(\n[CI/Tests ]   |                     'host/port and sock can not be specified at the same time')\n[CI/Tests ]   |     \n[CI/Tests ]   |             infos = await self._ensure_resolved(\n[CI/Tests ]   |                 (host, port), family=family,\n[CI/Tests ]   |                 type=socket.SOCK_STREAM, proto=proto, flags=flags, loop=self)\n[CI/Tests ]   |             if not infos:\n[CI/Tests ]   |                 raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             if local_addr is not None:\n[CI/Tests ]   |                 laddr_infos = await self._ensure_resolved(\n[CI/Tests ]   |                     local_addr, family=family,\n[CI/Tests ]   |                     type=socket.SOCK_STREAM, proto=proto,\n[CI/Tests ]   |                     flags=flags, loop=self)\n[CI/Tests ]   |                 if not laddr_infos:\n[CI/Tests ]   |                     raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             exceptions = []\n[CI/Tests ]   |             for family, type, proto, cname, address in infos:\n[CI/Tests ]   |                 try:\n[CI/Tests ]   |                     sock = socket.socket(family=family, type=type, proto=proto)\n[CI/Tests ]   |                     sock.setblocking(False)\n[CI/Tests ]   |                     if local_addr is not None:\n[CI/Tests ]   |                         for _, _, _, _, laddr in laddr_infos:\n[CI/Tests ]   |                             try:\n[CI/Tests ]   |                                 sock.bind(laddr)\n[CI/Tests ]   |                                 break\n[CI/Tests ]   |                             except OSError as exc:\n[CI/Tests ]   |                                 msg = (\n[CI/Tests ]   |                                     f'error while attempting to bind on '\n[CI/Tests ]   |                                     f'address {laddr!r}: '\n[CI/Tests ]   |                                     f'{exc.strerror.lower()}'\n[CI/Tests ]   |                                 )\n[CI/Tests ]   |                                 exc = OSError(exc.errno, msg)\n[CI/Tests ]   |                                 exceptions.append(exc)\n[CI/Tests ]   |                         else:\n[CI/Tests ]   |                             sock.close()\n[CI/Tests ]   |                             sock = None\n[CI/Tests ]   |                             continue\n[CI/Tests ]   |                     if self._debug:\n[CI/Tests ]   |                         logger.debug(\"connect %r to %r\", sock, address)\n[CI/Tests ]   |                     await self.sock_connect(sock, address)\n[CI/Tests ]   |                 except OSError as exc:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     exceptions.append(exc)\n[CI/Tests ]   |                 except:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     raise\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     break\n[CI/Tests ]   |             else:\n[CI/Tests ]   |                 if len(exceptions) == 1:\n[CI/Tests ]   |                     raise exceptions[0]\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     # If they all have the same str(), raise one.\n[CI/Tests ]   |                     model = str(exceptions[0])\n[CI/Tests ]   |                     if all(str(exc) == model for exc in exceptions):\n[CI/Tests ]   |                         raise exceptions[0]\n[CI/Tests ]   |                     # Raise a combined exception so the user can see all\n[CI/Tests ]   |                     # the various error messages.\n[CI/Tests ]   |                     raise OSError('Multiple exceptions: {}'.format(\n[CI/Tests ]   | >                       ', '.join(str(exc) for exc in exceptions)))\n[CI/Tests ]   | E                   OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | \n[CI/Tests ]   | address    = ('::1', 11211, 0, 0)\n[CI/Tests ]   | cname      = ''\n[CI/Tests ]   | exceptions = [ConnectionRefusedError(111, \"Connect call failed ('127.0.0.1', 11211)\"), OSError(99, 'Cannot assign requested address')]\n[CI/Tests ]   | family     = <AddressFamily.AF_INET6: 10>\n[CI/Tests ]   | flags      = 0\n[CI/Tests ]   | host       = 'localhost'\n[CI/Tests ]   | infos      = [(<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('127.0.0.1', 11211)), (<AddressFamily.AF_INET6: 10>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('::1', 11211, 0, 0))]\n[CI/Tests ]   | local_addr = None\n[CI/Tests ]   | model      = \"[Errno 111] Connect call failed ('127.0.0.1', 11211)\"\n[CI/Tests ]   | port       = 11211\n[CI/Tests ]   | proto      = 6\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ed28dd0>\n[CI/Tests ]   | self       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | server_hostname = None\n[CI/Tests ]   | sock       = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6>\n[CI/Tests ]   | ssl        = None\n[CI/Tests ]   | ssl_handshake_timeout = None\n[CI/Tests ]   | type       = <SocketKind.SOCK_STREAM: 1>\n[CI/Tests ]   | \n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/base_events.py:971: OSError\n[CI/Tests ]   | ________________________________ test_multi_get ________________________________\n[CI/Tests ]   | \n[CI/Tests ]   | mcache = <aiomcache.client.Client object at 0x7f8a7ef2c950>\n[CI/Tests ]   | \n[CI/Tests ]   |     async def test_multi_get(mcache: Client) -> None:\n[CI/Tests ]   |         key1, value1 = b'key:multi_get:1', b'1'\n[CI/Tests ]   |         key2, value2 = b'key:multi_get:2', b'2'\n[CI/Tests ]   | >       await mcache.set(key1, value1)\n[CI/Tests ]   | \n[CI/Tests ]   | key1       = b'key:multi_get:1'\n[CI/Tests ]   | key2       = b'key:multi_get:2'\n[CI/Tests ]   | mcache     = <aiomcache.client.Client object at 0x7f8a7ef2c950>\n[CI/Tests ]   | value1     = b'1'\n[CI/Tests ]   | value2     = b'2'\n[CI/Tests ]   | \n[CI/Tests ]   | tests/commands_test.py:122: \n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | aiomcache/client.py:40: in wrapper\n[CI/Tests ]   |     conn = await self._pool.acquire()\n[CI/Tests ]   |         args       = (b'key:multi_get:1', b'1')\n[CI/Tests ]   |         func       = <function FlagClient.set at 0x7f8a7edf9050>\n[CI/Tests ]   |         kwargs     = {}\n[CI/Tests ]   |         self       = <aiomcache.client.Client object at 0x7f8a7ef2c950>\n[CI/Tests ]   | aiomcache/pool.py:40: in acquire\n[CI/Tests ]   |     _conn = await self._create_new_conn()\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ef2cf10>\n[CI/Tests ]   | aiomcache/pool.py:71: in _create_new_conn\n[CI/Tests ]   |     self._host, self._port, **self.conn_args)\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ef2cf10>\n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/streams.py:77: in open_connection\n[CI/Tests ]   |     lambda: protocol, host, port, **kwds)\n[CI/Tests ]   |         host       = 'localhost'\n[CI/Tests ]   |         kwds       = {}\n[CI/Tests ]   |         limit      = 65536\n[CI/Tests ]   |         loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   |         port       = 11211\n[CI/Tests ]   |         protocol   = <asyncio.streams.StreamReaderProtocol object at 0x7f8a7ef2cf90>\n[CI/Tests ]   |         reader     = <StreamReader>\n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | \n[CI/Tests ]   | self = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ed305f0>\n[CI/Tests ]   | host = 'localhost', port = 11211\n[CI/Tests ]   | \n[CI/Tests ]   |     async def create_connection(\n[CI/Tests ]   |             self, protocol_factory, host=None, port=None,\n[CI/Tests ]   |             *, ssl=None, family=0,\n[CI/Tests ]   |             proto=0, flags=0, sock=None,\n[CI/Tests ]   |             local_addr=None, server_hostname=None,\n[CI/Tests ]   |             ssl_handshake_timeout=None):\n[CI/Tests ]   |         \"\"\"Connect to a TCP server.\n[CI/Tests ]   |     \n[CI/Tests ]   |         Create a streaming transport connection to a given Internet host and\n[CI/Tests ]   |         port: socket family AF_INET or socket.AF_INET6 depending on host (or\n[CI/Tests ]   |         family if specified), socket type SOCK_STREAM. protocol_factory must be\n[CI/Tests ]   |         a callable returning a protocol instance.\n[CI/Tests ]   |     \n[CI/Tests ]   |         This method is a coroutine which will try to establish the connection\n[CI/Tests ]   |         in the background.  When successful, the coroutine returns a\n[CI/Tests ]   |         (transport, protocol) pair.\n[CI/Tests ]   |         \"\"\"\n[CI/Tests ]   |         if server_hostname is not None and not ssl:\n[CI/Tests ]   |             raise ValueError('server_hostname is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if server_hostname is None and ssl:\n[CI/Tests ]   |             # Use host as default for server_hostname.  It is an error\n[CI/Tests ]   |             # if host is empty or not set, e.g. when an\n[CI/Tests ]   |             # already-connected socket was passed or when only a port\n[CI/Tests ]   |             # is given.  To avoid this error, you can pass\n[CI/Tests ]   |             # server_hostname='' -- this will bypass the hostname\n[CI/Tests ]   |             # check.  (This also means that if host is a numeric\n[CI/Tests ]   |             # IP/IPv6 address, we will attempt to verify that exact\n[CI/Tests ]   |             # address; this will probably fail, but it is possible to\n[CI/Tests ]   |             # create a certificate for a specific IP address, so we\n[CI/Tests ]   |             # don't judge it here.)\n[CI/Tests ]   |             if not host:\n[CI/Tests ]   |                 raise ValueError('You must set server_hostname '\n[CI/Tests ]   |                                  'when using ssl without a host')\n[CI/Tests ]   |             server_hostname = host\n[CI/Tests ]   |     \n[CI/Tests ]   |         if ssl_handshake_timeout is not None and not ssl:\n[CI/Tests ]   |             raise ValueError(\n[CI/Tests ]   |                 'ssl_handshake_timeout is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if host is not None or port is not None:\n[CI/Tests ]   |             if sock is not None:\n[CI/Tests ]   |                 raise ValueError(\n[CI/Tests ]   |                     'host/port and sock can not be specified at the same time')\n[CI/Tests ]   |     \n[CI/Tests ]   |             infos = await self._ensure_resolved(\n[CI/Tests ]   |                 (host, port), family=family,\n[CI/Tests ]   |                 type=socket.SOCK_STREAM, proto=proto, flags=flags, loop=self)\n[CI/Tests ]   |             if not infos:\n[CI/Tests ]   |                 raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             if local_addr is not None:\n[CI/Tests ]   |                 laddr_infos = await self._ensure_resolved(\n[CI/Tests ]   |                     local_addr, family=family,\n[CI/Tests ]   |                     type=socket.SOCK_STREAM, proto=proto,\n[CI/Tests ]   |                     flags=flags, loop=self)\n[CI/Tests ]   |                 if not laddr_infos:\n[CI/Tests ]   |                     raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             exceptions = []\n[CI/Tests ]   |             for family, type, proto, cname, address in infos:\n[CI/Tests ]   |                 try:\n[CI/Tests ]   |                     sock = socket.socket(family=family, type=type, proto=proto)\n[CI/Tests ]   |                     sock.setblocking(False)\n[CI/Tests ]   |                     if local_addr is not None:\n[CI/Tests ]   |                         for _, _, _, _, laddr in laddr_infos:\n[CI/Tests ]   |                             try:\n[CI/Tests ]   |                                 sock.bind(laddr)\n[CI/Tests ]   |                                 break\n[CI/Tests ]   |                             except OSError as exc:\n[CI/Tests ]   |                                 msg = (\n[CI/Tests ]   |                                     f'error while attempting to bind on '\n[CI/Tests ]   |                                     f'address {laddr!r}: '\n[CI/Tests ]   |                                     f'{exc.strerror.lower()}'\n[CI/Tests ]   |                                 )\n[CI/Tests ]   |                                 exc = OSError(exc.errno, msg)\n[CI/Tests ]   |                                 exceptions.append(exc)\n[CI/Tests ]   |                         else:\n[CI/Tests ]   |                             sock.close()\n[CI/Tests ]   |                             sock = None\n[CI/Tests ]   |                             continue\n[CI/Tests ]   |                     if self._debug:\n[CI/Tests ]   |                         logger.debug(\"connect %r to %r\", sock, address)\n[CI/Tests ]   |                     await self.sock_connect(sock, address)\n[CI/Tests ]   |                 except OSError as exc:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     exceptions.append(exc)\n[CI/Tests ]   |                 except:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     raise\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     break\n[CI/Tests ]   |             else:\n[CI/Tests ]   |                 if len(exceptions) == 1:\n[CI/Tests ]   |                     raise exceptions[0]\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     # If they all have the same str(), raise one.\n[CI/Tests ]   |                     model = str(exceptions[0])\n[CI/Tests ]   |                     if all(str(exc) == model for exc in exceptions):\n[CI/Tests ]   |                         raise exceptions[0]\n[CI/Tests ]   |                     # Raise a combined exception so the user can see all\n[CI/Tests ]   |                     # the various error messages.\n[CI/Tests ]   |                     raise OSError('Multiple exceptions: {}'.format(\n[CI/Tests ]   | >                       ', '.join(str(exc) for exc in exceptions)))\n[CI/Tests ]   | E                   OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | \n[CI/Tests ]   | address    = ('::1', 11211, 0, 0)\n[CI/Tests ]   | cname      = ''\n[CI/Tests ]   | exceptions = [ConnectionRefusedError(111, \"Connect call failed ('127.0.0.1', 11211)\"), OSError(99, 'Cannot assign requested address')]\n[CI/Tests ]   | family     = <AddressFamily.AF_INET6: 10>\n[CI/Tests ]   | flags      = 0\n[CI/Tests ]   | host       = 'localhost'\n[CI/Tests ]   | infos      = [(<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('127.0.0.1', 11211)), (<AddressFamily.AF_INET6: 10>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('::1', 11211, 0, 0))]\n[CI/Tests ]   | local_addr = None\n[CI/Tests ]   | model      = \"[Errno 111] Connect call failed ('127.0.0.1', 11211)\"\n[CI/Tests ]   | port       = 11211\n[CI/Tests ]   | proto      = 6\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ed305f0>\n[CI/Tests ]   | self       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | server_hostname = None\n[CI/Tests ]   | sock       = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6>\n[CI/Tests ]   | ssl        = None\n[CI/Tests ]   | ssl_handshake_timeout = None\n[CI/Tests ]   | type       = <SocketKind.SOCK_STREAM: 1>\n[CI/Tests ]   | \n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/base_events.py:971: OSError\n[CI/Tests ]   | _________________________ test_multi_get_doubling_keys _________________________\n[CI/Tests ]   | \n[CI/Tests ]   | mcache = <aiomcache.client.Client object at 0x7f8a7ec5ea10>\n[CI/Tests ]   | \n[CI/Tests ]   |     async def test_multi_get_doubling_keys(mcache: Client) -> None:\n[CI/Tests ]   |         key, value = b'key:multi_get:3', b'1'\n[CI/Tests ]   | >       await mcache.set(key, value)\n[CI/Tests ]   | \n[CI/Tests ]   | key        = b'key:multi_get:3'\n[CI/Tests ]   | mcache     = <aiomcache.client.Client object at 0x7f8a7ec5ea10>\n[CI/Tests ]   | value      = b'1'\n[CI/Tests ]   | \n[CI/Tests ]   | tests/commands_test.py:135: \n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | aiomcache/client.py:40: in wrapper\n[CI/Tests ]   |     conn = await self._pool.acquire()\n[CI/Tests ]   |         args       = (b'key:multi_get:3', b'1')\n[CI/Tests ]   |         func       = <function FlagClient.set at 0x7f8a7edf9050>\n[CI/Tests ]   |         kwargs     = {}\n[CI/Tests ]   |         self       = <aiomcache.client.Client object at 0x7f8a7ec5ea10>\n[CI/Tests ]   | aiomcache/pool.py:40: in acquire\n[CI/Tests ]   |     _conn = await self._create_new_conn()\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ec5ecd0>\n[CI/Tests ]   | aiomcache/pool.py:71: in _create_new_conn\n[CI/Tests ]   |     self._host, self._port, **self.conn_args)\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ec5ecd0>\n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/streams.py:77: in open_connection\n[CI/Tests ]   |     lambda: protocol, host, port, **kwds)\n[CI/Tests ]   |         host       = 'localhost'\n[CI/Tests ]   |         kwds       = {}\n[CI/Tests ]   |         limit      = 65536\n[CI/Tests ]   |         loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   |         port       = 11211\n[CI/Tests ]   |         protocol   = <asyncio.streams.StreamReaderProtocol object at 0x7f8a7ec5e3d0>\n[CI/Tests ]   |         reader     = <StreamReader>\n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | \n[CI/Tests ]   | self = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ed30dd0>\n[CI/Tests ]   | host = 'localhost', port = 11211\n[CI/Tests ]   | \n[CI/Tests ]   |     async def create_connection(\n[CI/Tests ]   |             self, protocol_factory, host=None, port=None,\n[CI/Tests ]   |             *, ssl=None, family=0,\n[CI/Tests ]   |             proto=0, flags=0, sock=None,\n[CI/Tests ]   |             local_addr=None, server_hostname=None,\n[CI/Tests ]   |             ssl_handshake_timeout=None):\n[CI/Tests ]   |         \"\"\"Connect to a TCP server.\n[CI/Tests ]   |     \n[CI/Tests ]   |         Create a streaming transport connection to a given Internet host and\n[CI/Tests ]   |         port: socket family AF_INET or socket.AF_INET6 depending on host (or\n[CI/Tests ]   |         family if specified), socket type SOCK_STREAM. protocol_factory must be\n[CI/Tests ]   |         a callable returning a protocol instance.\n[CI/Tests ]   |     \n[CI/Tests ]   |         This method is a coroutine which will try to establish the connection\n[CI/Tests ]   |         in the background.  When successful, the coroutine returns a\n[CI/Tests ]   |         (transport, protocol) pair.\n[CI/Tests ]   |         \"\"\"\n[CI/Tests ]   |         if server_hostname is not None and not ssl:\n[CI/Tests ]   |             raise ValueError('server_hostname is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if server_hostname is None and ssl:\n[CI/Tests ]   |             # Use host as default for server_hostname.  It is an error\n[CI/Tests ]   |             # if host is empty or not set, e.g. when an\n[CI/Tests ]   |             # already-connected socket was passed or when only a port\n[CI/Tests ]   |             # is given.  To avoid this error, you can pass\n[CI/Tests ]   |             # server_hostname='' -- this will bypass the hostname\n[CI/Tests ]   |             # check.  (This also means that if host is a numeric\n[CI/Tests ]   |             # IP/IPv6 address, we will attempt to verify that exact\n[CI/Tests ]   |             # address; this will probably fail, but it is possible to\n[CI/Tests ]   |             # create a certificate for a specific IP address, so we\n[CI/Tests ]   |             # don't judge it here.)\n[CI/Tests ]   |             if not host:\n[CI/Tests ]   |                 raise ValueError('You must set server_hostname '\n[CI/Tests ]   |                                  'when using ssl without a host')\n[CI/Tests ]   |             server_hostname = host\n[CI/Tests ]   |     \n[CI/Tests ]   |         if ssl_handshake_timeout is not None and not ssl:\n[CI/Tests ]   |             raise ValueError(\n[CI/Tests ]   |                 'ssl_handshake_timeout is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if host is not None or port is not None:\n[CI/Tests ]   |             if sock is not None:\n[CI/Tests ]   |                 raise ValueError(\n[CI/Tests ]   |                     'host/port and sock can not be specified at the same time')\n[CI/Tests ]   |     \n[CI/Tests ]   |             infos = await self._ensure_resolved(\n[CI/Tests ]   |                 (host, port), family=family,\n[CI/Tests ]   |                 type=socket.SOCK_STREAM, proto=proto, flags=flags, loop=self)\n[CI/Tests ]   |             if not infos:\n[CI/Tests ]   |                 raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             if local_addr is not None:\n[CI/Tests ]   |                 laddr_infos = await self._ensure_resolved(\n[CI/Tests ]   |                     local_addr, family=family,\n[CI/Tests ]   |                     type=socket.SOCK_STREAM, proto=proto,\n[CI/Tests ]   |                     flags=flags, loop=self)\n[CI/Tests ]   |                 if not laddr_infos:\n[CI/Tests ]   |                     raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             exceptions = []\n[CI/Tests ]   |             for family, type, proto, cname, address in infos:\n[CI/Tests ]   |                 try:\n[CI/Tests ]   |                     sock = socket.socket(family=family, type=type, proto=proto)\n[CI/Tests ]   |                     sock.setblocking(False)\n[CI/Tests ]   |                     if local_addr is not None:\n[CI/Tests ]   |                         for _, _, _, _, laddr in laddr_infos:\n[CI/Tests ]   |                             try:\n[CI/Tests ]   |                                 sock.bind(laddr)\n[CI/Tests ]   |                                 break\n[CI/Tests ]   |                             except OSError as exc:\n[CI/Tests ]   |                                 msg = (\n[CI/Tests ]   |                                     f'error while attempting to bind on '\n[CI/Tests ]   |                                     f'address {laddr!r}: '\n[CI/Tests ]   |                                     f'{exc.strerror.lower()}'\n[CI/Tests ]   |                                 )\n[CI/Tests ]   |                                 exc = OSError(exc.errno, msg)\n[CI/Tests ]   |                                 exceptions.append(exc)\n[CI/Tests ]   |                         else:\n[CI/Tests ]   |                             sock.close()\n[CI/Tests ]   |                             sock = None\n[CI/Tests ]   |                             continue\n[CI/Tests ]   |                     if self._debug:\n[CI/Tests ]   |                         logger.debug(\"connect %r to %r\", sock, address)\n[CI/Tests ]   |                     await self.sock_connect(sock, address)\n[CI/Tests ]   |                 except OSError as exc:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     exceptions.append(exc)\n[CI/Tests ]   |                 except:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     raise\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     break\n[CI/Tests ]   |             else:\n[CI/Tests ]   |                 if len(exceptions) == 1:\n[CI/Tests ]   |                     raise exceptions[0]\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     # If they all have the same str(), raise one.\n[CI/Tests ]   |                     model = str(exceptions[0])\n[CI/Tests ]   |                     if all(str(exc) == model for exc in exceptions):\n[CI/Tests ]   |                         raise exceptions[0]\n[CI/Tests ]   |                     # Raise a combined exception so the user can see all\n[CI/Tests ]   |                     # the various error messages.\n[CI/Tests ]   |                     raise OSError('Multiple exceptions: {}'.format(\n[CI/Tests ]   | >                       ', '.join(str(exc) for exc in exceptions)))\n[CI/Tests ]   | E                   OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | \n[CI/Tests ]   | address    = ('::1', 11211, 0, 0)\n[CI/Tests ]   | cname      = ''\n[CI/Tests ]   | exceptions = [ConnectionRefusedError(111, \"Connect call failed ('127.0.0.1', 11211)\"), OSError(99, 'Cannot assign requested address')]\n[CI/Tests ]   | family     = <AddressFamily.AF_INET6: 10>\n[CI/Tests ]   | flags      = 0\n[CI/Tests ]   | host       = 'localhost'\n[CI/Tests ]   | infos      = [(<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('127.0.0.1', 11211)), (<AddressFamily.AF_INET6: 10>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('::1', 11211, 0, 0))]\n[CI/Tests ]   | local_addr = None\n[CI/Tests ]   | model      = \"[Errno 111] Connect call failed ('127.0.0.1', 11211)\"\n[CI/Tests ]   | port       = 11211\n[CI/Tests ]   | proto      = 6\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ed30dd0>\n[CI/Tests ]   | self       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | server_hostname = None\n[CI/Tests ]   | sock       = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6>\n[CI/Tests ]   | ssl        = None\n[CI/Tests ]   | ssl_handshake_timeout = None\n[CI/Tests ]   | type       = <SocketKind.SOCK_STREAM: 1>\n[CI/Tests ]   | \n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/base_events.py:971: OSError\n[CI/Tests ]   | _______________________________ test_set_expire ________________________________\n[CI/Tests ]   | \n[CI/Tests ]   | mcache = <aiomcache.client.Client object at 0x7f8a7eb99b90>\n[CI/Tests ]   | \n[CI/Tests ]   |     async def test_set_expire(mcache: Client) -> None:\n[CI/Tests ]   |         key, value = b'key:set', b'1'\n[CI/Tests ]   | >       await mcache.set(key, value, exptime=1)\n[CI/Tests ]   | \n[CI/Tests ]   | key        = b'key:set'\n[CI/Tests ]   | mcache     = <aiomcache.client.Client object at 0x7f8a7eb99b90>\n[CI/Tests ]   | value      = b'1'\n[CI/Tests ]   | \n[CI/Tests ]   | tests/commands_test.py:143: \n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | aiomcache/client.py:40: in wrapper\n[CI/Tests ]   |     conn = await self._pool.acquire()\n[CI/Tests ]   |         args       = (b'key:set', b'1')\n[CI/Tests ]   |         func       = <function FlagClient.set at 0x7f8a7edf9050>\n[CI/Tests ]   |         kwargs     = {'exptime': 1}\n[CI/Tests ]   |         self       = <aiomcache.client.Client object at 0x7f8a7eb99b90>\n[CI/Tests ]   | aiomcache/pool.py:40: in acquire\n[CI/Tests ]   |     _conn = await self._create_new_conn()\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7eb99c10>\n[CI/Tests ]   | aiomcache/pool.py:71: in _create_new_conn\n[CI/Tests ]   |     self._host, self._port, **self.conn_args)\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7eb99c10>\n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/streams.py:77: in open_connection\n[CI/Tests ]   |     lambda: protocol, host, port, **kwds)\n[CI/Tests ]   |         host       = 'localhost'\n[CI/Tests ]   |         kwds       = {}\n[CI/Tests ]   |         limit      = 65536\n[CI/Tests ]   |         loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   |         port       = 11211\n[CI/Tests ]   |         protocol   = <asyncio.streams.StreamReaderProtocol object at 0x7f8a7eb99ed0>\n[CI/Tests ]   |         reader     = <StreamReader>\n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | \n[CI/Tests ]   | self = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ed284d0>\n[CI/Tests ]   | host = 'localhost', port = 11211\n[CI/Tests ]   | \n[CI/Tests ]   |     async def create_connection(\n[CI/Tests ]   |             self, protocol_factory, host=None, port=None,\n[CI/Tests ]   |             *, ssl=None, family=0,\n[CI/Tests ]   |             proto=0, flags=0, sock=None,\n[CI/Tests ]   |             local_addr=None, server_hostname=None,\n[CI/Tests ]   |             ssl_handshake_timeout=None):\n[CI/Tests ]   |         \"\"\"Connect to a TCP server.\n[CI/Tests ]   |     \n[CI/Tests ]   |         Create a streaming transport connection to a given Internet host and\n[CI/Tests ]   |         port: socket family AF_INET or socket.AF_INET6 depending on host (or\n[CI/Tests ]   |         family if specified), socket type SOCK_STREAM. protocol_factory must be\n[CI/Tests ]   |         a callable returning a protocol instance.\n[CI/Tests ]   |     \n[CI/Tests ]   |         This method is a coroutine which will try to establish the connection\n[CI/Tests ]   |         in the background.  When successful, the coroutine returns a\n[CI/Tests ]   |         (transport, protocol) pair.\n[CI/Tests ]   |         \"\"\"\n[CI/Tests ]   |         if server_hostname is not None and not ssl:\n[CI/Tests ]   |             raise ValueError('server_hostname is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if server_hostname is None and ssl:\n[CI/Tests ]   |             # Use host as default for server_hostname.  It is an error\n[CI/Tests ]   |             # if host is empty or not set, e.g. when an\n[CI/Tests ]   |             # already-connected socket was passed or when only a port\n[CI/Tests ]   |             # is given.  To avoid this error, you can pass\n[CI/Tests ]   |             # server_hostname='' -- this will bypass the hostname\n[CI/Tests ]   |             # check.  (This also means that if host is a numeric\n[CI/Tests ]   |             # IP/IPv6 address, we will attempt to verify that exact\n[CI/Tests ]   |             # address; this will probably fail, but it is possible to\n[CI/Tests ]   |             # create a certificate for a specific IP address, so we\n[CI/Tests ]   |             # don't judge it here.)\n[CI/Tests ]   |             if not host:\n[CI/Tests ]   |                 raise ValueError('You must set server_hostname '\n[CI/Tests ]   |                                  'when using ssl without a host')\n[CI/Tests ]   |             server_hostname = host\n[CI/Tests ]   |     \n[CI/Tests ]   |         if ssl_handshake_timeout is not None and not ssl:\n[CI/Tests ]   |             raise ValueError(\n[CI/Tests ]   |                 'ssl_handshake_timeout is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if host is not None or port is not None:\n[CI/Tests ]   |             if sock is not None:\n[CI/Tests ]   |                 raise ValueError(\n[CI/Tests ]   |                     'host/port and sock can not be specified at the same time')\n[CI/Tests ]   |     \n[CI/Tests ]   |             infos = await self._ensure_resolved(\n[CI/Tests ]   |                 (host, port), family=family,\n[CI/Tests ]   |                 type=socket.SOCK_STREAM, proto=proto, flags=flags, loop=self)\n[CI/Tests ]   |             if not infos:\n[CI/Tests ]   |                 raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             if local_addr is not None:\n[CI/Tests ]   |                 laddr_infos = await self._ensure_resolved(\n[CI/Tests ]   |                     local_addr, family=family,\n[CI/Tests ]   |                     type=socket.SOCK_STREAM, proto=proto,\n[CI/Tests ]   |                     flags=flags, loop=self)\n[CI/Tests ]   |                 if not laddr_infos:\n[CI/Tests ]   |                     raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             exceptions = []\n[CI/Tests ]   |             for family, type, proto, cname, address in infos:\n[CI/Tests ]   |                 try:\n[CI/Tests ]   |                     sock = socket.socket(family=family, type=type, proto=proto)\n[CI/Tests ]   |                     sock.setblocking(False)\n[CI/Tests ]   |                     if local_addr is not None:\n[CI/Tests ]   |                         for _, _, _, _, laddr in laddr_infos:\n[CI/Tests ]   |                             try:\n[CI/Tests ]   |                                 sock.bind(laddr)\n[CI/Tests ]   |                                 break\n[CI/Tests ]   |                             except OSError as exc:\n[CI/Tests ]   |                                 msg = (\n[CI/Tests ]   |                                     f'error while attempting to bind on '\n[CI/Tests ]   |                                     f'address {laddr!r}: '\n[CI/Tests ]   |                                     f'{exc.strerror.lower()}'\n[CI/Tests ]   |                                 )\n[CI/Tests ]   |                                 exc = OSError(exc.errno, msg)\n[CI/Tests ]   |                                 exceptions.append(exc)\n[CI/Tests ]   |                         else:\n[CI/Tests ]   |                             sock.close()\n[CI/Tests ]   |                             sock = None\n[CI/Tests ]   |                             continue\n[CI/Tests ]   |                     if self._debug:\n[CI/Tests ]   |                         logger.debug(\"connect %r to %r\", sock, address)\n[CI/Tests ]   |                     await self.sock_connect(sock, address)\n[CI/Tests ]   |                 except OSError as exc:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     exceptions.append(exc)\n[CI/Tests ]   |                 except:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     raise\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     break\n[CI/Tests ]   |             else:\n[CI/Tests ]   |                 if len(exceptions) == 1:\n[CI/Tests ]   |                     raise exceptions[0]\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     # If they all have the same str(), raise one.\n[CI/Tests ]   |                     model = str(exceptions[0])\n[CI/Tests ]   |                     if all(str(exc) == model for exc in exceptions):\n[CI/Tests ]   |                         raise exceptions[0]\n[CI/Tests ]   |                     # Raise a combined exception so the user can see all\n[CI/Tests ]   |                     # the various error messages.\n[CI/Tests ]   |                     raise OSError('Multiple exceptions: {}'.format(\n[CI/Tests ]   | >                       ', '.join(str(exc) for exc in exceptions)))\n[CI/Tests ]   | E                   OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | \n[CI/Tests ]   | address    = ('::1', 11211, 0, 0)\n[CI/Tests ]   | cname      = ''\n[CI/Tests ]   | exceptions = [ConnectionRefusedError(111, \"Connect call failed ('127.0.0.1', 11211)\"), OSError(99, 'Cannot assign requested address')]\n[CI/Tests ]   | family     = <AddressFamily.AF_INET6: 10>\n[CI/Tests ]   | flags      = 0\n[CI/Tests ]   | host       = 'localhost'\n[CI/Tests ]   | infos      = [(<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('127.0.0.1', 11211)), (<AddressFamily.AF_INET6: 10>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('::1', 11211, 0, 0))]\n[CI/Tests ]   | local_addr = None\n[CI/Tests ]   | model      = \"[Errno 111] Connect call failed ('127.0.0.1', 11211)\"\n[CI/Tests ]   | port       = 11211\n[CI/Tests ]   | proto      = 6\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ed284d0>\n[CI/Tests ]   | self       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | server_hostname = None\n[CI/Tests ]   | sock       = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6>\n[CI/Tests ]   | ssl        = None\n[CI/Tests ]   | ssl_handshake_timeout = None\n[CI/Tests ]   | type       = <SocketKind.SOCK_STREAM: 1>\n[CI/Tests ]   | \n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/base_events.py:971: OSError\n[CI/Tests ]   | _______________________________ test_set_errors ________________________________\n[CI/Tests ]   | \n[CI/Tests ]   | mcache = <aiomcache.client.Client object at 0x7f8a7ec836d0>\n[CI/Tests ]   | \n[CI/Tests ]   |     async def test_set_errors(mcache: Client) -> None:\n[CI/Tests ]   |         key, value = b'key:set', b'1'\n[CI/Tests ]   | >       await mcache.set(key, value, exptime=1)\n[CI/Tests ]   | \n[CI/Tests ]   | key        = b'key:set'\n[CI/Tests ]   | mcache     = <aiomcache.client.Client object at 0x7f8a7ec836d0>\n[CI/Tests ]   | value      = b'1'\n[CI/Tests ]   | \n[CI/Tests ]   | tests/commands_test.py:155: \n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | aiomcache/client.py:40: in wrapper\n[CI/Tests ]   |     conn = await self._pool.acquire()\n[CI/Tests ]   |         args       = (b'key:set', b'1')\n[CI/Tests ]   |         func       = <function FlagClient.set at 0x7f8a7edf9050>\n[CI/Tests ]   |         kwargs     = {'exptime': 1}\n[CI/Tests ]   |         self       = <aiomcache.client.Client object at 0x7f8a7ec836d0>\n[CI/Tests ]   | aiomcache/pool.py:40: in acquire\n[CI/Tests ]   |     _conn = await self._create_new_conn()\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ec83790>\n[CI/Tests ]   | aiomcache/pool.py:71: in _create_new_conn\n[CI/Tests ]   |     self._host, self._port, **self.conn_args)\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ec83790>\n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/streams.py:77: in open_connection\n[CI/Tests ]   |     lambda: protocol, host, port, **kwds)\n[CI/Tests ]   |         host       = 'localhost'\n[CI/Tests ]   |         kwds       = {}\n[CI/Tests ]   |         limit      = 65536\n[CI/Tests ]   |         loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   |         port       = 11211\n[CI/Tests ]   |         protocol   = <asyncio.streams.StreamReaderProtocol object at 0x7f8a7ec83b10>\n[CI/Tests ]   |         reader     = <StreamReader>\n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | \n[CI/Tests ]   | self = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ed30b00>\n[CI/Tests ]   | host = 'localhost', port = 11211\n[CI/Tests ]   | \n[CI/Tests ]   |     async def create_connection(\n[CI/Tests ]   |             self, protocol_factory, host=None, port=None,\n[CI/Tests ]   |             *, ssl=None, family=0,\n[CI/Tests ]   |             proto=0, flags=0, sock=None,\n[CI/Tests ]   |             local_addr=None, server_hostname=None,\n[CI/Tests ]   |             ssl_handshake_timeout=None):\n[CI/Tests ]   |         \"\"\"Connect to a TCP server.\n[CI/Tests ]   |     \n[CI/Tests ]   |         Create a streaming transport connection to a given Internet host and\n[CI/Tests ]   |         port: socket family AF_INET or socket.AF_INET6 depending on host (or\n[CI/Tests ]   |         family if specified), socket type SOCK_STREAM. protocol_factory must be\n[CI/Tests ]   |         a callable returning a protocol instance.\n[CI/Tests ]   |     \n[CI/Tests ]   |         This method is a coroutine which will try to establish the connection\n[CI/Tests ]   |         in the background.  When successful, the coroutine returns a\n[CI/Tests ]   |         (transport, protocol) pair.\n[CI/Tests ]   |         \"\"\"\n[CI/Tests ]   |         if server_hostname is not None and not ssl:\n[CI/Tests ]   |             raise ValueError('server_hostname is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if server_hostname is None and ssl:\n[CI/Tests ]   |             # Use host as default for server_hostname.  It is an error\n[CI/Tests ]   |             # if host is empty or not set, e.g. when an\n[CI/Tests ]   |             # already-connected socket was passed or when only a port\n[CI/Tests ]   |             # is given.  To avoid this error, you can pass\n[CI/Tests ]   |             # server_hostname='' -- this will bypass the hostname\n[CI/Tests ]   |             # check.  (This also means that if host is a numeric\n[CI/Tests ]   |             # IP/IPv6 address, we will attempt to verify that exact\n[CI/Tests ]   |             # address; this will probably fail, but it is possible to\n[CI/Tests ]   |             # create a certificate for a specific IP address, so we\n[CI/Tests ]   |             # don't judge it here.)\n[CI/Tests ]   |             if not host:\n[CI/Tests ]   |                 raise ValueError('You must set server_hostname '\n[CI/Tests ]   |                                  'when using ssl without a host')\n[CI/Tests ]   |             server_hostname = host\n[CI/Tests ]   |     \n[CI/Tests ]   |         if ssl_handshake_timeout is not None and not ssl:\n[CI/Tests ]   |             raise ValueError(\n[CI/Tests ]   |                 'ssl_handshake_timeout is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if host is not None or port is not None:\n[CI/Tests ]   |             if sock is not None:\n[CI/Tests ]   |                 raise ValueError(\n[CI/Tests ]   |                     'host/port and sock can not be specified at the same time')\n[CI/Tests ]   |     \n[CI/Tests ]   |             infos = await self._ensure_resolved(\n[CI/Tests ]   |                 (host, port), family=family,\n[CI/Tests ]   |                 type=socket.SOCK_STREAM, proto=proto, flags=flags, loop=self)\n[CI/Tests ]   |             if not infos:\n[CI/Tests ]   |                 raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             if local_addr is not None:\n[CI/Tests ]   |                 laddr_infos = await self._ensure_resolved(\n[CI/Tests ]   |                     local_addr, family=family,\n[CI/Tests ]   |                     type=socket.SOCK_STREAM, proto=proto,\n[CI/Tests ]   |                     flags=flags, loop=self)\n[CI/Tests ]   |                 if not laddr_infos:\n[CI/Tests ]   |                     raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             exceptions = []\n[CI/Tests ]   |             for family, type, proto, cname, address in infos:\n[CI/Tests ]   |                 try:\n[CI/Tests ]   |                     sock = socket.socket(family=family, type=type, proto=proto)\n[CI/Tests ]   |                     sock.setblocking(False)\n[CI/Tests ]   |                     if local_addr is not None:\n[CI/Tests ]   |                         for _, _, _, _, laddr in laddr_infos:\n[CI/Tests ]   |                             try:\n[CI/Tests ]   |                                 sock.bind(laddr)\n[CI/Tests ]   |                                 break\n[CI/Tests ]   |                             except OSError as exc:\n[CI/Tests ]   |                                 msg = (\n[CI/Tests ]   |                                     f'error while attempting to bind on '\n[CI/Tests ]   |                                     f'address {laddr!r}: '\n[CI/Tests ]   |                                     f'{exc.strerror.lower()}'\n[CI/Tests ]   |                                 )\n[CI/Tests ]   |                                 exc = OSError(exc.errno, msg)\n[CI/Tests ]   |                                 exceptions.append(exc)\n[CI/Tests ]   |                         else:\n[CI/Tests ]   |                             sock.close()\n[CI/Tests ]   |                             sock = None\n[CI/Tests ]   |                             continue\n[CI/Tests ]   |                     if self._debug:\n[CI/Tests ]   |                         logger.debug(\"connect %r to %r\", sock, address)\n[CI/Tests ]   |                     await self.sock_connect(sock, address)\n[CI/Tests ]   |                 except OSError as exc:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     exceptions.append(exc)\n[CI/Tests ]   |                 except:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     raise\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     break\n[CI/Tests ]   |             else:\n[CI/Tests ]   |                 if len(exceptions) == 1:\n[CI/Tests ]   |                     raise exceptions[0]\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     # If they all have the same str(), raise one.\n[CI/Tests ]   |                     model = str(exceptions[0])\n[CI/Tests ]   |                     if all(str(exc) == model for exc in exceptions):\n[CI/Tests ]   |                         raise exceptions[0]\n[CI/Tests ]   |                     # Raise a combined exception so the user can see all\n[CI/Tests ]   |                     # the various error messages.\n[CI/Tests ]   |                     raise OSError('Multiple exceptions: {}'.format(\n[CI/Tests ]   | >                       ', '.join(str(exc) for exc in exceptions)))\n[CI/Tests ]   | E                   OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | \n[CI/Tests ]   | address    = ('::1', 11211, 0, 0)\n[CI/Tests ]   | cname      = ''\n[CI/Tests ]   | exceptions = [ConnectionRefusedError(111, \"Connect call failed ('127.0.0.1', 11211)\"), OSError(99, 'Cannot assign requested address')]\n[CI/Tests ]   | family     = <AddressFamily.AF_INET6: 10>\n[CI/Tests ]   | flags      = 0\n[CI/Tests ]   | host       = 'localhost'\n[CI/Tests ]   | infos      = [(<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('127.0.0.1', 11211)), (<AddressFamily.AF_INET6: 10>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('::1', 11211, 0, 0))]\n[CI/Tests ]   | local_addr = None\n[CI/Tests ]   | model      = \"[Errno 111] Connect call failed ('127.0.0.1', 11211)\"\n[CI/Tests ]   | port       = 11211\n[CI/Tests ]   | proto      = 6\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ed30b00>\n[CI/Tests ]   | self       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | server_hostname = None\n[CI/Tests ]   | sock       = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6>\n[CI/Tests ]   | ssl        = None\n[CI/Tests ]   | ssl_handshake_timeout = None\n[CI/Tests ]   | type       = <SocketKind.SOCK_STREAM: 1>\n[CI/Tests ]   | \n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/base_events.py:971: OSError\n[CI/Tests ]   | ________________________________ test_gets_cas _________________________________\n[CI/Tests ]   | \n[CI/Tests ]   | mcache = <aiomcache.client.Client object at 0x7f8a7ea6fa50>\n[CI/Tests ]   | \n[CI/Tests ]   |     async def test_gets_cas(mcache: Client) -> None:\n[CI/Tests ]   |         key, value = b'key:set', b'1'\n[CI/Tests ]   | >       await mcache.set(key, value)\n[CI/Tests ]   | \n[CI/Tests ]   | key        = b'key:set'\n[CI/Tests ]   | mcache     = <aiomcache.client.Client object at 0x7f8a7ea6fa50>\n[CI/Tests ]   | value      = b'1'\n[CI/Tests ]   | \n[CI/Tests ]   | tests/commands_test.py:166: \n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | aiomcache/client.py:40: in wrapper\n[CI/Tests ]   |     conn = await self._pool.acquire()\n[CI/Tests ]   |         args       = (b'key:set', b'1')\n[CI/Tests ]   |         func       = <function FlagClient.set at 0x7f8a7edf9050>\n[CI/Tests ]   |         kwargs     = {}\n[CI/Tests ]   |         self       = <aiomcache.client.Client object at 0x7f8a7ea6fa50>\n[CI/Tests ]   | aiomcache/pool.py:40: in acquire\n[CI/Tests ]   |     _conn = await self._create_new_conn()\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ea6f990>\n[CI/Tests ]   | aiomcache/pool.py:71: in _create_new_conn\n[CI/Tests ]   |     self._host, self._port, **self.conn_args)\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ea6f990>\n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/streams.py:77: in open_connection\n[CI/Tests ]   |     lambda: protocol, host, port, **kwds)\n[CI/Tests ]   |         host       = 'localhost'\n[CI/Tests ]   |         kwds       = {}\n[CI/Tests ]   |         limit      = 65536\n[CI/Tests ]   |         loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   |         port       = 11211\n[CI/Tests ]   |         protocol   = <asyncio.streams.StreamReaderProtocol object at 0x7f8a7ea6fdd0>\n[CI/Tests ]   |         reader     = <StreamReader>\n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | \n[CI/Tests ]   | self = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ed30680>\n[CI/Tests ]   | host = 'localhost', port = 11211\n[CI/Tests ]   | \n[CI/Tests ]   |     async def create_connection(\n[CI/Tests ]   |             self, protocol_factory, host=None, port=None,\n[CI/Tests ]   |             *, ssl=None, family=0,\n[CI/Tests ]   |             proto=0, flags=0, sock=None,\n[CI/Tests ]   |             local_addr=None, server_hostname=None,\n[CI/Tests ]   |             ssl_handshake_timeout=None):\n[CI/Tests ]   |         \"\"\"Connect to a TCP server.\n[CI/Tests ]   |     \n[CI/Tests ]   |         Create a streaming transport connection to a given Internet host and\n[CI/Tests ]   |         port: socket family AF_INET or socket.AF_INET6 depending on host (or\n[CI/Tests ]   |         family if specified), socket type SOCK_STREAM. protocol_factory must be\n[CI/Tests ]   |         a callable returning a protocol instance.\n[CI/Tests ]   |     \n[CI/Tests ]   |         This method is a coroutine which will try to establish the connection\n[CI/Tests ]   |         in the background.  When successful, the coroutine returns a\n[CI/Tests ]   |         (transport, protocol) pair.\n[CI/Tests ]   |         \"\"\"\n[CI/Tests ]   |         if server_hostname is not None and not ssl:\n[CI/Tests ]   |             raise ValueError('server_hostname is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if server_hostname is None and ssl:\n[CI/Tests ]   |             # Use host as default for server_hostname.  It is an error\n[CI/Tests ]   |             # if host is empty or not set, e.g. when an\n[CI/Tests ]   |             # already-connected socket was passed or when only a port\n[CI/Tests ]   |             # is given.  To avoid this error, you can pass\n[CI/Tests ]   |             # server_hostname='' -- this will bypass the hostname\n[CI/Tests ]   |             # check.  (This also means that if host is a numeric\n[CI/Tests ]   |             # IP/IPv6 address, we will attempt to verify that exact\n[CI/Tests ]   |             # address; this will probably fail, but it is possible to\n[CI/Tests ]   |             # create a certificate for a specific IP address, so we\n[CI/Tests ]   |             # don't judge it here.)\n[CI/Tests ]   |             if not host:\n[CI/Tests ]   |                 raise ValueError('You must set server_hostname '\n[CI/Tests ]   |                                  'when using ssl without a host')\n[CI/Tests ]   |             server_hostname = host\n[CI/Tests ]   |     \n[CI/Tests ]   |         if ssl_handshake_timeout is not None and not ssl:\n[CI/Tests ]   |             raise ValueError(\n[CI/Tests ]   |                 'ssl_handshake_timeout is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if host is not None or port is not None:\n[CI/Tests ]   |             if sock is not None:\n[CI/Tests ]   |                 raise ValueError(\n[CI/Tests ]   |                     'host/port and sock can not be specified at the same time')\n[CI/Tests ]   |     \n[CI/Tests ]   |             infos = await self._ensure_resolved(\n[CI/Tests ]   |                 (host, port), family=family,\n[CI/Tests ]   |                 type=socket.SOCK_STREAM, proto=proto, flags=flags, loop=self)\n[CI/Tests ]   |             if not infos:\n[CI/Tests ]   |                 raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             if local_addr is not None:\n[CI/Tests ]   |                 laddr_infos = await self._ensure_resolved(\n[CI/Tests ]   |                     local_addr, family=family,\n[CI/Tests ]   |                     type=socket.SOCK_STREAM, proto=proto,\n[CI/Tests ]   |                     flags=flags, loop=self)\n[CI/Tests ]   |                 if not laddr_infos:\n[CI/Tests ]   |                     raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             exceptions = []\n[CI/Tests ]   |             for family, type, proto, cname, address in infos:\n[CI/Tests ]   |                 try:\n[CI/Tests ]   |                     sock = socket.socket(family=family, type=type, proto=proto)\n[CI/Tests ]   |                     sock.setblocking(False)\n[CI/Tests ]   |                     if local_addr is not None:\n[CI/Tests ]   |                         for _, _, _, _, laddr in laddr_infos:\n[CI/Tests ]   |                             try:\n[CI/Tests ]   |                                 sock.bind(laddr)\n[CI/Tests ]   |                                 break\n[CI/Tests ]   |                             except OSError as exc:\n[CI/Tests ]   |                                 msg = (\n[CI/Tests ]   |                                     f'error while attempting to bind on '\n[CI/Tests ]   |                                     f'address {laddr!r}: '\n[CI/Tests ]   |                                     f'{exc.strerror.lower()}'\n[CI/Tests ]   |                                 )\n[CI/Tests ]   |                                 exc = OSError(exc.errno, msg)\n[CI/Tests ]   |                                 exceptions.append(exc)\n[CI/Tests ]   |                         else:\n[CI/Tests ]   |                             sock.close()\n[CI/Tests ]   |                             sock = None\n[CI/Tests ]   |                             continue\n[CI/Tests ]   |                     if self._debug:\n[CI/Tests ]   |                         logger.debug(\"connect %r to %r\", sock, address)\n[CI/Tests ]   |                     await self.sock_connect(sock, address)\n[CI/Tests ]   |                 except OSError as exc:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     exceptions.append(exc)\n[CI/Tests ]   |                 except:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     raise\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     break\n[CI/Tests ]   |             else:\n[CI/Tests ]   |                 if len(exceptions) == 1:\n[CI/Tests ]   |                     raise exceptions[0]\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     # If they all have the same str(), raise one.\n[CI/Tests ]   |                     model = str(exceptions[0])\n[CI/Tests ]   |                     if all(str(exc) == model for exc in exceptions):\n[CI/Tests ]   |                         raise exceptions[0]\n[CI/Tests ]   |                     # Raise a combined exception so the user can see all\n[CI/Tests ]   |                     # the various error messages.\n[CI/Tests ]   |                     raise OSError('Multiple exceptions: {}'.format(\n[CI/Tests ]   | >                       ', '.join(str(exc) for exc in exceptions)))\n[CI/Tests ]   | E                   OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | \n[CI/Tests ]   | address    = ('::1', 11211, 0, 0)\n[CI/Tests ]   | cname      = ''\n[CI/Tests ]   | exceptions = [ConnectionRefusedError(111, \"Connect call failed ('127.0.0.1', 11211)\"), OSError(99, 'Cannot assign requested address')]\n[CI/Tests ]   | family     = <AddressFamily.AF_INET6: 10>\n[CI/Tests ]   | flags      = 0\n[CI/Tests ]   | host       = 'localhost'\n[CI/Tests ]   | infos      = [(<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('127.0.0.1', 11211)), (<AddressFamily.AF_INET6: 10>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('::1', 11211, 0, 0))]\n[CI/Tests ]   | local_addr = None\n[CI/Tests ]   | model      = \"[Errno 111] Connect call failed ('127.0.0.1', 11211)\"\n[CI/Tests ]   | port       = 11211\n[CI/Tests ]   | proto      = 6\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ed30680>\n[CI/Tests ]   | self       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | server_hostname = None\n[CI/Tests ]   | sock       = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6>\n[CI/Tests ]   | ssl        = None\n[CI/Tests ]   | ssl_handshake_timeout = None\n[CI/Tests ]   | type       = <SocketKind.SOCK_STREAM: 1>\n[CI/Tests ]   | \n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/base_events.py:971: OSError\n[CI/Tests ]   | _______________________________ test_cas_missing _______________________________\n[CI/Tests ]   | \n[CI/Tests ]   | mcache = <aiomcache.client.Client object at 0x7f8a7ea26a90>\n[CI/Tests ]   | \n[CI/Tests ]   |     async def test_cas_missing(mcache: Client) -> None:\n[CI/Tests ]   |         key, value = b'key:set', b'1'\n[CI/Tests ]   | >       stored = await mcache.cas(key, value, 123)\n[CI/Tests ]   | \n[CI/Tests ]   | key        = b'key:set'\n[CI/Tests ]   | mcache     = <aiomcache.client.Client object at 0x7f8a7ea26a90>\n[CI/Tests ]   | value      = b'1'\n[CI/Tests ]   | \n[CI/Tests ]   | tests/commands_test.py:181: \n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | aiomcache/client.py:40: in wrapper\n[CI/Tests ]   |     conn = await self._pool.acquire()\n[CI/Tests ]   |         args       = (b'key:set', b'1', 123)\n[CI/Tests ]   |         func       = <function FlagClient.cas at 0x7f8a7edf9170>\n[CI/Tests ]   |         kwargs     = {}\n[CI/Tests ]   |         self       = <aiomcache.client.Client object at 0x7f8a7ea26a90>\n[CI/Tests ]   | aiomcache/pool.py:40: in acquire\n[CI/Tests ]   |     _conn = await self._create_new_conn()\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ea26c50>\n[CI/Tests ]   | aiomcache/pool.py:71: in _create_new_conn\n[CI/Tests ]   |     self._host, self._port, **self.conn_args)\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ea26c50>\n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/streams.py:77: in open_connection\n[CI/Tests ]   |     lambda: protocol, host, port, **kwds)\n[CI/Tests ]   |         host       = 'localhost'\n[CI/Tests ]   |         kwds       = {}\n[CI/Tests ]   |         limit      = 65536\n[CI/Tests ]   |         loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   |         port       = 11211\n[CI/Tests ]   |         protocol   = <asyncio.streams.StreamReaderProtocol object at 0x7f8a7ea26cd0>\n[CI/Tests ]   |         reader     = <StreamReader>\n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | \n[CI/Tests ]   | self = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ed305f0>\n[CI/Tests ]   | host = 'localhost', port = 11211\n[CI/Tests ]   | \n[CI/Tests ]   |     async def create_connection(\n[CI/Tests ]   |             self, protocol_factory, host=None, port=None,\n[CI/Tests ]   |             *, ssl=None, family=0,\n[CI/Tests ]   |             proto=0, flags=0, sock=None,\n[CI/Tests ]   |             local_addr=None, server_hostname=None,\n[CI/Tests ]   |             ssl_handshake_timeout=None):\n[CI/Tests ]   |         \"\"\"Connect to a TCP server.\n[CI/Tests ]   |     \n[CI/Tests ]   |         Create a streaming transport connection to a given Internet host and\n[CI/Tests ]   |         port: socket family AF_INET or socket.AF_INET6 depending on host (or\n[CI/Tests ]   |         family if specified), socket type SOCK_STREAM. protocol_factory must be\n[CI/Tests ]   |         a callable returning a protocol instance.\n[CI/Tests ]   |     \n[CI/Tests ]   |         This method is a coroutine which will try to establish the connection\n[CI/Tests ]   |         in the background.  When successful, the coroutine returns a\n[CI/Tests ]   |         (transport, protocol) pair.\n[CI/Tests ]   |         \"\"\"\n[CI/Tests ]   |         if server_hostname is not None and not ssl:\n[CI/Tests ]   |             raise ValueError('server_hostname is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if server_hostname is None and ssl:\n[CI/Tests ]   |             # Use host as default for server_hostname.  It is an error\n[CI/Tests ]   |             # if host is empty or not set, e.g. when an\n[CI/Tests ]   |             # already-connected socket was passed or when only a port\n[CI/Tests ]   |             # is given.  To avoid this error, you can pass\n[CI/Tests ]   |             # server_hostname='' -- this will bypass the hostname\n[CI/Tests ]   |             # check.  (This also means that if host is a numeric\n[CI/Tests ]   |             # IP/IPv6 address, we will attempt to verify that exact\n[CI/Tests ]   |             # address; this will probably fail, but it is possible to\n[CI/Tests ]   |             # create a certificate for a specific IP address, so we\n[CI/Tests ]   |             # don't judge it here.)\n[CI/Tests ]   |             if not host:\n[CI/Tests ]   |                 raise ValueError('You must set server_hostname '\n[CI/Tests ]   |                                  'when using ssl without a host')\n[CI/Tests ]   |             server_hostname = host\n[CI/Tests ]   |     \n[CI/Tests ]   |         if ssl_handshake_timeout is not None and not ssl:\n[CI/Tests ]   |             raise ValueError(\n[CI/Tests ]   |                 'ssl_handshake_timeout is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if host is not None or port is not None:\n[CI/Tests ]   |             if sock is not None:\n[CI/Tests ]   |                 raise ValueError(\n[CI/Tests ]   |                     'host/port and sock can not be specified at the same time')\n[CI/Tests ]   |     \n[CI/Tests ]   |             infos = await self._ensure_resolved(\n[CI/Tests ]   |                 (host, port), family=family,\n[CI/Tests ]   |                 type=socket.SOCK_STREAM, proto=proto, flags=flags, loop=self)\n[CI/Tests ]   |             if not infos:\n[CI/Tests ]   |                 raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             if local_addr is not None:\n[CI/Tests ]   |                 laddr_infos = await self._ensure_resolved(\n[CI/Tests ]   |                     local_addr, family=family,\n[CI/Tests ]   |                     type=socket.SOCK_STREAM, proto=proto,\n[CI/Tests ]   |                     flags=flags, loop=self)\n[CI/Tests ]   |                 if not laddr_infos:\n[CI/Tests ]   |                     raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             exceptions = []\n[CI/Tests ]   |             for family, type, proto, cname, address in infos:\n[CI/Tests ]   |                 try:\n[CI/Tests ]   |                     sock = socket.socket(family=family, type=type, proto=proto)\n[CI/Tests ]   |                     sock.setblocking(False)\n[CI/Tests ]   |                     if local_addr is not None:\n[CI/Tests ]   |                         for _, _, _, _, laddr in laddr_infos:\n[CI/Tests ]   |                             try:\n[CI/Tests ]   |                                 sock.bind(laddr)\n[CI/Tests ]   |                                 break\n[CI/Tests ]   |                             except OSError as exc:\n[CI/Tests ]   |                                 msg = (\n[CI/Tests ]   |                                     f'error while attempting to bind on '\n[CI/Tests ]   |                                     f'address {laddr!r}: '\n[CI/Tests ]   |                                     f'{exc.strerror.lower()}'\n[CI/Tests ]   |                                 )\n[CI/Tests ]   |                                 exc = OSError(exc.errno, msg)\n[CI/Tests ]   |                                 exceptions.append(exc)\n[CI/Tests ]   |                         else:\n[CI/Tests ]   |                             sock.close()\n[CI/Tests ]   |                             sock = None\n[CI/Tests ]   |                             continue\n[CI/Tests ]   |                     if self._debug:\n[CI/Tests ]   |                         logger.debug(\"connect %r to %r\", sock, address)\n[CI/Tests ]   |                     await self.sock_connect(sock, address)\n[CI/Tests ]   |                 except OSError as exc:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     exceptions.append(exc)\n[CI/Tests ]   |                 except:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     raise\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     break\n[CI/Tests ]   |             else:\n[CI/Tests ]   |                 if len(exceptions) == 1:\n[CI/Tests ]   |                     raise exceptions[0]\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     # If they all have the same str(), raise one.\n[CI/Tests ]   |                     model = str(exceptions[0])\n[CI/Tests ]   |                     if all(str(exc) == model for exc in exceptions):\n[CI/Tests ]   |                         raise exceptions[0]\n[CI/Tests ]   |                     # Raise a combined exception so the user can see all\n[CI/Tests ]   |                     # the various error messages.\n[CI/Tests ]   |                     raise OSError('Multiple exceptions: {}'.format(\n[CI/Tests ]   | >                       ', '.join(str(exc) for exc in exceptions)))\n[CI/Tests ]   | E                   OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | \n[CI/Tests ]   | address    = ('::1', 11211, 0, 0)\n[CI/Tests ]   | cname      = ''\n[CI/Tests ]   | exceptions = [ConnectionRefusedError(111, \"Connect call failed ('127.0.0.1', 11211)\"), OSError(99, 'Cannot assign requested address')]\n[CI/Tests ]   | family     = <AddressFamily.AF_INET6: 10>\n[CI/Tests ]   | flags      = 0\n[CI/Tests ]   | host       = 'localhost'\n[CI/Tests ]   | infos      = [(<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('127.0.0.1', 11211)), (<AddressFamily.AF_INET6: 10>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('::1', 11211, 0, 0))]\n[CI/Tests ]   | local_addr = None\n[CI/Tests ]   | model      = \"[Errno 111] Connect call failed ('127.0.0.1', 11211)\"\n[CI/Tests ]   | port       = 11211\n[CI/Tests ]   | proto      = 6\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ed305f0>\n[CI/Tests ]   | self       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | server_hostname = None\n[CI/Tests ]   | sock       = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6>\n[CI/Tests ]   | ssl        = None\n[CI/Tests ]   | ssl_handshake_timeout = None\n[CI/Tests ]   | type       = <SocketKind.SOCK_STREAM: 1>\n[CI/Tests ]   | \n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/base_events.py:971: OSError\n[CI/Tests ]   | ___________________________________ test_add ___________________________________\n[CI/Tests ]   | \n[CI/Tests ]   | mcache = <aiomcache.client.Client object at 0x7f8a7ef326d0>\n[CI/Tests ]   | \n[CI/Tests ]   |     async def test_add(mcache: Client) -> None:\n[CI/Tests ]   |         key, value = b'key:add', b'1'\n[CI/Tests ]   | >       await mcache.set(key, value)\n[CI/Tests ]   | \n[CI/Tests ]   | key        = b'key:add'\n[CI/Tests ]   | mcache     = <aiomcache.client.Client object at 0x7f8a7ef326d0>\n[CI/Tests ]   | value      = b'1'\n[CI/Tests ]   | \n[CI/Tests ]   | tests/commands_test.py:187: \n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | aiomcache/client.py:40: in wrapper\n[CI/Tests ]   |     conn = await self._pool.acquire()\n[CI/Tests ]   |         args       = (b'key:add', b'1')\n[CI/Tests ]   |         func       = <function FlagClient.set at 0x7f8a7edf9050>\n[CI/Tests ]   |         kwargs     = {}\n[CI/Tests ]   |         self       = <aiomcache.client.Client object at 0x7f8a7ef326d0>\n[CI/Tests ]   | aiomcache/pool.py:40: in acquire\n[CI/Tests ]   |     _conn = await self._create_new_conn()\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ef32d50>\n[CI/Tests ]   | aiomcache/pool.py:71: in _create_new_conn\n[CI/Tests ]   |     self._host, self._port, **self.conn_args)\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ef32d50>\n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/streams.py:77: in open_connection\n[CI/Tests ]   |     lambda: protocol, host, port, **kwds)\n[CI/Tests ]   |         host       = 'localhost'\n[CI/Tests ]   |         kwds       = {}\n[CI/Tests ]   |         limit      = 65536\n[CI/Tests ]   |         loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   |         port       = 11211\n[CI/Tests ]   |         protocol   = <asyncio.streams.StreamReaderProtocol object at 0x7f8a7ef32e10>\n[CI/Tests ]   |         reader     = <StreamReader>\n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | \n[CI/Tests ]   | self = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ed30d40>\n[CI/Tests ]   | host = 'localhost', port = 11211\n[CI/Tests ]   | \n[CI/Tests ]   |     async def create_connection(\n[CI/Tests ]   |             self, protocol_factory, host=None, port=None,\n[CI/Tests ]   |             *, ssl=None, family=0,\n[CI/Tests ]   |             proto=0, flags=0, sock=None,\n[CI/Tests ]   |             local_addr=None, server_hostname=None,\n[CI/Tests ]   |             ssl_handshake_timeout=None):\n[CI/Tests ]   |         \"\"\"Connect to a TCP server.\n[CI/Tests ]   |     \n[CI/Tests ]   |         Create a streaming transport connection to a given Internet host and\n[CI/Tests ]   |         port: socket family AF_INET or socket.AF_INET6 depending on host (or\n[CI/Tests ]   |         family if specified), socket type SOCK_STREAM. protocol_factory must be\n[CI/Tests ]   |         a callable returning a protocol instance.\n[CI/Tests ]   |     \n[CI/Tests ]   |         This method is a coroutine which will try to establish the connection\n[CI/Tests ]   |         in the background.  When successful, the coroutine returns a\n[CI/Tests ]   |         (transport, protocol) pair.\n[CI/Tests ]   |         \"\"\"\n[CI/Tests ]   |         if server_hostname is not None and not ssl:\n[CI/Tests ]   |             raise ValueError('server_hostname is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if server_hostname is None and ssl:\n[CI/Tests ]   |             # Use host as default for server_hostname.  It is an error\n[CI/Tests ]   |             # if host is empty or not set, e.g. when an\n[CI/Tests ]   |             # already-connected socket was passed or when only a port\n[CI/Tests ]   |             # is given.  To avoid this error, you can pass\n[CI/Tests ]   |             # server_hostname='' -- this will bypass the hostname\n[CI/Tests ]   |             # check.  (This also means that if host is a numeric\n[CI/Tests ]   |             # IP/IPv6 address, we will attempt to verify that exact\n[CI/Tests ]   |             # address; this will probably fail, but it is possible to\n[CI/Tests ]   |             # create a certificate for a specific IP address, so we\n[CI/Tests ]   |             # don't judge it here.)\n[CI/Tests ]   |             if not host:\n[CI/Tests ]   |                 raise ValueError('You must set server_hostname '\n[CI/Tests ]   |                                  'when using ssl without a host')\n[CI/Tests ]   |             server_hostname = host\n[CI/Tests ]   |     \n[CI/Tests ]   |         if ssl_handshake_timeout is not None and not ssl:\n[CI/Tests ]   |             raise ValueError(\n[CI/Tests ]   |                 'ssl_handshake_timeout is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if host is not None or port is not None:\n[CI/Tests ]   |             if sock is not None:\n[CI/Tests ]   |                 raise ValueError(\n[CI/Tests ]   |                     'host/port and sock can not be specified at the same time')\n[CI/Tests ]   |     \n[CI/Tests ]   |             infos = await self._ensure_resolved(\n[CI/Tests ]   |                 (host, port), family=family,\n[CI/Tests ]   |                 type=socket.SOCK_STREAM, proto=proto, flags=flags, loop=self)\n[CI/Tests ]   |             if not infos:\n[CI/Tests ]   |                 raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             if local_addr is not None:\n[CI/Tests ]   |                 laddr_infos = await self._ensure_resolved(\n[CI/Tests ]   |                     local_addr, family=family,\n[CI/Tests ]   |                     type=socket.SOCK_STREAM, proto=proto,\n[CI/Tests ]   |                     flags=flags, loop=self)\n[CI/Tests ]   |                 if not laddr_infos:\n[CI/Tests ]   |                     raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             exceptions = []\n[CI/Tests ]   |             for family, type, proto, cname, address in infos:\n[CI/Tests ]   |                 try:\n[CI/Tests ]   |                     sock = socket.socket(family=family, type=type, proto=proto)\n[CI/Tests ]   |                     sock.setblocking(False)\n[CI/Tests ]   |                     if local_addr is not None:\n[CI/Tests ]   |                         for _, _, _, _, laddr in laddr_infos:\n[CI/Tests ]   |                             try:\n[CI/Tests ]   |                                 sock.bind(laddr)\n[CI/Tests ]   |                                 break\n[CI/Tests ]   |                             except OSError as exc:\n[CI/Tests ]   |                                 msg = (\n[CI/Tests ]   |                                     f'error while attempting to bind on '\n[CI/Tests ]   |                                     f'address {laddr!r}: '\n[CI/Tests ]   |                                     f'{exc.strerror.lower()}'\n[CI/Tests ]   |                                 )\n[CI/Tests ]   |                                 exc = OSError(exc.errno, msg)\n[CI/Tests ]   |                                 exceptions.append(exc)\n[CI/Tests ]   |                         else:\n[CI/Tests ]   |                             sock.close()\n[CI/Tests ]   |                             sock = None\n[CI/Tests ]   |                             continue\n[CI/Tests ]   |                     if self._debug:\n[CI/Tests ]   |                         logger.debug(\"connect %r to %r\", sock, address)\n[CI/Tests ]   |                     await self.sock_connect(sock, address)\n[CI/Tests ]   |                 except OSError as exc:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     exceptions.append(exc)\n[CI/Tests ]   |                 except:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     raise\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     break\n[CI/Tests ]   |             else:\n[CI/Tests ]   |                 if len(exceptions) == 1:\n[CI/Tests ]   |                     raise exceptions[0]\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     # If they all have the same str(), raise one.\n[CI/Tests ]   |                     model = str(exceptions[0])\n[CI/Tests ]   |                     if all(str(exc) == model for exc in exceptions):\n[CI/Tests ]   |                         raise exceptions[0]\n[CI/Tests ]   |                     # Raise a combined exception so the user can see all\n[CI/Tests ]   |                     # the various error messages.\n[CI/Tests ]   |                     raise OSError('Multiple exceptions: {}'.format(\n[CI/Tests ]   | >                       ', '.join(str(exc) for exc in exceptions)))\n[CI/Tests ]   | E                   OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | \n[CI/Tests ]   | address    = ('::1', 11211, 0, 0)\n[CI/Tests ]   | cname      = ''\n[CI/Tests ]   | exceptions = [ConnectionRefusedError(111, \"Connect call failed ('127.0.0.1', 11211)\"), OSError(99, 'Cannot assign requested address')]\n[CI/Tests ]   | family     = <AddressFamily.AF_INET6: 10>\n[CI/Tests ]   | flags      = 0\n[CI/Tests ]   | host       = 'localhost'\n[CI/Tests ]   | infos      = [(<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('127.0.0.1', 11211)), (<AddressFamily.AF_INET6: 10>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('::1', 11211, 0, 0))]\n[CI/Tests ]   | local_addr = None\n[CI/Tests ]   | model      = \"[Errno 111] Connect call failed ('127.0.0.1', 11211)\"\n[CI/Tests ]   | port       = 11211\n[CI/Tests ]   | proto      = 6\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ed30d40>\n[CI/Tests ]   | self       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | server_hostname = None\n[CI/Tests ]   | sock       = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6>\n[CI/Tests ]   | ssl        = None\n[CI/Tests ]   | ssl_handshake_timeout = None\n[CI/Tests ]   | type       = <SocketKind.SOCK_STREAM: 1>\n[CI/Tests ]   | \n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/base_events.py:971: OSError\n[CI/Tests ]   | _________________________________ test_replace _________________________________\n[CI/Tests ]   | \n[CI/Tests ]   | mcache = <aiomcache.client.Client object at 0x7f8a7ee90210>\n[CI/Tests ]   | \n[CI/Tests ]   |     async def test_replace(mcache: Client) -> None:\n[CI/Tests ]   |         key, value = b'key:replace', b'1'\n[CI/Tests ]   | >       await mcache.set(key, value)\n[CI/Tests ]   | \n[CI/Tests ]   | key        = b'key:replace'\n[CI/Tests ]   | mcache     = <aiomcache.client.Client object at 0x7f8a7ee90210>\n[CI/Tests ]   | value      = b'1'\n[CI/Tests ]   | \n[CI/Tests ]   | tests/commands_test.py:201: \n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | aiomcache/client.py:40: in wrapper\n[CI/Tests ]   |     conn = await self._pool.acquire()\n[CI/Tests ]   |         args       = (b'key:replace', b'1')\n[CI/Tests ]   |         func       = <function FlagClient.set at 0x7f8a7edf9050>\n[CI/Tests ]   |         kwargs     = {}\n[CI/Tests ]   |         self       = <aiomcache.client.Client object at 0x7f8a7ee90210>\n[CI/Tests ]   | aiomcache/pool.py:40: in acquire\n[CI/Tests ]   |     _conn = await self._create_new_conn()\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ee90050>\n[CI/Tests ]   | aiomcache/pool.py:71: in _create_new_conn\n[CI/Tests ]   |     self._host, self._port, **self.conn_args)\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ee90050>\n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/streams.py:77: in open_connection\n[CI/Tests ]   |     lambda: protocol, host, port, **kwds)\n[CI/Tests ]   |         host       = 'localhost'\n[CI/Tests ]   |         kwds       = {}\n[CI/Tests ]   |         limit      = 65536\n[CI/Tests ]   |         loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   |         port       = 11211\n[CI/Tests ]   |         protocol   = <asyncio.streams.StreamReaderProtocol object at 0x7f8a7ee90490>\n[CI/Tests ]   |         reader     = <StreamReader>\n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | \n[CI/Tests ]   | self = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ed169e0>\n[CI/Tests ]   | host = 'localhost', port = 11211\n[CI/Tests ]   | \n[CI/Tests ]   |     async def create_connection(\n[CI/Tests ]   |             self, protocol_factory, host=None, port=None,\n[CI/Tests ]   |             *, ssl=None, family=0,\n[CI/Tests ]   |             proto=0, flags=0, sock=None,\n[CI/Tests ]   |             local_addr=None, server_hostname=None,\n[CI/Tests ]   |             ssl_handshake_timeout=None):\n[CI/Tests ]   |         \"\"\"Connect to a TCP server.\n[CI/Tests ]   |     \n[CI/Tests ]   |         Create a streaming transport connection to a given Internet host and\n[CI/Tests ]   |         port: socket family AF_INET or socket.AF_INET6 depending on host (or\n[CI/Tests ]   |         family if specified), socket type SOCK_STREAM. protocol_factory must be\n[CI/Tests ]   |         a callable returning a protocol instance.\n[CI/Tests ]   |     \n[CI/Tests ]   |         This method is a coroutine which will try to establish the connection\n[CI/Tests ]   |         in the background.  When successful, the coroutine returns a\n[CI/Tests ]   |         (transport, protocol) pair.\n[CI/Tests ]   |         \"\"\"\n[CI/Tests ]   |         if server_hostname is not None and not ssl:\n[CI/Tests ]   |             raise ValueError('server_hostname is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if server_hostname is None and ssl:\n[CI/Tests ]   |             # Use host as default for server_hostname.  It is an error\n[CI/Tests ]   |             # if host is empty or not set, e.g. when an\n[CI/Tests ]   |             # already-connected socket was passed or when only a port\n[CI/Tests ]   |             # is given.  To avoid this error, you can pass\n[CI/Tests ]   |             # server_hostname='' -- this will bypass the hostname\n[CI/Tests ]   |             # check.  (This also means that if host is a numeric\n[CI/Tests ]   |             # IP/IPv6 address, we will attempt to verify that exact\n[CI/Tests ]   |             # address; this will probably fail, but it is possible to\n[CI/Tests ]   |             # create a certificate for a specific IP address, so we\n[CI/Tests ]   |             # don't judge it here.)\n[CI/Tests ]   |             if not host:\n[CI/Tests ]   |                 raise ValueError('You must set server_hostname '\n[CI/Tests ]   |                                  'when using ssl without a host')\n[CI/Tests ]   |             server_hostname = host\n[CI/Tests ]   |     \n[CI/Tests ]   |         if ssl_handshake_timeout is not None and not ssl:\n[CI/Tests ]   |             raise ValueError(\n[CI/Tests ]   |                 'ssl_handshake_timeout is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if host is not None or port is not None:\n[CI/Tests ]   |             if sock is not None:\n[CI/Tests ]   |                 raise ValueError(\n[CI/Tests ]   |                     'host/port and sock can not be specified at the same time')\n[CI/Tests ]   |     \n[CI/Tests ]   |             infos = await self._ensure_resolved(\n[CI/Tests ]   |                 (host, port), family=family,\n[CI/Tests ]   |                 type=socket.SOCK_STREAM, proto=proto, flags=flags, loop=self)\n[CI/Tests ]   |             if not infos:\n[CI/Tests ]   |                 raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             if local_addr is not None:\n[CI/Tests ]   |                 laddr_infos = await self._ensure_resolved(\n[CI/Tests ]   |                     local_addr, family=family,\n[CI/Tests ]   |                     type=socket.SOCK_STREAM, proto=proto,\n[CI/Tests ]   |                     flags=flags, loop=self)\n[CI/Tests ]   |                 if not laddr_infos:\n[CI/Tests ]   |                     raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             exceptions = []\n[CI/Tests ]   |             for family, type, proto, cname, address in infos:\n[CI/Tests ]   |                 try:\n[CI/Tests ]   |                     sock = socket.socket(family=family, type=type, proto=proto)\n[CI/Tests ]   |                     sock.setblocking(False)\n[CI/Tests ]   |                     if local_addr is not None:\n[CI/Tests ]   |                         for _, _, _, _, laddr in laddr_infos:\n[CI/Tests ]   |                             try:\n[CI/Tests ]   |                                 sock.bind(laddr)\n[CI/Tests ]   |                                 break\n[CI/Tests ]   |                             except OSError as exc:\n[CI/Tests ]   |                                 msg = (\n[CI/Tests ]   |                                     f'error while attempting to bind on '\n[CI/Tests ]   |                                     f'address {laddr!r}: '\n[CI/Tests ]   |                                     f'{exc.strerror.lower()}'\n[CI/Tests ]   |                                 )\n[CI/Tests ]   |                                 exc = OSError(exc.errno, msg)\n[CI/Tests ]   |                                 exceptions.append(exc)\n[CI/Tests ]   |                         else:\n[CI/Tests ]   |                             sock.close()\n[CI/Tests ]   |                             sock = None\n[CI/Tests ]   |                             continue\n[CI/Tests ]   |                     if self._debug:\n[CI/Tests ]   |                         logger.debug(\"connect %r to %r\", sock, address)\n[CI/Tests ]   |                     await self.sock_connect(sock, address)\n[CI/Tests ]   |                 except OSError as exc:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     exceptions.append(exc)\n[CI/Tests ]   |                 except:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     raise\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     break\n[CI/Tests ]   |             else:\n[CI/Tests ]   |                 if len(exceptions) == 1:\n[CI/Tests ]   |                     raise exceptions[0]\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     # If they all have the same str(), raise one.\n[CI/Tests ]   |                     model = str(exceptions[0])\n[CI/Tests ]   |                     if all(str(exc) == model for exc in exceptions):\n[CI/Tests ]   |                         raise exceptions[0]\n[CI/Tests ]   |                     # Raise a combined exception so the user can see all\n[CI/Tests ]   |                     # the various error messages.\n[CI/Tests ]   |                     raise OSError('Multiple exceptions: {}'.format(\n[CI/Tests ]   | >                       ', '.join(str(exc) for exc in exceptions)))\n[CI/Tests ]   | E                   OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | \n[CI/Tests ]   | address    = ('::1', 11211, 0, 0)\n[CI/Tests ]   | cname      = ''\n[CI/Tests ]   | exceptions = [ConnectionRefusedError(111, \"Connect call failed ('127.0.0.1', 11211)\"), OSError(99, 'Cannot assign requested address')]\n[CI/Tests ]   | family     = <AddressFamily.AF_INET6: 10>\n[CI/Tests ]   | flags      = 0\n[CI/Tests ]   | host       = 'localhost'\n[CI/Tests ]   | infos      = [(<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('127.0.0.1', 11211)), (<AddressFamily.AF_INET6: 10>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('::1', 11211, 0, 0))]\n[CI/Tests ]   | local_addr = None\n[CI/Tests ]   | model      = \"[Errno 111] Connect call failed ('127.0.0.1', 11211)\"\n[CI/Tests ]   | port       = 11211\n[CI/Tests ]   | proto      = 6\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ed169e0>\n[CI/Tests ]   | self       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | server_hostname = None\n[CI/Tests ]   | sock       = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6>\n[CI/Tests ]   | ssl        = None\n[CI/Tests ]   | ssl_handshake_timeout = None\n[CI/Tests ]   | type       = <SocketKind.SOCK_STREAM: 1>\n[CI/Tests ]   | \n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/base_events.py:971: OSError\n[CI/Tests ]   | _________________________________ test_append __________________________________\n[CI/Tests ]   | \n[CI/Tests ]   | mcache = <aiomcache.client.Client object at 0x7f8a7ea26e10>\n[CI/Tests ]   | \n[CI/Tests ]   |     async def test_append(mcache: Client) -> None:\n[CI/Tests ]   |         key, value = b'key:append', b'1'\n[CI/Tests ]   | >       await mcache.set(key, value)\n[CI/Tests ]   | \n[CI/Tests ]   | key        = b'key:append'\n[CI/Tests ]   | mcache     = <aiomcache.client.Client object at 0x7f8a7ea26e10>\n[CI/Tests ]   | value      = b'1'\n[CI/Tests ]   | \n[CI/Tests ]   | tests/commands_test.py:218: \n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | aiomcache/client.py:40: in wrapper\n[CI/Tests ]   |     conn = await self._pool.acquire()\n[CI/Tests ]   |         args       = (b'key:append', b'1')\n[CI/Tests ]   |         func       = <function FlagClient.set at 0x7f8a7edf9050>\n[CI/Tests ]   |         kwargs     = {}\n[CI/Tests ]   |         self       = <aiomcache.client.Client object at 0x7f8a7ea26e10>\n[CI/Tests ]   | aiomcache/pool.py:40: in acquire\n[CI/Tests ]   |     _conn = await self._create_new_conn()\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ea26c50>\n[CI/Tests ]   | aiomcache/pool.py:71: in _create_new_conn\n[CI/Tests ]   |     self._host, self._port, **self.conn_args)\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ea26c50>\n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/streams.py:77: in open_connection\n[CI/Tests ]   |     lambda: protocol, host, port, **kwds)\n[CI/Tests ]   |         host       = 'localhost'\n[CI/Tests ]   |         kwds       = {}\n[CI/Tests ]   |         limit      = 65536\n[CI/Tests ]   |         loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   |         port       = 11211\n[CI/Tests ]   |         protocol   = <asyncio.streams.StreamReaderProtocol object at 0x7f8a7ea26ed0>\n[CI/Tests ]   |         reader     = <StreamReader>\n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | \n[CI/Tests ]   | self = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ed165f0>\n[CI/Tests ]   | host = 'localhost', port = 11211\n[CI/Tests ]   | \n[CI/Tests ]   |     async def create_connection(\n[CI/Tests ]   |             self, protocol_factory, host=None, port=None,\n[CI/Tests ]   |             *, ssl=None, family=0,\n[CI/Tests ]   |             proto=0, flags=0, sock=None,\n[CI/Tests ]   |             local_addr=None, server_hostname=None,\n[CI/Tests ]   |             ssl_handshake_timeout=None):\n[CI/Tests ]   |         \"\"\"Connect to a TCP server.\n[CI/Tests ]   |     \n[CI/Tests ]   |         Create a streaming transport connection to a given Internet host and\n[CI/Tests ]   |         port: socket family AF_INET or socket.AF_INET6 depending on host (or\n[CI/Tests ]   |         family if specified), socket type SOCK_STREAM. protocol_factory must be\n[CI/Tests ]   |         a callable returning a protocol instance.\n[CI/Tests ]   |     \n[CI/Tests ]   |         This method is a coroutine which will try to establish the connection\n[CI/Tests ]   |         in the background.  When successful, the coroutine returns a\n[CI/Tests ]   |         (transport, protocol) pair.\n[CI/Tests ]   |         \"\"\"\n[CI/Tests ]   |         if server_hostname is not None and not ssl:\n[CI/Tests ]   |             raise ValueError('server_hostname is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if server_hostname is None and ssl:\n[CI/Tests ]   |             # Use host as default for server_hostname.  It is an error\n[CI/Tests ]   |             # if host is empty or not set, e.g. when an\n[CI/Tests ]   |             # already-connected socket was passed or when only a port\n[CI/Tests ]   |             # is given.  To avoid this error, you can pass\n[CI/Tests ]   |             # server_hostname='' -- this will bypass the hostname\n[CI/Tests ]   |             # check.  (This also means that if host is a numeric\n[CI/Tests ]   |             # IP/IPv6 address, we will attempt to verify that exact\n[CI/Tests ]   |             # address; this will probably fail, but it is possible to\n[CI/Tests ]   |             # create a certificate for a specific IP address, so we\n[CI/Tests ]   |             # don't judge it here.)\n[CI/Tests ]   |             if not host:\n[CI/Tests ]   |                 raise ValueError('You must set server_hostname '\n[CI/Tests ]   |                                  'when using ssl without a host')\n[CI/Tests ]   |             server_hostname = host\n[CI/Tests ]   |     \n[CI/Tests ]   |         if ssl_handshake_timeout is not None and not ssl:\n[CI/Tests ]   |             raise ValueError(\n[CI/Tests ]   |                 'ssl_handshake_timeout is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if host is not None or port is not None:\n[CI/Tests ]   |             if sock is not None:\n[CI/Tests ]   |                 raise ValueError(\n[CI/Tests ]   |                     'host/port and sock can not be specified at the same time')\n[CI/Tests ]   |     \n[CI/Tests ]   |             infos = await self._ensure_resolved(\n[CI/Tests ]   |                 (host, port), family=family,\n[CI/Tests ]   |                 type=socket.SOCK_STREAM, proto=proto, flags=flags, loop=self)\n[CI/Tests ]   |             if not infos:\n[CI/Tests ]   |                 raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             if local_addr is not None:\n[CI/Tests ]   |                 laddr_infos = await self._ensure_resolved(\n[CI/Tests ]   |                     local_addr, family=family,\n[CI/Tests ]   |                     type=socket.SOCK_STREAM, proto=proto,\n[CI/Tests ]   |                     flags=flags, loop=self)\n[CI/Tests ]   |                 if not laddr_infos:\n[CI/Tests ]   |                     raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             exceptions = []\n[CI/Tests ]   |             for family, type, proto, cname, address in infos:\n[CI/Tests ]   |                 try:\n[CI/Tests ]   |                     sock = socket.socket(family=family, type=type, proto=proto)\n[CI/Tests ]   |                     sock.setblocking(False)\n[CI/Tests ]   |                     if local_addr is not None:\n[CI/Tests ]   |                         for _, _, _, _, laddr in laddr_infos:\n[CI/Tests ]   |                             try:\n[CI/Tests ]   |                                 sock.bind(laddr)\n[CI/Tests ]   |                                 break\n[CI/Tests ]   |                             except OSError as exc:\n[CI/Tests ]   |                                 msg = (\n[CI/Tests ]   |                                     f'error while attempting to bind on '\n[CI/Tests ]   |                                     f'address {laddr!r}: '\n[CI/Tests ]   |                                     f'{exc.strerror.lower()}'\n[CI/Tests ]   |                                 )\n[CI/Tests ]   |                                 exc = OSError(exc.errno, msg)\n[CI/Tests ]   |                                 exceptions.append(exc)\n[CI/Tests ]   |                         else:\n[CI/Tests ]   |                             sock.close()\n[CI/Tests ]   |                             sock = None\n[CI/Tests ]   |                             continue\n[CI/Tests ]   |                     if self._debug:\n[CI/Tests ]   |                         logger.debug(\"connect %r to %r\", sock, address)\n[CI/Tests ]   |                     await self.sock_connect(sock, address)\n[CI/Tests ]   |                 except OSError as exc:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     exceptions.append(exc)\n[CI/Tests ]   |                 except:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     raise\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     break\n[CI/Tests ]   |             else:\n[CI/Tests ]   |                 if len(exceptions) == 1:\n[CI/Tests ]   |                     raise exceptions[0]\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     # If they all have the same str(), raise one.\n[CI/Tests ]   |                     model = str(exceptions[0])\n[CI/Tests ]   |                     if all(str(exc) == model for exc in exceptions):\n[CI/Tests ]   |                         raise exceptions[0]\n[CI/Tests ]   |                     # Raise a combined exception so the user can see all\n[CI/Tests ]   |                     # the various error messages.\n[CI/Tests ]   |                     raise OSError('Multiple exceptions: {}'.format(\n[CI/Tests ]   | >                       ', '.join(str(exc) for exc in exceptions)))\n[CI/Tests ]   | E                   OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | \n[CI/Tests ]   | address    = ('::1', 11211, 0, 0)\n[CI/Tests ]   | cname      = ''\n[CI/Tests ]   | exceptions = [ConnectionRefusedError(111, \"Connect call failed ('127.0.0.1', 11211)\"), OSError(99, 'Cannot assign requested address')]\n[CI/Tests ]   | family     = <AddressFamily.AF_INET6: 10>\n[CI/Tests ]   | flags      = 0\n[CI/Tests ]   | host       = 'localhost'\n[CI/Tests ]   | infos      = [(<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('127.0.0.1', 11211)), (<AddressFamily.AF_INET6: 10>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('::1', 11211, 0, 0))]\n[CI/Tests ]   | local_addr = None\n[CI/Tests ]   | model      = \"[Errno 111] Connect call failed ('127.0.0.1', 11211)\"\n[CI/Tests ]   | port       = 11211\n[CI/Tests ]   | proto      = 6\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ed165f0>\n[CI/Tests ]   | self       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | server_hostname = None\n[CI/Tests ]   | sock       = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6>\n[CI/Tests ]   | ssl        = None\n[CI/Tests ]   | ssl_handshake_timeout = None\n[CI/Tests ]   | type       = <SocketKind.SOCK_STREAM: 1>\n[CI/Tests ]   | \n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/base_events.py:971: OSError\n[CI/Tests ]   | _________________________________ test_prepend _________________________________\n[CI/Tests ]   | \n[CI/Tests ]   | mcache = <aiomcache.client.Client object at 0x7f8a7ea73210>\n[CI/Tests ]   | \n[CI/Tests ]   |     async def test_prepend(mcache: Client) -> None:\n[CI/Tests ]   |         key, value = b'key:prepend', b'1'\n[CI/Tests ]   | >       await mcache.set(key, value)\n[CI/Tests ]   | \n[CI/Tests ]   | key        = b'key:prepend'\n[CI/Tests ]   | mcache     = <aiomcache.client.Client object at 0x7f8a7ea73210>\n[CI/Tests ]   | value      = b'1'\n[CI/Tests ]   | \n[CI/Tests ]   | tests/commands_test.py:236: \n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | aiomcache/client.py:40: in wrapper\n[CI/Tests ]   |     conn = await self._pool.acquire()\n[CI/Tests ]   |         args       = (b'key:prepend', b'1')\n[CI/Tests ]   |         func       = <function FlagClient.set at 0x7f8a7edf9050>\n[CI/Tests ]   |         kwargs     = {}\n[CI/Tests ]   |         self       = <aiomcache.client.Client object at 0x7f8a7ea73210>\n[CI/Tests ]   | aiomcache/pool.py:40: in acquire\n[CI/Tests ]   |     _conn = await self._create_new_conn()\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ea73690>\n[CI/Tests ]   | aiomcache/pool.py:71: in _create_new_conn\n[CI/Tests ]   |     self._host, self._port, **self.conn_args)\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ea73690>\n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/streams.py:77: in open_connection\n[CI/Tests ]   |     lambda: protocol, host, port, **kwds)\n[CI/Tests ]   |         host       = 'localhost'\n[CI/Tests ]   |         kwds       = {}\n[CI/Tests ]   |         limit      = 65536\n[CI/Tests ]   |         loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   |         port       = 11211\n[CI/Tests ]   |         protocol   = <asyncio.streams.StreamReaderProtocol object at 0x7f8a7ea73950>\n[CI/Tests ]   |         reader     = <StreamReader>\n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | \n[CI/Tests ]   | self = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ed30a70>\n[CI/Tests ]   | host = 'localhost', port = 11211\n[CI/Tests ]   | \n[CI/Tests ]   |     async def create_connection(\n[CI/Tests ]   |             self, protocol_factory, host=None, port=None,\n[CI/Tests ]   |             *, ssl=None, family=0,\n[CI/Tests ]   |             proto=0, flags=0, sock=None,\n[CI/Tests ]   |             local_addr=None, server_hostname=None,\n[CI/Tests ]   |             ssl_handshake_timeout=None):\n[CI/Tests ]   |         \"\"\"Connect to a TCP server.\n[CI/Tests ]   |     \n[CI/Tests ]   |         Create a streaming transport connection to a given Internet host and\n[CI/Tests ]   |         port: socket family AF_INET or socket.AF_INET6 depending on host (or\n[CI/Tests ]   |         family if specified), socket type SOCK_STREAM. protocol_factory must be\n[CI/Tests ]   |         a callable returning a protocol instance.\n[CI/Tests ]   |     \n[CI/Tests ]   |         This method is a coroutine which will try to establish the connection\n[CI/Tests ]   |         in the background.  When successful, the coroutine returns a\n[CI/Tests ]   |         (transport, protocol) pair.\n[CI/Tests ]   |         \"\"\"\n[CI/Tests ]   |         if server_hostname is not None and not ssl:\n[CI/Tests ]   |             raise ValueError('server_hostname is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if server_hostname is None and ssl:\n[CI/Tests ]   |             # Use host as default for server_hostname.  It is an error\n[CI/Tests ]   |             # if host is empty or not set, e.g. when an\n[CI/Tests ]   |             # already-connected socket was passed or when only a port\n[CI/Tests ]   |             # is given.  To avoid this error, you can pass\n[CI/Tests ]   |             # server_hostname='' -- this will bypass the hostname\n[CI/Tests ]   |             # check.  (This also means that if host is a numeric\n[CI/Tests ]   |             # IP/IPv6 address, we will attempt to verify that exact\n[CI/Tests ]   |             # address; this will probably fail, but it is possible to\n[CI/Tests ]   |             # create a certificate for a specific IP address, so we\n[CI/Tests ]   |             # don't judge it here.)\n[CI/Tests ]   |             if not host:\n[CI/Tests ]   |                 raise ValueError('You must set server_hostname '\n[CI/Tests ]   |                                  'when using ssl without a host')\n[CI/Tests ]   |             server_hostname = host\n[CI/Tests ]   |     \n[CI/Tests ]   |         if ssl_handshake_timeout is not None and not ssl:\n[CI/Tests ]   |             raise ValueError(\n[CI/Tests ]   |                 'ssl_handshake_timeout is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if host is not None or port is not None:\n[CI/Tests ]   |             if sock is not None:\n[CI/Tests ]   |                 raise ValueError(\n[CI/Tests ]   |                     'host/port and sock can not be specified at the same time')\n[CI/Tests ]   |     \n[CI/Tests ]   |             infos = await self._ensure_resolved(\n[CI/Tests ]   |                 (host, port), family=family,\n[CI/Tests ]   |                 type=socket.SOCK_STREAM, proto=proto, flags=flags, loop=self)\n[CI/Tests ]   |             if not infos:\n[CI/Tests ]   |                 raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             if local_addr is not None:\n[CI/Tests ]   |                 laddr_infos = await self._ensure_resolved(\n[CI/Tests ]   |                     local_addr, family=family,\n[CI/Tests ]   |                     type=socket.SOCK_STREAM, proto=proto,\n[CI/Tests ]   |                     flags=flags, loop=self)\n[CI/Tests ]   |                 if not laddr_infos:\n[CI/Tests ]   |                     raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             exceptions = []\n[CI/Tests ]   |             for family, type, proto, cname, address in infos:\n[CI/Tests ]   |                 try:\n[CI/Tests ]   |                     sock = socket.socket(family=family, type=type, proto=proto)\n[CI/Tests ]   |                     sock.setblocking(False)\n[CI/Tests ]   |                     if local_addr is not None:\n[CI/Tests ]   |                         for _, _, _, _, laddr in laddr_infos:\n[CI/Tests ]   |                             try:\n[CI/Tests ]   |                                 sock.bind(laddr)\n[CI/Tests ]   |                                 break\n[CI/Tests ]   |                             except OSError as exc:\n[CI/Tests ]   |                                 msg = (\n[CI/Tests ]   |                                     f'error while attempting to bind on '\n[CI/Tests ]   |                                     f'address {laddr!r}: '\n[CI/Tests ]   |                                     f'{exc.strerror.lower()}'\n[CI/Tests ]   |                                 )\n[CI/Tests ]   |                                 exc = OSError(exc.errno, msg)\n[CI/Tests ]   |                                 exceptions.append(exc)\n[CI/Tests ]   |                         else:\n[CI/Tests ]   |                             sock.close()\n[CI/Tests ]   |                             sock = None\n[CI/Tests ]   |                             continue\n[CI/Tests ]   |                     if self._debug:\n[CI/Tests ]   |                         logger.debug(\"connect %r to %r\", sock, address)\n[CI/Tests ]   |                     await self.sock_connect(sock, address)\n[CI/Tests ]   |                 except OSError as exc:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     exceptions.append(exc)\n[CI/Tests ]   |                 except:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     raise\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     break\n[CI/Tests ]   |             else:\n[CI/Tests ]   |                 if len(exceptions) == 1:\n[CI/Tests ]   |                     raise exceptions[0]\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     # If they all have the same str(), raise one.\n[CI/Tests ]   |                     model = str(exceptions[0])\n[CI/Tests ]   |                     if all(str(exc) == model for exc in exceptions):\n[CI/Tests ]   |                         raise exceptions[0]\n[CI/Tests ]   |                     # Raise a combined exception so the user can see all\n[CI/Tests ]   |                     # the various error messages.\n[CI/Tests ]   |                     raise OSError('Multiple exceptions: {}'.format(\n[CI/Tests ]   | >                       ', '.join(str(exc) for exc in exceptions)))\n[CI/Tests ]   | E                   OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | \n[CI/Tests ]   | address    = ('::1', 11211, 0, 0)\n[CI/Tests ]   | cname      = ''\n[CI/Tests ]   | exceptions = [ConnectionRefusedError(111, \"Connect call failed ('127.0.0.1', 11211)\"), OSError(99, 'Cannot assign requested address')]\n[CI/Tests ]   | family     = <AddressFamily.AF_INET6: 10>\n[CI/Tests ]   | flags      = 0\n[CI/Tests ]   | host       = 'localhost'\n[CI/Tests ]   | infos      = [(<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('127.0.0.1', 11211)), (<AddressFamily.AF_INET6: 10>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('::1', 11211, 0, 0))]\n[CI/Tests ]   | local_addr = None\n[CI/Tests ]   | model      = \"[Errno 111] Connect call failed ('127.0.0.1', 11211)\"\n[CI/Tests ]   | port       = 11211\n[CI/Tests ]   | proto      = 6\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ed30a70>\n[CI/Tests ]   | self       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | server_hostname = None\n[CI/Tests ]   | sock       = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6>\n[CI/Tests ]   | ssl        = None\n[CI/Tests ]   | ssl_handshake_timeout = None\n[CI/Tests ]   | type       = <SocketKind.SOCK_STREAM: 1>\n[CI/Tests ]   | \n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/base_events.py:971: OSError\n[CI/Tests ]   | _________________________________ test_delete __________________________________\n[CI/Tests ]   | \n[CI/Tests ]   | mcache = <aiomcache.client.Client object at 0x7f8a7e9dce10>\n[CI/Tests ]   | \n[CI/Tests ]   |     async def test_delete(mcache: Client) -> None:\n[CI/Tests ]   |         key, value = b'key:delete', b'value'\n[CI/Tests ]   | >       await mcache.set(key, value)\n[CI/Tests ]   | \n[CI/Tests ]   | key        = b'key:delete'\n[CI/Tests ]   | mcache     = <aiomcache.client.Client object at 0x7f8a7e9dce10>\n[CI/Tests ]   | value      = b'value'\n[CI/Tests ]   | \n[CI/Tests ]   | tests/commands_test.py:254: \n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | aiomcache/client.py:40: in wrapper\n[CI/Tests ]   |     conn = await self._pool.acquire()\n[CI/Tests ]   |         args       = (b'key:delete', b'value')\n[CI/Tests ]   |         func       = <function FlagClient.set at 0x7f8a7edf9050>\n[CI/Tests ]   |         kwargs     = {}\n[CI/Tests ]   |         self       = <aiomcache.client.Client object at 0x7f8a7e9dce10>\n[CI/Tests ]   | aiomcache/pool.py:40: in acquire\n[CI/Tests ]   |     _conn = await self._create_new_conn()\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7e9dc790>\n[CI/Tests ]   | aiomcache/pool.py:71: in _create_new_conn\n[CI/Tests ]   |     self._host, self._port, **self.conn_args)\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7e9dc790>\n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/streams.py:77: in open_connection\n[CI/Tests ]   |     lambda: protocol, host, port, **kwds)\n[CI/Tests ]   |         host       = 'localhost'\n[CI/Tests ]   |         kwds       = {}\n[CI/Tests ]   |         limit      = 65536\n[CI/Tests ]   |         loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   |         port       = 11211\n[CI/Tests ]   |         protocol   = <asyncio.streams.StreamReaderProtocol object at 0x7f8a7e9dcb10>\n[CI/Tests ]   |         reader     = <StreamReader>\n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | \n[CI/Tests ]   | self = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ec86290>\n[CI/Tests ]   | host = 'localhost', port = 11211\n[CI/Tests ]   | \n[CI/Tests ]   |     async def create_connection(\n[CI/Tests ]   |             self, protocol_factory, host=None, port=None,\n[CI/Tests ]   |             *, ssl=None, family=0,\n[CI/Tests ]   |             proto=0, flags=0, sock=None,\n[CI/Tests ]   |             local_addr=None, server_hostname=None,\n[CI/Tests ]   |             ssl_handshake_timeout=None):\n[CI/Tests ]   |         \"\"\"Connect to a TCP server.\n[CI/Tests ]   |     \n[CI/Tests ]   |         Create a streaming transport connection to a given Internet host and\n[CI/Tests ]   |         port: socket family AF_INET or socket.AF_INET6 depending on host (or\n[CI/Tests ]   |         family if specified), socket type SOCK_STREAM. protocol_factory must be\n[CI/Tests ]   |         a callable returning a protocol instance.\n[CI/Tests ]   |     \n[CI/Tests ]   |         This method is a coroutine which will try to establish the connection\n[CI/Tests ]   |         in the background.  When successful, the coroutine returns a\n[CI/Tests ]   |         (transport, protocol) pair.\n[CI/Tests ]   |         \"\"\"\n[CI/Tests ]   |         if server_hostname is not None and not ssl:\n[CI/Tests ]   |             raise ValueError('server_hostname is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if server_hostname is None and ssl:\n[CI/Tests ]   |             # Use host as default for server_hostname.  It is an error\n[CI/Tests ]   |             # if host is empty or not set, e.g. when an\n[CI/Tests ]   |             # already-connected socket was passed or when only a port\n[CI/Tests ]   |             # is given.  To avoid this error, you can pass\n[CI/Tests ]   |             # server_hostname='' -- this will bypass the hostname\n[CI/Tests ]   |             # check.  (This also means that if host is a numeric\n[CI/Tests ]   |             # IP/IPv6 address, we will attempt to verify that exact\n[CI/Tests ]   |             # address; this will probably fail, but it is possible to\n[CI/Tests ]   |             # create a certificate for a specific IP address, so we\n[CI/Tests ]   |             # don't judge it here.)\n[CI/Tests ]   |             if not host:\n[CI/Tests ]   |                 raise ValueError('You must set server_hostname '\n[CI/Tests ]   |                                  'when using ssl without a host')\n[CI/Tests ]   |             server_hostname = host\n[CI/Tests ]   |     \n[CI/Tests ]   |         if ssl_handshake_timeout is not None and not ssl:\n[CI/Tests ]   |             raise ValueError(\n[CI/Tests ]   |                 'ssl_handshake_timeout is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if host is not None or port is not None:\n[CI/Tests ]   |             if sock is not None:\n[CI/Tests ]   |                 raise ValueError(\n[CI/Tests ]   |                     'host/port and sock can not be specified at the same time')\n[CI/Tests ]   |     \n[CI/Tests ]   |             infos = await self._ensure_resolved(\n[CI/Tests ]   |                 (host, port), family=family,\n[CI/Tests ]   |                 type=socket.SOCK_STREAM, proto=proto, flags=flags, loop=self)\n[CI/Tests ]   |             if not infos:\n[CI/Tests ]   |                 raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             if local_addr is not None:\n[CI/Tests ]   |                 laddr_infos = await self._ensure_resolved(\n[CI/Tests ]   |                     local_addr, family=family,\n[CI/Tests ]   |                     type=socket.SOCK_STREAM, proto=proto,\n[CI/Tests ]   |                     flags=flags, loop=self)\n[CI/Tests ]   |                 if not laddr_infos:\n[CI/Tests ]   |                     raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             exceptions = []\n[CI/Tests ]   |             for family, type, proto, cname, address in infos:\n[CI/Tests ]   |                 try:\n[CI/Tests ]   |                     sock = socket.socket(family=family, type=type, proto=proto)\n[CI/Tests ]   |                     sock.setblocking(False)\n[CI/Tests ]   |                     if local_addr is not None:\n[CI/Tests ]   |                         for _, _, _, _, laddr in laddr_infos:\n[CI/Tests ]   |                             try:\n[CI/Tests ]   |                                 sock.bind(laddr)\n[CI/Tests ]   |                                 break\n[CI/Tests ]   |                             except OSError as exc:\n[CI/Tests ]   |                                 msg = (\n[CI/Tests ]   |                                     f'error while attempting to bind on '\n[CI/Tests ]   |                                     f'address {laddr!r}: '\n[CI/Tests ]   |                                     f'{exc.strerror.lower()}'\n[CI/Tests ]   |                                 )\n[CI/Tests ]   |                                 exc = OSError(exc.errno, msg)\n[CI/Tests ]   |                                 exceptions.append(exc)\n[CI/Tests ]   |                         else:\n[CI/Tests ]   |                             sock.close()\n[CI/Tests ]   |                             sock = None\n[CI/Tests ]   |                             continue\n[CI/Tests ]   |                     if self._debug:\n[CI/Tests ]   |                         logger.debug(\"connect %r to %r\", sock, address)\n[CI/Tests ]   |                     await self.sock_connect(sock, address)\n[CI/Tests ]   |                 except OSError as exc:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     exceptions.append(exc)\n[CI/Tests ]   |                 except:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     raise\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     break\n[CI/Tests ]   |             else:\n[CI/Tests ]   |                 if len(exceptions) == 1:\n[CI/Tests ]   |                     raise exceptions[0]\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     # If they all have the same str(), raise one.\n[CI/Tests ]   |                     model = str(exceptions[0])\n[CI/Tests ]   |                     if all(str(exc) == model for exc in exceptions):\n[CI/Tests ]   |                         raise exceptions[0]\n[CI/Tests ]   |                     # Raise a combined exception so the user can see all\n[CI/Tests ]   |                     # the various error messages.\n[CI/Tests ]   |                     raise OSError('Multiple exceptions: {}'.format(\n[CI/Tests ]   | >                       ', '.join(str(exc) for exc in exceptions)))\n[CI/Tests ]   | E                   OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | \n[CI/Tests ]   | address    = ('::1', 11211, 0, 0)\n[CI/Tests ]   | cname      = ''\n[CI/Tests ]   | exceptions = [ConnectionRefusedError(111, \"Connect call failed ('127.0.0.1', 11211)\"), OSError(99, 'Cannot assign requested address')]\n[CI/Tests ]   | family     = <AddressFamily.AF_INET6: 10>\n[CI/Tests ]   | flags      = 0\n[CI/Tests ]   | host       = 'localhost'\n[CI/Tests ]   | infos      = [(<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('127.0.0.1', 11211)), (<AddressFamily.AF_INET6: 10>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('::1', 11211, 0, 0))]\n[CI/Tests ]   | local_addr = None\n[CI/Tests ]   | model      = \"[Errno 111] Connect call failed ('127.0.0.1', 11211)\"\n[CI/Tests ]   | port       = 11211\n[CI/Tests ]   | proto      = 6\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ec86290>\n[CI/Tests ]   | self       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | server_hostname = None\n[CI/Tests ]   | sock       = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6>\n[CI/Tests ]   | ssl        = None\n[CI/Tests ]   | ssl_handshake_timeout = None\n[CI/Tests ]   | type       = <SocketKind.SOCK_STREAM: 1>\n[CI/Tests ]   | \n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/base_events.py:971: OSError\n[CI/Tests ]   | __________________________ test_delete_key_not_exists __________________________\n[CI/Tests ]   | \n[CI/Tests ]   | mcache = <aiomcache.client.Client object at 0x7f8a7ed71a10>\n[CI/Tests ]   | \n[CI/Tests ]   |     async def test_delete_key_not_exists(mcache: Client) -> None:\n[CI/Tests ]   | >       is_deleted = await mcache.delete(b\"not:key\")\n[CI/Tests ]   | \n[CI/Tests ]   | mcache     = <aiomcache.client.Client object at 0x7f8a7ed71a10>\n[CI/Tests ]   | \n[CI/Tests ]   | tests/commands_test.py:276: \n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | aiomcache/client.py:40: in wrapper\n[CI/Tests ]   |     conn = await self._pool.acquire()\n[CI/Tests ]   |         args       = (b'not:key',)\n[CI/Tests ]   |         func       = <function FlagClient.delete at 0x7f8a7ef629e0>\n[CI/Tests ]   |         kwargs     = {}\n[CI/Tests ]   |         self       = <aiomcache.client.Client object at 0x7f8a7ed71a10>\n[CI/Tests ]   | aiomcache/pool.py:40: in acquire\n[CI/Tests ]   |     _conn = await self._create_new_conn()\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ed718d0>\n[CI/Tests ]   | aiomcache/pool.py:71: in _create_new_conn\n[CI/Tests ]   |     self._host, self._port, **self.conn_args)\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ed718d0>\n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/streams.py:77: in open_connection\n[CI/Tests ]   |     lambda: protocol, host, port, **kwds)\n[CI/Tests ]   |         host       = 'localhost'\n[CI/Tests ]   |         kwds       = {}\n[CI/Tests ]   |         limit      = 65536\n[CI/Tests ]   |         loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   |         port       = 11211\n[CI/Tests ]   |         protocol   = <asyncio.streams.StreamReaderProtocol object at 0x7f8a7ed71410>\n[CI/Tests ]   |         reader     = <StreamReader>\n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | \n[CI/Tests ]   | self = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ec86a70>\n[CI/Tests ]   | host = 'localhost', port = 11211\n[CI/Tests ]   | \n[CI/Tests ]   |     async def create_connection(\n[CI/Tests ]   |             self, protocol_factory, host=None, port=None,\n[CI/Tests ]   |             *, ssl=None, family=0,\n[CI/Tests ]   |             proto=0, flags=0, sock=None,\n[CI/Tests ]   |             local_addr=None, server_hostname=None,\n[CI/Tests ]   |             ssl_handshake_timeout=None):\n[CI/Tests ]   |         \"\"\"Connect to a TCP server.\n[CI/Tests ]   |     \n[CI/Tests ]   |         Create a streaming transport connection to a given Internet host and\n[CI/Tests ]   |         port: socket family AF_INET or socket.AF_INET6 depending on host (or\n[CI/Tests ]   |         family if specified), socket type SOCK_STREAM. protocol_factory must be\n[CI/Tests ]   |         a callable returning a protocol instance.\n[CI/Tests ]   |     \n[CI/Tests ]   |         This method is a coroutine which will try to establish the connection\n[CI/Tests ]   |         in the background.  When successful, the coroutine returns a\n[CI/Tests ]   |         (transport, protocol) pair.\n[CI/Tests ]   |         \"\"\"\n[CI/Tests ]   |         if server_hostname is not None and not ssl:\n[CI/Tests ]   |             raise ValueError('server_hostname is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if server_hostname is None and ssl:\n[CI/Tests ]   |             # Use host as default for server_hostname.  It is an error\n[CI/Tests ]   |             # if host is empty or not set, e.g. when an\n[CI/Tests ]   |             # already-connected socket was passed or when only a port\n[CI/Tests ]   |             # is given.  To avoid this error, you can pass\n[CI/Tests ]   |             # server_hostname='' -- this will bypass the hostname\n[CI/Tests ]   |             # check.  (This also means that if host is a numeric\n[CI/Tests ]   |             # IP/IPv6 address, we will attempt to verify that exact\n[CI/Tests ]   |             # address; this will probably fail, but it is possible to\n[CI/Tests ]   |             # create a certificate for a specific IP address, so we\n[CI/Tests ]   |             # don't judge it here.)\n[CI/Tests ]   |             if not host:\n[CI/Tests ]   |                 raise ValueError('You must set server_hostname '\n[CI/Tests ]   |                                  'when using ssl without a host')\n[CI/Tests ]   |             server_hostname = host\n[CI/Tests ]   |     \n[CI/Tests ]   |         if ssl_handshake_timeout is not None and not ssl:\n[CI/Tests ]   |             raise ValueError(\n[CI/Tests ]   |                 'ssl_handshake_timeout is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if host is not None or port is not None:\n[CI/Tests ]   |             if sock is not None:\n[CI/Tests ]   |                 raise ValueError(\n[CI/Tests ]   |                     'host/port and sock can not be specified at the same time')\n[CI/Tests ]   |     \n[CI/Tests ]   |             infos = await self._ensure_resolved(\n[CI/Tests ]   |                 (host, port), family=family,\n[CI/Tests ]   |                 type=socket.SOCK_STREAM, proto=proto, flags=flags, loop=self)\n[CI/Tests ]   |             if not infos:\n[CI/Tests ]   |                 raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             if local_addr is not None:\n[CI/Tests ]   |                 laddr_infos = await self._ensure_resolved(\n[CI/Tests ]   |                     local_addr, family=family,\n[CI/Tests ]   |                     type=socket.SOCK_STREAM, proto=proto,\n[CI/Tests ]   |                     flags=flags, loop=self)\n[CI/Tests ]   |                 if not laddr_infos:\n[CI/Tests ]   |                     raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             exceptions = []\n[CI/Tests ]   |             for family, type, proto, cname, address in infos:\n[CI/Tests ]   |                 try:\n[CI/Tests ]   |                     sock = socket.socket(family=family, type=type, proto=proto)\n[CI/Tests ]   |                     sock.setblocking(False)\n[CI/Tests ]   |                     if local_addr is not None:\n[CI/Tests ]   |                         for _, _, _, _, laddr in laddr_infos:\n[CI/Tests ]   |                             try:\n[CI/Tests ]   |                                 sock.bind(laddr)\n[CI/Tests ]   |                                 break\n[CI/Tests ]   |                             except OSError as exc:\n[CI/Tests ]   |                                 msg = (\n[CI/Tests ]   |                                     f'error while attempting to bind on '\n[CI/Tests ]   |                                     f'address {laddr!r}: '\n[CI/Tests ]   |                                     f'{exc.strerror.lower()}'\n[CI/Tests ]   |                                 )\n[CI/Tests ]   |                                 exc = OSError(exc.errno, msg)\n[CI/Tests ]   |                                 exceptions.append(exc)\n[CI/Tests ]   |                         else:\n[CI/Tests ]   |                             sock.close()\n[CI/Tests ]   |                             sock = None\n[CI/Tests ]   |                             continue\n[CI/Tests ]   |                     if self._debug:\n[CI/Tests ]   |                         logger.debug(\"connect %r to %r\", sock, address)\n[CI/Tests ]   |                     await self.sock_connect(sock, address)\n[CI/Tests ]   |                 except OSError as exc:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     exceptions.append(exc)\n[CI/Tests ]   |                 except:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     raise\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     break\n[CI/Tests ]   |             else:\n[CI/Tests ]   |                 if len(exceptions) == 1:\n[CI/Tests ]   |                     raise exceptions[0]\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     # If they all have the same str(), raise one.\n[CI/Tests ]   |                     model = str(exceptions[0])\n[CI/Tests ]   |                     if all(str(exc) == model for exc in exceptions):\n[CI/Tests ]   |                         raise exceptions[0]\n[CI/Tests ]   |                     # Raise a combined exception so the user can see all\n[CI/Tests ]   |                     # the various error messages.\n[CI/Tests ]   |                     raise OSError('Multiple exceptions: {}'.format(\n[CI/Tests ]   | >                       ', '.join(str(exc) for exc in exceptions)))\n[CI/Tests ]   | E                   OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | \n[CI/Tests ]   | address    = ('::1', 11211, 0, 0)\n[CI/Tests ]   | cname      = ''\n[CI/Tests ]   | exceptions = [ConnectionRefusedError(111, \"Connect call failed ('127.0.0.1', 11211)\"), OSError(99, 'Cannot assign requested address')]\n[CI/Tests ]   | family     = <AddressFamily.AF_INET6: 10>\n[CI/Tests ]   | flags      = 0\n[CI/Tests ]   | host       = 'localhost'\n[CI/Tests ]   | infos      = [(<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('127.0.0.1', 11211)), (<AddressFamily.AF_INET6: 10>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('::1', 11211, 0, 0))]\n[CI/Tests ]   | local_addr = None\n[CI/Tests ]   | model      = \"[Errno 111] Connect call failed ('127.0.0.1', 11211)\"\n[CI/Tests ]   | port       = 11211\n[CI/Tests ]   | proto      = 6\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ec86a70>\n[CI/Tests ]   | self       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | server_hostname = None\n[CI/Tests ]   | sock       = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6>\n[CI/Tests ]   | ssl        = None\n[CI/Tests ]   | ssl_handshake_timeout = None\n[CI/Tests ]   | type       = <SocketKind.SOCK_STREAM: 1>\n[CI/Tests ]   | \n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/base_events.py:971: OSError\n[CI/Tests ]   | __________________________________ test_incr ___________________________________\n[CI/Tests ]   | \n[CI/Tests ]   | mcache = <aiomcache.client.Client object at 0x7f8a7ee6b0d0>\n[CI/Tests ]   | \n[CI/Tests ]   |     async def test_incr(mcache: Client) -> None:\n[CI/Tests ]   |         key, value = b'key:incr:1', b'1'\n[CI/Tests ]   | >       await mcache.set(key, value)\n[CI/Tests ]   | \n[CI/Tests ]   | key        = b'key:incr:1'\n[CI/Tests ]   | mcache     = <aiomcache.client.Client object at 0x7f8a7ee6b0d0>\n[CI/Tests ]   | value      = b'1'\n[CI/Tests ]   | \n[CI/Tests ]   | tests/commands_test.py:282: \n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | aiomcache/client.py:40: in wrapper\n[CI/Tests ]   |     conn = await self._pool.acquire()\n[CI/Tests ]   |         args       = (b'key:incr:1', b'1')\n[CI/Tests ]   |         func       = <function FlagClient.set at 0x7f8a7edf9050>\n[CI/Tests ]   |         kwargs     = {}\n[CI/Tests ]   |         self       = <aiomcache.client.Client object at 0x7f8a7ee6b0d0>\n[CI/Tests ]   | aiomcache/pool.py:40: in acquire\n[CI/Tests ]   |     _conn = await self._create_new_conn()\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ee6bcd0>\n[CI/Tests ]   | aiomcache/pool.py:71: in _create_new_conn\n[CI/Tests ]   |     self._host, self._port, **self.conn_args)\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ee6bcd0>\n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/streams.py:77: in open_connection\n[CI/Tests ]   |     lambda: protocol, host, port, **kwds)\n[CI/Tests ]   |         host       = 'localhost'\n[CI/Tests ]   |         kwds       = {}\n[CI/Tests ]   |         limit      = 65536\n[CI/Tests ]   |         loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   |         port       = 11211\n[CI/Tests ]   |         protocol   = <asyncio.streams.StreamReaderProtocol object at 0x7f8a7ee6bfd0>\n[CI/Tests ]   |         reader     = <StreamReader>\n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | \n[CI/Tests ]   | self = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ed16320>\n[CI/Tests ]   | host = 'localhost', port = 11211\n[CI/Tests ]   | \n[CI/Tests ]   |     async def create_connection(\n[CI/Tests ]   |             self, protocol_factory, host=None, port=None,\n[CI/Tests ]   |             *, ssl=None, family=0,\n[CI/Tests ]   |             proto=0, flags=0, sock=None,\n[CI/Tests ]   |             local_addr=None, server_hostname=None,\n[CI/Tests ]   |             ssl_handshake_timeout=None):\n[CI/Tests ]   |         \"\"\"Connect to a TCP server.\n[CI/Tests ]   |     \n[CI/Tests ]   |         Create a streaming transport connection to a given Internet host and\n[CI/Tests ]   |         port: socket family AF_INET or socket.AF_INET6 depending on host (or\n[CI/Tests ]   |         family if specified), socket type SOCK_STREAM. protocol_factory must be\n[CI/Tests ]   |         a callable returning a protocol instance.\n[CI/Tests ]   |     \n[CI/Tests ]   |         This method is a coroutine which will try to establish the connection\n[CI/Tests ]   |         in the background.  When successful, the coroutine returns a\n[CI/Tests ]   |         (transport, protocol) pair.\n[CI/Tests ]   |         \"\"\"\n[CI/Tests ]   |         if server_hostname is not None and not ssl:\n[CI/Tests ]   |             raise ValueError('server_hostname is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if server_hostname is None and ssl:\n[CI/Tests ]   |             # Use host as default for server_hostname.  It is an error\n[CI/Tests ]   |             # if host is empty or not set, e.g. when an\n[CI/Tests ]   |             # already-connected socket was passed or when only a port\n[CI/Tests ]   |             # is given.  To avoid this error, you can pass\n[CI/Tests ]   |             # server_hostname='' -- this will bypass the hostname\n[CI/Tests ]   |             # check.  (This also means that if host is a numeric\n[CI/Tests ]   |             # IP/IPv6 address, we will attempt to verify that exact\n[CI/Tests ]   |             # address; this will probably fail, but it is possible to\n[CI/Tests ]   |             # create a certificate for a specific IP address, so we\n[CI/Tests ]   |             # don't judge it here.)\n[CI/Tests ]   |             if not host:\n[CI/Tests ]   |                 raise ValueError('You must set server_hostname '\n[CI/Tests ]   |                                  'when using ssl without a host')\n[CI/Tests ]   |             server_hostname = host\n[CI/Tests ]   |     \n[CI/Tests ]   |         if ssl_handshake_timeout is not None and not ssl:\n[CI/Tests ]   |             raise ValueError(\n[CI/Tests ]   |                 'ssl_handshake_timeout is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if host is not None or port is not None:\n[CI/Tests ]   |             if sock is not None:\n[CI/Tests ]   |                 raise ValueError(\n[CI/Tests ]   |                     'host/port and sock can not be specified at the same time')\n[CI/Tests ]   |     \n[CI/Tests ]   |             infos = await self._ensure_resolved(\n[CI/Tests ]   |                 (host, port), family=family,\n[CI/Tests ]   |                 type=socket.SOCK_STREAM, proto=proto, flags=flags, loop=self)\n[CI/Tests ]   |             if not infos:\n[CI/Tests ]   |                 raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             if local_addr is not None:\n[CI/Tests ]   |                 laddr_infos = await self._ensure_resolved(\n[CI/Tests ]   |                     local_addr, family=family,\n[CI/Tests ]   |                     type=socket.SOCK_STREAM, proto=proto,\n[CI/Tests ]   |                     flags=flags, loop=self)\n[CI/Tests ]   |                 if not laddr_infos:\n[CI/Tests ]   |                     raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             exceptions = []\n[CI/Tests ]   |             for family, type, proto, cname, address in infos:\n[CI/Tests ]   |                 try:\n[CI/Tests ]   |                     sock = socket.socket(family=family, type=type, proto=proto)\n[CI/Tests ]   |                     sock.setblocking(False)\n[CI/Tests ]   |                     if local_addr is not None:\n[CI/Tests ]   |                         for _, _, _, _, laddr in laddr_infos:\n[CI/Tests ]   |                             try:\n[CI/Tests ]   |                                 sock.bind(laddr)\n[CI/Tests ]   |                                 break\n[CI/Tests ]   |                             except OSError as exc:\n[CI/Tests ]   |                                 msg = (\n[CI/Tests ]   |                                     f'error while attempting to bind on '\n[CI/Tests ]   |                                     f'address {laddr!r}: '\n[CI/Tests ]   |                                     f'{exc.strerror.lower()}'\n[CI/Tests ]   |                                 )\n[CI/Tests ]   |                                 exc = OSError(exc.errno, msg)\n[CI/Tests ]   |                                 exceptions.append(exc)\n[CI/Tests ]   |                         else:\n[CI/Tests ]   |                             sock.close()\n[CI/Tests ]   |                             sock = None\n[CI/Tests ]   |                             continue\n[CI/Tests ]   |                     if self._debug:\n[CI/Tests ]   |                         logger.debug(\"connect %r to %r\", sock, address)\n[CI/Tests ]   |                     await self.sock_connect(sock, address)\n[CI/Tests ]   |                 except OSError as exc:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     exceptions.append(exc)\n[CI/Tests ]   |                 except:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     raise\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     break\n[CI/Tests ]   |             else:\n[CI/Tests ]   |                 if len(exceptions) == 1:\n[CI/Tests ]   |                     raise exceptions[0]\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     # If they all have the same str(), raise one.\n[CI/Tests ]   |                     model = str(exceptions[0])\n[CI/Tests ]   |                     if all(str(exc) == model for exc in exceptions):\n[CI/Tests ]   |                         raise exceptions[0]\n[CI/Tests ]   |                     # Raise a combined exception so the user can see all\n[CI/Tests ]   |                     # the various error messages.\n[CI/Tests ]   |                     raise OSError('Multiple exceptions: {}'.format(\n[CI/Tests ]   | >                       ', '.join(str(exc) for exc in exceptions)))\n[CI/Tests ]   | E                   OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | \n[CI/Tests ]   | address    = ('::1', 11211, 0, 0)\n[CI/Tests ]   | cname      = ''\n[CI/Tests ]   | exceptions = [ConnectionRefusedError(111, \"Connect call failed ('127.0.0.1', 11211)\"), OSError(99, 'Cannot assign requested address')]\n[CI/Tests ]   | family     = <AddressFamily.AF_INET6: 10>\n[CI/Tests ]   | flags      = 0\n[CI/Tests ]   | host       = 'localhost'\n[CI/Tests ]   | infos      = [(<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('127.0.0.1', 11211)), (<AddressFamily.AF_INET6: 10>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('::1', 11211, 0, 0))]\n[CI/Tests ]   | local_addr = None\n[CI/Tests ]   | model      = \"[Errno 111] Connect call failed ('127.0.0.1', 11211)\"\n[CI/Tests ]   | port       = 11211\n[CI/Tests ]   | proto      = 6\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ed16320>\n[CI/Tests ]   | self       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | server_hostname = None\n[CI/Tests ]   | sock       = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6>\n[CI/Tests ]   | ssl        = None\n[CI/Tests ]   | ssl_handshake_timeout = None\n[CI/Tests ]   | type       = <SocketKind.SOCK_STREAM: 1>\n[CI/Tests ]   | \n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/base_events.py:971: OSError\n[CI/Tests ]   | _______________________________ test_incr_errors _______________________________\n[CI/Tests ]   | \n[CI/Tests ]   | mcache = <aiomcache.client.Client object at 0x7f8a7d775ad0>\n[CI/Tests ]   | \n[CI/Tests ]   |     async def test_incr_errors(mcache: Client) -> None:\n[CI/Tests ]   |         key, value = b'key:incr:2', b'string'\n[CI/Tests ]   | >       await mcache.set(key, value)\n[CI/Tests ]   | \n[CI/Tests ]   | key        = b'key:incr:2'\n[CI/Tests ]   | mcache     = <aiomcache.client.Client object at 0x7f8a7d775ad0>\n[CI/Tests ]   | value      = b'string'\n[CI/Tests ]   | \n[CI/Tests ]   | tests/commands_test.py:294: \n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | aiomcache/client.py:40: in wrapper\n[CI/Tests ]   |     conn = await self._pool.acquire()\n[CI/Tests ]   |         args       = (b'key:incr:2', b'string')\n[CI/Tests ]   |         func       = <function FlagClient.set at 0x7f8a7edf9050>\n[CI/Tests ]   |         kwargs     = {}\n[CI/Tests ]   |         self       = <aiomcache.client.Client object at 0x7f8a7d775ad0>\n[CI/Tests ]   | aiomcache/pool.py:40: in acquire\n[CI/Tests ]   |     _conn = await self._create_new_conn()\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7d775b10>\n[CI/Tests ]   | aiomcache/pool.py:71: in _create_new_conn\n[CI/Tests ]   |     self._host, self._port, **self.conn_args)\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7d775b10>\n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/streams.py:77: in open_connection\n[CI/Tests ]   |     lambda: protocol, host, port, **kwds)\n[CI/Tests ]   |         host       = 'localhost'\n[CI/Tests ]   |         kwds       = {}\n[CI/Tests ]   |         limit      = 65536\n[CI/Tests ]   |         loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   |         port       = 11211\n[CI/Tests ]   |         protocol   = <asyncio.streams.StreamReaderProtocol object at 0x7f8a7d775c10>\n[CI/Tests ]   |         reader     = <StreamReader>\n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | \n[CI/Tests ]   | self = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ec864d0>\n[CI/Tests ]   | host = 'localhost', port = 11211\n[CI/Tests ]   | \n[CI/Tests ]   |     async def create_connection(\n[CI/Tests ]   |             self, protocol_factory, host=None, port=None,\n[CI/Tests ]   |             *, ssl=None, family=0,\n[CI/Tests ]   |             proto=0, flags=0, sock=None,\n[CI/Tests ]   |             local_addr=None, server_hostname=None,\n[CI/Tests ]   |             ssl_handshake_timeout=None):\n[CI/Tests ]   |         \"\"\"Connect to a TCP server.\n[CI/Tests ]   |     \n[CI/Tests ]   |         Create a streaming transport connection to a given Internet host and\n[CI/Tests ]   |         port: socket family AF_INET or socket.AF_INET6 depending on host (or\n[CI/Tests ]   |         family if specified), socket type SOCK_STREAM. protocol_factory must be\n[CI/Tests ]   |         a callable returning a protocol instance.\n[CI/Tests ]   |     \n[CI/Tests ]   |         This method is a coroutine which will try to establish the connection\n[CI/Tests ]   |         in the background.  When successful, the coroutine returns a\n[CI/Tests ]   |         (transport, protocol) pair.\n[CI/Tests ]   |         \"\"\"\n[CI/Tests ]   |         if server_hostname is not None and not ssl:\n[CI/Tests ]   |             raise ValueError('server_hostname is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if server_hostname is None and ssl:\n[CI/Tests ]   |             # Use host as default for server_hostname.  It is an error\n[CI/Tests ]   |             # if host is empty or not set, e.g. when an\n[CI/Tests ]   |             # already-connected socket was passed or when only a port\n[CI/Tests ]   |             # is given.  To avoid this error, you can pass\n[CI/Tests ]   |             # server_hostname='' -- this will bypass the hostname\n[CI/Tests ]   |             # check.  (This also means that if host is a numeric\n[CI/Tests ]   |             # IP/IPv6 address, we will attempt to verify that exact\n[CI/Tests ]   |             # address; this will probably fail, but it is possible to\n[CI/Tests ]   |             # create a certificate for a specific IP address, so we\n[CI/Tests ]   |             # don't judge it here.)\n[CI/Tests ]   |             if not host:\n[CI/Tests ]   |                 raise ValueError('You must set server_hostname '\n[CI/Tests ]   |                                  'when using ssl without a host')\n[CI/Tests ]   |             server_hostname = host\n[CI/Tests ]   |     \n[CI/Tests ]   |         if ssl_handshake_timeout is not None and not ssl:\n[CI/Tests ]   |             raise ValueError(\n[CI/Tests ]   |                 'ssl_handshake_timeout is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if host is not None or port is not None:\n[CI/Tests ]   |             if sock is not None:\n[CI/Tests ]   |                 raise ValueError(\n[CI/Tests ]   |                     'host/port and sock can not be specified at the same time')\n[CI/Tests ]   |     \n[CI/Tests ]   |             infos = await self._ensure_resolved(\n[CI/Tests ]   |                 (host, port), family=family,\n[CI/Tests ]   |                 type=socket.SOCK_STREAM, proto=proto, flags=flags, loop=self)\n[CI/Tests ]   |             if not infos:\n[CI/Tests ]   |                 raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             if local_addr is not None:\n[CI/Tests ]   |                 laddr_infos = await self._ensure_resolved(\n[CI/Tests ]   |                     local_addr, family=family,\n[CI/Tests ]   |                     type=socket.SOCK_STREAM, proto=proto,\n[CI/Tests ]   |                     flags=flags, loop=self)\n[CI/Tests ]   |                 if not laddr_infos:\n[CI/Tests ]   |                     raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             exceptions = []\n[CI/Tests ]   |             for family, type, proto, cname, address in infos:\n[CI/Tests ]   |                 try:\n[CI/Tests ]   |                     sock = socket.socket(family=family, type=type, proto=proto)\n[CI/Tests ]   |                     sock.setblocking(False)\n[CI/Tests ]   |                     if local_addr is not None:\n[CI/Tests ]   |                         for _, _, _, _, laddr in laddr_infos:\n[CI/Tests ]   |                             try:\n[CI/Tests ]   |                                 sock.bind(laddr)\n[CI/Tests ]   |                                 break\n[CI/Tests ]   |                             except OSError as exc:\n[CI/Tests ]   |                                 msg = (\n[CI/Tests ]   |                                     f'error while attempting to bind on '\n[CI/Tests ]   |                                     f'address {laddr!r}: '\n[CI/Tests ]   |                                     f'{exc.strerror.lower()}'\n[CI/Tests ]   |                                 )\n[CI/Tests ]   |                                 exc = OSError(exc.errno, msg)\n[CI/Tests ]   |                                 exceptions.append(exc)\n[CI/Tests ]   |                         else:\n[CI/Tests ]   |                             sock.close()\n[CI/Tests ]   |                             sock = None\n[CI/Tests ]   |                             continue\n[CI/Tests ]   |                     if self._debug:\n[CI/Tests ]   |                         logger.debug(\"connect %r to %r\", sock, address)\n[CI/Tests ]   |                     await self.sock_connect(sock, address)\n[CI/Tests ]   |                 except OSError as exc:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     exceptions.append(exc)\n[CI/Tests ]   |                 except:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     raise\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     break\n[CI/Tests ]   |             else:\n[CI/Tests ]   |                 if len(exceptions) == 1:\n[CI/Tests ]   |                     raise exceptions[0]\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     # If they all have the same str(), raise one.\n[CI/Tests ]   |                     model = str(exceptions[0])\n[CI/Tests ]   |                     if all(str(exc) == model for exc in exceptions):\n[CI/Tests ]   |                         raise exceptions[0]\n[CI/Tests ]   |                     # Raise a combined exception so the user can see all\n[CI/Tests ]   |                     # the various error messages.\n[CI/Tests ]   |                     raise OSError('Multiple exceptions: {}'.format(\n[CI/Tests ]   | >                       ', '.join(str(exc) for exc in exceptions)))\n[CI/Tests ]   | E                   OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | \n[CI/Tests ]   | address    = ('::1', 11211, 0, 0)\n[CI/Tests ]   | cname      = ''\n[CI/Tests ]   | exceptions = [ConnectionRefusedError(111, \"Connect call failed ('127.0.0.1', 11211)\"), OSError(99, 'Cannot assign requested address')]\n[CI/Tests ]   | family     = <AddressFamily.AF_INET6: 10>\n[CI/Tests ]   | flags      = 0\n[CI/Tests ]   | host       = 'localhost'\n[CI/Tests ]   | infos      = [(<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('127.0.0.1', 11211)), (<AddressFamily.AF_INET6: 10>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('::1', 11211, 0, 0))]\n[CI/Tests ]   | local_addr = None\n[CI/Tests ]   | model      = \"[Errno 111] Connect call failed ('127.0.0.1', 11211)\"\n[CI/Tests ]   | port       = 11211\n[CI/Tests ]   | proto      = 6\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ec864d0>\n[CI/Tests ]   | self       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | server_hostname = None\n[CI/Tests ]   | sock       = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6>\n[CI/Tests ]   | ssl        = None\n[CI/Tests ]   | ssl_handshake_timeout = None\n[CI/Tests ]   | type       = <SocketKind.SOCK_STREAM: 1>\n[CI/Tests ]   | \n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/base_events.py:971: OSError\n[CI/Tests ]   | __________________________________ test_decr ___________________________________\n[CI/Tests ]   | \n[CI/Tests ]   | mcache = <aiomcache.client.Client object at 0x7f8a7ef1f9d0>\n[CI/Tests ]   | \n[CI/Tests ]   |     async def test_decr(mcache: Client) -> None:\n[CI/Tests ]   |         key, value = b'key:decr:1', b'17'\n[CI/Tests ]   | >       await mcache.set(key, value)\n[CI/Tests ]   | \n[CI/Tests ]   | key        = b'key:decr:1'\n[CI/Tests ]   | mcache     = <aiomcache.client.Client object at 0x7f8a7ef1f9d0>\n[CI/Tests ]   | value      = b'17'\n[CI/Tests ]   | \n[CI/Tests ]   | tests/commands_test.py:305: \n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | aiomcache/client.py:40: in wrapper\n[CI/Tests ]   |     conn = await self._pool.acquire()\n[CI/Tests ]   |         args       = (b'key:decr:1', b'17')\n[CI/Tests ]   |         func       = <function FlagClient.set at 0x7f8a7edf9050>\n[CI/Tests ]   |         kwargs     = {}\n[CI/Tests ]   |         self       = <aiomcache.client.Client object at 0x7f8a7ef1f9d0>\n[CI/Tests ]   | aiomcache/pool.py:40: in acquire\n[CI/Tests ]   |     _conn = await self._create_new_conn()\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ef1f390>\n[CI/Tests ]   | aiomcache/pool.py:71: in _create_new_conn\n[CI/Tests ]   |     self._host, self._port, **self.conn_args)\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ef1f390>\n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/streams.py:77: in open_connection\n[CI/Tests ]   |     lambda: protocol, host, port, **kwds)\n[CI/Tests ]   |         host       = 'localhost'\n[CI/Tests ]   |         kwds       = {}\n[CI/Tests ]   |         limit      = 65536\n[CI/Tests ]   |         loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   |         port       = 11211\n[CI/Tests ]   |         protocol   = <asyncio.streams.StreamReaderProtocol object at 0x7f8a7ef1fa10>\n[CI/Tests ]   |         reader     = <StreamReader>\n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | \n[CI/Tests ]   | self = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ec868c0>\n[CI/Tests ]   | host = 'localhost', port = 11211\n[CI/Tests ]   | \n[CI/Tests ]   |     async def create_connection(\n[CI/Tests ]   |             self, protocol_factory, host=None, port=None,\n[CI/Tests ]   |             *, ssl=None, family=0,\n[CI/Tests ]   |             proto=0, flags=0, sock=None,\n[CI/Tests ]   |             local_addr=None, server_hostname=None,\n[CI/Tests ]   |             ssl_handshake_timeout=None):\n[CI/Tests ]   |         \"\"\"Connect to a TCP server.\n[CI/Tests ]   |     \n[CI/Tests ]   |         Create a streaming transport connection to a given Internet host and\n[CI/Tests ]   |         port: socket family AF_INET or socket.AF_INET6 depending on host (or\n[CI/Tests ]   |         family if specified), socket type SOCK_STREAM. protocol_factory must be\n[CI/Tests ]   |         a callable returning a protocol instance.\n[CI/Tests ]   |     \n[CI/Tests ]   |         This method is a coroutine which will try to establish the connection\n[CI/Tests ]   |         in the background.  When successful, the coroutine returns a\n[CI/Tests ]   |         (transport, protocol) pair.\n[CI/Tests ]   |         \"\"\"\n[CI/Tests ]   |         if server_hostname is not None and not ssl:\n[CI/Tests ]   |             raise ValueError('server_hostname is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if server_hostname is None and ssl:\n[CI/Tests ]   |             # Use host as default for server_hostname.  It is an error\n[CI/Tests ]   |             # if host is empty or not set, e.g. when an\n[CI/Tests ]   |             # already-connected socket was passed or when only a port\n[CI/Tests ]   |             # is given.  To avoid this error, you can pass\n[CI/Tests ]   |             # server_hostname='' -- this will bypass the hostname\n[CI/Tests ]   |             # check.  (This also means that if host is a numeric\n[CI/Tests ]   |             # IP/IPv6 address, we will attempt to verify that exact\n[CI/Tests ]   |             # address; this will probably fail, but it is possible to\n[CI/Tests ]   |             # create a certificate for a specific IP address, so we\n[CI/Tests ]   |             # don't judge it here.)\n[CI/Tests ]   |             if not host:\n[CI/Tests ]   |                 raise ValueError('You must set server_hostname '\n[CI/Tests ]   |                                  'when using ssl without a host')\n[CI/Tests ]   |             server_hostname = host\n[CI/Tests ]   |     \n[CI/Tests ]   |         if ssl_handshake_timeout is not None and not ssl:\n[CI/Tests ]   |             raise ValueError(\n[CI/Tests ]   |                 'ssl_handshake_timeout is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if host is not None or port is not None:\n[CI/Tests ]   |             if sock is not None:\n[CI/Tests ]   |                 raise ValueError(\n[CI/Tests ]   |                     'host/port and sock can not be specified at the same time')\n[CI/Tests ]   |     \n[CI/Tests ]   |             infos = await self._ensure_resolved(\n[CI/Tests ]   |                 (host, port), family=family,\n[CI/Tests ]   |                 type=socket.SOCK_STREAM, proto=proto, flags=flags, loop=self)\n[CI/Tests ]   |             if not infos:\n[CI/Tests ]   |                 raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             if local_addr is not None:\n[CI/Tests ]   |                 laddr_infos = await self._ensure_resolved(\n[CI/Tests ]   |                     local_addr, family=family,\n[CI/Tests ]   |                     type=socket.SOCK_STREAM, proto=proto,\n[CI/Tests ]   |                     flags=flags, loop=self)\n[CI/Tests ]   |                 if not laddr_infos:\n[CI/Tests ]   |                     raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             exceptions = []\n[CI/Tests ]   |             for family, type, proto, cname, address in infos:\n[CI/Tests ]   |                 try:\n[CI/Tests ]   |                     sock = socket.socket(family=family, type=type, proto=proto)\n[CI/Tests ]   |                     sock.setblocking(False)\n[CI/Tests ]   |                     if local_addr is not None:\n[CI/Tests ]   |                         for _, _, _, _, laddr in laddr_infos:\n[CI/Tests ]   |                             try:\n[CI/Tests ]   |                                 sock.bind(laddr)\n[CI/Tests ]   |                                 break\n[CI/Tests ]   |                             except OSError as exc:\n[CI/Tests ]   |                                 msg = (\n[CI/Tests ]   |                                     f'error while attempting to bind on '\n[CI/Tests ]   |                                     f'address {laddr!r}: '\n[CI/Tests ]   |                                     f'{exc.strerror.lower()}'\n[CI/Tests ]   |                                 )\n[CI/Tests ]   |                                 exc = OSError(exc.errno, msg)\n[CI/Tests ]   |                                 exceptions.append(exc)\n[CI/Tests ]   |                         else:\n[CI/Tests ]   |                             sock.close()\n[CI/Tests ]   |                             sock = None\n[CI/Tests ]   |                             continue\n[CI/Tests ]   |                     if self._debug:\n[CI/Tests ]   |                         logger.debug(\"connect %r to %r\", sock, address)\n[CI/Tests ]   |                     await self.sock_connect(sock, address)\n[CI/Tests ]   |                 except OSError as exc:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     exceptions.append(exc)\n[CI/Tests ]   |                 except:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     raise\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     break\n[CI/Tests ]   |             else:\n[CI/Tests ]   |                 if len(exceptions) == 1:\n[CI/Tests ]   |                     raise exceptions[0]\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     # If they all have the same str(), raise one.\n[CI/Tests ]   |                     model = str(exceptions[0])\n[CI/Tests ]   |                     if all(str(exc) == model for exc in exceptions):\n[CI/Tests ]   |                         raise exceptions[0]\n[CI/Tests ]   |                     # Raise a combined exception so the user can see all\n[CI/Tests ]   |                     # the various error messages.\n[CI/Tests ]   |                     raise OSError('Multiple exceptions: {}'.format(\n[CI/Tests ]   | >                       ', '.join(str(exc) for exc in exceptions)))\n[CI/Tests ]   | E                   OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | \n[CI/Tests ]   | address    = ('::1', 11211, 0, 0)\n[CI/Tests ]   | cname      = ''\n[CI/Tests ]   | exceptions = [ConnectionRefusedError(111, \"Connect call failed ('127.0.0.1', 11211)\"), OSError(99, 'Cannot assign requested address')]\n[CI/Tests ]   | family     = <AddressFamily.AF_INET6: 10>\n[CI/Tests ]   | flags      = 0\n[CI/Tests ]   | host       = 'localhost'\n[CI/Tests ]   | infos      = [(<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('127.0.0.1', 11211)), (<AddressFamily.AF_INET6: 10>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('::1', 11211, 0, 0))]\n[CI/Tests ]   | local_addr = None\n[CI/Tests ]   | model      = \"[Errno 111] Connect call failed ('127.0.0.1', 11211)\"\n[CI/Tests ]   | port       = 11211\n[CI/Tests ]   | proto      = 6\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ec868c0>\n[CI/Tests ]   | self       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | server_hostname = None\n[CI/Tests ]   | sock       = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6>\n[CI/Tests ]   | ssl        = None\n[CI/Tests ]   | ssl_handshake_timeout = None\n[CI/Tests ]   | type       = <SocketKind.SOCK_STREAM: 1>\n[CI/Tests ]   | \n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/base_events.py:971: OSError\n[CI/Tests ]   | _______________________________ test_decr_errors _______________________________\n[CI/Tests ]   | \n[CI/Tests ]   | mcache = <aiomcache.client.Client object at 0x7f8a7e0bc290>\n[CI/Tests ]   | \n[CI/Tests ]   |     async def test_decr_errors(mcache: Client) -> None:\n[CI/Tests ]   |         key, value = b'key:decr:2', b'string'\n[CI/Tests ]   | >       await mcache.set(key, value)\n[CI/Tests ]   | \n[CI/Tests ]   | key        = b'key:decr:2'\n[CI/Tests ]   | mcache     = <aiomcache.client.Client object at 0x7f8a7e0bc290>\n[CI/Tests ]   | value      = b'string'\n[CI/Tests ]   | \n[CI/Tests ]   | tests/commands_test.py:319: \n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | aiomcache/client.py:40: in wrapper\n[CI/Tests ]   |     conn = await self._pool.acquire()\n[CI/Tests ]   |         args       = (b'key:decr:2', b'string')\n[CI/Tests ]   |         func       = <function FlagClient.set at 0x7f8a7edf9050>\n[CI/Tests ]   |         kwargs     = {}\n[CI/Tests ]   |         self       = <aiomcache.client.Client object at 0x7f8a7e0bc290>\n[CI/Tests ]   | aiomcache/pool.py:40: in acquire\n[CI/Tests ]   |     _conn = await self._create_new_conn()\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7e0bc250>\n[CI/Tests ]   | aiomcache/pool.py:71: in _create_new_conn\n[CI/Tests ]   |     self._host, self._port, **self.conn_args)\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7e0bc250>\n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/streams.py:77: in open_connection\n[CI/Tests ]   |     lambda: protocol, host, port, **kwds)\n[CI/Tests ]   |         host       = 'localhost'\n[CI/Tests ]   |         kwds       = {}\n[CI/Tests ]   |         limit      = 65536\n[CI/Tests ]   |         loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   |         port       = 11211\n[CI/Tests ]   |         protocol   = <asyncio.streams.StreamReaderProtocol object at 0x7f8a7e0bc3d0>\n[CI/Tests ]   |         reader     = <StreamReader>\n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | \n[CI/Tests ]   | self = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ec86cb0>\n[CI/Tests ]   | host = 'localhost', port = 11211\n[CI/Tests ]   | \n[CI/Tests ]   |     async def create_connection(\n[CI/Tests ]   |             self, protocol_factory, host=None, port=None,\n[CI/Tests ]   |             *, ssl=None, family=0,\n[CI/Tests ]   |             proto=0, flags=0, sock=None,\n[CI/Tests ]   |             local_addr=None, server_hostname=None,\n[CI/Tests ]   |             ssl_handshake_timeout=None):\n[CI/Tests ]   |         \"\"\"Connect to a TCP server.\n[CI/Tests ]   |     \n[CI/Tests ]   |         Create a streaming transport connection to a given Internet host and\n[CI/Tests ]   |         port: socket family AF_INET or socket.AF_INET6 depending on host (or\n[CI/Tests ]   |         family if specified), socket type SOCK_STREAM. protocol_factory must be\n[CI/Tests ]   |         a callable returning a protocol instance.\n[CI/Tests ]   |     \n[CI/Tests ]   |         This method is a coroutine which will try to establish the connection\n[CI/Tests ]   |         in the background.  When successful, the coroutine returns a\n[CI/Tests ]   |         (transport, protocol) pair.\n[CI/Tests ]   |         \"\"\"\n[CI/Tests ]   |         if server_hostname is not None and not ssl:\n[CI/Tests ]   |             raise ValueError('server_hostname is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if server_hostname is None and ssl:\n[CI/Tests ]   |             # Use host as default for server_hostname.  It is an error\n[CI/Tests ]   |             # if host is empty or not set, e.g. when an\n[CI/Tests ]   |             # already-connected socket was passed or when only a port\n[CI/Tests ]   |             # is given.  To avoid this error, you can pass\n[CI/Tests ]   |             # server_hostname='' -- this will bypass the hostname\n[CI/Tests ]   |             # check.  (This also means that if host is a numeric\n[CI/Tests ]   |             # IP/IPv6 address, we will attempt to verify that exact\n[CI/Tests ]   |             # address; this will probably fail, but it is possible to\n[CI/Tests ]   |             # create a certificate for a specific IP address, so we\n[CI/Tests ]   |             # don't judge it here.)\n[CI/Tests ]   |             if not host:\n[CI/Tests ]   |                 raise ValueError('You must set server_hostname '\n[CI/Tests ]   |                                  'when using ssl without a host')\n[CI/Tests ]   |             server_hostname = host\n[CI/Tests ]   |     \n[CI/Tests ]   |         if ssl_handshake_timeout is not None and not ssl:\n[CI/Tests ]   |             raise ValueError(\n[CI/Tests ]   |                 'ssl_handshake_timeout is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if host is not None or port is not None:\n[CI/Tests ]   |             if sock is not None:\n[CI/Tests ]   |                 raise ValueError(\n[CI/Tests ]   |                     'host/port and sock can not be specified at the same time')\n[CI/Tests ]   |     \n[CI/Tests ]   |             infos = await self._ensure_resolved(\n[CI/Tests ]   |                 (host, port), family=family,\n[CI/Tests ]   |                 type=socket.SOCK_STREAM, proto=proto, flags=flags, loop=self)\n[CI/Tests ]   |             if not infos:\n[CI/Tests ]   |                 raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             if local_addr is not None:\n[CI/Tests ]   |                 laddr_infos = await self._ensure_resolved(\n[CI/Tests ]   |                     local_addr, family=family,\n[CI/Tests ]   |                     type=socket.SOCK_STREAM, proto=proto,\n[CI/Tests ]   |                     flags=flags, loop=self)\n[CI/Tests ]   |                 if not laddr_infos:\n[CI/Tests ]   |                     raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             exceptions = []\n[CI/Tests ]   |             for family, type, proto, cname, address in infos:\n[CI/Tests ]   |                 try:\n[CI/Tests ]   |                     sock = socket.socket(family=family, type=type, proto=proto)\n[CI/Tests ]   |                     sock.setblocking(False)\n[CI/Tests ]   |                     if local_addr is not None:\n[CI/Tests ]   |                         for _, _, _, _, laddr in laddr_infos:\n[CI/Tests ]   |                             try:\n[CI/Tests ]   |                                 sock.bind(laddr)\n[CI/Tests ]   |                                 break\n[CI/Tests ]   |                             except OSError as exc:\n[CI/Tests ]   |                                 msg = (\n[CI/Tests ]   |                                     f'error while attempting to bind on '\n[CI/Tests ]   |                                     f'address {laddr!r}: '\n[CI/Tests ]   |                                     f'{exc.strerror.lower()}'\n[CI/Tests ]   |                                 )\n[CI/Tests ]   |                                 exc = OSError(exc.errno, msg)\n[CI/Tests ]   |                                 exceptions.append(exc)\n[CI/Tests ]   |                         else:\n[CI/Tests ]   |                             sock.close()\n[CI/Tests ]   |                             sock = None\n[CI/Tests ]   |                             continue\n[CI/Tests ]   |                     if self._debug:\n[CI/Tests ]   |                         logger.debug(\"connect %r to %r\", sock, address)\n[CI/Tests ]   |                     await self.sock_connect(sock, address)\n[CI/Tests ]   |                 except OSError as exc:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     exceptions.append(exc)\n[CI/Tests ]   |                 except:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     raise\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     break\n[CI/Tests ]   |             else:\n[CI/Tests ]   |                 if len(exceptions) == 1:\n[CI/Tests ]   |                     raise exceptions[0]\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     # If they all have the same str(), raise one.\n[CI/Tests ]   |                     model = str(exceptions[0])\n[CI/Tests ]   |                     if all(str(exc) == model for exc in exceptions):\n[CI/Tests ]   |                         raise exceptions[0]\n[CI/Tests ]   |                     # Raise a combined exception so the user can see all\n[CI/Tests ]   |                     # the various error messages.\n[CI/Tests ]   |                     raise OSError('Multiple exceptions: {}'.format(\n[CI/Tests ]   | >                       ', '.join(str(exc) for exc in exceptions)))\n[CI/Tests ]   | E                   OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | \n[CI/Tests ]   | address    = ('::1', 11211, 0, 0)\n[CI/Tests ]   | cname      = ''\n[CI/Tests ]   | exceptions = [ConnectionRefusedError(111, \"Connect call failed ('127.0.0.1', 11211)\"), OSError(99, 'Cannot assign requested address')]\n[CI/Tests ]   | family     = <AddressFamily.AF_INET6: 10>\n[CI/Tests ]   | flags      = 0\n[CI/Tests ]   | host       = 'localhost'\n[CI/Tests ]   | infos      = [(<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('127.0.0.1', 11211)), (<AddressFamily.AF_INET6: 10>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('::1', 11211, 0, 0))]\n[CI/Tests ]   | local_addr = None\n[CI/Tests ]   | model      = \"[Errno 111] Connect call failed ('127.0.0.1', 11211)\"\n[CI/Tests ]   | port       = 11211\n[CI/Tests ]   | proto      = 6\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ec86cb0>\n[CI/Tests ]   | self       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | server_hostname = None\n[CI/Tests ]   | sock       = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6>\n[CI/Tests ]   | ssl        = None\n[CI/Tests ]   | ssl_handshake_timeout = None\n[CI/Tests ]   | type       = <SocketKind.SOCK_STREAM: 1>\n[CI/Tests ]   | \n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/base_events.py:971: OSError\n[CI/Tests ]   | __________________________________ test_stats __________________________________\n[CI/Tests ]   | \n[CI/Tests ]   | mcache = <aiomcache.client.Client object at 0x7f8a7edd6590>\n[CI/Tests ]   | \n[CI/Tests ]   |     async def test_stats(mcache: Client) -> None:\n[CI/Tests ]   | >       stats = await mcache.stats()\n[CI/Tests ]   | \n[CI/Tests ]   | mcache     = <aiomcache.client.Client object at 0x7f8a7edd6590>\n[CI/Tests ]   | \n[CI/Tests ]   | tests/commands_test.py:329: \n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | aiomcache/client.py:40: in wrapper\n[CI/Tests ]   |     conn = await self._pool.acquire()\n[CI/Tests ]   |         args       = ()\n[CI/Tests ]   |         func       = <function FlagClient.stats at 0x7f8a7ef62e60>\n[CI/Tests ]   |         kwargs     = {}\n[CI/Tests ]   |         self       = <aiomcache.client.Client object at 0x7f8a7edd6590>\n[CI/Tests ]   | aiomcache/pool.py:40: in acquire\n[CI/Tests ]   |     _conn = await self._create_new_conn()\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7edd6d10>\n[CI/Tests ]   | aiomcache/pool.py:71: in _create_new_conn\n[CI/Tests ]   |     self._host, self._port, **self.conn_args)\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7edd6d10>\n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/streams.py:77: in open_connection\n[CI/Tests ]   |     lambda: protocol, host, port, **kwds)\n[CI/Tests ]   |         host       = 'localhost'\n[CI/Tests ]   |         kwds       = {}\n[CI/Tests ]   |         limit      = 65536\n[CI/Tests ]   |         loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   |         port       = 11211\n[CI/Tests ]   |         protocol   = <asyncio.streams.StreamReaderProtocol object at 0x7f8a7edd64d0>\n[CI/Tests ]   |         reader     = <StreamReader>\n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | \n[CI/Tests ]   | self = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ed16b90>\n[CI/Tests ]   | host = 'localhost', port = 11211\n[CI/Tests ]   | \n[CI/Tests ]   |     async def create_connection(\n[CI/Tests ]   |             self, protocol_factory, host=None, port=None,\n[CI/Tests ]   |             *, ssl=None, family=0,\n[CI/Tests ]   |             proto=0, flags=0, sock=None,\n[CI/Tests ]   |             local_addr=None, server_hostname=None,\n[CI/Tests ]   |             ssl_handshake_timeout=None):\n[CI/Tests ]   |         \"\"\"Connect to a TCP server.\n[CI/Tests ]   |     \n[CI/Tests ]   |         Create a streaming transport connection to a given Internet host and\n[CI/Tests ]   |         port: socket family AF_INET or socket.AF_INET6 depending on host (or\n[CI/Tests ]   |         family if specified), socket type SOCK_STREAM. protocol_factory must be\n[CI/Tests ]   |         a callable returning a protocol instance.\n[CI/Tests ]   |     \n[CI/Tests ]   |         This method is a coroutine which will try to establish the connection\n[CI/Tests ]   |         in the background.  When successful, the coroutine returns a\n[CI/Tests ]   |         (transport, protocol) pair.\n[CI/Tests ]   |         \"\"\"\n[CI/Tests ]   |         if server_hostname is not None and not ssl:\n[CI/Tests ]   |             raise ValueError('server_hostname is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if server_hostname is None and ssl:\n[CI/Tests ]   |             # Use host as default for server_hostname.  It is an error\n[CI/Tests ]   |             # if host is empty or not set, e.g. when an\n[CI/Tests ]   |             # already-connected socket was passed or when only a port\n[CI/Tests ]   |             # is given.  To avoid this error, you can pass\n[CI/Tests ]   |             # server_hostname='' -- this will bypass the hostname\n[CI/Tests ]   |             # check.  (This also means that if host is a numeric\n[CI/Tests ]   |             # IP/IPv6 address, we will attempt to verify that exact\n[CI/Tests ]   |             # address; this will probably fail, but it is possible to\n[CI/Tests ]   |             # create a certificate for a specific IP address, so we\n[CI/Tests ]   |             # don't judge it here.)\n[CI/Tests ]   |             if not host:\n[CI/Tests ]   |                 raise ValueError('You must set server_hostname '\n[CI/Tests ]   |                                  'when using ssl without a host')\n[CI/Tests ]   |             server_hostname = host\n[CI/Tests ]   |     \n[CI/Tests ]   |         if ssl_handshake_timeout is not None and not ssl:\n[CI/Tests ]   |             raise ValueError(\n[CI/Tests ]   |                 'ssl_handshake_timeout is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if host is not None or port is not None:\n[CI/Tests ]   |             if sock is not None:\n[CI/Tests ]   |                 raise ValueError(\n[CI/Tests ]   |                     'host/port and sock can not be specified at the same time')\n[CI/Tests ]   |     \n[CI/Tests ]   |             infos = await self._ensure_resolved(\n[CI/Tests ]   |                 (host, port), family=family,\n[CI/Tests ]   |                 type=socket.SOCK_STREAM, proto=proto, flags=flags, loop=self)\n[CI/Tests ]   |             if not infos:\n[CI/Tests ]   |                 raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             if local_addr is not None:\n[CI/Tests ]   |                 laddr_infos = await self._ensure_resolved(\n[CI/Tests ]   |                     local_addr, family=family,\n[CI/Tests ]   |                     type=socket.SOCK_STREAM, proto=proto,\n[CI/Tests ]   |                     flags=flags, loop=self)\n[CI/Tests ]   |                 if not laddr_infos:\n[CI/Tests ]   |                     raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             exceptions = []\n[CI/Tests ]   |             for family, type, proto, cname, address in infos:\n[CI/Tests ]   |                 try:\n[CI/Tests ]   |                     sock = socket.socket(family=family, type=type, proto=proto)\n[CI/Tests ]   |                     sock.setblocking(False)\n[CI/Tests ]   |                     if local_addr is not None:\n[CI/Tests ]   |                         for _, _, _, _, laddr in laddr_infos:\n[CI/Tests ]   |                             try:\n[CI/Tests ]   |                                 sock.bind(laddr)\n[CI/Tests ]   |                                 break\n[CI/Tests ]   |                             except OSError as exc:\n[CI/Tests ]   |                                 msg = (\n[CI/Tests ]   |                                     f'error while attempting to bind on '\n[CI/Tests ]   |                                     f'address {laddr!r}: '\n[CI/Tests ]   |                                     f'{exc.strerror.lower()}'\n[CI/Tests ]   |                                 )\n[CI/Tests ]   |                                 exc = OSError(exc.errno, msg)\n[CI/Tests ]   |                                 exceptions.append(exc)\n[CI/Tests ]   |                         else:\n[CI/Tests ]   |                             sock.close()\n[CI/Tests ]   |                             sock = None\n[CI/Tests ]   |                             continue\n[CI/Tests ]   |                     if self._debug:\n[CI/Tests ]   |                         logger.debug(\"connect %r to %r\", sock, address)\n[CI/Tests ]   |                     await self.sock_connect(sock, address)\n[CI/Tests ]   |                 except OSError as exc:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     exceptions.append(exc)\n[CI/Tests ]   |                 except:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     raise\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     break\n[CI/Tests ]   |             else:\n[CI/Tests ]   |                 if len(exceptions) == 1:\n[CI/Tests ]   |                     raise exceptions[0]\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     # If they all have the same str(), raise one.\n[CI/Tests ]   |                     model = str(exceptions[0])\n[CI/Tests ]   |                     if all(str(exc) == model for exc in exceptions):\n[CI/Tests ]   |                         raise exceptions[0]\n[CI/Tests ]   |                     # Raise a combined exception so the user can see all\n[CI/Tests ]   |                     # the various error messages.\n[CI/Tests ]   |                     raise OSError('Multiple exceptions: {}'.format(\n[CI/Tests ]   | >                       ', '.join(str(exc) for exc in exceptions)))\n[CI/Tests ]   | E                   OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | \n[CI/Tests ]   | address    = ('::1', 11211, 0, 0)\n[CI/Tests ]   | cname      = ''\n[CI/Tests ]   | exceptions = [ConnectionRefusedError(111, \"Connect call failed ('127.0.0.1', 11211)\"), OSError(99, 'Cannot assign requested address')]\n[CI/Tests ]   | family     = <AddressFamily.AF_INET6: 10>\n[CI/Tests ]   | flags      = 0\n[CI/Tests ]   | host       = 'localhost'\n[CI/Tests ]   | infos      = [(<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('127.0.0.1', 11211)), (<AddressFamily.AF_INET6: 10>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('::1', 11211, 0, 0))]\n[CI/Tests ]   | local_addr = None\n[CI/Tests ]   | model      = \"[Errno 111] Connect call failed ('127.0.0.1', 11211)\"\n[CI/Tests ]   | port       = 11211\n[CI/Tests ]   | proto      = 6\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ed16b90>\n[CI/Tests ]   | self       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | server_hostname = None\n[CI/Tests ]   | sock       = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6>\n[CI/Tests ]   | ssl        = None\n[CI/Tests ]   | ssl_handshake_timeout = None\n[CI/Tests ]   | type       = <SocketKind.SOCK_STREAM: 1>\n[CI/Tests ]   | \n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/base_events.py:971: OSError\n[CI/Tests ]   | __________________________________ test_touch __________________________________\n[CI/Tests ]   | \n[CI/Tests ]   | mcache = <aiomcache.client.Client object at 0x7f8a7e9f54d0>\n[CI/Tests ]   | \n[CI/Tests ]   |     async def test_touch(mcache: Client) -> None:\n[CI/Tests ]   |         key, value = b'key:touch:1', b'17'\n[CI/Tests ]   | >       await mcache.set(key, value)\n[CI/Tests ]   | \n[CI/Tests ]   | key        = b'key:touch:1'\n[CI/Tests ]   | mcache     = <aiomcache.client.Client object at 0x7f8a7e9f54d0>\n[CI/Tests ]   | value      = b'17'\n[CI/Tests ]   | \n[CI/Tests ]   | tests/commands_test.py:335: \n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | aiomcache/client.py:40: in wrapper\n[CI/Tests ]   |     conn = await self._pool.acquire()\n[CI/Tests ]   |         args       = (b'key:touch:1', b'17')\n[CI/Tests ]   |         func       = <function FlagClient.set at 0x7f8a7edf9050>\n[CI/Tests ]   |         kwargs     = {}\n[CI/Tests ]   |         self       = <aiomcache.client.Client object at 0x7f8a7e9f54d0>\n[CI/Tests ]   | aiomcache/pool.py:40: in acquire\n[CI/Tests ]   |     _conn = await self._create_new_conn()\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7e9f5550>\n[CI/Tests ]   | aiomcache/pool.py:71: in _create_new_conn\n[CI/Tests ]   |     self._host, self._port, **self.conn_args)\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7e9f5550>\n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/streams.py:77: in open_connection\n[CI/Tests ]   |     lambda: protocol, host, port, **kwds)\n[CI/Tests ]   |         host       = 'localhost'\n[CI/Tests ]   |         kwds       = {}\n[CI/Tests ]   |         limit      = 65536\n[CI/Tests ]   |         loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   |         port       = 11211\n[CI/Tests ]   |         protocol   = <asyncio.streams.StreamReaderProtocol object at 0x7f8a7e9f57d0>\n[CI/Tests ]   |         reader     = <StreamReader>\n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | \n[CI/Tests ]   | self = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ea66680>\n[CI/Tests ]   | host = 'localhost', port = 11211\n[CI/Tests ]   | \n[CI/Tests ]   |     async def create_connection(\n[CI/Tests ]   |             self, protocol_factory, host=None, port=None,\n[CI/Tests ]   |             *, ssl=None, family=0,\n[CI/Tests ]   |             proto=0, flags=0, sock=None,\n[CI/Tests ]   |             local_addr=None, server_hostname=None,\n[CI/Tests ]   |             ssl_handshake_timeout=None):\n[CI/Tests ]   |         \"\"\"Connect to a TCP server.\n[CI/Tests ]   |     \n[CI/Tests ]   |         Create a streaming transport connection to a given Internet host and\n[CI/Tests ]   |         port: socket family AF_INET or socket.AF_INET6 depending on host (or\n[CI/Tests ]   |         family if specified), socket type SOCK_STREAM. protocol_factory must be\n[CI/Tests ]   |         a callable returning a protocol instance.\n[CI/Tests ]   |     \n[CI/Tests ]   |         This method is a coroutine which will try to establish the connection\n[CI/Tests ]   |         in the background.  When successful, the coroutine returns a\n[CI/Tests ]   |         (transport, protocol) pair.\n[CI/Tests ]   |         \"\"\"\n[CI/Tests ]   |         if server_hostname is not None and not ssl:\n[CI/Tests ]   |             raise ValueError('server_hostname is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if server_hostname is None and ssl:\n[CI/Tests ]   |             # Use host as default for server_hostname.  It is an error\n[CI/Tests ]   |             # if host is empty or not set, e.g. when an\n[CI/Tests ]   |             # already-connected socket was passed or when only a port\n[CI/Tests ]   |             # is given.  To avoid this error, you can pass\n[CI/Tests ]   |             # server_hostname='' -- this will bypass the hostname\n[CI/Tests ]   |             # check.  (This also means that if host is a numeric\n[CI/Tests ]   |             # IP/IPv6 address, we will attempt to verify that exact\n[CI/Tests ]   |             # address; this will probably fail, but it is possible to\n[CI/Tests ]   |             # create a certificate for a specific IP address, so we\n[CI/Tests ]   |             # don't judge it here.)\n[CI/Tests ]   |             if not host:\n[CI/Tests ]   |                 raise ValueError('You must set server_hostname '\n[CI/Tests ]   |                                  'when using ssl without a host')\n[CI/Tests ]   |             server_hostname = host\n[CI/Tests ]   |     \n[CI/Tests ]   |         if ssl_handshake_timeout is not None and not ssl:\n[CI/Tests ]   |             raise ValueError(\n[CI/Tests ]   |                 'ssl_handshake_timeout is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if host is not None or port is not None:\n[CI/Tests ]   |             if sock is not None:\n[CI/Tests ]   |                 raise ValueError(\n[CI/Tests ]   |                     'host/port and sock can not be specified at the same time')\n[CI/Tests ]   |     \n[CI/Tests ]   |             infos = await self._ensure_resolved(\n[CI/Tests ]   |                 (host, port), family=family,\n[CI/Tests ]   |                 type=socket.SOCK_STREAM, proto=proto, flags=flags, loop=self)\n[CI/Tests ]   |             if not infos:\n[CI/Tests ]   |                 raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             if local_addr is not None:\n[CI/Tests ]   |                 laddr_infos = await self._ensure_resolved(\n[CI/Tests ]   |                     local_addr, family=family,\n[CI/Tests ]   |                     type=socket.SOCK_STREAM, proto=proto,\n[CI/Tests ]   |                     flags=flags, loop=self)\n[CI/Tests ]   |                 if not laddr_infos:\n[CI/Tests ]   |                     raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             exceptions = []\n[CI/Tests ]   |             for family, type, proto, cname, address in infos:\n[CI/Tests ]   |                 try:\n[CI/Tests ]   |                     sock = socket.socket(family=family, type=type, proto=proto)\n[CI/Tests ]   |                     sock.setblocking(False)\n[CI/Tests ]   |                     if local_addr is not None:\n[CI/Tests ]   |                         for _, _, _, _, laddr in laddr_infos:\n[CI/Tests ]   |                             try:\n[CI/Tests ]   |                                 sock.bind(laddr)\n[CI/Tests ]   |                                 break\n[CI/Tests ]   |                             except OSError as exc:\n[CI/Tests ]   |                                 msg = (\n[CI/Tests ]   |                                     f'error while attempting to bind on '\n[CI/Tests ]   |                                     f'address {laddr!r}: '\n[CI/Tests ]   |                                     f'{exc.strerror.lower()}'\n[CI/Tests ]   |                                 )\n[CI/Tests ]   |                                 exc = OSError(exc.errno, msg)\n[CI/Tests ]   |                                 exceptions.append(exc)\n[CI/Tests ]   |                         else:\n[CI/Tests ]   |                             sock.close()\n[CI/Tests ]   |                             sock = None\n[CI/Tests ]   |                             continue\n[CI/Tests ]   |                     if self._debug:\n[CI/Tests ]   |                         logger.debug(\"connect %r to %r\", sock, address)\n[CI/Tests ]   |                     await self.sock_connect(sock, address)\n[CI/Tests ]   |                 except OSError as exc:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     exceptions.append(exc)\n[CI/Tests ]   |                 except:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     raise\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     break\n[CI/Tests ]   |             else:\n[CI/Tests ]   |                 if len(exceptions) == 1:\n[CI/Tests ]   |                     raise exceptions[0]\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     # If they all have the same str(), raise one.\n[CI/Tests ]   |                     model = str(exceptions[0])\n[CI/Tests ]   |                     if all(str(exc) == model for exc in exceptions):\n[CI/Tests ]   |                         raise exceptions[0]\n[CI/Tests ]   |                     # Raise a combined exception so the user can see all\n[CI/Tests ]   |                     # the various error messages.\n[CI/Tests ]   |                     raise OSError('Multiple exceptions: {}'.format(\n[CI/Tests ]   | >                       ', '.join(str(exc) for exc in exceptions)))\n[CI/Tests ]   | E                   OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | \n[CI/Tests ]   | address    = ('::1', 11211, 0, 0)\n[CI/Tests ]   | cname      = ''\n[CI/Tests ]   | exceptions = [ConnectionRefusedError(111, \"Connect call failed ('127.0.0.1', 11211)\"), OSError(99, 'Cannot assign requested address')]\n[CI/Tests ]   | family     = <AddressFamily.AF_INET6: 10>\n[CI/Tests ]   | flags      = 0\n[CI/Tests ]   | host       = 'localhost'\n[CI/Tests ]   | infos      = [(<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('127.0.0.1', 11211)), (<AddressFamily.AF_INET6: 10>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('::1', 11211, 0, 0))]\n[CI/Tests ]   | local_addr = None\n[CI/Tests ]   | model      = \"[Errno 111] Connect call failed ('127.0.0.1', 11211)\"\n[CI/Tests ]   | port       = 11211\n[CI/Tests ]   | proto      = 6\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ea66680>\n[CI/Tests ]   | self       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | server_hostname = None\n[CI/Tests ]   | sock       = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6>\n[CI/Tests ]   | ssl        = None\n[CI/Tests ]   | ssl_handshake_timeout = None\n[CI/Tests ]   | type       = <SocketKind.SOCK_STREAM: 1>\n[CI/Tests ]   | \n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/base_events.py:971: OSError\n[CI/Tests ]   | ____________________________ test_flag_helper[key] _____________________________\n[CI/Tests ]   | \n[CI/Tests ]   | mcache_flag_client = <aiomcache.client.FlagClient object at 0x7f8a7ee78dd0>\n[CI/Tests ]   | value = 'key'\n[CI/Tests ]   | \n[CI/Tests ]   |     @pytest.mark.parametrize(\n[CI/Tests ]   |         \"value\",\n[CI/Tests ]   |         [\n[CI/Tests ]   |             \"key\",\n[CI/Tests ]   |             b\"bkey\",\n[CI/Tests ]   |             False,\n[CI/Tests ]   |             1,\n[CI/Tests ]   |             None,\n[CI/Tests ]   |             0.5,\n[CI/Tests ]   |             [1, 2, 3],\n[CI/Tests ]   |             tuple([1, 2, 3]),\n[CI/Tests ]   |             [datetime.date(2015, 12, 28)],\n[CI/Tests ]   |             bytes(\"!@#\", \"utf-8\"),\n[CI/Tests ]   |             bytes(\"\uc548\ub155\ud558\uc138\uc694\", \"utf-8\"),\n[CI/Tests ]   |         ]\n[CI/Tests ]   |     )\n[CI/Tests ]   |     async def test_flag_helper(\n[CI/Tests ]   |             mcache_flag_client: FlagClient[Any], value: object) -> None:\n[CI/Tests ]   |         key = b\"key:test_flag_helper\"\n[CI/Tests ]   |     \n[CI/Tests ]   | >       await mcache_flag_client.set(key, value)\n[CI/Tests ]   | \n[CI/Tests ]   | key        = b'key:test_flag_helper'\n[CI/Tests ]   | mcache_flag_client = <aiomcache.client.FlagClient object at 0x7f8a7ee78dd0>\n[CI/Tests ]   | value      = 'key'\n[CI/Tests ]   | \n[CI/Tests ]   | tests/commands_test.py:385: \n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | aiomcache/client.py:40: in wrapper\n[CI/Tests ]   |     conn = await self._pool.acquire()\n[CI/Tests ]   |         args       = (b'key:test_flag_helper', 'key')\n[CI/Tests ]   |         func       = <function FlagClient.set at 0x7f8a7edf9050>\n[CI/Tests ]   |         kwargs     = {}\n[CI/Tests ]   |         self       = <aiomcache.client.FlagClient object at 0x7f8a7ee78dd0>\n[CI/Tests ]   | aiomcache/pool.py:40: in acquire\n[CI/Tests ]   |     _conn = await self._create_new_conn()\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ee781d0>\n[CI/Tests ]   | aiomcache/pool.py:71: in _create_new_conn\n[CI/Tests ]   |     self._host, self._port, **self.conn_args)\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ee781d0>\n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/streams.py:77: in open_connection\n[CI/Tests ]   |     lambda: protocol, host, port, **kwds)\n[CI/Tests ]   |         host       = 'localhost'\n[CI/Tests ]   |         kwds       = {}\n[CI/Tests ]   |         limit      = 65536\n[CI/Tests ]   |         loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   |         port       = 11211\n[CI/Tests ]   |         protocol   = <asyncio.streams.StreamReaderProtocol object at 0x7f8a7e082f50>\n[CI/Tests ]   |         reader     = <StreamReader>\n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | \n[CI/Tests ]   | self = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7e98d200>\n[CI/Tests ]   | host = 'localhost', port = 11211\n[CI/Tests ]   | \n[CI/Tests ]   |     async def create_connection(\n[CI/Tests ]   |             self, protocol_factory, host=None, port=None,\n[CI/Tests ]   |             *, ssl=None, family=0,\n[CI/Tests ]   |             proto=0, flags=0, sock=None,\n[CI/Tests ]   |             local_addr=None, server_hostname=None,\n[CI/Tests ]   |             ssl_handshake_timeout=None):\n[CI/Tests ]   |         \"\"\"Connect to a TCP server.\n[CI/Tests ]   |     \n[CI/Tests ]   |         Create a streaming transport connection to a given Internet host and\n[CI/Tests ]   |         port: socket family AF_INET or socket.AF_INET6 depending on host (or\n[CI/Tests ]   |         family if specified), socket type SOCK_STREAM. protocol_factory must be\n[CI/Tests ]   |         a callable returning a protocol instance.\n[CI/Tests ]   |     \n[CI/Tests ]   |         This method is a coroutine which will try to establish the connection\n[CI/Tests ]   |         in the background.  When successful, the coroutine returns a\n[CI/Tests ]   |         (transport, protocol) pair.\n[CI/Tests ]   |         \"\"\"\n[CI/Tests ]   |         if server_hostname is not None and not ssl:\n[CI/Tests ]   |             raise ValueError('server_hostname is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if server_hostname is None and ssl:\n[CI/Tests ]   |             # Use host as default for server_hostname.  It is an error\n[CI/Tests ]   |             # if host is empty or not set, e.g. when an\n[CI/Tests ]   |             # already-connected socket was passed or when only a port\n[CI/Tests ]   |             # is given.  To avoid this error, you can pass\n[CI/Tests ]   |             # server_hostname='' -- this will bypass the hostname\n[CI/Tests ]   |             # check.  (This also means that if host is a numeric\n[CI/Tests ]   |             # IP/IPv6 address, we will attempt to verify that exact\n[CI/Tests ]   |             # address; this will probably fail, but it is possible to\n[CI/Tests ]   |             # create a certificate for a specific IP address, so we\n[CI/Tests ]   |             # don't judge it here.)\n[CI/Tests ]   |             if not host:\n[CI/Tests ]   |                 raise ValueError('You must set server_hostname '\n[CI/Tests ]   |                                  'when using ssl without a host')\n[CI/Tests ]   |             server_hostname = host\n[CI/Tests ]   |     \n[CI/Tests ]   |         if ssl_handshake_timeout is not None and not ssl:\n[CI/Tests ]   |             raise ValueError(\n[CI/Tests ]   |                 'ssl_handshake_timeout is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if host is not None or port is not None:\n[CI/Tests ]   |             if sock is not None:\n[CI/Tests ]   |                 raise ValueError(\n[CI/Tests ]   |                     'host/port and sock can not be specified at the same time')\n[CI/Tests ]   |     \n[CI/Tests ]   |             infos = await self._ensure_resolved(\n[CI/Tests ]   |                 (host, port), family=family,\n[CI/Tests ]   |                 type=socket.SOCK_STREAM, proto=proto, flags=flags, loop=self)\n[CI/Tests ]   |             if not infos:\n[CI/Tests ]   |                 raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             if local_addr is not None:\n[CI/Tests ]   |                 laddr_infos = await self._ensure_resolved(\n[CI/Tests ]   |                     local_addr, family=family,\n[CI/Tests ]   |                     type=socket.SOCK_STREAM, proto=proto,\n[CI/Tests ]   |                     flags=flags, loop=self)\n[CI/Tests ]   |                 if not laddr_infos:\n[CI/Tests ]   |                     raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             exceptions = []\n[CI/Tests ]   |             for family, type, proto, cname, address in infos:\n[CI/Tests ]   |                 try:\n[CI/Tests ]   |                     sock = socket.socket(family=family, type=type, proto=proto)\n[CI/Tests ]   |                     sock.setblocking(False)\n[CI/Tests ]   |                     if local_addr is not None:\n[CI/Tests ]   |                         for _, _, _, _, laddr in laddr_infos:\n[CI/Tests ]   |                             try:\n[CI/Tests ]   |                                 sock.bind(laddr)\n[CI/Tests ]   |                                 break\n[CI/Tests ]   |                             except OSError as exc:\n[CI/Tests ]   |                                 msg = (\n[CI/Tests ]   |                                     f'error while attempting to bind on '\n[CI/Tests ]   |                                     f'address {laddr!r}: '\n[CI/Tests ]   |                                     f'{exc.strerror.lower()}'\n[CI/Tests ]   |                                 )\n[CI/Tests ]   |                                 exc = OSError(exc.errno, msg)\n[CI/Tests ]   |                                 exceptions.append(exc)\n[CI/Tests ]   |                         else:\n[CI/Tests ]   |                             sock.close()\n[CI/Tests ]   |                             sock = None\n[CI/Tests ]   |                             continue\n[CI/Tests ]   |                     if self._debug:\n[CI/Tests ]   |                         logger.debug(\"connect %r to %r\", sock, address)\n[CI/Tests ]   |                     await self.sock_connect(sock, address)\n[CI/Tests ]   |                 except OSError as exc:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     exceptions.append(exc)\n[CI/Tests ]   |                 except:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     raise\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     break\n[CI/Tests ]   |             else:\n[CI/Tests ]   |                 if len(exceptions) == 1:\n[CI/Tests ]   |                     raise exceptions[0]\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     # If they all have the same str(), raise one.\n[CI/Tests ]   |                     model = str(exceptions[0])\n[CI/Tests ]   |                     if all(str(exc) == model for exc in exceptions):\n[CI/Tests ]   |                         raise exceptions[0]\n[CI/Tests ]   |                     # Raise a combined exception so the user can see all\n[CI/Tests ]   |                     # the various error messages.\n[CI/Tests ]   |                     raise OSError('Multiple exceptions: {}'.format(\n[CI/Tests ]   | >                       ', '.join(str(exc) for exc in exceptions)))\n[CI/Tests ]   | E                   OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | \n[CI/Tests ]   | address    = ('::1', 11211, 0, 0)\n[CI/Tests ]   | cname      = ''\n[CI/Tests ]   | exceptions = [ConnectionRefusedError(111, \"Connect call failed ('127.0.0.1', 11211)\"), OSError(99, 'Cannot assign requested address')]\n[CI/Tests ]   | family     = <AddressFamily.AF_INET6: 10>\n[CI/Tests ]   | flags      = 0\n[CI/Tests ]   | host       = 'localhost'\n[CI/Tests ]   | infos      = [(<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('127.0.0.1', 11211)), (<AddressFamily.AF_INET6: 10>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('::1', 11211, 0, 0))]\n[CI/Tests ]   | local_addr = None\n[CI/Tests ]   | model      = \"[Errno 111] Connect call failed ('127.0.0.1', 11211)\"\n[CI/Tests ]   | port       = 11211\n[CI/Tests ]   | proto      = 6\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7e98d200>\n[CI/Tests ]   | self       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | server_hostname = None\n[CI/Tests ]   | sock       = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6>\n[CI/Tests ]   | ssl        = None\n[CI/Tests ]   | ssl_handshake_timeout = None\n[CI/Tests ]   | type       = <SocketKind.SOCK_STREAM: 1>\n[CI/Tests ]   | \n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/base_events.py:971: OSError\n[CI/Tests ]   | ____________________________ test_flag_helper[bkey] ____________________________\n[CI/Tests ]   | \n[CI/Tests ]   | mcache_flag_client = <aiomcache.client.FlagClient object at 0x7f8a7ef1f790>\n[CI/Tests ]   | value = b'bkey'\n[CI/Tests ]   | \n[CI/Tests ]   |     @pytest.mark.parametrize(\n[CI/Tests ]   |         \"value\",\n[CI/Tests ]   |         [\n[CI/Tests ]   |             \"key\",\n[CI/Tests ]   |             b\"bkey\",\n[CI/Tests ]   |             False,\n[CI/Tests ]   |             1,\n[CI/Tests ]   |             None,\n[CI/Tests ]   |             0.5,\n[CI/Tests ]   |             [1, 2, 3],\n[CI/Tests ]   |             tuple([1, 2, 3]),\n[CI/Tests ]   |             [datetime.date(2015, 12, 28)],\n[CI/Tests ]   |             bytes(\"!@#\", \"utf-8\"),\n[CI/Tests ]   |             bytes(\"\uc548\ub155\ud558\uc138\uc694\", \"utf-8\"),\n[CI/Tests ]   |         ]\n[CI/Tests ]   |     )\n[CI/Tests ]   |     async def test_flag_helper(\n[CI/Tests ]   |             mcache_flag_client: FlagClient[Any], value: object) -> None:\n[CI/Tests ]   |         key = b\"key:test_flag_helper\"\n[CI/Tests ]   |     \n[CI/Tests ]   | >       await mcache_flag_client.set(key, value)\n[CI/Tests ]   | \n[CI/Tests ]   | key        = b'key:test_flag_helper'\n[CI/Tests ]   | mcache_flag_client = <aiomcache.client.FlagClient object at 0x7f8a7ef1f790>\n[CI/Tests ]   | value      = b'bkey'\n[CI/Tests ]   | \n[CI/Tests ]   | tests/commands_test.py:385: \n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | aiomcache/client.py:40: in wrapper\n[CI/Tests ]   |     conn = await self._pool.acquire()\n[CI/Tests ]   |         args       = (b'key:test_flag_helper', b'bkey')\n[CI/Tests ]   |         func       = <function FlagClient.set at 0x7f8a7edf9050>\n[CI/Tests ]   |         kwargs     = {}\n[CI/Tests ]   |         self       = <aiomcache.client.FlagClient object at 0x7f8a7ef1f790>\n[CI/Tests ]   | aiomcache/pool.py:40: in acquire\n[CI/Tests ]   |     _conn = await self._create_new_conn()\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ef1f2d0>\n[CI/Tests ]   | aiomcache/pool.py:71: in _create_new_conn\n[CI/Tests ]   |     self._host, self._port, **self.conn_args)\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ef1f2d0>\n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/streams.py:77: in open_connection\n[CI/Tests ]   |     lambda: protocol, host, port, **kwds)\n[CI/Tests ]   |         host       = 'localhost'\n[CI/Tests ]   |         kwds       = {}\n[CI/Tests ]   |         limit      = 65536\n[CI/Tests ]   |         loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   |         port       = 11211\n[CI/Tests ]   |         protocol   = <asyncio.streams.StreamReaderProtocol object at 0x7f8a7ef1f8d0>\n[CI/Tests ]   |         reader     = <StreamReader>\n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | \n[CI/Tests ]   | self = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ec868c0>\n[CI/Tests ]   | host = 'localhost', port = 11211\n[CI/Tests ]   | \n[CI/Tests ]   |     async def create_connection(\n[CI/Tests ]   |             self, protocol_factory, host=None, port=None,\n[CI/Tests ]   |             *, ssl=None, family=0,\n[CI/Tests ]   |             proto=0, flags=0, sock=None,\n[CI/Tests ]   |             local_addr=None, server_hostname=None,\n[CI/Tests ]   |             ssl_handshake_timeout=None):\n[CI/Tests ]   |         \"\"\"Connect to a TCP server.\n[CI/Tests ]   |     \n[CI/Tests ]   |         Create a streaming transport connection to a given Internet host and\n[CI/Tests ]   |         port: socket family AF_INET or socket.AF_INET6 depending on host (or\n[CI/Tests ]   |         family if specified), socket type SOCK_STREAM. protocol_factory must be\n[CI/Tests ]   |         a callable returning a protocol instance.\n[CI/Tests ]   |     \n[CI/Tests ]   |         This method is a coroutine which will try to establish the connection\n[CI/Tests ]   |         in the background.  When successful, the coroutine returns a\n[CI/Tests ]   |         (transport, protocol) pair.\n[CI/Tests ]   |         \"\"\"\n[CI/Tests ]   |         if server_hostname is not None and not ssl:\n[CI/Tests ]   |             raise ValueError('server_hostname is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if server_hostname is None and ssl:\n[CI/Tests ]   |             # Use host as default for server_hostname.  It is an error\n[CI/Tests ]   |             # if host is empty or not set, e.g. when an\n[CI/Tests ]   |             # already-connected socket was passed or when only a port\n[CI/Tests ]   |             # is given.  To avoid this error, you can pass\n[CI/Tests ]   |             # server_hostname='' -- this will bypass the hostname\n[CI/Tests ]   |             # check.  (This also means that if host is a numeric\n[CI/Tests ]   |             # IP/IPv6 address, we will attempt to verify that exact\n[CI/Tests ]   |             # address; this will probably fail, but it is possible to\n[CI/Tests ]   |             # create a certificate for a specific IP address, so we\n[CI/Tests ]   |             # don't judge it here.)\n[CI/Tests ]   |             if not host:\n[CI/Tests ]   |                 raise ValueError('You must set server_hostname '\n[CI/Tests ]   |                                  'when using ssl without a host')\n[CI/Tests ]   |             server_hostname = host\n[CI/Tests ]   |     \n[CI/Tests ]   |         if ssl_handshake_timeout is not None and not ssl:\n[CI/Tests ]   |             raise ValueError(\n[CI/Tests ]   |                 'ssl_handshake_timeout is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if host is not None or port is not None:\n[CI/Tests ]   |             if sock is not None:\n[CI/Tests ]   |                 raise ValueError(\n[CI/Tests ]   |                     'host/port and sock can not be specified at the same time')\n[CI/Tests ]   |     \n[CI/Tests ]   |             infos = await self._ensure_resolved(\n[CI/Tests ]   |                 (host, port), family=family,\n[CI/Tests ]   |                 type=socket.SOCK_STREAM, proto=proto, flags=flags, loop=self)\n[CI/Tests ]   |             if not infos:\n[CI/Tests ]   |                 raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             if local_addr is not None:\n[CI/Tests ]   |                 laddr_infos = await self._ensure_resolved(\n[CI/Tests ]   |                     local_addr, family=family,\n[CI/Tests ]   |                     type=socket.SOCK_STREAM, proto=proto,\n[CI/Tests ]   |                     flags=flags, loop=self)\n[CI/Tests ]   |                 if not laddr_infos:\n[CI/Tests ]   |                     raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             exceptions = []\n[CI/Tests ]   |             for family, type, proto, cname, address in infos:\n[CI/Tests ]   |                 try:\n[CI/Tests ]   |                     sock = socket.socket(family=family, type=type, proto=proto)\n[CI/Tests ]   |                     sock.setblocking(False)\n[CI/Tests ]   |                     if local_addr is not None:\n[CI/Tests ]   |                         for _, _, _, _, laddr in laddr_infos:\n[CI/Tests ]   |                             try:\n[CI/Tests ]   |                                 sock.bind(laddr)\n[CI/Tests ]   |                                 break\n[CI/Tests ]   |                             except OSError as exc:\n[CI/Tests ]   |                                 msg = (\n[CI/Tests ]   |                                     f'error while attempting to bind on '\n[CI/Tests ]   |                                     f'address {laddr!r}: '\n[CI/Tests ]   |                                     f'{exc.strerror.lower()}'\n[CI/Tests ]   |                                 )\n[CI/Tests ]   |                                 exc = OSError(exc.errno, msg)\n[CI/Tests ]   |                                 exceptions.append(exc)\n[CI/Tests ]   |                         else:\n[CI/Tests ]   |                             sock.close()\n[CI/Tests ]   |                             sock = None\n[CI/Tests ]   |                             continue\n[CI/Tests ]   |                     if self._debug:\n[CI/Tests ]   |                         logger.debug(\"connect %r to %r\", sock, address)\n[CI/Tests ]   |                     await self.sock_connect(sock, address)\n[CI/Tests ]   |                 except OSError as exc:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     exceptions.append(exc)\n[CI/Tests ]   |                 except:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     raise\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     break\n[CI/Tests ]   |             else:\n[CI/Tests ]   |                 if len(exceptions) == 1:\n[CI/Tests ]   |                     raise exceptions[0]\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     # If they all have the same str(), raise one.\n[CI/Tests ]   |                     model = str(exceptions[0])\n[CI/Tests ]   |                     if all(str(exc) == model for exc in exceptions):\n[CI/Tests ]   |                         raise exceptions[0]\n[CI/Tests ]   |                     # Raise a combined exception so the user can see all\n[CI/Tests ]   |                     # the various error messages.\n[CI/Tests ]   |                     raise OSError('Multiple exceptions: {}'.format(\n[CI/Tests ]   | >                       ', '.join(str(exc) for exc in exceptions)))\n[CI/Tests ]   | E                   OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | \n[CI/Tests ]   | address    = ('::1', 11211, 0, 0)\n[CI/Tests ]   | cname      = ''\n[CI/Tests ]   | exceptions = [ConnectionRefusedError(111, \"Connect call failed ('127.0.0.1', 11211)\"), OSError(99, 'Cannot assign requested address')]\n[CI/Tests ]   | family     = <AddressFamily.AF_INET6: 10>\n[CI/Tests ]   | flags      = 0\n[CI/Tests ]   | host       = 'localhost'\n[CI/Tests ]   | infos      = [(<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('127.0.0.1', 11211)), (<AddressFamily.AF_INET6: 10>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('::1', 11211, 0, 0))]\n[CI/Tests ]   | local_addr = None\n[CI/Tests ]   | model      = \"[Errno 111] Connect call failed ('127.0.0.1', 11211)\"\n[CI/Tests ]   | port       = 11211\n[CI/Tests ]   | proto      = 6\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ec868c0>\n[CI/Tests ]   | self       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | server_hostname = None\n[CI/Tests ]   | sock       = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6>\n[CI/Tests ]   | ssl        = None\n[CI/Tests ]   | ssl_handshake_timeout = None\n[CI/Tests ]   | type       = <SocketKind.SOCK_STREAM: 1>\n[CI/Tests ]   | \n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/base_events.py:971: OSError\n[CI/Tests ]   | ___________________________ test_flag_helper[False] ____________________________\n[CI/Tests ]   | \n[CI/Tests ]   | mcache_flag_client = <aiomcache.client.FlagClient object at 0x7f8a7ee67050>\n[CI/Tests ]   | value = False\n[CI/Tests ]   | \n[CI/Tests ]   |     @pytest.mark.parametrize(\n[CI/Tests ]   |         \"value\",\n[CI/Tests ]   |         [\n[CI/Tests ]   |             \"key\",\n[CI/Tests ]   |             b\"bkey\",\n[CI/Tests ]   |             False,\n[CI/Tests ]   |             1,\n[CI/Tests ]   |             None,\n[CI/Tests ]   |             0.5,\n[CI/Tests ]   |             [1, 2, 3],\n[CI/Tests ]   |             tuple([1, 2, 3]),\n[CI/Tests ]   |             [datetime.date(2015, 12, 28)],\n[CI/Tests ]   |             bytes(\"!@#\", \"utf-8\"),\n[CI/Tests ]   |             bytes(\"\uc548\ub155\ud558\uc138\uc694\", \"utf-8\"),\n[CI/Tests ]   |         ]\n[CI/Tests ]   |     )\n[CI/Tests ]   |     async def test_flag_helper(\n[CI/Tests ]   |             mcache_flag_client: FlagClient[Any], value: object) -> None:\n[CI/Tests ]   |         key = b\"key:test_flag_helper\"\n[CI/Tests ]   |     \n[CI/Tests ]   | >       await mcache_flag_client.set(key, value)\n[CI/Tests ]   | \n[CI/Tests ]   | key        = b'key:test_flag_helper'\n[CI/Tests ]   | mcache_flag_client = <aiomcache.client.FlagClient object at 0x7f8a7ee67050>\n[CI/Tests ]   | value      = False\n[CI/Tests ]   | \n[CI/Tests ]   | tests/commands_test.py:385: \n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | aiomcache/client.py:40: in wrapper\n[CI/Tests ]   |     conn = await self._pool.acquire()\n[CI/Tests ]   |         args       = (b'key:test_flag_helper', False)\n[CI/Tests ]   |         func       = <function FlagClient.set at 0x7f8a7edf9050>\n[CI/Tests ]   |         kwargs     = {}\n[CI/Tests ]   |         self       = <aiomcache.client.FlagClient object at 0x7f8a7ee67050>\n[CI/Tests ]   | aiomcache/pool.py:40: in acquire\n[CI/Tests ]   |     _conn = await self._create_new_conn()\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ee67210>\n[CI/Tests ]   | aiomcache/pool.py:71: in _create_new_conn\n[CI/Tests ]   |     self._host, self._port, **self.conn_args)\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ee67210>\n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/streams.py:77: in open_connection\n[CI/Tests ]   |     lambda: protocol, host, port, **kwds)\n[CI/Tests ]   |         host       = 'localhost'\n[CI/Tests ]   |         kwds       = {}\n[CI/Tests ]   |         limit      = 65536\n[CI/Tests ]   |         loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   |         port       = 11211\n[CI/Tests ]   |         protocol   = <asyncio.streams.StreamReaderProtocol object at 0x7f8a7ee67290>\n[CI/Tests ]   |         reader     = <StreamReader>\n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | \n[CI/Tests ]   | self = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ea66560>\n[CI/Tests ]   | host = 'localhost', port = 11211\n[CI/Tests ]   | \n[CI/Tests ]   |     async def create_connection(\n[CI/Tests ]   |             self, protocol_factory, host=None, port=None,\n[CI/Tests ]   |             *, ssl=None, family=0,\n[CI/Tests ]   |             proto=0, flags=0, sock=None,\n[CI/Tests ]   |             local_addr=None, server_hostname=None,\n[CI/Tests ]   |             ssl_handshake_timeout=None):\n[CI/Tests ]   |         \"\"\"Connect to a TCP server.\n[CI/Tests ]   |     \n[CI/Tests ]   |         Create a streaming transport connection to a given Internet host and\n[CI/Tests ]   |         port: socket family AF_INET or socket.AF_INET6 depending on host (or\n[CI/Tests ]   |         family if specified), socket type SOCK_STREAM. protocol_factory must be\n[CI/Tests ]   |         a callable returning a protocol instance.\n[CI/Tests ]   |     \n[CI/Tests ]   |         This method is a coroutine which will try to establish the connection\n[CI/Tests ]   |         in the background.  When successful, the coroutine returns a\n[CI/Tests ]   |         (transport, protocol) pair.\n[CI/Tests ]   |         \"\"\"\n[CI/Tests ]   |         if server_hostname is not None and not ssl:\n[CI/Tests ]   |             raise ValueError('server_hostname is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if server_hostname is None and ssl:\n[CI/Tests ]   |             # Use host as default for server_hostname.  It is an error\n[CI/Tests ]   |             # if host is empty or not set, e.g. when an\n[CI/Tests ]   |             # already-connected socket was passed or when only a port\n[CI/Tests ]   |             # is given.  To avoid this error, you can pass\n[CI/Tests ]   |             # server_hostname='' -- this will bypass the hostname\n[CI/Tests ]   |             # check.  (This also means that if host is a numeric\n[CI/Tests ]   |             # IP/IPv6 address, we will attempt to verify that exact\n[CI/Tests ]   |             # address; this will probably fail, but it is possible to\n[CI/Tests ]   |             # create a certificate for a specific IP address, so we\n[CI/Tests ]   |             # don't judge it here.)\n[CI/Tests ]   |             if not host:\n[CI/Tests ]   |                 raise ValueError('You must set server_hostname '\n[CI/Tests ]   |                                  'when using ssl without a host')\n[CI/Tests ]   |             server_hostname = host\n[CI/Tests ]   |     \n[CI/Tests ]   |         if ssl_handshake_timeout is not None and not ssl:\n[CI/Tests ]   |             raise ValueError(\n[CI/Tests ]   |                 'ssl_handshake_timeout is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if host is not None or port is not None:\n[CI/Tests ]   |             if sock is not None:\n[CI/Tests ]   |                 raise ValueError(\n[CI/Tests ]   |                     'host/port and sock can not be specified at the same time')\n[CI/Tests ]   |     \n[CI/Tests ]   |             infos = await self._ensure_resolved(\n[CI/Tests ]   |                 (host, port), family=family,\n[CI/Tests ]   |                 type=socket.SOCK_STREAM, proto=proto, flags=flags, loop=self)\n[CI/Tests ]   |             if not infos:\n[CI/Tests ]   |                 raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             if local_addr is not None:\n[CI/Tests ]   |                 laddr_infos = await self._ensure_resolved(\n[CI/Tests ]   |                     local_addr, family=family,\n[CI/Tests ]   |                     type=socket.SOCK_STREAM, proto=proto,\n[CI/Tests ]   |                     flags=flags, loop=self)\n[CI/Tests ]   |                 if not laddr_infos:\n[CI/Tests ]   |                     raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             exceptions = []\n[CI/Tests ]   |             for family, type, proto, cname, address in infos:\n[CI/Tests ]   |                 try:\n[CI/Tests ]   |                     sock = socket.socket(family=family, type=type, proto=proto)\n[CI/Tests ]   |                     sock.setblocking(False)\n[CI/Tests ]   |                     if local_addr is not None:\n[CI/Tests ]   |                         for _, _, _, _, laddr in laddr_infos:\n[CI/Tests ]   |                             try:\n[CI/Tests ]   |                                 sock.bind(laddr)\n[CI/Tests ]   |                                 break\n[CI/Tests ]   |                             except OSError as exc:\n[CI/Tests ]   |                                 msg = (\n[CI/Tests ]   |                                     f'error while attempting to bind on '\n[CI/Tests ]   |                                     f'address {laddr!r}: '\n[CI/Tests ]   |                                     f'{exc.strerror.lower()}'\n[CI/Tests ]   |                                 )\n[CI/Tests ]   |                                 exc = OSError(exc.errno, msg)\n[CI/Tests ]   |                                 exceptions.append(exc)\n[CI/Tests ]   |                         else:\n[CI/Tests ]   |                             sock.close()\n[CI/Tests ]   |                             sock = None\n[CI/Tests ]   |                             continue\n[CI/Tests ]   |                     if self._debug:\n[CI/Tests ]   |                         logger.debug(\"connect %r to %r\", sock, address)\n[CI/Tests ]   |                     await self.sock_connect(sock, address)\n[CI/Tests ]   |                 except OSError as exc:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     exceptions.append(exc)\n[CI/Tests ]   |                 except:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     raise\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     break\n[CI/Tests ]   |             else:\n[CI/Tests ]   |                 if len(exceptions) == 1:\n[CI/Tests ]   |                     raise exceptions[0]\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     # If they all have the same str(), raise one.\n[CI/Tests ]   |                     model = str(exceptions[0])\n[CI/Tests ]   |                     if all(str(exc) == model for exc in exceptions):\n[CI/Tests ]   |                         raise exceptions[0]\n[CI/Tests ]   |                     # Raise a combined exception so the user can see all\n[CI/Tests ]   |                     # the various error messages.\n[CI/Tests ]   |                     raise OSError('Multiple exceptions: {}'.format(\n[CI/Tests ]   | >                       ', '.join(str(exc) for exc in exceptions)))\n[CI/Tests ]   | E                   OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | \n[CI/Tests ]   | address    = ('::1', 11211, 0, 0)\n[CI/Tests ]   | cname      = ''\n[CI/Tests ]   | exceptions = [ConnectionRefusedError(111, \"Connect call failed ('127.0.0.1', 11211)\"), OSError(99, 'Cannot assign requested address')]\n[CI/Tests ]   | family     = <AddressFamily.AF_INET6: 10>\n[CI/Tests ]   | flags      = 0\n[CI/Tests ]   | host       = 'localhost'\n[CI/Tests ]   | infos      = [(<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('127.0.0.1', 11211)), (<AddressFamily.AF_INET6: 10>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('::1', 11211, 0, 0))]\n[CI/Tests ]   | local_addr = None\n[CI/Tests ]   | model      = \"[Errno 111] Connect call failed ('127.0.0.1', 11211)\"\n[CI/Tests ]   | port       = 11211\n[CI/Tests ]   | proto      = 6\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ea66560>\n[CI/Tests ]   | self       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | server_hostname = None\n[CI/Tests ]   | sock       = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6>\n[CI/Tests ]   | ssl        = None\n[CI/Tests ]   | ssl_handshake_timeout = None\n[CI/Tests ]   | type       = <SocketKind.SOCK_STREAM: 1>\n[CI/Tests ]   | \n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/base_events.py:971: OSError\n[CI/Tests ]   | _____________________________ test_flag_helper[1] ______________________________\n[CI/Tests ]   | \n[CI/Tests ]   | mcache_flag_client = <aiomcache.client.FlagClient object at 0x7f8a7ec43450>\n[CI/Tests ]   | value = 1\n[CI/Tests ]   | \n[CI/Tests ]   |     @pytest.mark.parametrize(\n[CI/Tests ]   |         \"value\",\n[CI/Tests ]   |         [\n[CI/Tests ]   |             \"key\",\n[CI/Tests ]   |             b\"bkey\",\n[CI/Tests ]   |             False,\n[CI/Tests ]   |             1,\n[CI/Tests ]   |             None,\n[CI/Tests ]   |             0.5,\n[CI/Tests ]   |             [1, 2, 3],\n[CI/Tests ]   |             tuple([1, 2, 3]),\n[CI/Tests ]   |             [datetime.date(2015, 12, 28)],\n[CI/Tests ]   |             bytes(\"!@#\", \"utf-8\"),\n[CI/Tests ]   |             bytes(\"\uc548\ub155\ud558\uc138\uc694\", \"utf-8\"),\n[CI/Tests ]   |         ]\n[CI/Tests ]   |     )\n[CI/Tests ]   |     async def test_flag_helper(\n[CI/Tests ]   |             mcache_flag_client: FlagClient[Any], value: object) -> None:\n[CI/Tests ]   |         key = b\"key:test_flag_helper\"\n[CI/Tests ]   |     \n[CI/Tests ]   | >       await mcache_flag_client.set(key, value)\n[CI/Tests ]   | \n[CI/Tests ]   | key        = b'key:test_flag_helper'\n[CI/Tests ]   | mcache_flag_client = <aiomcache.client.FlagClient object at 0x7f8a7ec43450>\n[CI/Tests ]   | value      = 1\n[CI/Tests ]   | \n[CI/Tests ]   | tests/commands_test.py:385: \n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | aiomcache/client.py:40: in wrapper\n[CI/Tests ]   |     conn = await self._pool.acquire()\n[CI/Tests ]   |         args       = (b'key:test_flag_helper', 1)\n[CI/Tests ]   |         func       = <function FlagClient.set at 0x7f8a7edf9050>\n[CI/Tests ]   |         kwargs     = {}\n[CI/Tests ]   |         self       = <aiomcache.client.FlagClient object at 0x7f8a7ec43450>\n[CI/Tests ]   | aiomcache/pool.py:40: in acquire\n[CI/Tests ]   |     _conn = await self._create_new_conn()\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ec43310>\n[CI/Tests ]   | aiomcache/pool.py:71: in _create_new_conn\n[CI/Tests ]   |     self._host, self._port, **self.conn_args)\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ec43310>\n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/streams.py:77: in open_connection\n[CI/Tests ]   |     lambda: protocol, host, port, **kwds)\n[CI/Tests ]   |         host       = 'localhost'\n[CI/Tests ]   |         kwds       = {}\n[CI/Tests ]   |         limit      = 65536\n[CI/Tests ]   |         loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   |         port       = 11211\n[CI/Tests ]   |         protocol   = <asyncio.streams.StreamReaderProtocol object at 0x7f8a7ec43950>\n[CI/Tests ]   |         reader     = <StreamReader>\n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | \n[CI/Tests ]   | self = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7e98d0e0>\n[CI/Tests ]   | host = 'localhost', port = 11211\n[CI/Tests ]   | \n[CI/Tests ]   |     async def create_connection(\n[CI/Tests ]   |             self, protocol_factory, host=None, port=None,\n[CI/Tests ]   |             *, ssl=None, family=0,\n[CI/Tests ]   |             proto=0, flags=0, sock=None,\n[CI/Tests ]   |             local_addr=None, server_hostname=None,\n[CI/Tests ]   |             ssl_handshake_timeout=None):\n[CI/Tests ]   |         \"\"\"Connect to a TCP server.\n[CI/Tests ]   |     \n[CI/Tests ]   |         Create a streaming transport connection to a given Internet host and\n[CI/Tests ]   |         port: socket family AF_INET or socket.AF_INET6 depending on host (or\n[CI/Tests ]   |         family if specified), socket type SOCK_STREAM. protocol_factory must be\n[CI/Tests ]   |         a callable returning a protocol instance.\n[CI/Tests ]   |     \n[CI/Tests ]   |         This method is a coroutine which will try to establish the connection\n[CI/Tests ]   |         in the background.  When successful, the coroutine returns a\n[CI/Tests ]   |         (transport, protocol) pair.\n[CI/Tests ]   |         \"\"\"\n[CI/Tests ]   |         if server_hostname is not None and not ssl:\n[CI/Tests ]   |             raise ValueError('server_hostname is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if server_hostname is None and ssl:\n[CI/Tests ]   |             # Use host as default for server_hostname.  It is an error\n[CI/Tests ]   |             # if host is empty or not set, e.g. when an\n[CI/Tests ]   |             # already-connected socket was passed or when only a port\n[CI/Tests ]   |             # is given.  To avoid this error, you can pass\n[CI/Tests ]   |             # server_hostname='' -- this will bypass the hostname\n[CI/Tests ]   |             # check.  (This also means that if host is a numeric\n[CI/Tests ]   |             # IP/IPv6 address, we will attempt to verify that exact\n[CI/Tests ]   |             # address; this will probably fail, but it is possible to\n[CI/Tests ]   |             # create a certificate for a specific IP address, so we\n[CI/Tests ]   |             # don't judge it here.)\n[CI/Tests ]   |             if not host:\n[CI/Tests ]   |                 raise ValueError('You must set server_hostname '\n[CI/Tests ]   |                                  'when using ssl without a host')\n[CI/Tests ]   |             server_hostname = host\n[CI/Tests ]   |     \n[CI/Tests ]   |         if ssl_handshake_timeout is not None and not ssl:\n[CI/Tests ]   |             raise ValueError(\n[CI/Tests ]   |                 'ssl_handshake_timeout is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if host is not None or port is not None:\n[CI/Tests ]   |             if sock is not None:\n[CI/Tests ]   |                 raise ValueError(\n[CI/Tests ]   |                     'host/port and sock can not be specified at the same time')\n[CI/Tests ]   |     \n[CI/Tests ]   |             infos = await self._ensure_resolved(\n[CI/Tests ]   |                 (host, port), family=family,\n[CI/Tests ]   |                 type=socket.SOCK_STREAM, proto=proto, flags=flags, loop=self)\n[CI/Tests ]   |             if not infos:\n[CI/Tests ]   |                 raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             if local_addr is not None:\n[CI/Tests ]   |                 laddr_infos = await self._ensure_resolved(\n[CI/Tests ]   |                     local_addr, family=family,\n[CI/Tests ]   |                     type=socket.SOCK_STREAM, proto=proto,\n[CI/Tests ]   |                     flags=flags, loop=self)\n[CI/Tests ]   |                 if not laddr_infos:\n[CI/Tests ]   |                     raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             exceptions = []\n[CI/Tests ]   |             for family, type, proto, cname, address in infos:\n[CI/Tests ]   |                 try:\n[CI/Tests ]   |                     sock = socket.socket(family=family, type=type, proto=proto)\n[CI/Tests ]   |                     sock.setblocking(False)\n[CI/Tests ]   |                     if local_addr is not None:\n[CI/Tests ]   |                         for _, _, _, _, laddr in laddr_infos:\n[CI/Tests ]   |                             try:\n[CI/Tests ]   |                                 sock.bind(laddr)\n[CI/Tests ]   |                                 break\n[CI/Tests ]   |                             except OSError as exc:\n[CI/Tests ]   |                                 msg = (\n[CI/Tests ]   |                                     f'error while attempting to bind on '\n[CI/Tests ]   |                                     f'address {laddr!r}: '\n[CI/Tests ]   |                                     f'{exc.strerror.lower()}'\n[CI/Tests ]   |                                 )\n[CI/Tests ]   |                                 exc = OSError(exc.errno, msg)\n[CI/Tests ]   |                                 exceptions.append(exc)\n[CI/Tests ]   |                         else:\n[CI/Tests ]   |                             sock.close()\n[CI/Tests ]   |                             sock = None\n[CI/Tests ]   |                             continue\n[CI/Tests ]   |                     if self._debug:\n[CI/Tests ]   |                         logger.debug(\"connect %r to %r\", sock, address)\n[CI/Tests ]   |                     await self.sock_connect(sock, address)\n[CI/Tests ]   |                 except OSError as exc:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     exceptions.append(exc)\n[CI/Tests ]   |                 except:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     raise\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     break\n[CI/Tests ]   |             else:\n[CI/Tests ]   |                 if len(exceptions) == 1:\n[CI/Tests ]   |                     raise exceptions[0]\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     # If they all have the same str(), raise one.\n[CI/Tests ]   |                     model = str(exceptions[0])\n[CI/Tests ]   |                     if all(str(exc) == model for exc in exceptions):\n[CI/Tests ]   |                         raise exceptions[0]\n[CI/Tests ]   |                     # Raise a combined exception so the user can see all\n[CI/Tests ]   |                     # the various error messages.\n[CI/Tests ]   |                     raise OSError('Multiple exceptions: {}'.format(\n[CI/Tests ]   | >                       ', '.join(str(exc) for exc in exceptions)))\n[CI/Tests ]   | E                   OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | \n[CI/Tests ]   | address    = ('::1', 11211, 0, 0)\n[CI/Tests ]   | cname      = ''\n[CI/Tests ]   | exceptions = [ConnectionRefusedError(111, \"Connect call failed ('127.0.0.1', 11211)\"), OSError(99, 'Cannot assign requested address')]\n[CI/Tests ]   | family     = <AddressFamily.AF_INET6: 10>\n[CI/Tests ]   | flags      = 0\n[CI/Tests ]   | host       = 'localhost'\n[CI/Tests ]   | infos      = [(<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('127.0.0.1', 11211)), (<AddressFamily.AF_INET6: 10>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('::1', 11211, 0, 0))]\n[CI/Tests ]   | local_addr = None\n[CI/Tests ]   | model      = \"[Errno 111] Connect call failed ('127.0.0.1', 11211)\"\n[CI/Tests ]   | port       = 11211\n[CI/Tests ]   | proto      = 6\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7e98d0e0>\n[CI/Tests ]   | self       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | server_hostname = None\n[CI/Tests ]   | sock       = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6>\n[CI/Tests ]   | ssl        = None\n[CI/Tests ]   | ssl_handshake_timeout = None\n[CI/Tests ]   | type       = <SocketKind.SOCK_STREAM: 1>\n[CI/Tests ]   | \n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/base_events.py:971: OSError\n[CI/Tests ]   | ____________________________ test_flag_helper[None] ____________________________\n[CI/Tests ]   | \n[CI/Tests ]   | mcache_flag_client = <aiomcache.client.FlagClient object at 0x7f8a7ed71090>\n[CI/Tests ]   | value = None\n[CI/Tests ]   | \n[CI/Tests ]   |     @pytest.mark.parametrize(\n[CI/Tests ]   |         \"value\",\n[CI/Tests ]   |         [\n[CI/Tests ]   |             \"key\",\n[CI/Tests ]   |             b\"bkey\",\n[CI/Tests ]   |             False,\n[CI/Tests ]   |             1,\n[CI/Tests ]   |             None,\n[CI/Tests ]   |             0.5,\n[CI/Tests ]   |             [1, 2, 3],\n[CI/Tests ]   |             tuple([1, 2, 3]),\n[CI/Tests ]   |             [datetime.date(2015, 12, 28)],\n[CI/Tests ]   |             bytes(\"!@#\", \"utf-8\"),\n[CI/Tests ]   |             bytes(\"\uc548\ub155\ud558\uc138\uc694\", \"utf-8\"),\n[CI/Tests ]   |         ]\n[CI/Tests ]   |     )\n[CI/Tests ]   |     async def test_flag_helper(\n[CI/Tests ]   |             mcache_flag_client: FlagClient[Any], value: object) -> None:\n[CI/Tests ]   |         key = b\"key:test_flag_helper\"\n[CI/Tests ]   |     \n[CI/Tests ]   | >       await mcache_flag_client.set(key, value)\n[CI/Tests ]   | \n[CI/Tests ]   | key        = b'key:test_flag_helper'\n[CI/Tests ]   | mcache_flag_client = <aiomcache.client.FlagClient object at 0x7f8a7ed71090>\n[CI/Tests ]   | value      = None\n[CI/Tests ]   | \n[CI/Tests ]   | tests/commands_test.py:385: \n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | aiomcache/client.py:40: in wrapper\n[CI/Tests ]   |     conn = await self._pool.acquire()\n[CI/Tests ]   |         args       = (b'key:test_flag_helper', None)\n[CI/Tests ]   |         func       = <function FlagClient.set at 0x7f8a7edf9050>\n[CI/Tests ]   |         kwargs     = {}\n[CI/Tests ]   |         self       = <aiomcache.client.FlagClient object at 0x7f8a7ed71090>\n[CI/Tests ]   | aiomcache/pool.py:40: in acquire\n[CI/Tests ]   |     _conn = await self._create_new_conn()\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ed71590>\n[CI/Tests ]   | aiomcache/pool.py:71: in _create_new_conn\n[CI/Tests ]   |     self._host, self._port, **self.conn_args)\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ed71590>\n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/streams.py:77: in open_connection\n[CI/Tests ]   |     lambda: protocol, host, port, **kwds)\n[CI/Tests ]   |         host       = 'localhost'\n[CI/Tests ]   |         kwds       = {}\n[CI/Tests ]   |         limit      = 65536\n[CI/Tests ]   |         loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   |         port       = 11211\n[CI/Tests ]   |         protocol   = <asyncio.streams.StreamReaderProtocol object at 0x7f8a7ea398d0>\n[CI/Tests ]   |         reader     = <StreamReader>\n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | \n[CI/Tests ]   | self = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ea66170>\n[CI/Tests ]   | host = 'localhost', port = 11211\n[CI/Tests ]   | \n[CI/Tests ]   |     async def create_connection(\n[CI/Tests ]   |             self, protocol_factory, host=None, port=None,\n[CI/Tests ]   |             *, ssl=None, family=0,\n[CI/Tests ]   |             proto=0, flags=0, sock=None,\n[CI/Tests ]   |             local_addr=None, server_hostname=None,\n[CI/Tests ]   |             ssl_handshake_timeout=None):\n[CI/Tests ]   |         \"\"\"Connect to a TCP server.\n[CI/Tests ]   |     \n[CI/Tests ]   |         Create a streaming transport connection to a given Internet host and\n[CI/Tests ]   |         port: socket family AF_INET or socket.AF_INET6 depending on host (or\n[CI/Tests ]   |         family if specified), socket type SOCK_STREAM. protocol_factory must be\n[CI/Tests ]   |         a callable returning a protocol instance.\n[CI/Tests ]   |     \n[CI/Tests ]   |         This method is a coroutine which will try to establish the connection\n[CI/Tests ]   |         in the background.  When successful, the coroutine returns a\n[CI/Tests ]   |         (transport, protocol) pair.\n[CI/Tests ]   |         \"\"\"\n[CI/Tests ]   |         if server_hostname is not None and not ssl:\n[CI/Tests ]   |             raise ValueError('server_hostname is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if server_hostname is None and ssl:\n[CI/Tests ]   |             # Use host as default for server_hostname.  It is an error\n[CI/Tests ]   |             # if host is empty or not set, e.g. when an\n[CI/Tests ]   |             # already-connected socket was passed or when only a port\n[CI/Tests ]   |             # is given.  To avoid this error, you can pass\n[CI/Tests ]   |             # server_hostname='' -- this will bypass the hostname\n[CI/Tests ]   |             # check.  (This also means that if host is a numeric\n[CI/Tests ]   |             # IP/IPv6 address, we will attempt to verify that exact\n[CI/Tests ]   |             # address; this will probably fail, but it is possible to\n[CI/Tests ]   |             # create a certificate for a specific IP address, so we\n[CI/Tests ]   |             # don't judge it here.)\n[CI/Tests ]   |             if not host:\n[CI/Tests ]   |                 raise ValueError('You must set server_hostname '\n[CI/Tests ]   |                                  'when using ssl without a host')\n[CI/Tests ]   |             server_hostname = host\n[CI/Tests ]   |     \n[CI/Tests ]   |         if ssl_handshake_timeout is not None and not ssl:\n[CI/Tests ]   |             raise ValueError(\n[CI/Tests ]   |                 'ssl_handshake_timeout is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if host is not None or port is not None:\n[CI/Tests ]   |             if sock is not None:\n[CI/Tests ]   |                 raise ValueError(\n[CI/Tests ]   |                     'host/port and sock can not be specified at the same time')\n[CI/Tests ]   |     \n[CI/Tests ]   |             infos = await self._ensure_resolved(\n[CI/Tests ]   |                 (host, port), family=family,\n[CI/Tests ]   |                 type=socket.SOCK_STREAM, proto=proto, flags=flags, loop=self)\n[CI/Tests ]   |             if not infos:\n[CI/Tests ]   |                 raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             if local_addr is not None:\n[CI/Tests ]   |                 laddr_infos = await self._ensure_resolved(\n[CI/Tests ]   |                     local_addr, family=family,\n[CI/Tests ]   |                     type=socket.SOCK_STREAM, proto=proto,\n[CI/Tests ]   |                     flags=flags, loop=self)\n[CI/Tests ]   |                 if not laddr_infos:\n[CI/Tests ]   |                     raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             exceptions = []\n[CI/Tests ]   |             for family, type, proto, cname, address in infos:\n[CI/Tests ]   |                 try:\n[CI/Tests ]   |                     sock = socket.socket(family=family, type=type, proto=proto)\n[CI/Tests ]   |                     sock.setblocking(False)\n[CI/Tests ]   |                     if local_addr is not None:\n[CI/Tests ]   |                         for _, _, _, _, laddr in laddr_infos:\n[CI/Tests ]   |                             try:\n[CI/Tests ]   |                                 sock.bind(laddr)\n[CI/Tests ]   |                                 break\n[CI/Tests ]   |                             except OSError as exc:\n[CI/Tests ]   |                                 msg = (\n[CI/Tests ]   |                                     f'error while attempting to bind on '\n[CI/Tests ]   |                                     f'address {laddr!r}: '\n[CI/Tests ]   |                                     f'{exc.strerror.lower()}'\n[CI/Tests ]   |                                 )\n[CI/Tests ]   |                                 exc = OSError(exc.errno, msg)\n[CI/Tests ]   |                                 exceptions.append(exc)\n[CI/Tests ]   |                         else:\n[CI/Tests ]   |                             sock.close()\n[CI/Tests ]   |                             sock = None\n[CI/Tests ]   |                             continue\n[CI/Tests ]   |                     if self._debug:\n[CI/Tests ]   |                         logger.debug(\"connect %r to %r\", sock, address)\n[CI/Tests ]   |                     await self.sock_connect(sock, address)\n[CI/Tests ]   |                 except OSError as exc:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     exceptions.append(exc)\n[CI/Tests ]   |                 except:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     raise\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     break\n[CI/Tests ]   |             else:\n[CI/Tests ]   |                 if len(exceptions) == 1:\n[CI/Tests ]   |                     raise exceptions[0]\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     # If they all have the same str(), raise one.\n[CI/Tests ]   |                     model = str(exceptions[0])\n[CI/Tests ]   |                     if all(str(exc) == model for exc in exceptions):\n[CI/Tests ]   |                         raise exceptions[0]\n[CI/Tests ]   |                     # Raise a combined exception so the user can see all\n[CI/Tests ]   |                     # the various error messages.\n[CI/Tests ]   |                     raise OSError('Multiple exceptions: {}'.format(\n[CI/Tests ]   | >                       ', '.join(str(exc) for exc in exceptions)))\n[CI/Tests ]   | E                   OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | \n[CI/Tests ]   | address    = ('::1', 11211, 0, 0)\n[CI/Tests ]   | cname      = ''\n[CI/Tests ]   | exceptions = [ConnectionRefusedError(111, \"Connect call failed ('127.0.0.1', 11211)\"), OSError(99, 'Cannot assign requested address')]\n[CI/Tests ]   | family     = <AddressFamily.AF_INET6: 10>\n[CI/Tests ]   | flags      = 0\n[CI/Tests ]   | host       = 'localhost'\n[CI/Tests ]   | infos      = [(<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('127.0.0.1', 11211)), (<AddressFamily.AF_INET6: 10>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('::1', 11211, 0, 0))]\n[CI/Tests ]   | local_addr = None\n[CI/Tests ]   | model      = \"[Errno 111] Connect call failed ('127.0.0.1', 11211)\"\n[CI/Tests ]   | port       = 11211\n[CI/Tests ]   | proto      = 6\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ea66170>\n[CI/Tests ]   | self       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | server_hostname = None\n[CI/Tests ]   | sock       = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6>\n[CI/Tests ]   | ssl        = None\n[CI/Tests ]   | ssl_handshake_timeout = None\n[CI/Tests ]   | type       = <SocketKind.SOCK_STREAM: 1>\n[CI/Tests ]   | \n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/base_events.py:971: OSError\n[CI/Tests ]   | ____________________________ test_flag_helper[0.5] _____________________________\n[CI/Tests ]   | \n[CI/Tests ]   | mcache_flag_client = <aiomcache.client.FlagClient object at 0x7f8a7e999d10>\n[CI/Tests ]   | value = 0.5\n[CI/Tests ]   | \n[CI/Tests ]   |     @pytest.mark.parametrize(\n[CI/Tests ]   |         \"value\",\n[CI/Tests ]   |         [\n[CI/Tests ]   |             \"key\",\n[CI/Tests ]   |             b\"bkey\",\n[CI/Tests ]   |             False,\n[CI/Tests ]   |             1,\n[CI/Tests ]   |             None,\n[CI/Tests ]   |             0.5,\n[CI/Tests ]   |             [1, 2, 3],\n[CI/Tests ]   |             tuple([1, 2, 3]),\n[CI/Tests ]   |             [datetime.date(2015, 12, 28)],\n[CI/Tests ]   |             bytes(\"!@#\", \"utf-8\"),\n[CI/Tests ]   |             bytes(\"\uc548\ub155\ud558\uc138\uc694\", \"utf-8\"),\n[CI/Tests ]   |         ]\n[CI/Tests ]   |     )\n[CI/Tests ]   |     async def test_flag_helper(\n[CI/Tests ]   |             mcache_flag_client: FlagClient[Any], value: object) -> None:\n[CI/Tests ]   |         key = b\"key:test_flag_helper\"\n[CI/Tests ]   |     \n[CI/Tests ]   | >       await mcache_flag_client.set(key, value)\n[CI/Tests ]   | \n[CI/Tests ]   | key        = b'key:test_flag_helper'\n[CI/Tests ]   | mcache_flag_client = <aiomcache.client.FlagClient object at 0x7f8a7e999d10>\n[CI/Tests ]   | value      = 0.5\n[CI/Tests ]   | \n[CI/Tests ]   | tests/commands_test.py:385: \n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | aiomcache/client.py:40: in wrapper\n[CI/Tests ]   |     conn = await self._pool.acquire()\n[CI/Tests ]   |         args       = (b'key:test_flag_helper', 0.5)\n[CI/Tests ]   |         func       = <function FlagClient.set at 0x7f8a7edf9050>\n[CI/Tests ]   |         kwargs     = {}\n[CI/Tests ]   |         self       = <aiomcache.client.FlagClient object at 0x7f8a7e999d10>\n[CI/Tests ]   | aiomcache/pool.py:40: in acquire\n[CI/Tests ]   |     _conn = await self._create_new_conn()\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7e999550>\n[CI/Tests ]   | aiomcache/pool.py:71: in _create_new_conn\n[CI/Tests ]   |     self._host, self._port, **self.conn_args)\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7e999550>\n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/streams.py:77: in open_connection\n[CI/Tests ]   |     lambda: protocol, host, port, **kwds)\n[CI/Tests ]   |         host       = 'localhost'\n[CI/Tests ]   |         kwds       = {}\n[CI/Tests ]   |         limit      = 65536\n[CI/Tests ]   |         loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   |         port       = 11211\n[CI/Tests ]   |         protocol   = <asyncio.streams.StreamReaderProtocol object at 0x7f8a7e999190>\n[CI/Tests ]   |         reader     = <StreamReader>\n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | \n[CI/Tests ]   | self = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7e98d440>\n[CI/Tests ]   | host = 'localhost', port = 11211\n[CI/Tests ]   | \n[CI/Tests ]   |     async def create_connection(\n[CI/Tests ]   |             self, protocol_factory, host=None, port=None,\n[CI/Tests ]   |             *, ssl=None, family=0,\n[CI/Tests ]   |             proto=0, flags=0, sock=None,\n[CI/Tests ]   |             local_addr=None, server_hostname=None,\n[CI/Tests ]   |             ssl_handshake_timeout=None):\n[CI/Tests ]   |         \"\"\"Connect to a TCP server.\n[CI/Tests ]   |     \n[CI/Tests ]   |         Create a streaming transport connection to a given Internet host and\n[CI/Tests ]   |         port: socket family AF_INET or socket.AF_INET6 depending on host (or\n[CI/Tests ]   |         family if specified), socket type SOCK_STREAM. protocol_factory must be\n[CI/Tests ]   |         a callable returning a protocol instance.\n[CI/Tests ]   |     \n[CI/Tests ]   |         This method is a coroutine which will try to establish the connection\n[CI/Tests ]   |         in the background.  When successful, the coroutine returns a\n[CI/Tests ]   |         (transport, protocol) pair.\n[CI/Tests ]   |         \"\"\"\n[CI/Tests ]   |         if server_hostname is not None and not ssl:\n[CI/Tests ]   |             raise ValueError('server_hostname is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if server_hostname is None and ssl:\n[CI/Tests ]   |             # Use host as default for server_hostname.  It is an error\n[CI/Tests ]   |             # if host is empty or not set, e.g. when an\n[CI/Tests ]   |             # already-connected socket was passed or when only a port\n[CI/Tests ]   |             # is given.  To avoid this error, you can pass\n[CI/Tests ]   |             # server_hostname='' -- this will bypass the hostname\n[CI/Tests ]   |             # check.  (This also means that if host is a numeric\n[CI/Tests ]   |             # IP/IPv6 address, we will attempt to verify that exact\n[CI/Tests ]   |             # address; this will probably fail, but it is possible to\n[CI/Tests ]   |             # create a certificate for a specific IP address, so we\n[CI/Tests ]   |             # don't judge it here.)\n[CI/Tests ]   |             if not host:\n[CI/Tests ]   |                 raise ValueError('You must set server_hostname '\n[CI/Tests ]   |                                  'when using ssl without a host')\n[CI/Tests ]   |             server_hostname = host\n[CI/Tests ]   |     \n[CI/Tests ]   |         if ssl_handshake_timeout is not None and not ssl:\n[CI/Tests ]   |             raise ValueError(\n[CI/Tests ]   |                 'ssl_handshake_timeout is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if host is not None or port is not None:\n[CI/Tests ]   |             if sock is not None:\n[CI/Tests ]   |                 raise ValueError(\n[CI/Tests ]   |                     'host/port and sock can not be specified at the same time')\n[CI/Tests ]   |     \n[CI/Tests ]   |             infos = await self._ensure_resolved(\n[CI/Tests ]   |                 (host, port), family=family,\n[CI/Tests ]   |                 type=socket.SOCK_STREAM, proto=proto, flags=flags, loop=self)\n[CI/Tests ]   |             if not infos:\n[CI/Tests ]   |                 raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             if local_addr is not None:\n[CI/Tests ]   |                 laddr_infos = await self._ensure_resolved(\n[CI/Tests ]   |                     local_addr, family=family,\n[CI/Tests ]   |                     type=socket.SOCK_STREAM, proto=proto,\n[CI/Tests ]   |                     flags=flags, loop=self)\n[CI/Tests ]   |                 if not laddr_infos:\n[CI/Tests ]   |                     raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             exceptions = []\n[CI/Tests ]   |             for family, type, proto, cname, address in infos:\n[CI/Tests ]   |                 try:\n[CI/Tests ]   |                     sock = socket.socket(family=family, type=type, proto=proto)\n[CI/Tests ]   |                     sock.setblocking(False)\n[CI/Tests ]   |                     if local_addr is not None:\n[CI/Tests ]   |                         for _, _, _, _, laddr in laddr_infos:\n[CI/Tests ]   |                             try:\n[CI/Tests ]   |                                 sock.bind(laddr)\n[CI/Tests ]   |                                 break\n[CI/Tests ]   |                             except OSError as exc:\n[CI/Tests ]   |                                 msg = (\n[CI/Tests ]   |                                     f'error while attempting to bind on '\n[CI/Tests ]   |                                     f'address {laddr!r}: '\n[CI/Tests ]   |                                     f'{exc.strerror.lower()}'\n[CI/Tests ]   |                                 )\n[CI/Tests ]   |                                 exc = OSError(exc.errno, msg)\n[CI/Tests ]   |                                 exceptions.append(exc)\n[CI/Tests ]   |                         else:\n[CI/Tests ]   |                             sock.close()\n[CI/Tests ]   |                             sock = None\n[CI/Tests ]   |                             continue\n[CI/Tests ]   |                     if self._debug:\n[CI/Tests ]   |                         logger.debug(\"connect %r to %r\", sock, address)\n[CI/Tests ]   |                     await self.sock_connect(sock, address)\n[CI/Tests ]   |                 except OSError as exc:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     exceptions.append(exc)\n[CI/Tests ]   |                 except:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     raise\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     break\n[CI/Tests ]   |             else:\n[CI/Tests ]   |                 if len(exceptions) == 1:\n[CI/Tests ]   |                     raise exceptions[0]\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     # If they all have the same str(), raise one.\n[CI/Tests ]   |                     model = str(exceptions[0])\n[CI/Tests ]   |                     if all(str(exc) == model for exc in exceptions):\n[CI/Tests ]   |                         raise exceptions[0]\n[CI/Tests ]   |                     # Raise a combined exception so the user can see all\n[CI/Tests ]   |                     # the various error messages.\n[CI/Tests ]   |                     raise OSError('Multiple exceptions: {}'.format(\n[CI/Tests ]   | >                       ', '.join(str(exc) for exc in exceptions)))\n[CI/Tests ]   | E                   OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | \n[CI/Tests ]   | address    = ('::1', 11211, 0, 0)\n[CI/Tests ]   | cname      = ''\n[CI/Tests ]   | exceptions = [ConnectionRefusedError(111, \"Connect call failed ('127.0.0.1', 11211)\"), OSError(99, 'Cannot assign requested address')]\n[CI/Tests ]   | family     = <AddressFamily.AF_INET6: 10>\n[CI/Tests ]   | flags      = 0\n[CI/Tests ]   | host       = 'localhost'\n[CI/Tests ]   | infos      = [(<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('127.0.0.1', 11211)), (<AddressFamily.AF_INET6: 10>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('::1', 11211, 0, 0))]\n[CI/Tests ]   | local_addr = None\n[CI/Tests ]   | model      = \"[Errno 111] Connect call failed ('127.0.0.1', 11211)\"\n[CI/Tests ]   | port       = 11211\n[CI/Tests ]   | proto      = 6\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7e98d440>\n[CI/Tests ]   | self       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | server_hostname = None\n[CI/Tests ]   | sock       = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6>\n[CI/Tests ]   | ssl        = None\n[CI/Tests ]   | ssl_handshake_timeout = None\n[CI/Tests ]   | type       = <SocketKind.SOCK_STREAM: 1>\n[CI/Tests ]   | \n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/base_events.py:971: OSError\n[CI/Tests ]   | ___________________________ test_flag_helper[value6] ___________________________\n[CI/Tests ]   | \n[CI/Tests ]   | mcache_flag_client = <aiomcache.client.FlagClient object at 0x7f8a7eb9c850>\n[CI/Tests ]   | value = [1, 2, 3]\n[CI/Tests ]   | \n[CI/Tests ]   |     @pytest.mark.parametrize(\n[CI/Tests ]   |         \"value\",\n[CI/Tests ]   |         [\n[CI/Tests ]   |             \"key\",\n[CI/Tests ]   |             b\"bkey\",\n[CI/Tests ]   |             False,\n[CI/Tests ]   |             1,\n[CI/Tests ]   |             None,\n[CI/Tests ]   |             0.5,\n[CI/Tests ]   |             [1, 2, 3],\n[CI/Tests ]   |             tuple([1, 2, 3]),\n[CI/Tests ]   |             [datetime.date(2015, 12, 28)],\n[CI/Tests ]   |             bytes(\"!@#\", \"utf-8\"),\n[CI/Tests ]   |             bytes(\"\uc548\ub155\ud558\uc138\uc694\", \"utf-8\"),\n[CI/Tests ]   |         ]\n[CI/Tests ]   |     )\n[CI/Tests ]   |     async def test_flag_helper(\n[CI/Tests ]   |             mcache_flag_client: FlagClient[Any], value: object) -> None:\n[CI/Tests ]   |         key = b\"key:test_flag_helper\"\n[CI/Tests ]   |     \n[CI/Tests ]   | >       await mcache_flag_client.set(key, value)\n[CI/Tests ]   | \n[CI/Tests ]   | key        = b'key:test_flag_helper'\n[CI/Tests ]   | mcache_flag_client = <aiomcache.client.FlagClient object at 0x7f8a7eb9c850>\n[CI/Tests ]   | value      = [1, 2, 3]\n[CI/Tests ]   | \n[CI/Tests ]   | tests/commands_test.py:385: \n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | aiomcache/client.py:40: in wrapper\n[CI/Tests ]   |     conn = await self._pool.acquire()\n[CI/Tests ]   |         args       = (b'key:test_flag_helper', [1, 2, 3])\n[CI/Tests ]   |         func       = <function FlagClient.set at 0x7f8a7edf9050>\n[CI/Tests ]   |         kwargs     = {}\n[CI/Tests ]   |         self       = <aiomcache.client.FlagClient object at 0x7f8a7eb9c850>\n[CI/Tests ]   | aiomcache/pool.py:40: in acquire\n[CI/Tests ]   |     _conn = await self._create_new_conn()\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7eb9c1d0>\n[CI/Tests ]   | aiomcache/pool.py:71: in _create_new_conn\n[CI/Tests ]   |     self._host, self._port, **self.conn_args)\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7eb9c1d0>\n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/streams.py:77: in open_connection\n[CI/Tests ]   |     lambda: protocol, host, port, **kwds)\n[CI/Tests ]   |         host       = 'localhost'\n[CI/Tests ]   |         kwds       = {}\n[CI/Tests ]   |         limit      = 65536\n[CI/Tests ]   |         loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   |         port       = 11211\n[CI/Tests ]   |         protocol   = <asyncio.streams.StreamReaderProtocol object at 0x7f8a7eb9c6d0>\n[CI/Tests ]   |         reader     = <StreamReader>\n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | \n[CI/Tests ]   | self = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7e98ddd0>\n[CI/Tests ]   | host = 'localhost', port = 11211\n[CI/Tests ]   | \n[CI/Tests ]   |     async def create_connection(\n[CI/Tests ]   |             self, protocol_factory, host=None, port=None,\n[CI/Tests ]   |             *, ssl=None, family=0,\n[CI/Tests ]   |             proto=0, flags=0, sock=None,\n[CI/Tests ]   |             local_addr=None, server_hostname=None,\n[CI/Tests ]   |             ssl_handshake_timeout=None):\n[CI/Tests ]   |         \"\"\"Connect to a TCP server.\n[CI/Tests ]   |     \n[CI/Tests ]   |         Create a streaming transport connection to a given Internet host and\n[CI/Tests ]   |         port: socket family AF_INET or socket.AF_INET6 depending on host (or\n[CI/Tests ]   |         family if specified), socket type SOCK_STREAM. protocol_factory must be\n[CI/Tests ]   |         a callable returning a protocol instance.\n[CI/Tests ]   |     \n[CI/Tests ]   |         This method is a coroutine which will try to establish the connection\n[CI/Tests ]   |         in the background.  When successful, the coroutine returns a\n[CI/Tests ]   |         (transport, protocol) pair.\n[CI/Tests ]   |         \"\"\"\n[CI/Tests ]   |         if server_hostname is not None and not ssl:\n[CI/Tests ]   |             raise ValueError('server_hostname is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if server_hostname is None and ssl:\n[CI/Tests ]   |             # Use host as default for server_hostname.  It is an error\n[CI/Tests ]   |             # if host is empty or not set, e.g. when an\n[CI/Tests ]   |             # already-connected socket was passed or when only a port\n[CI/Tests ]   |             # is given.  To avoid this error, you can pass\n[CI/Tests ]   |             # server_hostname='' -- this will bypass the hostname\n[CI/Tests ]   |             # check.  (This also means that if host is a numeric\n[CI/Tests ]   |             # IP/IPv6 address, we will attempt to verify that exact\n[CI/Tests ]   |             # address; this will probably fail, but it is possible to\n[CI/Tests ]   |             # create a certificate for a specific IP address, so we\n[CI/Tests ]   |             # don't judge it here.)\n[CI/Tests ]   |             if not host:\n[CI/Tests ]   |                 raise ValueError('You must set server_hostname '\n[CI/Tests ]   |                                  'when using ssl without a host')\n[CI/Tests ]   |             server_hostname = host\n[CI/Tests ]   |     \n[CI/Tests ]   |         if ssl_handshake_timeout is not None and not ssl:\n[CI/Tests ]   |             raise ValueError(\n[CI/Tests ]   |                 'ssl_handshake_timeout is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if host is not None or port is not None:\n[CI/Tests ]   |             if sock is not None:\n[CI/Tests ]   |                 raise ValueError(\n[CI/Tests ]   |                     'host/port and sock can not be specified at the same time')\n[CI/Tests ]   |     \n[CI/Tests ]   |             infos = await self._ensure_resolved(\n[CI/Tests ]   |                 (host, port), family=family,\n[CI/Tests ]   |                 type=socket.SOCK_STREAM, proto=proto, flags=flags, loop=self)\n[CI/Tests ]   |             if not infos:\n[CI/Tests ]   |                 raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             if local_addr is not None:\n[CI/Tests ]   |                 laddr_infos = await self._ensure_resolved(\n[CI/Tests ]   |                     local_addr, family=family,\n[CI/Tests ]   |                     type=socket.SOCK_STREAM, proto=proto,\n[CI/Tests ]   |                     flags=flags, loop=self)\n[CI/Tests ]   |                 if not laddr_infos:\n[CI/Tests ]   |                     raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             exceptions = []\n[CI/Tests ]   |             for family, type, proto, cname, address in infos:\n[CI/Tests ]   |                 try:\n[CI/Tests ]   |                     sock = socket.socket(family=family, type=type, proto=proto)\n[CI/Tests ]   |                     sock.setblocking(False)\n[CI/Tests ]   |                     if local_addr is not None:\n[CI/Tests ]   |                         for _, _, _, _, laddr in laddr_infos:\n[CI/Tests ]   |                             try:\n[CI/Tests ]   |                                 sock.bind(laddr)\n[CI/Tests ]   |                                 break\n[CI/Tests ]   |                             except OSError as exc:\n[CI/Tests ]   |                                 msg = (\n[CI/Tests ]   |                                     f'error while attempting to bind on '\n[CI/Tests ]   |                                     f'address {laddr!r}: '\n[CI/Tests ]   |                                     f'{exc.strerror.lower()}'\n[CI/Tests ]   |                                 )\n[CI/Tests ]   |                                 exc = OSError(exc.errno, msg)\n[CI/Tests ]   |                                 exceptions.append(exc)\n[CI/Tests ]   |                         else:\n[CI/Tests ]   |                             sock.close()\n[CI/Tests ]   |                             sock = None\n[CI/Tests ]   |                             continue\n[CI/Tests ]   |                     if self._debug:\n[CI/Tests ]   |                         logger.debug(\"connect %r to %r\", sock, address)\n[CI/Tests ]   |                     await self.sock_connect(sock, address)\n[CI/Tests ]   |                 except OSError as exc:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     exceptions.append(exc)\n[CI/Tests ]   |                 except:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     raise\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     break\n[CI/Tests ]   |             else:\n[CI/Tests ]   |                 if len(exceptions) == 1:\n[CI/Tests ]   |                     raise exceptions[0]\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     # If they all have the same str(), raise one.\n[CI/Tests ]   |                     model = str(exceptions[0])\n[CI/Tests ]   |                     if all(str(exc) == model for exc in exceptions):\n[CI/Tests ]   |                         raise exceptions[0]\n[CI/Tests ]   |                     # Raise a combined exception so the user can see all\n[CI/Tests ]   |                     # the various error messages.\n[CI/Tests ]   |                     raise OSError('Multiple exceptions: {}'.format(\n[CI/Tests ]   | >                       ', '.join(str(exc) for exc in exceptions)))\n[CI/Tests ]   | E                   OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | \n[CI/Tests ]   | address    = ('::1', 11211, 0, 0)\n[CI/Tests ]   | cname      = ''\n[CI/Tests ]   | exceptions = [ConnectionRefusedError(111, \"Connect call failed ('127.0.0.1', 11211)\"), OSError(99, 'Cannot assign requested address')]\n[CI/Tests ]   | family     = <AddressFamily.AF_INET6: 10>\n[CI/Tests ]   | flags      = 0\n[CI/Tests ]   | host       = 'localhost'\n[CI/Tests ]   | infos      = [(<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('127.0.0.1', 11211)), (<AddressFamily.AF_INET6: 10>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('::1', 11211, 0, 0))]\n[CI/Tests ]   | local_addr = None\n[CI/Tests ]   | model      = \"[Errno 111] Connect call failed ('127.0.0.1', 11211)\"\n[CI/Tests ]   | port       = 11211\n[CI/Tests ]   | proto      = 6\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7e98ddd0>\n[CI/Tests ]   | self       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | server_hostname = None\n[CI/Tests ]   | sock       = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6>\n[CI/Tests ]   | ssl        = None\n[CI/Tests ]   | ssl_handshake_timeout = None\n[CI/Tests ]   | type       = <SocketKind.SOCK_STREAM: 1>\n[CI/Tests ]   | \n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/base_events.py:971: OSError\n[CI/Tests ]   | ___________________________ test_flag_helper[value7] ___________________________\n[CI/Tests ]   | \n[CI/Tests ]   | mcache_flag_client = <aiomcache.client.FlagClient object at 0x7f8a7ee67250>\n[CI/Tests ]   | value = (1, 2, 3)\n[CI/Tests ]   | \n[CI/Tests ]   |     @pytest.mark.parametrize(\n[CI/Tests ]   |         \"value\",\n[CI/Tests ]   |         [\n[CI/Tests ]   |             \"key\",\n[CI/Tests ]   |             b\"bkey\",\n[CI/Tests ]   |             False,\n[CI/Tests ]   |             1,\n[CI/Tests ]   |             None,\n[CI/Tests ]   |             0.5,\n[CI/Tests ]   |             [1, 2, 3],\n[CI/Tests ]   |             tuple([1, 2, 3]),\n[CI/Tests ]   |             [datetime.date(2015, 12, 28)],\n[CI/Tests ]   |             bytes(\"!@#\", \"utf-8\"),\n[CI/Tests ]   |             bytes(\"\uc548\ub155\ud558\uc138\uc694\", \"utf-8\"),\n[CI/Tests ]   |         ]\n[CI/Tests ]   |     )\n[CI/Tests ]   |     async def test_flag_helper(\n[CI/Tests ]   |             mcache_flag_client: FlagClient[Any], value: object) -> None:\n[CI/Tests ]   |         key = b\"key:test_flag_helper\"\n[CI/Tests ]   |     \n[CI/Tests ]   | >       await mcache_flag_client.set(key, value)\n[CI/Tests ]   | \n[CI/Tests ]   | key        = b'key:test_flag_helper'\n[CI/Tests ]   | mcache_flag_client = <aiomcache.client.FlagClient object at 0x7f8a7ee67250>\n[CI/Tests ]   | value      = (1, 2, 3)\n[CI/Tests ]   | \n[CI/Tests ]   | tests/commands_test.py:385: \n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | aiomcache/client.py:40: in wrapper\n[CI/Tests ]   |     conn = await self._pool.acquire()\n[CI/Tests ]   |         args       = (b'key:test_flag_helper', (1, 2, 3))\n[CI/Tests ]   |         func       = <function FlagClient.set at 0x7f8a7edf9050>\n[CI/Tests ]   |         kwargs     = {}\n[CI/Tests ]   |         self       = <aiomcache.client.FlagClient object at 0x7f8a7ee67250>\n[CI/Tests ]   | aiomcache/pool.py:40: in acquire\n[CI/Tests ]   |     _conn = await self._create_new_conn()\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ee67050>\n[CI/Tests ]   | aiomcache/pool.py:71: in _create_new_conn\n[CI/Tests ]   |     self._host, self._port, **self.conn_args)\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ee67050>\n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/streams.py:77: in open_connection\n[CI/Tests ]   |     lambda: protocol, host, port, **kwds)\n[CI/Tests ]   |         host       = 'localhost'\n[CI/Tests ]   |         kwds       = {}\n[CI/Tests ]   |         limit      = 65536\n[CI/Tests ]   |         loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   |         port       = 11211\n[CI/Tests ]   |         protocol   = <asyncio.streams.StreamReaderProtocol object at 0x7f8a7ee67610>\n[CI/Tests ]   |         reader     = <StreamReader>\n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | \n[CI/Tests ]   | self = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7e98d050>\n[CI/Tests ]   | host = 'localhost', port = 11211\n[CI/Tests ]   | \n[CI/Tests ]   |     async def create_connection(\n[CI/Tests ]   |             self, protocol_factory, host=None, port=None,\n[CI/Tests ]   |             *, ssl=None, family=0,\n[CI/Tests ]   |             proto=0, flags=0, sock=None,\n[CI/Tests ]   |             local_addr=None, server_hostname=None,\n[CI/Tests ]   |             ssl_handshake_timeout=None):\n[CI/Tests ]   |         \"\"\"Connect to a TCP server.\n[CI/Tests ]   |     \n[CI/Tests ]   |         Create a streaming transport connection to a given Internet host and\n[CI/Tests ]   |         port: socket family AF_INET or socket.AF_INET6 depending on host (or\n[CI/Tests ]   |         family if specified), socket type SOCK_STREAM. protocol_factory must be\n[CI/Tests ]   |         a callable returning a protocol instance.\n[CI/Tests ]   |     \n[CI/Tests ]   |         This method is a coroutine which will try to establish the connection\n[CI/Tests ]   |         in the background.  When successful, the coroutine returns a\n[CI/Tests ]   |         (transport, protocol) pair.\n[CI/Tests ]   |         \"\"\"\n[CI/Tests ]   |         if server_hostname is not None and not ssl:\n[CI/Tests ]   |             raise ValueError('server_hostname is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if server_hostname is None and ssl:\n[CI/Tests ]   |             # Use host as default for server_hostname.  It is an error\n[CI/Tests ]   |             # if host is empty or not set, e.g. when an\n[CI/Tests ]   |             # already-connected socket was passed or when only a port\n[CI/Tests ]   |             # is given.  To avoid this error, you can pass\n[CI/Tests ]   |             # server_hostname='' -- this will bypass the hostname\n[CI/Tests ]   |             # check.  (This also means that if host is a numeric\n[CI/Tests ]   |             # IP/IPv6 address, we will attempt to verify that exact\n[CI/Tests ]   |             # address; this will probably fail, but it is possible to\n[CI/Tests ]   |             # create a certificate for a specific IP address, so we\n[CI/Tests ]   |             # don't judge it here.)\n[CI/Tests ]   |             if not host:\n[CI/Tests ]   |                 raise ValueError('You must set server_hostname '\n[CI/Tests ]   |                                  'when using ssl without a host')\n[CI/Tests ]   |             server_hostname = host\n[CI/Tests ]   |     \n[CI/Tests ]   |         if ssl_handshake_timeout is not None and not ssl:\n[CI/Tests ]   |             raise ValueError(\n[CI/Tests ]   |                 'ssl_handshake_timeout is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if host is not None or port is not None:\n[CI/Tests ]   |             if sock is not None:\n[CI/Tests ]   |                 raise ValueError(\n[CI/Tests ]   |                     'host/port and sock can not be specified at the same time')\n[CI/Tests ]   |     \n[CI/Tests ]   |             infos = await self._ensure_resolved(\n[CI/Tests ]   |                 (host, port), family=family,\n[CI/Tests ]   |                 type=socket.SOCK_STREAM, proto=proto, flags=flags, loop=self)\n[CI/Tests ]   |             if not infos:\n[CI/Tests ]   |                 raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             if local_addr is not None:\n[CI/Tests ]   |                 laddr_infos = await self._ensure_resolved(\n[CI/Tests ]   |                     local_addr, family=family,\n[CI/Tests ]   |                     type=socket.SOCK_STREAM, proto=proto,\n[CI/Tests ]   |                     flags=flags, loop=self)\n[CI/Tests ]   |                 if not laddr_infos:\n[CI/Tests ]   |                     raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             exceptions = []\n[CI/Tests ]   |             for family, type, proto, cname, address in infos:\n[CI/Tests ]   |                 try:\n[CI/Tests ]   |                     sock = socket.socket(family=family, type=type, proto=proto)\n[CI/Tests ]   |                     sock.setblocking(False)\n[CI/Tests ]   |                     if local_addr is not None:\n[CI/Tests ]   |                         for _, _, _, _, laddr in laddr_infos:\n[CI/Tests ]   |                             try:\n[CI/Tests ]   |                                 sock.bind(laddr)\n[CI/Tests ]   |                                 break\n[CI/Tests ]   |                             except OSError as exc:\n[CI/Tests ]   |                                 msg = (\n[CI/Tests ]   |                                     f'error while attempting to bind on '\n[CI/Tests ]   |                                     f'address {laddr!r}: '\n[CI/Tests ]   |                                     f'{exc.strerror.lower()}'\n[CI/Tests ]   |                                 )\n[CI/Tests ]   |                                 exc = OSError(exc.errno, msg)\n[CI/Tests ]   |                                 exceptions.append(exc)\n[CI/Tests ]   |                         else:\n[CI/Tests ]   |                             sock.close()\n[CI/Tests ]   |                             sock = None\n[CI/Tests ]   |                             continue\n[CI/Tests ]   |                     if self._debug:\n[CI/Tests ]   |                         logger.debug(\"connect %r to %r\", sock, address)\n[CI/Tests ]   |                     await self.sock_connect(sock, address)\n[CI/Tests ]   |                 except OSError as exc:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     exceptions.append(exc)\n[CI/Tests ]   |                 except:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     raise\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     break\n[CI/Tests ]   |             else:\n[CI/Tests ]   |                 if len(exceptions) == 1:\n[CI/Tests ]   |                     raise exceptions[0]\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     # If they all have the same str(), raise one.\n[CI/Tests ]   |                     model = str(exceptions[0])\n[CI/Tests ]   |                     if all(str(exc) == model for exc in exceptions):\n[CI/Tests ]   |                         raise exceptions[0]\n[CI/Tests ]   |                     # Raise a combined exception so the user can see all\n[CI/Tests ]   |                     # the various error messages.\n[CI/Tests ]   |                     raise OSError('Multiple exceptions: {}'.format(\n[CI/Tests ]   | >                       ', '.join(str(exc) for exc in exceptions)))\n[CI/Tests ]   | E                   OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | \n[CI/Tests ]   | address    = ('::1', 11211, 0, 0)\n[CI/Tests ]   | cname      = ''\n[CI/Tests ]   | exceptions = [ConnectionRefusedError(111, \"Connect call failed ('127.0.0.1', 11211)\"), OSError(99, 'Cannot assign requested address')]\n[CI/Tests ]   | family     = <AddressFamily.AF_INET6: 10>\n[CI/Tests ]   | flags      = 0\n[CI/Tests ]   | host       = 'localhost'\n[CI/Tests ]   | infos      = [(<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('127.0.0.1', 11211)), (<AddressFamily.AF_INET6: 10>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('::1', 11211, 0, 0))]\n[CI/Tests ]   | local_addr = None\n[CI/Tests ]   | model      = \"[Errno 111] Connect call failed ('127.0.0.1', 11211)\"\n[CI/Tests ]   | port       = 11211\n[CI/Tests ]   | proto      = 6\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7e98d050>\n[CI/Tests ]   | self       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | server_hostname = None\n[CI/Tests ]   | sock       = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6>\n[CI/Tests ]   | ssl        = None\n[CI/Tests ]   | ssl_handshake_timeout = None\n[CI/Tests ]   | type       = <SocketKind.SOCK_STREAM: 1>\n[CI/Tests ]   | \n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/base_events.py:971: OSError\n[CI/Tests ]   | ___________________________ test_flag_helper[value8] ___________________________\n[CI/Tests ]   | \n[CI/Tests ]   | mcache_flag_client = <aiomcache.client.FlagClient object at 0x7f8a7ec43690>\n[CI/Tests ]   | value = [datetime.date(2015, 12, 28)]\n[CI/Tests ]   | \n[CI/Tests ]   |     @pytest.mark.parametrize(\n[CI/Tests ]   |         \"value\",\n[CI/Tests ]   |         [\n[CI/Tests ]   |             \"key\",\n[CI/Tests ]   |             b\"bkey\",\n[CI/Tests ]   |             False,\n[CI/Tests ]   |             1,\n[CI/Tests ]   |             None,\n[CI/Tests ]   |             0.5,\n[CI/Tests ]   |             [1, 2, 3],\n[CI/Tests ]   |             tuple([1, 2, 3]),\n[CI/Tests ]   |             [datetime.date(2015, 12, 28)],\n[CI/Tests ]   |             bytes(\"!@#\", \"utf-8\"),\n[CI/Tests ]   |             bytes(\"\uc548\ub155\ud558\uc138\uc694\", \"utf-8\"),\n[CI/Tests ]   |         ]\n[CI/Tests ]   |     )\n[CI/Tests ]   |     async def test_flag_helper(\n[CI/Tests ]   |             mcache_flag_client: FlagClient[Any], value: object) -> None:\n[CI/Tests ]   |         key = b\"key:test_flag_helper\"\n[CI/Tests ]   |     \n[CI/Tests ]   | >       await mcache_flag_client.set(key, value)\n[CI/Tests ]   | \n[CI/Tests ]   | key        = b'key:test_flag_helper'\n[CI/Tests ]   | mcache_flag_client = <aiomcache.client.FlagClient object at 0x7f8a7ec43690>\n[CI/Tests ]   | value      = [datetime.date(2015, 12, 28)]\n[CI/Tests ]   | \n[CI/Tests ]   | tests/commands_test.py:385: \n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | aiomcache/client.py:40: in wrapper\n[CI/Tests ]   |     conn = await self._pool.acquire()\n[CI/Tests ]   |         args       = (b'key:test_flag_helper', [datetime.date(2015, 12, 28)])\n[CI/Tests ]   |         func       = <function FlagClient.set at 0x7f8a7edf9050>\n[CI/Tests ]   |         kwargs     = {}\n[CI/Tests ]   |         self       = <aiomcache.client.FlagClient object at 0x7f8a7ec43690>\n[CI/Tests ]   | aiomcache/pool.py:40: in acquire\n[CI/Tests ]   |     _conn = await self._create_new_conn()\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ec43590>\n[CI/Tests ]   | aiomcache/pool.py:71: in _create_new_conn\n[CI/Tests ]   |     self._host, self._port, **self.conn_args)\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ec43590>\n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/streams.py:77: in open_connection\n[CI/Tests ]   |     lambda: protocol, host, port, **kwds)\n[CI/Tests ]   |         host       = 'localhost'\n[CI/Tests ]   |         kwds       = {}\n[CI/Tests ]   |         limit      = 65536\n[CI/Tests ]   |         loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   |         port       = 11211\n[CI/Tests ]   |         protocol   = <asyncio.streams.StreamReaderProtocol object at 0x7f8a7ec43110>\n[CI/Tests ]   |         reader     = <StreamReader>\n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | \n[CI/Tests ]   | self = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7e98d290>\n[CI/Tests ]   | host = 'localhost', port = 11211\n[CI/Tests ]   | \n[CI/Tests ]   |     async def create_connection(\n[CI/Tests ]   |             self, protocol_factory, host=None, port=None,\n[CI/Tests ]   |             *, ssl=None, family=0,\n[CI/Tests ]   |             proto=0, flags=0, sock=None,\n[CI/Tests ]   |             local_addr=None, server_hostname=None,\n[CI/Tests ]   |             ssl_handshake_timeout=None):\n[CI/Tests ]   |         \"\"\"Connect to a TCP server.\n[CI/Tests ]   |     \n[CI/Tests ]   |         Create a streaming transport connection to a given Internet host and\n[CI/Tests ]   |         port: socket family AF_INET or socket.AF_INET6 depending on host (or\n[CI/Tests ]   |         family if specified), socket type SOCK_STREAM. protocol_factory must be\n[CI/Tests ]   |         a callable returning a protocol instance.\n[CI/Tests ]   |     \n[CI/Tests ]   |         This method is a coroutine which will try to establish the connection\n[CI/Tests ]   |         in the background.  When successful, the coroutine returns a\n[CI/Tests ]   |         (transport, protocol) pair.\n[CI/Tests ]   |         \"\"\"\n[CI/Tests ]   |         if server_hostname is not None and not ssl:\n[CI/Tests ]   |             raise ValueError('server_hostname is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if server_hostname is None and ssl:\n[CI/Tests ]   |             # Use host as default for server_hostname.  It is an error\n[CI/Tests ]   |             # if host is empty or not set, e.g. when an\n[CI/Tests ]   |             # already-connected socket was passed or when only a port\n[CI/Tests ]   |             # is given.  To avoid this error, you can pass\n[CI/Tests ]   |             # server_hostname='' -- this will bypass the hostname\n[CI/Tests ]   |             # check.  (This also means that if host is a numeric\n[CI/Tests ]   |             # IP/IPv6 address, we will attempt to verify that exact\n[CI/Tests ]   |             # address; this will probably fail, but it is possible to\n[CI/Tests ]   |             # create a certificate for a specific IP address, so we\n[CI/Tests ]   |             # don't judge it here.)\n[CI/Tests ]   |             if not host:\n[CI/Tests ]   |                 raise ValueError('You must set server_hostname '\n[CI/Tests ]   |                                  'when using ssl without a host')\n[CI/Tests ]   |             server_hostname = host\n[CI/Tests ]   |     \n[CI/Tests ]   |         if ssl_handshake_timeout is not None and not ssl:\n[CI/Tests ]   |             raise ValueError(\n[CI/Tests ]   |                 'ssl_handshake_timeout is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if host is not None or port is not None:\n[CI/Tests ]   |             if sock is not None:\n[CI/Tests ]   |                 raise ValueError(\n[CI/Tests ]   |                     'host/port and sock can not be specified at the same time')\n[CI/Tests ]   |     \n[CI/Tests ]   |             infos = await self._ensure_resolved(\n[CI/Tests ]   |                 (host, port), family=family,\n[CI/Tests ]   |                 type=socket.SOCK_STREAM, proto=proto, flags=flags, loop=self)\n[CI/Tests ]   |             if not infos:\n[CI/Tests ]   |                 raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             if local_addr is not None:\n[CI/Tests ]   |                 laddr_infos = await self._ensure_resolved(\n[CI/Tests ]   |                     local_addr, family=family,\n[CI/Tests ]   |                     type=socket.SOCK_STREAM, proto=proto,\n[CI/Tests ]   |                     flags=flags, loop=self)\n[CI/Tests ]   |                 if not laddr_infos:\n[CI/Tests ]   |                     raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             exceptions = []\n[CI/Tests ]   |             for family, type, proto, cname, address in infos:\n[CI/Tests ]   |                 try:\n[CI/Tests ]   |                     sock = socket.socket(family=family, type=type, proto=proto)\n[CI/Tests ]   |                     sock.setblocking(False)\n[CI/Tests ]   |                     if local_addr is not None:\n[CI/Tests ]   |                         for _, _, _, _, laddr in laddr_infos:\n[CI/Tests ]   |                             try:\n[CI/Tests ]   |                                 sock.bind(laddr)\n[CI/Tests ]   |                                 break\n[CI/Tests ]   |                             except OSError as exc:\n[CI/Tests ]   |                                 msg = (\n[CI/Tests ]   |                                     f'error while attempting to bind on '\n[CI/Tests ]   |                                     f'address {laddr!r}: '\n[CI/Tests ]   |                                     f'{exc.strerror.lower()}'\n[CI/Tests ]   |                                 )\n[CI/Tests ]   |                                 exc = OSError(exc.errno, msg)\n[CI/Tests ]   |                                 exceptions.append(exc)\n[CI/Tests ]   |                         else:\n[CI/Tests ]   |                             sock.close()\n[CI/Tests ]   |                             sock = None\n[CI/Tests ]   |                             continue\n[CI/Tests ]   |                     if self._debug:\n[CI/Tests ]   |                         logger.debug(\"connect %r to %r\", sock, address)\n[CI/Tests ]   |                     await self.sock_connect(sock, address)\n[CI/Tests ]   |                 except OSError as exc:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     exceptions.append(exc)\n[CI/Tests ]   |                 except:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     raise\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     break\n[CI/Tests ]   |             else:\n[CI/Tests ]   |                 if len(exceptions) == 1:\n[CI/Tests ]   |                     raise exceptions[0]\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     # If they all have the same str(), raise one.\n[CI/Tests ]   |                     model = str(exceptions[0])\n[CI/Tests ]   |                     if all(str(exc) == model for exc in exceptions):\n[CI/Tests ]   |                         raise exceptions[0]\n[CI/Tests ]   |                     # Raise a combined exception so the user can see all\n[CI/Tests ]   |                     # the various error messages.\n[CI/Tests ]   |                     raise OSError('Multiple exceptions: {}'.format(\n[CI/Tests ]   | >                       ', '.join(str(exc) for exc in exceptions)))\n[CI/Tests ]   | E                   OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | \n[CI/Tests ]   | address    = ('::1', 11211, 0, 0)\n[CI/Tests ]   | cname      = ''\n[CI/Tests ]   | exceptions = [ConnectionRefusedError(111, \"Connect call failed ('127.0.0.1', 11211)\"), OSError(99, 'Cannot assign requested address')]\n[CI/Tests ]   | family     = <AddressFamily.AF_INET6: 10>\n[CI/Tests ]   | flags      = 0\n[CI/Tests ]   | host       = 'localhost'\n[CI/Tests ]   | infos      = [(<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('127.0.0.1', 11211)), (<AddressFamily.AF_INET6: 10>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('::1', 11211, 0, 0))]\n[CI/Tests ]   | local_addr = None\n[CI/Tests ]   | model      = \"[Errno 111] Connect call failed ('127.0.0.1', 11211)\"\n[CI/Tests ]   | port       = 11211\n[CI/Tests ]   | proto      = 6\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7e98d290>\n[CI/Tests ]   | self       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | server_hostname = None\n[CI/Tests ]   | sock       = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6>\n[CI/Tests ]   | ssl        = None\n[CI/Tests ]   | ssl_handshake_timeout = None\n[CI/Tests ]   | type       = <SocketKind.SOCK_STREAM: 1>\n[CI/Tests ]   | \n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/base_events.py:971: OSError\n[CI/Tests ]   | ____________________________ test_flag_helper[!@#] _____________________________\n[CI/Tests ]   | \n[CI/Tests ]   | mcache_flag_client = <aiomcache.client.FlagClient object at 0x7f8a7ee38c10>\n[CI/Tests ]   | value = b'!@#'\n[CI/Tests ]   | \n[CI/Tests ]   |     @pytest.mark.parametrize(\n[CI/Tests ]   |         \"value\",\n[CI/Tests ]   |         [\n[CI/Tests ]   |             \"key\",\n[CI/Tests ]   |             b\"bkey\",\n[CI/Tests ]   |             False,\n[CI/Tests ]   |             1,\n[CI/Tests ]   |             None,\n[CI/Tests ]   |             0.5,\n[CI/Tests ]   |             [1, 2, 3],\n[CI/Tests ]   |             tuple([1, 2, 3]),\n[CI/Tests ]   |             [datetime.date(2015, 12, 28)],\n[CI/Tests ]   |             bytes(\"!@#\", \"utf-8\"),\n[CI/Tests ]   |             bytes(\"\uc548\ub155\ud558\uc138\uc694\", \"utf-8\"),\n[CI/Tests ]   |         ]\n[CI/Tests ]   |     )\n[CI/Tests ]   |     async def test_flag_helper(\n[CI/Tests ]   |             mcache_flag_client: FlagClient[Any], value: object) -> None:\n[CI/Tests ]   |         key = b\"key:test_flag_helper\"\n[CI/Tests ]   |     \n[CI/Tests ]   | >       await mcache_flag_client.set(key, value)\n[CI/Tests ]   | \n[CI/Tests ]   | key        = b'key:test_flag_helper'\n[CI/Tests ]   | mcache_flag_client = <aiomcache.client.FlagClient object at 0x7f8a7ee38c10>\n[CI/Tests ]   | value      = b'!@#'\n[CI/Tests ]   | \n[CI/Tests ]   | tests/commands_test.py:385: \n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | aiomcache/client.py:40: in wrapper\n[CI/Tests ]   |     conn = await self._pool.acquire()\n[CI/Tests ]   |         args       = (b'key:test_flag_helper', b'!@#')\n[CI/Tests ]   |         func       = <function FlagClient.set at 0x7f8a7edf9050>\n[CI/Tests ]   |         kwargs     = {}\n[CI/Tests ]   |         self       = <aiomcache.client.FlagClient object at 0x7f8a7ee38c10>\n[CI/Tests ]   | aiomcache/pool.py:40: in acquire\n[CI/Tests ]   |     _conn = await self._create_new_conn()\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ee38050>\n[CI/Tests ]   | aiomcache/pool.py:71: in _create_new_conn\n[CI/Tests ]   |     self._host, self._port, **self.conn_args)\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ee38050>\n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/streams.py:77: in open_connection\n[CI/Tests ]   |     lambda: protocol, host, port, **kwds)\n[CI/Tests ]   |         host       = 'localhost'\n[CI/Tests ]   |         kwds       = {}\n[CI/Tests ]   |         limit      = 65536\n[CI/Tests ]   |         loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   |         port       = 11211\n[CI/Tests ]   |         protocol   = <asyncio.streams.StreamReaderProtocol object at 0x7f8a7ee38b90>\n[CI/Tests ]   |         reader     = <StreamReader>\n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | \n[CI/Tests ]   | self = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ebb1680>\n[CI/Tests ]   | host = 'localhost', port = 11211\n[CI/Tests ]   | \n[CI/Tests ]   |     async def create_connection(\n[CI/Tests ]   |             self, protocol_factory, host=None, port=None,\n[CI/Tests ]   |             *, ssl=None, family=0,\n[CI/Tests ]   |             proto=0, flags=0, sock=None,\n[CI/Tests ]   |             local_addr=None, server_hostname=None,\n[CI/Tests ]   |             ssl_handshake_timeout=None):\n[CI/Tests ]   |         \"\"\"Connect to a TCP server.\n[CI/Tests ]   |     \n[CI/Tests ]   |         Create a streaming transport connection to a given Internet host and\n[CI/Tests ]   |         port: socket family AF_INET or socket.AF_INET6 depending on host (or\n[CI/Tests ]   |         family if specified), socket type SOCK_STREAM. protocol_factory must be\n[CI/Tests ]   |         a callable returning a protocol instance.\n[CI/Tests ]   |     \n[CI/Tests ]   |         This method is a coroutine which will try to establish the connection\n[CI/Tests ]   |         in the background.  When successful, the coroutine returns a\n[CI/Tests ]   |         (transport, protocol) pair.\n[CI/Tests ]   |         \"\"\"\n[CI/Tests ]   |         if server_hostname is not None and not ssl:\n[CI/Tests ]   |             raise ValueError('server_hostname is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if server_hostname is None and ssl:\n[CI/Tests ]   |             # Use host as default for server_hostname.  It is an error\n[CI/Tests ]   |             # if host is empty or not set, e.g. when an\n[CI/Tests ]   |             # already-connected socket was passed or when only a port\n[CI/Tests ]   |             # is given.  To avoid this error, you can pass\n[CI/Tests ]   |             # server_hostname='' -- this will bypass the hostname\n[CI/Tests ]   |             # check.  (This also means that if host is a numeric\n[CI/Tests ]   |             # IP/IPv6 address, we will attempt to verify that exact\n[CI/Tests ]   |             # address; this will probably fail, but it is possible to\n[CI/Tests ]   |             # create a certificate for a specific IP address, so we\n[CI/Tests ]   |             # don't judge it here.)\n[CI/Tests ]   |             if not host:\n[CI/Tests ]   |                 raise ValueError('You must set server_hostname '\n[CI/Tests ]   |                                  'when using ssl without a host')\n[CI/Tests ]   |             server_hostname = host\n[CI/Tests ]   |     \n[CI/Tests ]   |         if ssl_handshake_timeout is not None and not ssl:\n[CI/Tests ]   |             raise ValueError(\n[CI/Tests ]   |                 'ssl_handshake_timeout is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if host is not None or port is not None:\n[CI/Tests ]   |             if sock is not None:\n[CI/Tests ]   |                 raise ValueError(\n[CI/Tests ]   |                     'host/port and sock can not be specified at the same time')\n[CI/Tests ]   |     \n[CI/Tests ]   |             infos = await self._ensure_resolved(\n[CI/Tests ]   |                 (host, port), family=family,\n[CI/Tests ]   |                 type=socket.SOCK_STREAM, proto=proto, flags=flags, loop=self)\n[CI/Tests ]   |             if not infos:\n[CI/Tests ]   |                 raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             if local_addr is not None:\n[CI/Tests ]   |                 laddr_infos = await self._ensure_resolved(\n[CI/Tests ]   |                     local_addr, family=family,\n[CI/Tests ]   |                     type=socket.SOCK_STREAM, proto=proto,\n[CI/Tests ]   |                     flags=flags, loop=self)\n[CI/Tests ]   |                 if not laddr_infos:\n[CI/Tests ]   |                     raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             exceptions = []\n[CI/Tests ]   |             for family, type, proto, cname, address in infos:\n[CI/Tests ]   |                 try:\n[CI/Tests ]   |                     sock = socket.socket(family=family, type=type, proto=proto)\n[CI/Tests ]   |                     sock.setblocking(False)\n[CI/Tests ]   |                     if local_addr is not None:\n[CI/Tests ]   |                         for _, _, _, _, laddr in laddr_infos:\n[CI/Tests ]   |                             try:\n[CI/Tests ]   |                                 sock.bind(laddr)\n[CI/Tests ]   |                                 break\n[CI/Tests ]   |                             except OSError as exc:\n[CI/Tests ]   |                                 msg = (\n[CI/Tests ]   |                                     f'error while attempting to bind on '\n[CI/Tests ]   |                                     f'address {laddr!r}: '\n[CI/Tests ]   |                                     f'{exc.strerror.lower()}'\n[CI/Tests ]   |                                 )\n[CI/Tests ]   |                                 exc = OSError(exc.errno, msg)\n[CI/Tests ]   |                                 exceptions.append(exc)\n[CI/Tests ]   |                         else:\n[CI/Tests ]   |                             sock.close()\n[CI/Tests ]   |                             sock = None\n[CI/Tests ]   |                             continue\n[CI/Tests ]   |                     if self._debug:\n[CI/Tests ]   |                         logger.debug(\"connect %r to %r\", sock, address)\n[CI/Tests ]   |                     await self.sock_connect(sock, address)\n[CI/Tests ]   |                 except OSError as exc:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     exceptions.append(exc)\n[CI/Tests ]   |                 except:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     raise\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     break\n[CI/Tests ]   |             else:\n[CI/Tests ]   |                 if len(exceptions) == 1:\n[CI/Tests ]   |                     raise exceptions[0]\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     # If they all have the same str(), raise one.\n[CI/Tests ]   |                     model = str(exceptions[0])\n[CI/Tests ]   |                     if all(str(exc) == model for exc in exceptions):\n[CI/Tests ]   |                         raise exceptions[0]\n[CI/Tests ]   |                     # Raise a combined exception so the user can see all\n[CI/Tests ]   |                     # the various error messages.\n[CI/Tests ]   |                     raise OSError('Multiple exceptions: {}'.format(\n[CI/Tests ]   | >                       ', '.join(str(exc) for exc in exceptions)))\n[CI/Tests ]   | E                   OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | \n[CI/Tests ]   | address    = ('::1', 11211, 0, 0)\n[CI/Tests ]   | cname      = ''\n[CI/Tests ]   | exceptions = [ConnectionRefusedError(111, \"Connect call failed ('127.0.0.1', 11211)\"), OSError(99, 'Cannot assign requested address')]\n[CI/Tests ]   | family     = <AddressFamily.AF_INET6: 10>\n[CI/Tests ]   | flags      = 0\n[CI/Tests ]   | host       = 'localhost'\n[CI/Tests ]   | infos      = [(<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('127.0.0.1', 11211)), (<AddressFamily.AF_INET6: 10>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('::1', 11211, 0, 0))]\n[CI/Tests ]   | local_addr = None\n[CI/Tests ]   | model      = \"[Errno 111] Connect call failed ('127.0.0.1', 11211)\"\n[CI/Tests ]   | port       = 11211\n[CI/Tests ]   | proto      = 6\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ebb1680>\n[CI/Tests ]   | self       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | server_hostname = None\n[CI/Tests ]   | sock       = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6>\n[CI/Tests ]   | ssl        = None\n[CI/Tests ]   | ssl_handshake_timeout = None\n[CI/Tests ]   | type       = <SocketKind.SOCK_STREAM: 1>\n[CI/Tests ]   | \n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/base_events.py:971: OSError\n[CI/Tests ]   | _ test_flag_helper[\\xec\\x95\\x88\\xeb\\x85\\x95\\xed\\x95\\x98\\xec\\x84\\xb8\\xec\\x9a\\x94] _\n[CI/Tests ]   | \n[CI/Tests ]   | mcache_flag_client = <aiomcache.client.FlagClient object at 0x7f8a7e98f850>\n[CI/Tests ]   | value = b'\\xec\\x95\\x88\\xeb\\x85\\x95\\xed\\x95\\x98\\xec\\x84\\xb8\\xec\\x9a\\x94'\n[CI/Tests ]   | \n[CI/Tests ]   |     @pytest.mark.parametrize(\n[CI/Tests ]   |         \"value\",\n[CI/Tests ]   |         [\n[CI/Tests ]   |             \"key\",\n[CI/Tests ]   |             b\"bkey\",\n[CI/Tests ]   |             False,\n[CI/Tests ]   |             1,\n[CI/Tests ]   |             None,\n[CI/Tests ]   |             0.5,\n[CI/Tests ]   |             [1, 2, 3],\n[CI/Tests ]   |             tuple([1, 2, 3]),\n[CI/Tests ]   |             [datetime.date(2015, 12, 28)],\n[CI/Tests ]   |             bytes(\"!@#\", \"utf-8\"),\n[CI/Tests ]   |             bytes(\"\uc548\ub155\ud558\uc138\uc694\", \"utf-8\"),\n[CI/Tests ]   |         ]\n[CI/Tests ]   |     )\n[CI/Tests ]   |     async def test_flag_helper(\n[CI/Tests ]   |             mcache_flag_client: FlagClient[Any], value: object) -> None:\n[CI/Tests ]   |         key = b\"key:test_flag_helper\"\n[CI/Tests ]   |     \n[CI/Tests ]   | >       await mcache_flag_client.set(key, value)\n[CI/Tests ]   | \n[CI/Tests ]   | key        = b'key:test_flag_helper'\n[CI/Tests ]   | mcache_flag_client = <aiomcache.client.FlagClient object at 0x7f8a7e98f850>\n[CI/Tests ]   | value      = b'\\xec\\x95\\x88\\xeb\\x85\\x95\\xed\\x95\\x98\\xec\\x84\\xb8\\xec\\x9a\\x94'\n[CI/Tests ]   | \n[CI/Tests ]   | tests/commands_test.py:385: \n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | aiomcache/client.py:40: in wrapper\n[CI/Tests ]   |     conn = await self._pool.acquire()\n[CI/Tests ]   |         args       = (b'key:test_flag_helper', b'\\xec\\x95\\x88\\xeb\\x85\\x95\\xed\\x95\\x98\\xec\\x84\\xb8\\xec\\x9a\\x94')\n[CI/Tests ]   |         func       = <function FlagClient.set at 0x7f8a7edf9050>\n[CI/Tests ]   |         kwargs     = {}\n[CI/Tests ]   |         self       = <aiomcache.client.FlagClient object at 0x7f8a7e98f850>\n[CI/Tests ]   | aiomcache/pool.py:40: in acquire\n[CI/Tests ]   |     _conn = await self._create_new_conn()\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7e98fe90>\n[CI/Tests ]   | aiomcache/pool.py:71: in _create_new_conn\n[CI/Tests ]   |     self._host, self._port, **self.conn_args)\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7e98fe90>\n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/streams.py:77: in open_connection\n[CI/Tests ]   |     lambda: protocol, host, port, **kwds)\n[CI/Tests ]   |         host       = 'localhost'\n[CI/Tests ]   |         kwds       = {}\n[CI/Tests ]   |         limit      = 65536\n[CI/Tests ]   |         loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   |         port       = 11211\n[CI/Tests ]   |         protocol   = <asyncio.streams.StreamReaderProtocol object at 0x7f8a7eb99510>\n[CI/Tests ]   |         reader     = <StreamReader>\n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | \n[CI/Tests ]   | self = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ebb1ef0>\n[CI/Tests ]   | host = 'localhost', port = 11211\n[CI/Tests ]   | \n[CI/Tests ]   |     async def create_connection(\n[CI/Tests ]   |             self, protocol_factory, host=None, port=None,\n[CI/Tests ]   |             *, ssl=None, family=0,\n[CI/Tests ]   |             proto=0, flags=0, sock=None,\n[CI/Tests ]   |             local_addr=None, server_hostname=None,\n[CI/Tests ]   |             ssl_handshake_timeout=None):\n[CI/Tests ]   |         \"\"\"Connect to a TCP server.\n[CI/Tests ]   |     \n[CI/Tests ]   |         Create a streaming transport connection to a given Internet host and\n[CI/Tests ]   |         port: socket family AF_INET or socket.AF_INET6 depending on host (or\n[CI/Tests ]   |         family if specified), socket type SOCK_STREAM. protocol_factory must be\n[CI/Tests ]   |         a callable returning a protocol instance.\n[CI/Tests ]   |     \n[CI/Tests ]   |         This method is a coroutine which will try to establish the connection\n[CI/Tests ]   |         in the background.  When successful, the coroutine returns a\n[CI/Tests ]   |         (transport, protocol) pair.\n[CI/Tests ]   |         \"\"\"\n[CI/Tests ]   |         if server_hostname is not None and not ssl:\n[CI/Tests ]   |             raise ValueError('server_hostname is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if server_hostname is None and ssl:\n[CI/Tests ]   |             # Use host as default for server_hostname.  It is an error\n[CI/Tests ]   |             # if host is empty or not set, e.g. when an\n[CI/Tests ]   |             # already-connected socket was passed or when only a port\n[CI/Tests ]   |             # is given.  To avoid this error, you can pass\n[CI/Tests ]   |             # server_hostname='' -- this will bypass the hostname\n[CI/Tests ]   |             # check.  (This also means that if host is a numeric\n[CI/Tests ]   |             # IP/IPv6 address, we will attempt to verify that exact\n[CI/Tests ]   |             # address; this will probably fail, but it is possible to\n[CI/Tests ]   |             # create a certificate for a specific IP address, so we\n[CI/Tests ]   |             # don't judge it here.)\n[CI/Tests ]   |             if not host:\n[CI/Tests ]   |                 raise ValueError('You must set server_hostname '\n[CI/Tests ]   |                                  'when using ssl without a host')\n[CI/Tests ]   |             server_hostname = host\n[CI/Tests ]   |     \n[CI/Tests ]   |         if ssl_handshake_timeout is not None and not ssl:\n[CI/Tests ]   |             raise ValueError(\n[CI/Tests ]   |                 'ssl_handshake_timeout is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if host is not None or port is not None:\n[CI/Tests ]   |             if sock is not None:\n[CI/Tests ]   |                 raise ValueError(\n[CI/Tests ]   |                     'host/port and sock can not be specified at the same time')\n[CI/Tests ]   |     \n[CI/Tests ]   |             infos = await self._ensure_resolved(\n[CI/Tests ]   |                 (host, port), family=family,\n[CI/Tests ]   |                 type=socket.SOCK_STREAM, proto=proto, flags=flags, loop=self)\n[CI/Tests ]   |             if not infos:\n[CI/Tests ]   |                 raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             if local_addr is not None:\n[CI/Tests ]   |                 laddr_infos = await self._ensure_resolved(\n[CI/Tests ]   |                     local_addr, family=family,\n[CI/Tests ]   |                     type=socket.SOCK_STREAM, proto=proto,\n[CI/Tests ]   |                     flags=flags, loop=self)\n[CI/Tests ]   |                 if not laddr_infos:\n[CI/Tests ]   |                     raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             exceptions = []\n[CI/Tests ]   |             for family, type, proto, cname, address in infos:\n[CI/Tests ]   |                 try:\n[CI/Tests ]   |                     sock = socket.socket(family=family, type=type, proto=proto)\n[CI/Tests ]   |                     sock.setblocking(False)\n[CI/Tests ]   |                     if local_addr is not None:\n[CI/Tests ]   |                         for _, _, _, _, laddr in laddr_infos:\n[CI/Tests ]   |                             try:\n[CI/Tests ]   |                                 sock.bind(laddr)\n[CI/Tests ]   |                                 break\n[CI/Tests ]   |                             except OSError as exc:\n[CI/Tests ]   |                                 msg = (\n[CI/Tests ]   |                                     f'error while attempting to bind on '\n[CI/Tests ]   |                                     f'address {laddr!r}: '\n[CI/Tests ]   |                                     f'{exc.strerror.lower()}'\n[CI/Tests ]   |                                 )\n[CI/Tests ]   |                                 exc = OSError(exc.errno, msg)\n[CI/Tests ]   |                                 exceptions.append(exc)\n[CI/Tests ]   |                         else:\n[CI/Tests ]   |                             sock.close()\n[CI/Tests ]   |                             sock = None\n[CI/Tests ]   |                             continue\n[CI/Tests ]   |                     if self._debug:\n[CI/Tests ]   |                         logger.debug(\"connect %r to %r\", sock, address)\n[CI/Tests ]   |                     await self.sock_connect(sock, address)\n[CI/Tests ]   |                 except OSError as exc:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     exceptions.append(exc)\n[CI/Tests ]   |                 except:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     raise\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     break\n[CI/Tests ]   |             else:\n[CI/Tests ]   |                 if len(exceptions) == 1:\n[CI/Tests ]   |                     raise exceptions[0]\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     # If they all have the same str(), raise one.\n[CI/Tests ]   |                     model = str(exceptions[0])\n[CI/Tests ]   |                     if all(str(exc) == model for exc in exceptions):\n[CI/Tests ]   |                         raise exceptions[0]\n[CI/Tests ]   |                     # Raise a combined exception so the user can see all\n[CI/Tests ]   |                     # the various error messages.\n[CI/Tests ]   |                     raise OSError('Multiple exceptions: {}'.format(\n[CI/Tests ]   | >                       ', '.join(str(exc) for exc in exceptions)))\n[CI/Tests ]   | E                   OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | \n[CI/Tests ]   | address    = ('::1', 11211, 0, 0)\n[CI/Tests ]   | cname      = ''\n[CI/Tests ]   | exceptions = [ConnectionRefusedError(111, \"Connect call failed ('127.0.0.1', 11211)\"), OSError(99, 'Cannot assign requested address')]\n[CI/Tests ]   | family     = <AddressFamily.AF_INET6: 10>\n[CI/Tests ]   | flags      = 0\n[CI/Tests ]   | host       = 'localhost'\n[CI/Tests ]   | infos      = [(<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('127.0.0.1', 11211)), (<AddressFamily.AF_INET6: 10>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('::1', 11211, 0, 0))]\n[CI/Tests ]   | local_addr = None\n[CI/Tests ]   | model      = \"[Errno 111] Connect call failed ('127.0.0.1', 11211)\"\n[CI/Tests ]   | port       = 11211\n[CI/Tests ]   | proto      = 6\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ebb1ef0>\n[CI/Tests ]   | self       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | server_hostname = None\n[CI/Tests ]   | sock       = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6>\n[CI/Tests ]   | ssl        = None\n[CI/Tests ]   | ssl_handshake_timeout = None\n[CI/Tests ]   | type       = <SocketKind.SOCK_STREAM: 1>\n[CI/Tests ]   | \n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/base_events.py:971: OSError\n[CI/Tests ]   | _______________ test_objects_not_supported_without_flag_handler ________________\n[CI/Tests ]   | \n[CI/Tests ]   | mcache = <aiomcache.client.Client object at 0x7f8a7e119090>\n[CI/Tests ]   | \n[CI/Tests ]   |     async def test_objects_not_supported_without_flag_handler(mcache: Client) -> None:\n[CI/Tests ]   |         key = b\"key:test_objects_not_supported_without_flag_handler\"\n[CI/Tests ]   |     \n[CI/Tests ]   |         date_value = datetime.date(2015, 12, 28)\n[CI/Tests ]   |     \n[CI/Tests ]   |         with pytest.raises(ValidationException):\n[CI/Tests ]   | >           await mcache.set(key, date_value)  # type: ignore[arg-type]\n[CI/Tests ]   | \n[CI/Tests ]   | date_value = datetime.date(2015, 12, 28)\n[CI/Tests ]   | key        = b'key:test_objects_not_supported_without_flag_handler'\n[CI/Tests ]   | mcache     = <aiomcache.client.Client object at 0x7f8a7e119090>\n[CI/Tests ]   | \n[CI/Tests ]   | tests/commands_test.py:396: \n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | aiomcache/client.py:40: in wrapper\n[CI/Tests ]   |     conn = await self._pool.acquire()\n[CI/Tests ]   |         args       = (b'key:test_objects_not_supported_without_flag_handler', datetime.date(2015, 12, 28))\n[CI/Tests ]   |         func       = <function FlagClient.set at 0x7f8a7edf9050>\n[CI/Tests ]   |         kwargs     = {}\n[CI/Tests ]   |         self       = <aiomcache.client.Client object at 0x7f8a7e119090>\n[CI/Tests ]   | aiomcache/pool.py:40: in acquire\n[CI/Tests ]   |     _conn = await self._create_new_conn()\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7e119810>\n[CI/Tests ]   | aiomcache/pool.py:71: in _create_new_conn\n[CI/Tests ]   |     self._host, self._port, **self.conn_args)\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7e119810>\n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/streams.py:77: in open_connection\n[CI/Tests ]   |     lambda: protocol, host, port, **kwds)\n[CI/Tests ]   |         host       = 'localhost'\n[CI/Tests ]   |         kwds       = {}\n[CI/Tests ]   |         limit      = 65536\n[CI/Tests ]   |         loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   |         port       = 11211\n[CI/Tests ]   |         protocol   = <asyncio.streams.StreamReaderProtocol object at 0x7f8a7e119bd0>\n[CI/Tests ]   |         reader     = <StreamReader>\n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | \n[CI/Tests ]   | self = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7e98df80>\n[CI/Tests ]   | host = 'localhost', port = 11211\n[CI/Tests ]   | \n[CI/Tests ]   |     async def create_connection(\n[CI/Tests ]   |             self, protocol_factory, host=None, port=None,\n[CI/Tests ]   |             *, ssl=None, family=0,\n[CI/Tests ]   |             proto=0, flags=0, sock=None,\n[CI/Tests ]   |             local_addr=None, server_hostname=None,\n[CI/Tests ]   |             ssl_handshake_timeout=None):\n[CI/Tests ]   |         \"\"\"Connect to a TCP server.\n[CI/Tests ]   |     \n[CI/Tests ]   |         Create a streaming transport connection to a given Internet host and\n[CI/Tests ]   |         port: socket family AF_INET or socket.AF_INET6 depending on host (or\n[CI/Tests ]   |         family if specified), socket type SOCK_STREAM. protocol_factory must be\n[CI/Tests ]   |         a callable returning a protocol instance.\n[CI/Tests ]   |     \n[CI/Tests ]   |         This method is a coroutine which will try to establish the connection\n[CI/Tests ]   |         in the background.  When successful, the coroutine returns a\n[CI/Tests ]   |         (transport, protocol) pair.\n[CI/Tests ]   |         \"\"\"\n[CI/Tests ]   |         if server_hostname is not None and not ssl:\n[CI/Tests ]   |             raise ValueError('server_hostname is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if server_hostname is None and ssl:\n[CI/Tests ]   |             # Use host as default for server_hostname.  It is an error\n[CI/Tests ]   |             # if host is empty or not set, e.g. when an\n[CI/Tests ]   |             # already-connected socket was passed or when only a port\n[CI/Tests ]   |             # is given.  To avoid this error, you can pass\n[CI/Tests ]   |             # server_hostname='' -- this will bypass the hostname\n[CI/Tests ]   |             # check.  (This also means that if host is a numeric\n[CI/Tests ]   |             # IP/IPv6 address, we will attempt to verify that exact\n[CI/Tests ]   |             # address; this will probably fail, but it is possible to\n[CI/Tests ]   |             # create a certificate for a specific IP address, so we\n[CI/Tests ]   |             # don't judge it here.)\n[CI/Tests ]   |             if not host:\n[CI/Tests ]   |                 raise ValueError('You must set server_hostname '\n[CI/Tests ]   |                                  'when using ssl without a host')\n[CI/Tests ]   |             server_hostname = host\n[CI/Tests ]   |     \n[CI/Tests ]   |         if ssl_handshake_timeout is not None and not ssl:\n[CI/Tests ]   |             raise ValueError(\n[CI/Tests ]   |                 'ssl_handshake_timeout is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if host is not None or port is not None:\n[CI/Tests ]   |             if sock is not None:\n[CI/Tests ]   |                 raise ValueError(\n[CI/Tests ]   |                     'host/port and sock can not be specified at the same time')\n[CI/Tests ]   |     \n[CI/Tests ]   |             infos = await self._ensure_resolved(\n[CI/Tests ]   |                 (host, port), family=family,\n[CI/Tests ]   |                 type=socket.SOCK_STREAM, proto=proto, flags=flags, loop=self)\n[CI/Tests ]   |             if not infos:\n[CI/Tests ]   |                 raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             if local_addr is not None:\n[CI/Tests ]   |                 laddr_infos = await self._ensure_resolved(\n[CI/Tests ]   |                     local_addr, family=family,\n[CI/Tests ]   |                     type=socket.SOCK_STREAM, proto=proto,\n[CI/Tests ]   |                     flags=flags, loop=self)\n[CI/Tests ]   |                 if not laddr_infos:\n[CI/Tests ]   |                     raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             exceptions = []\n[CI/Tests ]   |             for family, type, proto, cname, address in infos:\n[CI/Tests ]   |                 try:\n[CI/Tests ]   |                     sock = socket.socket(family=family, type=type, proto=proto)\n[CI/Tests ]   |                     sock.setblocking(False)\n[CI/Tests ]   |                     if local_addr is not None:\n[CI/Tests ]   |                         for _, _, _, _, laddr in laddr_infos:\n[CI/Tests ]   |                             try:\n[CI/Tests ]   |                                 sock.bind(laddr)\n[CI/Tests ]   |                                 break\n[CI/Tests ]   |                             except OSError as exc:\n[CI/Tests ]   |                                 msg = (\n[CI/Tests ]   |                                     f'error while attempting to bind on '\n[CI/Tests ]   |                                     f'address {laddr!r}: '\n[CI/Tests ]   |                                     f'{exc.strerror.lower()}'\n[CI/Tests ]   |                                 )\n[CI/Tests ]   |                                 exc = OSError(exc.errno, msg)\n[CI/Tests ]   |                                 exceptions.append(exc)\n[CI/Tests ]   |                         else:\n[CI/Tests ]   |                             sock.close()\n[CI/Tests ]   |                             sock = None\n[CI/Tests ]   |                             continue\n[CI/Tests ]   |                     if self._debug:\n[CI/Tests ]   |                         logger.debug(\"connect %r to %r\", sock, address)\n[CI/Tests ]   |                     await self.sock_connect(sock, address)\n[CI/Tests ]   |                 except OSError as exc:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     exceptions.append(exc)\n[CI/Tests ]   |                 except:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     raise\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     break\n[CI/Tests ]   |             else:\n[CI/Tests ]   |                 if len(exceptions) == 1:\n[CI/Tests ]   |                     raise exceptions[0]\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     # If they all have the same str(), raise one.\n[CI/Tests ]   |                     model = str(exceptions[0])\n[CI/Tests ]   |                     if all(str(exc) == model for exc in exceptions):\n[CI/Tests ]   |                         raise exceptions[0]\n[CI/Tests ]   |                     # Raise a combined exception so the user can see all\n[CI/Tests ]   |                     # the various error messages.\n[CI/Tests ]   |                     raise OSError('Multiple exceptions: {}'.format(\n[CI/Tests ]   | >                       ', '.join(str(exc) for exc in exceptions)))\n[CI/Tests ]   | E                   OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | \n[CI/Tests ]   | address    = ('::1', 11211, 0, 0)\n[CI/Tests ]   | cname      = ''\n[CI/Tests ]   | exceptions = [ConnectionRefusedError(111, \"Connect call failed ('127.0.0.1', 11211)\"), OSError(99, 'Cannot assign requested address')]\n[CI/Tests ]   | family     = <AddressFamily.AF_INET6: 10>\n[CI/Tests ]   | flags      = 0\n[CI/Tests ]   | host       = 'localhost'\n[CI/Tests ]   | infos      = [(<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('127.0.0.1', 11211)), (<AddressFamily.AF_INET6: 10>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('::1', 11211, 0, 0))]\n[CI/Tests ]   | local_addr = None\n[CI/Tests ]   | model      = \"[Errno 111] Connect call failed ('127.0.0.1', 11211)\"\n[CI/Tests ]   | port       = 11211\n[CI/Tests ]   | proto      = 6\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7e98df80>\n[CI/Tests ]   | self       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | server_hostname = None\n[CI/Tests ]   | sock       = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6>\n[CI/Tests ]   | ssl        = None\n[CI/Tests ]   | ssl_handshake_timeout = None\n[CI/Tests ]   | type       = <SocketKind.SOCK_STREAM: 1>\n[CI/Tests ]   | \n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/base_events.py:971: OSError\n[CI/Tests ]   | _________________ test_flag_handler_invoked_only_when_expected _________________\n[CI/Tests ]   | \n[CI/Tests ]   | mcache_flag_client = <aiomcache.client.FlagClient object at 0x7f8a7ecdee10>\n[CI/Tests ]   | demo_flag_helper = <tests.flag_helper.FlagHelperDemo object at 0x7f8a7ef76fd0>\n[CI/Tests ]   | \n[CI/Tests ]   |     async def test_flag_handler_invoked_only_when_expected(\n[CI/Tests ]   |             mcache_flag_client: FlagClient[Any], demo_flag_helper: FlagHelperDemo) -> None:\n[CI/Tests ]   |         key = b\"key:test_flag_handler_invoked_only_when_expected\"\n[CI/Tests ]   |     \n[CI/Tests ]   |         orig_get_count = demo_flag_helper.get_invocation_count\n[CI/Tests ]   |         orig_set_count = demo_flag_helper.set_invocation_count\n[CI/Tests ]   |     \n[CI/Tests ]   |         # should be invoked on non-byte values\n[CI/Tests ]   |     \n[CI/Tests ]   |         date_value = datetime.date(2015, 12, 28)\n[CI/Tests ]   |     \n[CI/Tests ]   | >       await mcache_flag_client.set(key, date_value)\n[CI/Tests ]   | \n[CI/Tests ]   | date_value = datetime.date(2015, 12, 28)\n[CI/Tests ]   | demo_flag_helper = <tests.flag_helper.FlagHelperDemo object at 0x7f8a7ef76fd0>\n[CI/Tests ]   | key        = b'key:test_flag_handler_invoked_only_when_expected'\n[CI/Tests ]   | mcache_flag_client = <aiomcache.client.FlagClient object at 0x7f8a7ecdee10>\n[CI/Tests ]   | orig_get_count = 0\n[CI/Tests ]   | orig_set_count = 0\n[CI/Tests ]   | \n[CI/Tests ]   | tests/commands_test.py:413: \n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | aiomcache/client.py:40: in wrapper\n[CI/Tests ]   |     conn = await self._pool.acquire()\n[CI/Tests ]   |         args       = (b'key:test_flag_handler_invoked_only_when_expected', datetime.date(2015, 12, 28))\n[CI/Tests ]   |         func       = <function FlagClient.set at 0x7f8a7edf9050>\n[CI/Tests ]   |         kwargs     = {}\n[CI/Tests ]   |         self       = <aiomcache.client.FlagClient object at 0x7f8a7ecdee10>\n[CI/Tests ]   | aiomcache/pool.py:40: in acquire\n[CI/Tests ]   |     _conn = await self._create_new_conn()\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ecdef10>\n[CI/Tests ]   | aiomcache/pool.py:71: in _create_new_conn\n[CI/Tests ]   |     self._host, self._port, **self.conn_args)\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ecdef10>\n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/streams.py:77: in open_connection\n[CI/Tests ]   |     lambda: protocol, host, port, **kwds)\n[CI/Tests ]   |         host       = 'localhost'\n[CI/Tests ]   |         kwds       = {}\n[CI/Tests ]   |         limit      = 65536\n[CI/Tests ]   |         loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   |         port       = 11211\n[CI/Tests ]   |         protocol   = <asyncio.streams.StreamReaderProtocol object at 0x7f8a7edd6d50>\n[CI/Tests ]   |         reader     = <StreamReader>\n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | \n[CI/Tests ]   | self = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ebb1950>\n[CI/Tests ]   | host = 'localhost', port = 11211\n[CI/Tests ]   | \n[CI/Tests ]   |     async def create_connection(\n[CI/Tests ]   |             self, protocol_factory, host=None, port=None,\n[CI/Tests ]   |             *, ssl=None, family=0,\n[CI/Tests ]   |             proto=0, flags=0, sock=None,\n[CI/Tests ]   |             local_addr=None, server_hostname=None,\n[CI/Tests ]   |             ssl_handshake_timeout=None):\n[CI/Tests ]   |         \"\"\"Connect to a TCP server.\n[CI/Tests ]   |     \n[CI/Tests ]   |         Create a streaming transport connection to a given Internet host and\n[CI/Tests ]   |         port: socket family AF_INET or socket.AF_INET6 depending on host (or\n[CI/Tests ]   |         family if specified), socket type SOCK_STREAM. protocol_factory must be\n[CI/Tests ]   |         a callable returning a protocol instance.\n[CI/Tests ]   |     \n[CI/Tests ]   |         This method is a coroutine which will try to establish the connection\n[CI/Tests ]   |         in the background.  When successful, the coroutine returns a\n[CI/Tests ]   |         (transport, protocol) pair.\n[CI/Tests ]   |         \"\"\"\n[CI/Tests ]   |         if server_hostname is not None and not ssl:\n[CI/Tests ]   |             raise ValueError('server_hostname is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if server_hostname is None and ssl:\n[CI/Tests ]   |             # Use host as default for server_hostname.  It is an error\n[CI/Tests ]   |             # if host is empty or not set, e.g. when an\n[CI/Tests ]   |             # already-connected socket was passed or when only a port\n[CI/Tests ]   |             # is given.  To avoid this error, you can pass\n[CI/Tests ]   |             # server_hostname='' -- this will bypass the hostname\n[CI/Tests ]   |             # check.  (This also means that if host is a numeric\n[CI/Tests ]   |             # IP/IPv6 address, we will attempt to verify that exact\n[CI/Tests ]   |             # address; this will probably fail, but it is possible to\n[CI/Tests ]   |             # create a certificate for a specific IP address, so we\n[CI/Tests ]   |             # don't judge it here.)\n[CI/Tests ]   |             if not host:\n[CI/Tests ]   |                 raise ValueError('You must set server_hostname '\n[CI/Tests ]   |                                  'when using ssl without a host')\n[CI/Tests ]   |             server_hostname = host\n[CI/Tests ]   |     \n[CI/Tests ]   |         if ssl_handshake_timeout is not None and not ssl:\n[CI/Tests ]   |             raise ValueError(\n[CI/Tests ]   |                 'ssl_handshake_timeout is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if host is not None or port is not None:\n[CI/Tests ]   |             if sock is not None:\n[CI/Tests ]   |                 raise ValueError(\n[CI/Tests ]   |                     'host/port and sock can not be specified at the same time')\n[CI/Tests ]   |     \n[CI/Tests ]   |             infos = await self._ensure_resolved(\n[CI/Tests ]   |                 (host, port), family=family,\n[CI/Tests ]   |                 type=socket.SOCK_STREAM, proto=proto, flags=flags, loop=self)\n[CI/Tests ]   |             if not infos:\n[CI/Tests ]   |                 raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             if local_addr is not None:\n[CI/Tests ]   |                 laddr_infos = await self._ensure_resolved(\n[CI/Tests ]   |                     local_addr, family=family,\n[CI/Tests ]   |                     type=socket.SOCK_STREAM, proto=proto,\n[CI/Tests ]   |                     flags=flags, loop=self)\n[CI/Tests ]   |                 if not laddr_infos:\n[CI/Tests ]   |                     raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             exceptions = []\n[CI/Tests ]   |             for family, type, proto, cname, address in infos:\n[CI/Tests ]   |                 try:\n[CI/Tests ]   |                     sock = socket.socket(family=family, type=type, proto=proto)\n[CI/Tests ]   |                     sock.setblocking(False)\n[CI/Tests ]   |                     if local_addr is not None:\n[CI/Tests ]   |                         for _, _, _, _, laddr in laddr_infos:\n[CI/Tests ]   |                             try:\n[CI/Tests ]   |                                 sock.bind(laddr)\n[CI/Tests ]   |                                 break\n[CI/Tests ]   |                             except OSError as exc:\n[CI/Tests ]   |                                 msg = (\n[CI/Tests ]   |                                     f'error while attempting to bind on '\n[CI/Tests ]   |                                     f'address {laddr!r}: '\n[CI/Tests ]   |                                     f'{exc.strerror.lower()}'\n[CI/Tests ]   |                                 )\n[CI/Tests ]   |                                 exc = OSError(exc.errno, msg)\n[CI/Tests ]   |                                 exceptions.append(exc)\n[CI/Tests ]   |                         else:\n[CI/Tests ]   |                             sock.close()\n[CI/Tests ]   |                             sock = None\n[CI/Tests ]   |                             continue\n[CI/Tests ]   |                     if self._debug:\n[CI/Tests ]   |                         logger.debug(\"connect %r to %r\", sock, address)\n[CI/Tests ]   |                     await self.sock_connect(sock, address)\n[CI/Tests ]   |                 except OSError as exc:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     exceptions.append(exc)\n[CI/Tests ]   |                 except:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     raise\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     break\n[CI/Tests ]   |             else:\n[CI/Tests ]   |                 if len(exceptions) == 1:\n[CI/Tests ]   |                     raise exceptions[0]\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     # If they all have the same str(), raise one.\n[CI/Tests ]   |                     model = str(exceptions[0])\n[CI/Tests ]   |                     if all(str(exc) == model for exc in exceptions):\n[CI/Tests ]   |                         raise exceptions[0]\n[CI/Tests ]   |                     # Raise a combined exception so the user can see all\n[CI/Tests ]   |                     # the various error messages.\n[CI/Tests ]   |                     raise OSError('Multiple exceptions: {}'.format(\n[CI/Tests ]   | >                       ', '.join(str(exc) for exc in exceptions)))\n[CI/Tests ]   | E                   OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | \n[CI/Tests ]   | address    = ('::1', 11211, 0, 0)\n[CI/Tests ]   | cname      = ''\n[CI/Tests ]   | exceptions = [ConnectionRefusedError(111, \"Connect call failed ('127.0.0.1', 11211)\"), OSError(99, 'Cannot assign requested address')]\n[CI/Tests ]   | family     = <AddressFamily.AF_INET6: 10>\n[CI/Tests ]   | flags      = 0\n[CI/Tests ]   | host       = 'localhost'\n[CI/Tests ]   | infos      = [(<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('127.0.0.1', 11211)), (<AddressFamily.AF_INET6: 10>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('::1', 11211, 0, 0))]\n[CI/Tests ]   | local_addr = None\n[CI/Tests ]   | model      = \"[Errno 111] Connect call failed ('127.0.0.1', 11211)\"\n[CI/Tests ]   | port       = 11211\n[CI/Tests ]   | proto      = 6\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ebb1950>\n[CI/Tests ]   | self       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | server_hostname = None\n[CI/Tests ]   | sock       = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6>\n[CI/Tests ]   | ssl        = None\n[CI/Tests ]   | ssl_handshake_timeout = None\n[CI/Tests ]   | type       = <SocketKind.SOCK_STREAM: 1>\n[CI/Tests ]   | \n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/base_events.py:971: OSError\n[CI/Tests ]   | ________________ test_ssl_client_fails_against_plaintext_server ________________\n[CI/Tests ]   | \n[CI/Tests ]   | mcache_params = {'host': 'localhost', 'port': 11211}\n[CI/Tests ]   | \n[CI/Tests ]   |     async def test_ssl_client_fails_against_plaintext_server(\n[CI/Tests ]   |         mcache_params: McacheParams,\n[CI/Tests ]   |     ) -> None:\n[CI/Tests ]   |         client = Client(**mcache_params, conn_args={\"ssl\": True})\n[CI/Tests ]   |         # If SSL was correctly enabled, this should\n[CI/Tests ]   |         # fail, since SSL isn't enabled on the memcache\n[CI/Tests ]   |         # server.\n[CI/Tests ]   |         with pytest.raises(ssl.SSLError):\n[CI/Tests ]   | >           await client.get(b\"key\")\n[CI/Tests ]   | \n[CI/Tests ]   | client     = <aiomcache.client.Client object at 0x7f8a7e99e110>\n[CI/Tests ]   | mcache_params = {'host': 'localhost', 'port': 11211}\n[CI/Tests ]   | \n[CI/Tests ]   | tests/conn_args_test.py:39: \n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | aiomcache/client.py:40: in wrapper\n[CI/Tests ]   |     conn = await self._pool.acquire()\n[CI/Tests ]   |         args       = (b'key',)\n[CI/Tests ]   |         func       = <function FlagClient.get at 0x7f8a7ef62b00>\n[CI/Tests ]   |         kwargs     = {}\n[CI/Tests ]   |         self       = <aiomcache.client.Client object at 0x7f8a7e99e110>\n[CI/Tests ]   | aiomcache/pool.py:40: in acquire\n[CI/Tests ]   |     _conn = await self._create_new_conn()\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7e99ef50>\n[CI/Tests ]   | aiomcache/pool.py:71: in _create_new_conn\n[CI/Tests ]   |     self._host, self._port, **self.conn_args)\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7e99ef50>\n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/streams.py:77: in open_connection\n[CI/Tests ]   |     lambda: protocol, host, port, **kwds)\n[CI/Tests ]   |         host       = 'localhost'\n[CI/Tests ]   |         kwds       = {'ssl': True}\n[CI/Tests ]   |         limit      = 65536\n[CI/Tests ]   |         loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   |         port       = 11211\n[CI/Tests ]   |         protocol   = <asyncio.streams.StreamReaderProtocol object at 0x7f8a7e99e750>\n[CI/Tests ]   |         reader     = <StreamReader>\n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | \n[CI/Tests ]   | self = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7e0d8170>\n[CI/Tests ]   | host = 'localhost', port = 11211\n[CI/Tests ]   | \n[CI/Tests ]   |     async def create_connection(\n[CI/Tests ]   |             self, protocol_factory, host=None, port=None,\n[CI/Tests ]   |             *, ssl=None, family=0,\n[CI/Tests ]   |             proto=0, flags=0, sock=None,\n[CI/Tests ]   |             local_addr=None, server_hostname=None,\n[CI/Tests ]   |             ssl_handshake_timeout=None):\n[CI/Tests ]   |         \"\"\"Connect to a TCP server.\n[CI/Tests ]   |     \n[CI/Tests ]   |         Create a streaming transport connection to a given Internet host and\n[CI/Tests ]   |         port: socket family AF_INET or socket.AF_INET6 depending on host (or\n[CI/Tests ]   |         family if specified), socket type SOCK_STREAM. protocol_factory must be\n[CI/Tests ]   |         a callable returning a protocol instance.\n[CI/Tests ]   |     \n[CI/Tests ]   |         This method is a coroutine which will try to establish the connection\n[CI/Tests ]   |         in the background.  When successful, the coroutine returns a\n[CI/Tests ]   |         (transport, protocol) pair.\n[CI/Tests ]   |         \"\"\"\n[CI/Tests ]   |         if server_hostname is not None and not ssl:\n[CI/Tests ]   |             raise ValueError('server_hostname is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if server_hostname is None and ssl:\n[CI/Tests ]   |             # Use host as default for server_hostname.  It is an error\n[CI/Tests ]   |             # if host is empty or not set, e.g. when an\n[CI/Tests ]   |             # already-connected socket was passed or when only a port\n[CI/Tests ]   |             # is given.  To avoid this error, you can pass\n[CI/Tests ]   |             # server_hostname='' -- this will bypass the hostname\n[CI/Tests ]   |             # check.  (This also means that if host is a numeric\n[CI/Tests ]   |             # IP/IPv6 address, we will attempt to verify that exact\n[CI/Tests ]   |             # address; this will probably fail, but it is possible to\n[CI/Tests ]   |             # create a certificate for a specific IP address, so we\n[CI/Tests ]   |             # don't judge it here.)\n[CI/Tests ]   |             if not host:\n[CI/Tests ]   |                 raise ValueError('You must set server_hostname '\n[CI/Tests ]   |                                  'when using ssl without a host')\n[CI/Tests ]   |             server_hostname = host\n[CI/Tests ]   |     \n[CI/Tests ]   |         if ssl_handshake_timeout is not None and not ssl:\n[CI/Tests ]   |             raise ValueError(\n[CI/Tests ]   |                 'ssl_handshake_timeout is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if host is not None or port is not None:\n[CI/Tests ]   |             if sock is not None:\n[CI/Tests ]   |                 raise ValueError(\n[CI/Tests ]   |                     'host/port and sock can not be specified at the same time')\n[CI/Tests ]   |     \n[CI/Tests ]   |             infos = await self._ensure_resolved(\n[CI/Tests ]   |                 (host, port), family=family,\n[CI/Tests ]   |                 type=socket.SOCK_STREAM, proto=proto, flags=flags, loop=self)\n[CI/Tests ]   |             if not infos:\n[CI/Tests ]   |                 raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             if local_addr is not None:\n[CI/Tests ]   |                 laddr_infos = await self._ensure_resolved(\n[CI/Tests ]   |                     local_addr, family=family,\n[CI/Tests ]   |                     type=socket.SOCK_STREAM, proto=proto,\n[CI/Tests ]   |                     flags=flags, loop=self)\n[CI/Tests ]   |                 if not laddr_infos:\n[CI/Tests ]   |                     raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             exceptions = []\n[CI/Tests ]   |             for family, type, proto, cname, address in infos:\n[CI/Tests ]   |                 try:\n[CI/Tests ]   |                     sock = socket.socket(family=family, type=type, proto=proto)\n[CI/Tests ]   |                     sock.setblocking(False)\n[CI/Tests ]   |                     if local_addr is not None:\n[CI/Tests ]   |                         for _, _, _, _, laddr in laddr_infos:\n[CI/Tests ]   |                             try:\n[CI/Tests ]   |                                 sock.bind(laddr)\n[CI/Tests ]   |                                 break\n[CI/Tests ]   |                             except OSError as exc:\n[CI/Tests ]   |                                 msg = (\n[CI/Tests ]   |                                     f'error while attempting to bind on '\n[CI/Tests ]   |                                     f'address {laddr!r}: '\n[CI/Tests ]   |                                     f'{exc.strerror.lower()}'\n[CI/Tests ]   |                                 )\n[CI/Tests ]   |                                 exc = OSError(exc.errno, msg)\n[CI/Tests ]   |                                 exceptions.append(exc)\n[CI/Tests ]   |                         else:\n[CI/Tests ]   |                             sock.close()\n[CI/Tests ]   |                             sock = None\n[CI/Tests ]   |                             continue\n[CI/Tests ]   |                     if self._debug:\n[CI/Tests ]   |                         logger.debug(\"connect %r to %r\", sock, address)\n[CI/Tests ]   |                     await self.sock_connect(sock, address)\n[CI/Tests ]   |                 except OSError as exc:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     exceptions.append(exc)\n[CI/Tests ]   |                 except:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     raise\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     break\n[CI/Tests ]   |             else:\n[CI/Tests ]   |                 if len(exceptions) == 1:\n[CI/Tests ]   |                     raise exceptions[0]\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     # If they all have the same str(), raise one.\n[CI/Tests ]   |                     model = str(exceptions[0])\n[CI/Tests ]   |                     if all(str(exc) == model for exc in exceptions):\n[CI/Tests ]   |                         raise exceptions[0]\n[CI/Tests ]   |                     # Raise a combined exception so the user can see all\n[CI/Tests ]   |                     # the various error messages.\n[CI/Tests ]   |                     raise OSError('Multiple exceptions: {}'.format(\n[CI/Tests ]   | >                       ', '.join(str(exc) for exc in exceptions)))\n[CI/Tests ]   | E                   OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | \n[CI/Tests ]   | address    = ('::1', 11211, 0, 0)\n[CI/Tests ]   | cname      = ''\n[CI/Tests ]   | exceptions = [ConnectionRefusedError(111, \"Connect call failed ('127.0.0.1', 11211)\"), OSError(99, 'Cannot assign requested address')]\n[CI/Tests ]   | family     = <AddressFamily.AF_INET6: 10>\n[CI/Tests ]   | flags      = 0\n[CI/Tests ]   | host       = 'localhost'\n[CI/Tests ]   | infos      = [(<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('127.0.0.1', 11211)), (<AddressFamily.AF_INET6: 10>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('::1', 11211, 0, 0))]\n[CI/Tests ]   | local_addr = None\n[CI/Tests ]   | model      = \"[Errno 111] Connect call failed ('127.0.0.1', 11211)\"\n[CI/Tests ]   | port       = 11211\n[CI/Tests ]   | proto      = 6\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7e0d8170>\n[CI/Tests ]   | self       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | server_hostname = 'localhost'\n[CI/Tests ]   | sock       = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6>\n[CI/Tests ]   | ssl        = True\n[CI/Tests ]   | ssl_handshake_timeout = None\n[CI/Tests ]   | type       = <SocketKind.SOCK_STREAM: 1>\n[CI/Tests ]   | \n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/base_events.py:971: OSError\n[CI/Tests ]   | __________________________ test_pool_acquire_release ___________________________\n[CI/Tests ]   | \n[CI/Tests ]   | mcache_params = {'host': 'localhost', 'port': 11211}\n[CI/Tests ]   | \n[CI/Tests ]   |     async def test_pool_acquire_release(mcache_params: McacheParams) -> None:\n[CI/Tests ]   |         pool = MemcachePool(minsize=1, maxsize=5, **mcache_params)\n[CI/Tests ]   | >       conn = await pool.acquire()\n[CI/Tests ]   | \n[CI/Tests ]   | mcache_params = {'host': 'localhost', 'port': 11211}\n[CI/Tests ]   | pool       = <aiomcache.pool.MemcachePool object at 0x7f8a7ef1f050>\n[CI/Tests ]   | \n[CI/Tests ]   | tests/pool_test.py:20: \n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | aiomcache/pool.py:40: in acquire\n[CI/Tests ]   |     _conn = await self._create_new_conn()\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ef1f050>\n[CI/Tests ]   | aiomcache/pool.py:71: in _create_new_conn\n[CI/Tests ]   |     self._host, self._port, **self.conn_args)\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ef1f050>\n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/streams.py:77: in open_connection\n[CI/Tests ]   |     lambda: protocol, host, port, **kwds)\n[CI/Tests ]   |         host       = 'localhost'\n[CI/Tests ]   |         kwds       = {}\n[CI/Tests ]   |         limit      = 65536\n[CI/Tests ]   |         loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   |         port       = 11211\n[CI/Tests ]   |         protocol   = <asyncio.streams.StreamReaderProtocol object at 0x7f8a7ef1fb10>\n[CI/Tests ]   |         reader     = <StreamReader>\n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | \n[CI/Tests ]   | self = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ebb13b0>\n[CI/Tests ]   | host = 'localhost', port = 11211\n[CI/Tests ]   | \n[CI/Tests ]   |     async def create_connection(\n[CI/Tests ]   |             self, protocol_factory, host=None, port=None,\n[CI/Tests ]   |             *, ssl=None, family=0,\n[CI/Tests ]   |             proto=0, flags=0, sock=None,\n[CI/Tests ]   |             local_addr=None, server_hostname=None,\n[CI/Tests ]   |             ssl_handshake_timeout=None):\n[CI/Tests ]   |         \"\"\"Connect to a TCP server.\n[CI/Tests ]   |     \n[CI/Tests ]   |         Create a streaming transport connection to a given Internet host and\n[CI/Tests ]   |         port: socket family AF_INET or socket.AF_INET6 depending on host (or\n[CI/Tests ]   |         family if specified), socket type SOCK_STREAM. protocol_factory must be\n[CI/Tests ]   |         a callable returning a protocol instance.\n[CI/Tests ]   |     \n[CI/Tests ]   |         This method is a coroutine which will try to establish the connection\n[CI/Tests ]   |         in the background.  When successful, the coroutine returns a\n[CI/Tests ]   |         (transport, protocol) pair.\n[CI/Tests ]   |         \"\"\"\n[CI/Tests ]   |         if server_hostname is not None and not ssl:\n[CI/Tests ]   |             raise ValueError('server_hostname is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if server_hostname is None and ssl:\n[CI/Tests ]   |             # Use host as default for server_hostname.  It is an error\n[CI/Tests ]   |             # if host is empty or not set, e.g. when an\n[CI/Tests ]   |             # already-connected socket was passed or when only a port\n[CI/Tests ]   |             # is given.  To avoid this error, you can pass\n[CI/Tests ]   |             # server_hostname='' -- this will bypass the hostname\n[CI/Tests ]   |             # check.  (This also means that if host is a numeric\n[CI/Tests ]   |             # IP/IPv6 address, we will attempt to verify that exact\n[CI/Tests ]   |             # address; this will probably fail, but it is possible to\n[CI/Tests ]   |             # create a certificate for a specific IP address, so we\n[CI/Tests ]   |             # don't judge it here.)\n[CI/Tests ]   |             if not host:\n[CI/Tests ]   |                 raise ValueError('You must set server_hostname '\n[CI/Tests ]   |                                  'when using ssl without a host')\n[CI/Tests ]   |             server_hostname = host\n[CI/Tests ]   |     \n[CI/Tests ]   |         if ssl_handshake_timeout is not None and not ssl:\n[CI/Tests ]   |             raise ValueError(\n[CI/Tests ]   |                 'ssl_handshake_timeout is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if host is not None or port is not None:\n[CI/Tests ]   |             if sock is not None:\n[CI/Tests ]   |                 raise ValueError(\n[CI/Tests ]   |                     'host/port and sock can not be specified at the same time')\n[CI/Tests ]   |     \n[CI/Tests ]   |             infos = await self._ensure_resolved(\n[CI/Tests ]   |                 (host, port), family=family,\n[CI/Tests ]   |                 type=socket.SOCK_STREAM, proto=proto, flags=flags, loop=self)\n[CI/Tests ]   |             if not infos:\n[CI/Tests ]   |                 raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             if local_addr is not None:\n[CI/Tests ]   |                 laddr_infos = await self._ensure_resolved(\n[CI/Tests ]   |                     local_addr, family=family,\n[CI/Tests ]   |                     type=socket.SOCK_STREAM, proto=proto,\n[CI/Tests ]   |                     flags=flags, loop=self)\n[CI/Tests ]   |                 if not laddr_infos:\n[CI/Tests ]   |                     raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             exceptions = []\n[CI/Tests ]   |             for family, type, proto, cname, address in infos:\n[CI/Tests ]   |                 try:\n[CI/Tests ]   |                     sock = socket.socket(family=family, type=type, proto=proto)\n[CI/Tests ]   |                     sock.setblocking(False)\n[CI/Tests ]   |                     if local_addr is not None:\n[CI/Tests ]   |                         for _, _, _, _, laddr in laddr_infos:\n[CI/Tests ]   |                             try:\n[CI/Tests ]   |                                 sock.bind(laddr)\n[CI/Tests ]   |                                 break\n[CI/Tests ]   |                             except OSError as exc:\n[CI/Tests ]   |                                 msg = (\n[CI/Tests ]   |                                     f'error while attempting to bind on '\n[CI/Tests ]   |                                     f'address {laddr!r}: '\n[CI/Tests ]   |                                     f'{exc.strerror.lower()}'\n[CI/Tests ]   |                                 )\n[CI/Tests ]   |                                 exc = OSError(exc.errno, msg)\n[CI/Tests ]   |                                 exceptions.append(exc)\n[CI/Tests ]   |                         else:\n[CI/Tests ]   |                             sock.close()\n[CI/Tests ]   |                             sock = None\n[CI/Tests ]   |                             continue\n[CI/Tests ]   |                     if self._debug:\n[CI/Tests ]   |                         logger.debug(\"connect %r to %r\", sock, address)\n[CI/Tests ]   |                     await self.sock_connect(sock, address)\n[CI/Tests ]   |                 except OSError as exc:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     exceptions.append(exc)\n[CI/Tests ]   |                 except:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     raise\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     break\n[CI/Tests ]   |             else:\n[CI/Tests ]   |                 if len(exceptions) == 1:\n[CI/Tests ]   |                     raise exceptions[0]\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     # If they all have the same str(), raise one.\n[CI/Tests ]   |                     model = str(exceptions[0])\n[CI/Tests ]   |                     if all(str(exc) == model for exc in exceptions):\n[CI/Tests ]   |                         raise exceptions[0]\n[CI/Tests ]   |                     # Raise a combined exception so the user can see all\n[CI/Tests ]   |                     # the various error messages.\n[CI/Tests ]   |                     raise OSError('Multiple exceptions: {}'.format(\n[CI/Tests ]   | >                       ', '.join(str(exc) for exc in exceptions)))\n[CI/Tests ]   | E                   OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | \n[CI/Tests ]   | address    = ('::1', 11211, 0, 0)\n[CI/Tests ]   | cname      = ''\n[CI/Tests ]   | exceptions = [ConnectionRefusedError(111, \"Connect call failed ('127.0.0.1', 11211)\"), OSError(99, 'Cannot assign requested address')]\n[CI/Tests ]   | family     = <AddressFamily.AF_INET6: 10>\n[CI/Tests ]   | flags      = 0\n[CI/Tests ]   | host       = 'localhost'\n[CI/Tests ]   | infos      = [(<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('127.0.0.1', 11211)), (<AddressFamily.AF_INET6: 10>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('::1', 11211, 0, 0))]\n[CI/Tests ]   | local_addr = None\n[CI/Tests ]   | model      = \"[Errno 111] Connect call failed ('127.0.0.1', 11211)\"\n[CI/Tests ]   | port       = 11211\n[CI/Tests ]   | proto      = 6\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7ebb13b0>\n[CI/Tests ]   | self       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | server_hostname = None\n[CI/Tests ]   | sock       = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6>\n[CI/Tests ]   | ssl        = None\n[CI/Tests ]   | ssl_handshake_timeout = None\n[CI/Tests ]   | type       = <SocketKind.SOCK_STREAM: 1>\n[CI/Tests ]   | \n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/base_events.py:971: OSError\n[CI/Tests ]   | __________________________ test_pool_acquire_release2 __________________________\n[CI/Tests ]   | \n[CI/Tests ]   | mcache_params = {'host': 'localhost', 'port': 11211}\n[CI/Tests ]   | \n[CI/Tests ]   |     async def test_pool_acquire_release2(mcache_params: McacheParams) -> None:\n[CI/Tests ]   |         pool = MemcachePool(minsize=1, maxsize=5, **mcache_params)\n[CI/Tests ]   |         reader, writer = await asyncio.open_connection(\n[CI/Tests ]   | >           mcache_params[\"host\"], mcache_params[\"port\"])\n[CI/Tests ]   | \n[CI/Tests ]   | mcache_params = {'host': 'localhost', 'port': 11211}\n[CI/Tests ]   | pool       = <aiomcache.pool.MemcachePool object at 0x7f8a7eea5b10>\n[CI/Tests ]   | \n[CI/Tests ]   | tests/pool_test.py:30: \n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/streams.py:77: in open_connection\n[CI/Tests ]   |     lambda: protocol, host, port, **kwds)\n[CI/Tests ]   |         host       = 'localhost'\n[CI/Tests ]   |         kwds       = {}\n[CI/Tests ]   |         limit      = 65536\n[CI/Tests ]   |         loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   |         port       = 11211\n[CI/Tests ]   |         protocol   = <asyncio.streams.StreamReaderProtocol object at 0x7f8a7eea5e50>\n[CI/Tests ]   |         reader     = <StreamReader>\n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | \n[CI/Tests ]   | self = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7e0d8a70>\n[CI/Tests ]   | host = 'localhost', port = 11211\n[CI/Tests ]   | \n[CI/Tests ]   |     async def create_connection(\n[CI/Tests ]   |             self, protocol_factory, host=None, port=None,\n[CI/Tests ]   |             *, ssl=None, family=0,\n[CI/Tests ]   |             proto=0, flags=0, sock=None,\n[CI/Tests ]   |             local_addr=None, server_hostname=None,\n[CI/Tests ]   |             ssl_handshake_timeout=None):\n[CI/Tests ]   |         \"\"\"Connect to a TCP server.\n[CI/Tests ]   |     \n[CI/Tests ]   |         Create a streaming transport connection to a given Internet host and\n[CI/Tests ]   |         port: socket family AF_INET or socket.AF_INET6 depending on host (or\n[CI/Tests ]   |         family if specified), socket type SOCK_STREAM. protocol_factory must be\n[CI/Tests ]   |         a callable returning a protocol instance.\n[CI/Tests ]   |     \n[CI/Tests ]   |         This method is a coroutine which will try to establish the connection\n[CI/Tests ]   |         in the background.  When successful, the coroutine returns a\n[CI/Tests ]   |         (transport, protocol) pair.\n[CI/Tests ]   |         \"\"\"\n[CI/Tests ]   |         if server_hostname is not None and not ssl:\n[CI/Tests ]   |             raise ValueError('server_hostname is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if server_hostname is None and ssl:\n[CI/Tests ]   |             # Use host as default for server_hostname.  It is an error\n[CI/Tests ]   |             # if host is empty or not set, e.g. when an\n[CI/Tests ]   |             # already-connected socket was passed or when only a port\n[CI/Tests ]   |             # is given.  To avoid this error, you can pass\n[CI/Tests ]   |             # server_hostname='' -- this will bypass the hostname\n[CI/Tests ]   |             # check.  (This also means that if host is a numeric\n[CI/Tests ]   |             # IP/IPv6 address, we will attempt to verify that exact\n[CI/Tests ]   |             # address; this will probably fail, but it is possible to\n[CI/Tests ]   |             # create a certificate for a specific IP address, so we\n[CI/Tests ]   |             # don't judge it here.)\n[CI/Tests ]   |             if not host:\n[CI/Tests ]   |                 raise ValueError('You must set server_hostname '\n[CI/Tests ]   |                                  'when using ssl without a host')\n[CI/Tests ]   |             server_hostname = host\n[CI/Tests ]   |     \n[CI/Tests ]   |         if ssl_handshake_timeout is not None and not ssl:\n[CI/Tests ]   |             raise ValueError(\n[CI/Tests ]   |                 'ssl_handshake_timeout is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if host is not None or port is not None:\n[CI/Tests ]   |             if sock is not None:\n[CI/Tests ]   |                 raise ValueError(\n[CI/Tests ]   |                     'host/port and sock can not be specified at the same time')\n[CI/Tests ]   |     \n[CI/Tests ]   |             infos = await self._ensure_resolved(\n[CI/Tests ]   |                 (host, port), family=family,\n[CI/Tests ]   |                 type=socket.SOCK_STREAM, proto=proto, flags=flags, loop=self)\n[CI/Tests ]   |             if not infos:\n[CI/Tests ]   |                 raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             if local_addr is not None:\n[CI/Tests ]   |                 laddr_infos = await self._ensure_resolved(\n[CI/Tests ]   |                     local_addr, family=family,\n[CI/Tests ]   |                     type=socket.SOCK_STREAM, proto=proto,\n[CI/Tests ]   |                     flags=flags, loop=self)\n[CI/Tests ]   |                 if not laddr_infos:\n[CI/Tests ]   |                     raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             exceptions = []\n[CI/Tests ]   |             for family, type, proto, cname, address in infos:\n[CI/Tests ]   |                 try:\n[CI/Tests ]   |                     sock = socket.socket(family=family, type=type, proto=proto)\n[CI/Tests ]   |                     sock.setblocking(False)\n[CI/Tests ]   |                     if local_addr is not None:\n[CI/Tests ]   |                         for _, _, _, _, laddr in laddr_infos:\n[CI/Tests ]   |                             try:\n[CI/Tests ]   |                                 sock.bind(laddr)\n[CI/Tests ]   |                                 break\n[CI/Tests ]   |                             except OSError as exc:\n[CI/Tests ]   |                                 msg = (\n[CI/Tests ]   |                                     f'error while attempting to bind on '\n[CI/Tests ]   |                                     f'address {laddr!r}: '\n[CI/Tests ]   |                                     f'{exc.strerror.lower()}'\n[CI/Tests ]   |                                 )\n[CI/Tests ]   |                                 exc = OSError(exc.errno, msg)\n[CI/Tests ]   |                                 exceptions.append(exc)\n[CI/Tests ]   |                         else:\n[CI/Tests ]   |                             sock.close()\n[CI/Tests ]   |                             sock = None\n[CI/Tests ]   |                             continue\n[CI/Tests ]   |                     if self._debug:\n[CI/Tests ]   |                         logger.debug(\"connect %r to %r\", sock, address)\n[CI/Tests ]   |                     await self.sock_connect(sock, address)\n[CI/Tests ]   |                 except OSError as exc:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     exceptions.append(exc)\n[CI/Tests ]   |                 except:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     raise\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     break\n[CI/Tests ]   |             else:\n[CI/Tests ]   |                 if len(exceptions) == 1:\n[CI/Tests ]   |                     raise exceptions[0]\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     # If they all have the same str(), raise one.\n[CI/Tests ]   |                     model = str(exceptions[0])\n[CI/Tests ]   |                     if all(str(exc) == model for exc in exceptions):\n[CI/Tests ]   |                         raise exceptions[0]\n[CI/Tests ]   |                     # Raise a combined exception so the user can see all\n[CI/Tests ]   |                     # the various error messages.\n[CI/Tests ]   |                     raise OSError('Multiple exceptions: {}'.format(\n[CI/Tests ]   | >                       ', '.join(str(exc) for exc in exceptions)))\n[CI/Tests ]   | E                   OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | \n[CI/Tests ]   | address    = ('::1', 11211, 0, 0)\n[CI/Tests ]   | cname      = ''\n[CI/Tests ]   | exceptions = [ConnectionRefusedError(111, \"Connect call failed ('127.0.0.1', 11211)\"), OSError(99, 'Cannot assign requested address')]\n[CI/Tests ]   | family     = <AddressFamily.AF_INET6: 10>\n[CI/Tests ]   | flags      = 0\n[CI/Tests ]   | host       = 'localhost'\n[CI/Tests ]   | infos      = [(<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('127.0.0.1', 11211)), (<AddressFamily.AF_INET6: 10>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('::1', 11211, 0, 0))]\n[CI/Tests ]   | local_addr = None\n[CI/Tests ]   | model      = \"[Errno 111] Connect call failed ('127.0.0.1', 11211)\"\n[CI/Tests ]   | port       = 11211\n[CI/Tests ]   | proto      = 6\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7e0d8a70>\n[CI/Tests ]   | self       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | server_hostname = None\n[CI/Tests ]   | sock       = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6>\n[CI/Tests ]   | ssl        = None\n[CI/Tests ]   | ssl_handshake_timeout = None\n[CI/Tests ]   | type       = <SocketKind.SOCK_STREAM: 1>\n[CI/Tests ]   | \n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/base_events.py:971: OSError\n[CI/Tests ]   | _______________________________ test_pool_clear ________________________________\n[CI/Tests ]   | \n[CI/Tests ]   | mcache_params = {'host': 'localhost', 'port': 11211}\n[CI/Tests ]   | \n[CI/Tests ]   |     async def test_pool_clear(mcache_params: McacheParams) -> None:\n[CI/Tests ]   |         pool = MemcachePool(minsize=1, maxsize=5, **mcache_params)\n[CI/Tests ]   | >       conn = await pool.acquire()\n[CI/Tests ]   | \n[CI/Tests ]   | mcache_params = {'host': 'localhost', 'port': 11211}\n[CI/Tests ]   | pool       = <aiomcache.pool.MemcachePool object at 0x7f8a7ee83a10>\n[CI/Tests ]   | \n[CI/Tests ]   | tests/pool_test.py:45: \n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | aiomcache/pool.py:40: in acquire\n[CI/Tests ]   |     _conn = await self._create_new_conn()\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ee83a10>\n[CI/Tests ]   | aiomcache/pool.py:71: in _create_new_conn\n[CI/Tests ]   |     self._host, self._port, **self.conn_args)\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ee83a10>\n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/streams.py:77: in open_connection\n[CI/Tests ]   |     lambda: protocol, host, port, **kwds)\n[CI/Tests ]   |         host       = 'localhost'\n[CI/Tests ]   |         kwds       = {}\n[CI/Tests ]   |         limit      = 65536\n[CI/Tests ]   |         loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   |         port       = 11211\n[CI/Tests ]   |         protocol   = <asyncio.streams.StreamReaderProtocol object at 0x7f8a7ee83090>\n[CI/Tests ]   |         reader     = <StreamReader>\n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | \n[CI/Tests ]   | self = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7e0d8dd0>\n[CI/Tests ]   | host = 'localhost', port = 11211\n[CI/Tests ]   | \n[CI/Tests ]   |     async def create_connection(\n[CI/Tests ]   |             self, protocol_factory, host=None, port=None,\n[CI/Tests ]   |             *, ssl=None, family=0,\n[CI/Tests ]   |             proto=0, flags=0, sock=None,\n[CI/Tests ]   |             local_addr=None, server_hostname=None,\n[CI/Tests ]   |             ssl_handshake_timeout=None):\n[CI/Tests ]   |         \"\"\"Connect to a TCP server.\n[CI/Tests ]   |     \n[CI/Tests ]   |         Create a streaming transport connection to a given Internet host and\n[CI/Tests ]   |         port: socket family AF_INET or socket.AF_INET6 depending on host (or\n[CI/Tests ]   |         family if specified), socket type SOCK_STREAM. protocol_factory must be\n[CI/Tests ]   |         a callable returning a protocol instance.\n[CI/Tests ]   |     \n[CI/Tests ]   |         This method is a coroutine which will try to establish the connection\n[CI/Tests ]   |         in the background.  When successful, the coroutine returns a\n[CI/Tests ]   |         (transport, protocol) pair.\n[CI/Tests ]   |         \"\"\"\n[CI/Tests ]   |         if server_hostname is not None and not ssl:\n[CI/Tests ]   |             raise ValueError('server_hostname is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if server_hostname is None and ssl:\n[CI/Tests ]   |             # Use host as default for server_hostname.  It is an error\n[CI/Tests ]   |             # if host is empty or not set, e.g. when an\n[CI/Tests ]   |             # already-connected socket was passed or when only a port\n[CI/Tests ]   |             # is given.  To avoid this error, you can pass\n[CI/Tests ]   |             # server_hostname='' -- this will bypass the hostname\n[CI/Tests ]   |             # check.  (This also means that if host is a numeric\n[CI/Tests ]   |             # IP/IPv6 address, we will attempt to verify that exact\n[CI/Tests ]   |             # address; this will probably fail, but it is possible to\n[CI/Tests ]   |             # create a certificate for a specific IP address, so we\n[CI/Tests ]   |             # don't judge it here.)\n[CI/Tests ]   |             if not host:\n[CI/Tests ]   |                 raise ValueError('You must set server_hostname '\n[CI/Tests ]   |                                  'when using ssl without a host')\n[CI/Tests ]   |             server_hostname = host\n[CI/Tests ]   |     \n[CI/Tests ]   |         if ssl_handshake_timeout is not None and not ssl:\n[CI/Tests ]   |             raise ValueError(\n[CI/Tests ]   |                 'ssl_handshake_timeout is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if host is not None or port is not None:\n[CI/Tests ]   |             if sock is not None:\n[CI/Tests ]   |                 raise ValueError(\n[CI/Tests ]   |                     'host/port and sock can not be specified at the same time')\n[CI/Tests ]   |     \n[CI/Tests ]   |             infos = await self._ensure_resolved(\n[CI/Tests ]   |                 (host, port), family=family,\n[CI/Tests ]   |                 type=socket.SOCK_STREAM, proto=proto, flags=flags, loop=self)\n[CI/Tests ]   |             if not infos:\n[CI/Tests ]   |                 raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             if local_addr is not None:\n[CI/Tests ]   |                 laddr_infos = await self._ensure_resolved(\n[CI/Tests ]   |                     local_addr, family=family,\n[CI/Tests ]   |                     type=socket.SOCK_STREAM, proto=proto,\n[CI/Tests ]   |                     flags=flags, loop=self)\n[CI/Tests ]   |                 if not laddr_infos:\n[CI/Tests ]   |                     raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             exceptions = []\n[CI/Tests ]   |             for family, type, proto, cname, address in infos:\n[CI/Tests ]   |                 try:\n[CI/Tests ]   |                     sock = socket.socket(family=family, type=type, proto=proto)\n[CI/Tests ]   |                     sock.setblocking(False)\n[CI/Tests ]   |                     if local_addr is not None:\n[CI/Tests ]   |                         for _, _, _, _, laddr in laddr_infos:\n[CI/Tests ]   |                             try:\n[CI/Tests ]   |                                 sock.bind(laddr)\n[CI/Tests ]   |                                 break\n[CI/Tests ]   |                             except OSError as exc:\n[CI/Tests ]   |                                 msg = (\n[CI/Tests ]   |                                     f'error while attempting to bind on '\n[CI/Tests ]   |                                     f'address {laddr!r}: '\n[CI/Tests ]   |                                     f'{exc.strerror.lower()}'\n[CI/Tests ]   |                                 )\n[CI/Tests ]   |                                 exc = OSError(exc.errno, msg)\n[CI/Tests ]   |                                 exceptions.append(exc)\n[CI/Tests ]   |                         else:\n[CI/Tests ]   |                             sock.close()\n[CI/Tests ]   |                             sock = None\n[CI/Tests ]   |                             continue\n[CI/Tests ]   |                     if self._debug:\n[CI/Tests ]   |                         logger.debug(\"connect %r to %r\", sock, address)\n[CI/Tests ]   |                     await self.sock_connect(sock, address)\n[CI/Tests ]   |                 except OSError as exc:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     exceptions.append(exc)\n[CI/Tests ]   |                 except:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     raise\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     break\n[CI/Tests ]   |             else:\n[CI/Tests ]   |                 if len(exceptions) == 1:\n[CI/Tests ]   |                     raise exceptions[0]\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     # If they all have the same str(), raise one.\n[CI/Tests ]   |                     model = str(exceptions[0])\n[CI/Tests ]   |                     if all(str(exc) == model for exc in exceptions):\n[CI/Tests ]   |                         raise exceptions[0]\n[CI/Tests ]   |                     # Raise a combined exception so the user can see all\n[CI/Tests ]   |                     # the various error messages.\n[CI/Tests ]   |                     raise OSError('Multiple exceptions: {}'.format(\n[CI/Tests ]   | >                       ', '.join(str(exc) for exc in exceptions)))\n[CI/Tests ]   | E                   OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | \n[CI/Tests ]   | address    = ('::1', 11211, 0, 0)\n[CI/Tests ]   | cname      = ''\n[CI/Tests ]   | exceptions = [ConnectionRefusedError(111, \"Connect call failed ('127.0.0.1', 11211)\"), OSError(99, 'Cannot assign requested address')]\n[CI/Tests ]   | family     = <AddressFamily.AF_INET6: 10>\n[CI/Tests ]   | flags      = 0\n[CI/Tests ]   | host       = 'localhost'\n[CI/Tests ]   | infos      = [(<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('127.0.0.1', 11211)), (<AddressFamily.AF_INET6: 10>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('::1', 11211, 0, 0))]\n[CI/Tests ]   | local_addr = None\n[CI/Tests ]   | model      = \"[Errno 111] Connect call failed ('127.0.0.1', 11211)\"\n[CI/Tests ]   | port       = 11211\n[CI/Tests ]   | proto      = 6\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7e0d8dd0>\n[CI/Tests ]   | self       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | server_hostname = None\n[CI/Tests ]   | sock       = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6>\n[CI/Tests ]   | ssl        = None\n[CI/Tests ]   | ssl_handshake_timeout = None\n[CI/Tests ]   | type       = <SocketKind.SOCK_STREAM: 1>\n[CI/Tests ]   | \n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/base_events.py:971: OSError\n[CI/Tests ]   | _________ test_acquire_dont_create_new_connection_if_have_conn_in_pool _________\n[CI/Tests ]   | \n[CI/Tests ]   | mcache_params = {'host': 'localhost', 'port': 11211}\n[CI/Tests ]   | \n[CI/Tests ]   |     async def test_acquire_dont_create_new_connection_if_have_conn_in_pool(\n[CI/Tests ]   |         mcache_params: McacheParams,\n[CI/Tests ]   |     ) -> None:\n[CI/Tests ]   |         pool = MemcachePool(minsize=1, maxsize=5, **mcache_params)\n[CI/Tests ]   |         assert pool.size() == 0\n[CI/Tests ]   |     \n[CI/Tests ]   |         # Add a valid connection\n[CI/Tests ]   | >       _conn = await pool._create_new_conn()\n[CI/Tests ]   | \n[CI/Tests ]   | mcache_params = {'host': 'localhost', 'port': 11211}\n[CI/Tests ]   | pool       = <aiomcache.pool.MemcachePool object at 0x7f8a7ec852d0>\n[CI/Tests ]   | \n[CI/Tests ]   | tests/pool_test.py:59: \n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | aiomcache/pool.py:71: in _create_new_conn\n[CI/Tests ]   |     self._host, self._port, **self.conn_args)\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ec852d0>\n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/streams.py:77: in open_connection\n[CI/Tests ]   |     lambda: protocol, host, port, **kwds)\n[CI/Tests ]   |         host       = 'localhost'\n[CI/Tests ]   |         kwds       = {}\n[CI/Tests ]   |         limit      = 65536\n[CI/Tests ]   |         loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   |         port       = 11211\n[CI/Tests ]   |         protocol   = <asyncio.streams.StreamReaderProtocol object at 0x7f8a7ec85950>\n[CI/Tests ]   |         reader     = <StreamReader>\n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | \n[CI/Tests ]   | self = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7e0c65f0>\n[CI/Tests ]   | host = 'localhost', port = 11211\n[CI/Tests ]   | \n[CI/Tests ]   |     async def create_connection(\n[CI/Tests ]   |             self, protocol_factory, host=None, port=None,\n[CI/Tests ]   |             *, ssl=None, family=0,\n[CI/Tests ]   |             proto=0, flags=0, sock=None,\n[CI/Tests ]   |             local_addr=None, server_hostname=None,\n[CI/Tests ]   |             ssl_handshake_timeout=None):\n[CI/Tests ]   |         \"\"\"Connect to a TCP server.\n[CI/Tests ]   |     \n[CI/Tests ]   |         Create a streaming transport connection to a given Internet host and\n[CI/Tests ]   |         port: socket family AF_INET or socket.AF_INET6 depending on host (or\n[CI/Tests ]   |         family if specified), socket type SOCK_STREAM. protocol_factory must be\n[CI/Tests ]   |         a callable returning a protocol instance.\n[CI/Tests ]   |     \n[CI/Tests ]   |         This method is a coroutine which will try to establish the connection\n[CI/Tests ]   |         in the background.  When successful, the coroutine returns a\n[CI/Tests ]   |         (transport, protocol) pair.\n[CI/Tests ]   |         \"\"\"\n[CI/Tests ]   |         if server_hostname is not None and not ssl:\n[CI/Tests ]   |             raise ValueError('server_hostname is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if server_hostname is None and ssl:\n[CI/Tests ]   |             # Use host as default for server_hostname.  It is an error\n[CI/Tests ]   |             # if host is empty or not set, e.g. when an\n[CI/Tests ]   |             # already-connected socket was passed or when only a port\n[CI/Tests ]   |             # is given.  To avoid this error, you can pass\n[CI/Tests ]   |             # server_hostname='' -- this will bypass the hostname\n[CI/Tests ]   |             # check.  (This also means that if host is a numeric\n[CI/Tests ]   |             # IP/IPv6 address, we will attempt to verify that exact\n[CI/Tests ]   |             # address; this will probably fail, but it is possible to\n[CI/Tests ]   |             # create a certificate for a specific IP address, so we\n[CI/Tests ]   |             # don't judge it here.)\n[CI/Tests ]   |             if not host:\n[CI/Tests ]   |                 raise ValueError('You must set server_hostname '\n[CI/Tests ]   |                                  'when using ssl without a host')\n[CI/Tests ]   |             server_hostname = host\n[CI/Tests ]   |     \n[CI/Tests ]   |         if ssl_handshake_timeout is not None and not ssl:\n[CI/Tests ]   |             raise ValueError(\n[CI/Tests ]   |                 'ssl_handshake_timeout is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if host is not None or port is not None:\n[CI/Tests ]   |             if sock is not None:\n[CI/Tests ]   |                 raise ValueError(\n[CI/Tests ]   |                     'host/port and sock can not be specified at the same time')\n[CI/Tests ]   |     \n[CI/Tests ]   |             infos = await self._ensure_resolved(\n[CI/Tests ]   |                 (host, port), family=family,\n[CI/Tests ]   |                 type=socket.SOCK_STREAM, proto=proto, flags=flags, loop=self)\n[CI/Tests ]   |             if not infos:\n[CI/Tests ]   |                 raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             if local_addr is not None:\n[CI/Tests ]   |                 laddr_infos = await self._ensure_resolved(\n[CI/Tests ]   |                     local_addr, family=family,\n[CI/Tests ]   |                     type=socket.SOCK_STREAM, proto=proto,\n[CI/Tests ]   |                     flags=flags, loop=self)\n[CI/Tests ]   |                 if not laddr_infos:\n[CI/Tests ]   |                     raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             exceptions = []\n[CI/Tests ]   |             for family, type, proto, cname, address in infos:\n[CI/Tests ]   |                 try:\n[CI/Tests ]   |                     sock = socket.socket(family=family, type=type, proto=proto)\n[CI/Tests ]   |                     sock.setblocking(False)\n[CI/Tests ]   |                     if local_addr is not None:\n[CI/Tests ]   |                         for _, _, _, _, laddr in laddr_infos:\n[CI/Tests ]   |                             try:\n[CI/Tests ]   |                                 sock.bind(laddr)\n[CI/Tests ]   |                                 break\n[CI/Tests ]   |                             except OSError as exc:\n[CI/Tests ]   |                                 msg = (\n[CI/Tests ]   |                                     f'error while attempting to bind on '\n[CI/Tests ]   |                                     f'address {laddr!r}: '\n[CI/Tests ]   |                                     f'{exc.strerror.lower()}'\n[CI/Tests ]   |                                 )\n[CI/Tests ]   |                                 exc = OSError(exc.errno, msg)\n[CI/Tests ]   |                                 exceptions.append(exc)\n[CI/Tests ]   |                         else:\n[CI/Tests ]   |                             sock.close()\n[CI/Tests ]   |                             sock = None\n[CI/Tests ]   |                             continue\n[CI/Tests ]   |                     if self._debug:\n[CI/Tests ]   |                         logger.debug(\"connect %r to %r\", sock, address)\n[CI/Tests ]   |                     await self.sock_connect(sock, address)\n[CI/Tests ]   |                 except OSError as exc:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     exceptions.append(exc)\n[CI/Tests ]   |                 except:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     raise\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     break\n[CI/Tests ]   |             else:\n[CI/Tests ]   |                 if len(exceptions) == 1:\n[CI/Tests ]   |                     raise exceptions[0]\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     # If they all have the same str(), raise one.\n[CI/Tests ]   |                     model = str(exceptions[0])\n[CI/Tests ]   |                     if all(str(exc) == model for exc in exceptions):\n[CI/Tests ]   |                         raise exceptions[0]\n[CI/Tests ]   |                     # Raise a combined exception so the user can see all\n[CI/Tests ]   |                     # the various error messages.\n[CI/Tests ]   |                     raise OSError('Multiple exceptions: {}'.format(\n[CI/Tests ]   | >                       ', '.join(str(exc) for exc in exceptions)))\n[CI/Tests ]   | E                   OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | \n[CI/Tests ]   | address    = ('::1', 11211, 0, 0)\n[CI/Tests ]   | cname      = ''\n[CI/Tests ]   | exceptions = [ConnectionRefusedError(111, \"Connect call failed ('127.0.0.1', 11211)\"), OSError(99, 'Cannot assign requested address')]\n[CI/Tests ]   | family     = <AddressFamily.AF_INET6: 10>\n[CI/Tests ]   | flags      = 0\n[CI/Tests ]   | host       = 'localhost'\n[CI/Tests ]   | infos      = [(<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('127.0.0.1', 11211)), (<AddressFamily.AF_INET6: 10>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('::1', 11211, 0, 0))]\n[CI/Tests ]   | local_addr = None\n[CI/Tests ]   | model      = \"[Errno 111] Connect call failed ('127.0.0.1', 11211)\"\n[CI/Tests ]   | port       = 11211\n[CI/Tests ]   | proto      = 6\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7e0c65f0>\n[CI/Tests ]   | self       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | server_hostname = None\n[CI/Tests ]   | sock       = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6>\n[CI/Tests ]   | ssl        = None\n[CI/Tests ]   | ssl_handshake_timeout = None\n[CI/Tests ]   | type       = <SocketKind.SOCK_STREAM: 1>\n[CI/Tests ]   | \n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/base_events.py:971: OSError\n[CI/Tests ]   | __________________________ test_acquire_limit_maxsize __________________________\n[CI/Tests ]   | \n[CI/Tests ]   | mcache_params = {'host': 'localhost', 'port': 11211}\n[CI/Tests ]   | \n[CI/Tests ]   |     async def test_acquire_limit_maxsize(mcache_params: McacheParams) -> None:\n[CI/Tests ]   |         pool = MemcachePool(minsize=1, maxsize=1, **mcache_params)\n[CI/Tests ]   |         assert pool.size() == 0\n[CI/Tests ]   |     \n[CI/Tests ]   |         # Create up to max connections\n[CI/Tests ]   | >       _conn = await pool.acquire()\n[CI/Tests ]   | \n[CI/Tests ]   | mcache_params = {'host': 'localhost', 'port': 11211}\n[CI/Tests ]   | pool       = <aiomcache.pool.MemcachePool object at 0x7f8a7d7aa450>\n[CI/Tests ]   | \n[CI/Tests ]   | tests/pool_test.py:76: \n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | aiomcache/pool.py:40: in acquire\n[CI/Tests ]   |     _conn = await self._create_new_conn()\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7d7aa450>\n[CI/Tests ]   | aiomcache/pool.py:71: in _create_new_conn\n[CI/Tests ]   |     self._host, self._port, **self.conn_args)\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7d7aa450>\n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/streams.py:77: in open_connection\n[CI/Tests ]   |     lambda: protocol, host, port, **kwds)\n[CI/Tests ]   |         host       = 'localhost'\n[CI/Tests ]   |         kwds       = {}\n[CI/Tests ]   |         limit      = 65536\n[CI/Tests ]   |         loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   |         port       = 11211\n[CI/Tests ]   |         protocol   = <asyncio.streams.StreamReaderProtocol object at 0x7f8a7d7aab10>\n[CI/Tests ]   |         reader     = <StreamReader>\n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | \n[CI/Tests ]   | self = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7e0c6cb0>\n[CI/Tests ]   | host = 'localhost', port = 11211\n[CI/Tests ]   | \n[CI/Tests ]   |     async def create_connection(\n[CI/Tests ]   |             self, protocol_factory, host=None, port=None,\n[CI/Tests ]   |             *, ssl=None, family=0,\n[CI/Tests ]   |             proto=0, flags=0, sock=None,\n[CI/Tests ]   |             local_addr=None, server_hostname=None,\n[CI/Tests ]   |             ssl_handshake_timeout=None):\n[CI/Tests ]   |         \"\"\"Connect to a TCP server.\n[CI/Tests ]   |     \n[CI/Tests ]   |         Create a streaming transport connection to a given Internet host and\n[CI/Tests ]   |         port: socket family AF_INET or socket.AF_INET6 depending on host (or\n[CI/Tests ]   |         family if specified), socket type SOCK_STREAM. protocol_factory must be\n[CI/Tests ]   |         a callable returning a protocol instance.\n[CI/Tests ]   |     \n[CI/Tests ]   |         This method is a coroutine which will try to establish the connection\n[CI/Tests ]   |         in the background.  When successful, the coroutine returns a\n[CI/Tests ]   |         (transport, protocol) pair.\n[CI/Tests ]   |         \"\"\"\n[CI/Tests ]   |         if server_hostname is not None and not ssl:\n[CI/Tests ]   |             raise ValueError('server_hostname is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if server_hostname is None and ssl:\n[CI/Tests ]   |             # Use host as default for server_hostname.  It is an error\n[CI/Tests ]   |             # if host is empty or not set, e.g. when an\n[CI/Tests ]   |             # already-connected socket was passed or when only a port\n[CI/Tests ]   |             # is given.  To avoid this error, you can pass\n[CI/Tests ]   |             # server_hostname='' -- this will bypass the hostname\n[CI/Tests ]   |             # check.  (This also means that if host is a numeric\n[CI/Tests ]   |             # IP/IPv6 address, we will attempt to verify that exact\n[CI/Tests ]   |             # address; this will probably fail, but it is possible to\n[CI/Tests ]   |             # create a certificate for a specific IP address, so we\n[CI/Tests ]   |             # don't judge it here.)\n[CI/Tests ]   |             if not host:\n[CI/Tests ]   |                 raise ValueError('You must set server_hostname '\n[CI/Tests ]   |                                  'when using ssl without a host')\n[CI/Tests ]   |             server_hostname = host\n[CI/Tests ]   |     \n[CI/Tests ]   |         if ssl_handshake_timeout is not None and not ssl:\n[CI/Tests ]   |             raise ValueError(\n[CI/Tests ]   |                 'ssl_handshake_timeout is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if host is not None or port is not None:\n[CI/Tests ]   |             if sock is not None:\n[CI/Tests ]   |                 raise ValueError(\n[CI/Tests ]   |                     'host/port and sock can not be specified at the same time')\n[CI/Tests ]   |     \n[CI/Tests ]   |             infos = await self._ensure_resolved(\n[CI/Tests ]   |                 (host, port), family=family,\n[CI/Tests ]   |                 type=socket.SOCK_STREAM, proto=proto, flags=flags, loop=self)\n[CI/Tests ]   |             if not infos:\n[CI/Tests ]   |                 raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             if local_addr is not None:\n[CI/Tests ]   |                 laddr_infos = await self._ensure_resolved(\n[CI/Tests ]   |                     local_addr, family=family,\n[CI/Tests ]   |                     type=socket.SOCK_STREAM, proto=proto,\n[CI/Tests ]   |                     flags=flags, loop=self)\n[CI/Tests ]   |                 if not laddr_infos:\n[CI/Tests ]   |                     raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             exceptions = []\n[CI/Tests ]   |             for family, type, proto, cname, address in infos:\n[CI/Tests ]   |                 try:\n[CI/Tests ]   |                     sock = socket.socket(family=family, type=type, proto=proto)\n[CI/Tests ]   |                     sock.setblocking(False)\n[CI/Tests ]   |                     if local_addr is not None:\n[CI/Tests ]   |                         for _, _, _, _, laddr in laddr_infos:\n[CI/Tests ]   |                             try:\n[CI/Tests ]   |                                 sock.bind(laddr)\n[CI/Tests ]   |                                 break\n[CI/Tests ]   |                             except OSError as exc:\n[CI/Tests ]   |                                 msg = (\n[CI/Tests ]   |                                     f'error while attempting to bind on '\n[CI/Tests ]   |                                     f'address {laddr!r}: '\n[CI/Tests ]   |                                     f'{exc.strerror.lower()}'\n[CI/Tests ]   |                                 )\n[CI/Tests ]   |                                 exc = OSError(exc.errno, msg)\n[CI/Tests ]   |                                 exceptions.append(exc)\n[CI/Tests ]   |                         else:\n[CI/Tests ]   |                             sock.close()\n[CI/Tests ]   |                             sock = None\n[CI/Tests ]   |                             continue\n[CI/Tests ]   |                     if self._debug:\n[CI/Tests ]   |                         logger.debug(\"connect %r to %r\", sock, address)\n[CI/Tests ]   |                     await self.sock_connect(sock, address)\n[CI/Tests ]   |                 except OSError as exc:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     exceptions.append(exc)\n[CI/Tests ]   |                 except:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     raise\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     break\n[CI/Tests ]   |             else:\n[CI/Tests ]   |                 if len(exceptions) == 1:\n[CI/Tests ]   |                     raise exceptions[0]\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     # If they all have the same str(), raise one.\n[CI/Tests ]   |                     model = str(exceptions[0])\n[CI/Tests ]   |                     if all(str(exc) == model for exc in exceptions):\n[CI/Tests ]   |                         raise exceptions[0]\n[CI/Tests ]   |                     # Raise a combined exception so the user can see all\n[CI/Tests ]   |                     # the various error messages.\n[CI/Tests ]   |                     raise OSError('Multiple exceptions: {}'.format(\n[CI/Tests ]   | >                       ', '.join(str(exc) for exc in exceptions)))\n[CI/Tests ]   | E                   OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | \n[CI/Tests ]   | address    = ('::1', 11211, 0, 0)\n[CI/Tests ]   | cname      = ''\n[CI/Tests ]   | exceptions = [ConnectionRefusedError(111, \"Connect call failed ('127.0.0.1', 11211)\"), OSError(99, 'Cannot assign requested address')]\n[CI/Tests ]   | family     = <AddressFamily.AF_INET6: 10>\n[CI/Tests ]   | flags      = 0\n[CI/Tests ]   | host       = 'localhost'\n[CI/Tests ]   | infos      = [(<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('127.0.0.1', 11211)), (<AddressFamily.AF_INET6: 10>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('::1', 11211, 0, 0))]\n[CI/Tests ]   | local_addr = None\n[CI/Tests ]   | model      = \"[Errno 111] Connect call failed ('127.0.0.1', 11211)\"\n[CI/Tests ]   | port       = 11211\n[CI/Tests ]   | proto      = 6\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7e0c6cb0>\n[CI/Tests ]   | self       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | server_hostname = None\n[CI/Tests ]   | sock       = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6>\n[CI/Tests ]   | ssl        = None\n[CI/Tests ]   | ssl_handshake_timeout = None\n[CI/Tests ]   | type       = <SocketKind.SOCK_STREAM: 1>\n[CI/Tests ]   | \n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/base_events.py:971: OSError\n[CI/Tests ]   | ________________________ test_acquire_task_cancellation ________________________\n[CI/Tests ]   | \n[CI/Tests ]   | mcache_params = {'host': 'localhost', 'port': 11211}\n[CI/Tests ]   | \n[CI/Tests ]   |     async def test_acquire_task_cancellation(mcache_params: McacheParams) -> None:\n[CI/Tests ]   |     \n[CI/Tests ]   |         class TestClient(Client):\n[CI/Tests ]   |             def __init__(self, pool_size: int = 4):\n[CI/Tests ]   |                 self._pool = MemcachePool(\n[CI/Tests ]   |                     minsize=pool_size, maxsize=pool_size,\n[CI/Tests ]   |                     **mcache_params)\n[CI/Tests ]   |     \n[CI/Tests ]   |             @acquire\n[CI/Tests ]   |             async def acquire_wait_release(self, conn: Connection) -> str:\n[CI/Tests ]   |                 assert self._pool.size() <= pool_size\n[CI/Tests ]   |                 await asyncio.sleep(random.uniform(0.01, 0.02))  # noqa: S311\n[CI/Tests ]   |                 return \"foo\"\n[CI/Tests ]   |     \n[CI/Tests ]   |         pool_size = 4\n[CI/Tests ]   |         client = TestClient(pool_size=pool_size)\n[CI/Tests ]   |         tasks = [\n[CI/Tests ]   |             asyncio.wait_for(\n[CI/Tests ]   |                 client.acquire_wait_release(),\n[CI/Tests ]   |                 random.uniform(1, 2)) for x in range(1000)  # noqa: S311\n[CI/Tests ]   |         ]\n[CI/Tests ]   |         results = await asyncio.gather(*tasks, return_exceptions=True)\n[CI/Tests ]   |         assert client._pool.size() <= pool_size\n[CI/Tests ]   |         assert len(client._pool._in_use) == 0\n[CI/Tests ]   | >       assert \"foo\" in results\n[CI/Tests ]   | E       assert 'foo' in [OSError(\"Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\"), OSError(\"Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\"), OSError(\"Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\"), OSError(\"Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\"), OSError(\"Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\"), OSError(\"Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\"), ...]\n[CI/Tests ]   | \n[CI/Tests ]   | TestClient = <class 'tests.pool_test.test_acquire_task_cancellation.<locals>.TestClient'>\n[CI/Tests ]   | client     = <tests.pool_test.test_acquire_task_cancellation.<locals>.TestClient object at 0x7f8a7ec53610>\n[CI/Tests ]   | mcache_params = {'host': 'localhost', 'port': 11211}\n[CI/Tests ]   | pool_size  = 4\n[CI/Tests ]   | results    = [OSError(\"Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requeste...le exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\"), ...]\n[CI/Tests ]   | tasks      = [<coroutine object wait_for at 0x7f8a7e0d8560>, <coroutine object wait_for at 0x7f8a7e0d84d0>, <coroutine object wait_... at 0x7f8a7e0d8170>, <coroutine object wait_for at 0x7f8a7ebb1dd0>, <coroutine object wait_for at 0x7f8a7ebb1950>, ...]\n[CI/Tests ]   | \n[CI/Tests ]   | tests/pool_test.py:120: AssertionError\n[CI/Tests ]   | ______________________ test_maxsize_greater_than_minsize _______________________\n[CI/Tests ]   | \n[CI/Tests ]   | mcache_params = {'host': 'localhost', 'port': 11211}\n[CI/Tests ]   | \n[CI/Tests ]   |     async def test_maxsize_greater_than_minsize(mcache_params: McacheParams) -> None:\n[CI/Tests ]   |         pool = MemcachePool(minsize=5, maxsize=1, **mcache_params)\n[CI/Tests ]   | >       conn = await pool.acquire()\n[CI/Tests ]   | \n[CI/Tests ]   | mcache_params = {'host': 'localhost', 'port': 11211}\n[CI/Tests ]   | pool       = <aiomcache.pool.MemcachePool object at 0x7f8a7ecab510>\n[CI/Tests ]   | \n[CI/Tests ]   | tests/pool_test.py:126: \n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | aiomcache/pool.py:40: in acquire\n[CI/Tests ]   |     _conn = await self._create_new_conn()\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ecab510>\n[CI/Tests ]   | aiomcache/pool.py:71: in _create_new_conn\n[CI/Tests ]   |     self._host, self._port, **self.conn_args)\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7ecab510>\n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/streams.py:77: in open_connection\n[CI/Tests ]   |     lambda: protocol, host, port, **kwds)\n[CI/Tests ]   |         host       = 'localhost'\n[CI/Tests ]   |         kwds       = {}\n[CI/Tests ]   |         limit      = 65536\n[CI/Tests ]   |         loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   |         port       = 11211\n[CI/Tests ]   |         protocol   = <asyncio.streams.StreamReaderProtocol object at 0x7f8a7ecabd10>\n[CI/Tests ]   |         reader     = <StreamReader>\n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | \n[CI/Tests ]   | self = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7c109440>\n[CI/Tests ]   | host = 'localhost', port = 11211\n[CI/Tests ]   | \n[CI/Tests ]   |     async def create_connection(\n[CI/Tests ]   |             self, protocol_factory, host=None, port=None,\n[CI/Tests ]   |             *, ssl=None, family=0,\n[CI/Tests ]   |             proto=0, flags=0, sock=None,\n[CI/Tests ]   |             local_addr=None, server_hostname=None,\n[CI/Tests ]   |             ssl_handshake_timeout=None):\n[CI/Tests ]   |         \"\"\"Connect to a TCP server.\n[CI/Tests ]   |     \n[CI/Tests ]   |         Create a streaming transport connection to a given Internet host and\n[CI/Tests ]   |         port: socket family AF_INET or socket.AF_INET6 depending on host (or\n[CI/Tests ]   |         family if specified), socket type SOCK_STREAM. protocol_factory must be\n[CI/Tests ]   |         a callable returning a protocol instance.\n[CI/Tests ]   |     \n[CI/Tests ]   |         This method is a coroutine which will try to establish the connection\n[CI/Tests ]   |         in the background.  When successful, the coroutine returns a\n[CI/Tests ]   |         (transport, protocol) pair.\n[CI/Tests ]   |         \"\"\"\n[CI/Tests ]   |         if server_hostname is not None and not ssl:\n[CI/Tests ]   |             raise ValueError('server_hostname is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if server_hostname is None and ssl:\n[CI/Tests ]   |             # Use host as default for server_hostname.  It is an error\n[CI/Tests ]   |             # if host is empty or not set, e.g. when an\n[CI/Tests ]   |             # already-connected socket was passed or when only a port\n[CI/Tests ]   |             # is given.  To avoid this error, you can pass\n[CI/Tests ]   |             # server_hostname='' -- this will bypass the hostname\n[CI/Tests ]   |             # check.  (This also means that if host is a numeric\n[CI/Tests ]   |             # IP/IPv6 address, we will attempt to verify that exact\n[CI/Tests ]   |             # address; this will probably fail, but it is possible to\n[CI/Tests ]   |             # create a certificate for a specific IP address, so we\n[CI/Tests ]   |             # don't judge it here.)\n[CI/Tests ]   |             if not host:\n[CI/Tests ]   |                 raise ValueError('You must set server_hostname '\n[CI/Tests ]   |                                  'when using ssl without a host')\n[CI/Tests ]   |             server_hostname = host\n[CI/Tests ]   |     \n[CI/Tests ]   |         if ssl_handshake_timeout is not None and not ssl:\n[CI/Tests ]   |             raise ValueError(\n[CI/Tests ]   |                 'ssl_handshake_timeout is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if host is not None or port is not None:\n[CI/Tests ]   |             if sock is not None:\n[CI/Tests ]   |                 raise ValueError(\n[CI/Tests ]   |                     'host/port and sock can not be specified at the same time')\n[CI/Tests ]   |     \n[CI/Tests ]   |             infos = await self._ensure_resolved(\n[CI/Tests ]   |                 (host, port), family=family,\n[CI/Tests ]   |                 type=socket.SOCK_STREAM, proto=proto, flags=flags, loop=self)\n[CI/Tests ]   |             if not infos:\n[CI/Tests ]   |                 raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             if local_addr is not None:\n[CI/Tests ]   |                 laddr_infos = await self._ensure_resolved(\n[CI/Tests ]   |                     local_addr, family=family,\n[CI/Tests ]   |                     type=socket.SOCK_STREAM, proto=proto,\n[CI/Tests ]   |                     flags=flags, loop=self)\n[CI/Tests ]   |                 if not laddr_infos:\n[CI/Tests ]   |                     raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             exceptions = []\n[CI/Tests ]   |             for family, type, proto, cname, address in infos:\n[CI/Tests ]   |                 try:\n[CI/Tests ]   |                     sock = socket.socket(family=family, type=type, proto=proto)\n[CI/Tests ]   |                     sock.setblocking(False)\n[CI/Tests ]   |                     if local_addr is not None:\n[CI/Tests ]   |                         for _, _, _, _, laddr in laddr_infos:\n[CI/Tests ]   |                             try:\n[CI/Tests ]   |                                 sock.bind(laddr)\n[CI/Tests ]   |                                 break\n[CI/Tests ]   |                             except OSError as exc:\n[CI/Tests ]   |                                 msg = (\n[CI/Tests ]   |                                     f'error while attempting to bind on '\n[CI/Tests ]   |                                     f'address {laddr!r}: '\n[CI/Tests ]   |                                     f'{exc.strerror.lower()}'\n[CI/Tests ]   |                                 )\n[CI/Tests ]   |                                 exc = OSError(exc.errno, msg)\n[CI/Tests ]   |                                 exceptions.append(exc)\n[CI/Tests ]   |                         else:\n[CI/Tests ]   |                             sock.close()\n[CI/Tests ]   |                             sock = None\n[CI/Tests ]   |                             continue\n[CI/Tests ]   |                     if self._debug:\n[CI/Tests ]   |                         logger.debug(\"connect %r to %r\", sock, address)\n[CI/Tests ]   |                     await self.sock_connect(sock, address)\n[CI/Tests ]   |                 except OSError as exc:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     exceptions.append(exc)\n[CI/Tests ]   |                 except:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     raise\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     break\n[CI/Tests ]   |             else:\n[CI/Tests ]   |                 if len(exceptions) == 1:\n[CI/Tests ]   |                     raise exceptions[0]\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     # If they all have the same str(), raise one.\n[CI/Tests ]   |                     model = str(exceptions[0])\n[CI/Tests ]   |                     if all(str(exc) == model for exc in exceptions):\n[CI/Tests ]   |                         raise exceptions[0]\n[CI/Tests ]   |                     # Raise a combined exception so the user can see all\n[CI/Tests ]   |                     # the various error messages.\n[CI/Tests ]   |                     raise OSError('Multiple exceptions: {}'.format(\n[CI/Tests ]   | >                       ', '.join(str(exc) for exc in exceptions)))\n[CI/Tests ]   | E                   OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | \n[CI/Tests ]   | address    = ('::1', 11211, 0, 0)\n[CI/Tests ]   | cname      = ''\n[CI/Tests ]   | exceptions = [ConnectionRefusedError(111, \"Connect call failed ('127.0.0.1', 11211)\"), OSError(99, 'Cannot assign requested address')]\n[CI/Tests ]   | family     = <AddressFamily.AF_INET6: 10>\n[CI/Tests ]   | flags      = 0\n[CI/Tests ]   | host       = 'localhost'\n[CI/Tests ]   | infos      = [(<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('127.0.0.1', 11211)), (<AddressFamily.AF_INET6: 10>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('::1', 11211, 0, 0))]\n[CI/Tests ]   | local_addr = None\n[CI/Tests ]   | model      = \"[Errno 111] Connect call failed ('127.0.0.1', 11211)\"\n[CI/Tests ]   | port       = 11211\n[CI/Tests ]   | proto      = 6\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7c109440>\n[CI/Tests ]   | self       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | server_hostname = None\n[CI/Tests ]   | sock       = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6>\n[CI/Tests ]   | ssl        = None\n[CI/Tests ]   | ssl_handshake_timeout = None\n[CI/Tests ]   | type       = <SocketKind.SOCK_STREAM: 1>\n[CI/Tests ]   | \n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/base_events.py:971: OSError\n[CI/Tests ]   | ________________________________ test_0_minsize ________________________________\n[CI/Tests ]   | \n[CI/Tests ]   | mcache_params = {'host': 'localhost', 'port': 11211}\n[CI/Tests ]   | \n[CI/Tests ]   |     async def test_0_minsize(mcache_params: McacheParams) -> None:\n[CI/Tests ]   |         pool = MemcachePool(minsize=0, maxsize=5, **mcache_params)\n[CI/Tests ]   | >       conn = await pool.acquire()\n[CI/Tests ]   | \n[CI/Tests ]   | mcache_params = {'host': 'localhost', 'port': 11211}\n[CI/Tests ]   | pool       = <aiomcache.pool.MemcachePool object at 0x7f8a7c087910>\n[CI/Tests ]   | \n[CI/Tests ]   | tests/pool_test.py:135: \n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | aiomcache/pool.py:40: in acquire\n[CI/Tests ]   |     _conn = await self._create_new_conn()\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7c087910>\n[CI/Tests ]   | aiomcache/pool.py:71: in _create_new_conn\n[CI/Tests ]   |     self._host, self._port, **self.conn_args)\n[CI/Tests ]   |         self       = <aiomcache.pool.MemcachePool object at 0x7f8a7c087910>\n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/streams.py:77: in open_connection\n[CI/Tests ]   |     lambda: protocol, host, port, **kwds)\n[CI/Tests ]   |         host       = 'localhost'\n[CI/Tests ]   |         kwds       = {}\n[CI/Tests ]   |         limit      = 65536\n[CI/Tests ]   |         loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   |         port       = 11211\n[CI/Tests ]   |         protocol   = <asyncio.streams.StreamReaderProtocol object at 0x7f8a6c6670d0>\n[CI/Tests ]   |         reader     = <StreamReader>\n[CI/Tests ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Tests ]   | \n[CI/Tests ]   | self = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7c159e60>\n[CI/Tests ]   | host = 'localhost', port = 11211\n[CI/Tests ]   | \n[CI/Tests ]   |     async def create_connection(\n[CI/Tests ]   |             self, protocol_factory, host=None, port=None,\n[CI/Tests ]   |             *, ssl=None, family=0,\n[CI/Tests ]   |             proto=0, flags=0, sock=None,\n[CI/Tests ]   |             local_addr=None, server_hostname=None,\n[CI/Tests ]   |             ssl_handshake_timeout=None):\n[CI/Tests ]   |         \"\"\"Connect to a TCP server.\n[CI/Tests ]   |     \n[CI/Tests ]   |         Create a streaming transport connection to a given Internet host and\n[CI/Tests ]   |         port: socket family AF_INET or socket.AF_INET6 depending on host (or\n[CI/Tests ]   |         family if specified), socket type SOCK_STREAM. protocol_factory must be\n[CI/Tests ]   |         a callable returning a protocol instance.\n[CI/Tests ]   |     \n[CI/Tests ]   |         This method is a coroutine which will try to establish the connection\n[CI/Tests ]   |         in the background.  When successful, the coroutine returns a\n[CI/Tests ]   |         (transport, protocol) pair.\n[CI/Tests ]   |         \"\"\"\n[CI/Tests ]   |         if server_hostname is not None and not ssl:\n[CI/Tests ]   |             raise ValueError('server_hostname is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if server_hostname is None and ssl:\n[CI/Tests ]   |             # Use host as default for server_hostname.  It is an error\n[CI/Tests ]   |             # if host is empty or not set, e.g. when an\n[CI/Tests ]   |             # already-connected socket was passed or when only a port\n[CI/Tests ]   |             # is given.  To avoid this error, you can pass\n[CI/Tests ]   |             # server_hostname='' -- this will bypass the hostname\n[CI/Tests ]   |             # check.  (This also means that if host is a numeric\n[CI/Tests ]   |             # IP/IPv6 address, we will attempt to verify that exact\n[CI/Tests ]   |             # address; this will probably fail, but it is possible to\n[CI/Tests ]   |             # create a certificate for a specific IP address, so we\n[CI/Tests ]   |             # don't judge it here.)\n[CI/Tests ]   |             if not host:\n[CI/Tests ]   |                 raise ValueError('You must set server_hostname '\n[CI/Tests ]   |                                  'when using ssl without a host')\n[CI/Tests ]   |             server_hostname = host\n[CI/Tests ]   |     \n[CI/Tests ]   |         if ssl_handshake_timeout is not None and not ssl:\n[CI/Tests ]   |             raise ValueError(\n[CI/Tests ]   |                 'ssl_handshake_timeout is only meaningful with ssl')\n[CI/Tests ]   |     \n[CI/Tests ]   |         if host is not None or port is not None:\n[CI/Tests ]   |             if sock is not None:\n[CI/Tests ]   |                 raise ValueError(\n[CI/Tests ]   |                     'host/port and sock can not be specified at the same time')\n[CI/Tests ]   |     \n[CI/Tests ]   |             infos = await self._ensure_resolved(\n[CI/Tests ]   |                 (host, port), family=family,\n[CI/Tests ]   |                 type=socket.SOCK_STREAM, proto=proto, flags=flags, loop=self)\n[CI/Tests ]   |             if not infos:\n[CI/Tests ]   |                 raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             if local_addr is not None:\n[CI/Tests ]   |                 laddr_infos = await self._ensure_resolved(\n[CI/Tests ]   |                     local_addr, family=family,\n[CI/Tests ]   |                     type=socket.SOCK_STREAM, proto=proto,\n[CI/Tests ]   |                     flags=flags, loop=self)\n[CI/Tests ]   |                 if not laddr_infos:\n[CI/Tests ]   |                     raise OSError('getaddrinfo() returned empty list')\n[CI/Tests ]   |     \n[CI/Tests ]   |             exceptions = []\n[CI/Tests ]   |             for family, type, proto, cname, address in infos:\n[CI/Tests ]   |                 try:\n[CI/Tests ]   |                     sock = socket.socket(family=family, type=type, proto=proto)\n[CI/Tests ]   |                     sock.setblocking(False)\n[CI/Tests ]   |                     if local_addr is not None:\n[CI/Tests ]   |                         for _, _, _, _, laddr in laddr_infos:\n[CI/Tests ]   |                             try:\n[CI/Tests ]   |                                 sock.bind(laddr)\n[CI/Tests ]   |                                 break\n[CI/Tests ]   |                             except OSError as exc:\n[CI/Tests ]   |                                 msg = (\n[CI/Tests ]   |                                     f'error while attempting to bind on '\n[CI/Tests ]   |                                     f'address {laddr!r}: '\n[CI/Tests ]   |                                     f'{exc.strerror.lower()}'\n[CI/Tests ]   |                                 )\n[CI/Tests ]   |                                 exc = OSError(exc.errno, msg)\n[CI/Tests ]   |                                 exceptions.append(exc)\n[CI/Tests ]   |                         else:\n[CI/Tests ]   |                             sock.close()\n[CI/Tests ]   |                             sock = None\n[CI/Tests ]   |                             continue\n[CI/Tests ]   |                     if self._debug:\n[CI/Tests ]   |                         logger.debug(\"connect %r to %r\", sock, address)\n[CI/Tests ]   |                     await self.sock_connect(sock, address)\n[CI/Tests ]   |                 except OSError as exc:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     exceptions.append(exc)\n[CI/Tests ]   |                 except:\n[CI/Tests ]   |                     if sock is not None:\n[CI/Tests ]   |                         sock.close()\n[CI/Tests ]   |                     raise\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     break\n[CI/Tests ]   |             else:\n[CI/Tests ]   |                 if len(exceptions) == 1:\n[CI/Tests ]   |                     raise exceptions[0]\n[CI/Tests ]   |                 else:\n[CI/Tests ]   |                     # If they all have the same str(), raise one.\n[CI/Tests ]   |                     model = str(exceptions[0])\n[CI/Tests ]   |                     if all(str(exc) == model for exc in exceptions):\n[CI/Tests ]   |                         raise exceptions[0]\n[CI/Tests ]   |                     # Raise a combined exception so the user can see all\n[CI/Tests ]   |                     # the various error messages.\n[CI/Tests ]   |                     raise OSError('Multiple exceptions: {}'.format(\n[CI/Tests ]   | >                       ', '.join(str(exc) for exc in exceptions)))\n[CI/Tests ]   | E                   OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | \n[CI/Tests ]   | address    = ('::1', 11211, 0, 0)\n[CI/Tests ]   | cname      = ''\n[CI/Tests ]   | exceptions = [ConnectionRefusedError(111, \"Connect call failed ('127.0.0.1', 11211)\"), OSError(99, 'Cannot assign requested address')]\n[CI/Tests ]   | family     = <AddressFamily.AF_INET6: 10>\n[CI/Tests ]   | flags      = 0\n[CI/Tests ]   | host       = 'localhost'\n[CI/Tests ]   | infos      = [(<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('127.0.0.1', 11211)), (<AddressFamily.AF_INET6: 10>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('::1', 11211, 0, 0))]\n[CI/Tests ]   | local_addr = None\n[CI/Tests ]   | model      = \"[Errno 111] Connect call failed ('127.0.0.1', 11211)\"\n[CI/Tests ]   | port       = 11211\n[CI/Tests ]   | proto      = 6\n[CI/Tests ]   | protocol_factory = <function open_connection.<locals>.<lambda> at 0x7f8a7c159e60>\n[CI/Tests ]   | self       = <_UnixSelectorEventLoop running=False closed=False debug=False>\n[CI/Tests ]   | server_hostname = None\n[CI/Tests ]   | sock       = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6>\n[CI/Tests ]   | ssl        = None\n[CI/Tests ]   | ssl_handshake_timeout = None\n[CI/Tests ]   | type       = <SocketKind.SOCK_STREAM: 1>\n[CI/Tests ]   | \n[CI/Tests ]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/asyncio/base_events.py:971: OSError\n[CI/Tests ]   | ============================= slowest 10 durations =============================\n[CI/Tests ]   | 0.85s call     tests/pool_test.py::test_acquire_task_cancellation\n[CI/Tests ]   | 0.22s call     tests/commands_test.py::test_version\n[CI/Tests ]   | 0.03s call     tests/commands_test.py::test_multi_get\n[CI/Tests ]   | 0.03s call     tests/commands_test.py::test_set_expire\n[CI/Tests ]   | 0.03s call     tests/commands_test.py::test_flush_all\n[CI/Tests ]   | 0.02s call     tests/commands_test.py::test_gets_cas\n[CI/Tests ]   | 0.02s call     tests/pool_test.py::test_bad_connection\n[CI/Tests ]   | 0.02s call     tests/commands_test.py::test_incr_errors\n[CI/Tests ]   | 0.02s setup    tests/commands_test.py::test_invalid_key[foo bar]\n[CI/Tests ]   | 0.02s call     tests/commands_test.py::test_gets\n[CI/Tests ]   | =========================== short test summary info ============================\n[CI/Tests ]   | SKIPPED [1] tests/conn_args_test.py:12: AsyncMock requires python3.8\n[CI/Tests ]   | FAILED tests/commands_test.py::test_version - OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | FAILED tests/commands_test.py::test_flush_all - OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | FAILED tests/commands_test.py::test_set_get - OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | FAILED tests/commands_test.py::test_gets - OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | FAILED tests/commands_test.py::test_multi_get - OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | FAILED tests/commands_test.py::test_multi_get_doubling_keys - OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | FAILED tests/commands_test.py::test_set_expire - OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | FAILED tests/commands_test.py::test_set_errors - OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | FAILED tests/commands_test.py::test_gets_cas - OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | FAILED tests/commands_test.py::test_cas_missing - OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | FAILED tests/commands_test.py::test_add - OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | FAILED tests/commands_test.py::test_replace - OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | FAILED tests/commands_test.py::test_append - OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | FAILED tests/commands_test.py::test_prepend - OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | FAILED tests/commands_test.py::test_delete - OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | FAILED tests/commands_test.py::test_delete_key_not_exists - OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | FAILED tests/commands_test.py::test_incr - OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | FAILED tests/commands_test.py::test_incr_errors - OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | FAILED tests/commands_test.py::test_decr - OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | FAILED tests/commands_test.py::test_decr_errors - OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | FAILED tests/commands_test.py::test_stats - OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | FAILED tests/commands_test.py::test_touch - OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | FAILED tests/commands_test.py::test_flag_helper[key] - OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | FAILED tests/commands_test.py::test_flag_helper[bkey] - OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | FAILED tests/commands_test.py::test_flag_helper[False] - OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | FAILED tests/commands_test.py::test_flag_helper[1] - OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | FAILED tests/commands_test.py::test_flag_helper[None] - OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | FAILED tests/commands_test.py::test_flag_helper[0.5] - OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | FAILED tests/commands_test.py::test_flag_helper[value6] - OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | FAILED tests/commands_test.py::test_flag_helper[value7] - OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | FAILED tests/commands_test.py::test_flag_helper[value8] - OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | FAILED tests/commands_test.py::test_flag_helper[!@#] - OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | FAILED tests/commands_test.py::test_flag_helper[\\xec\\x95\\x88\\xeb\\x85\\x95\\xed\\x95\\x98\\xec\\x84\\xb8\\xec\\x9a\\x94] - OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | FAILED tests/commands_test.py::test_objects_not_supported_without_flag_handler - OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | FAILED tests/commands_test.py::test_flag_handler_invoked_only_when_expected - OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | FAILED tests/conn_args_test.py::test_ssl_client_fails_against_plaintext_server - OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | FAILED tests/pool_test.py::test_pool_acquire_release - OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | FAILED tests/pool_test.py::test_pool_acquire_release2 - OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | FAILED tests/pool_test.py::test_pool_clear - OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | FAILED tests/pool_test.py::test_acquire_dont_create_new_connection_if_have_conn_in_pool - OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | FAILED tests/pool_test.py::test_acquire_limit_maxsize - OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | FAILED tests/pool_test.py::test_acquire_task_cancellation - assert 'foo' in [OSError(\"Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\"), OSError(\"Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\"), OSError(\"Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\"), OSError(\"Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\"), OSError(\"Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\"), OSError(\"Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\"), ...]\n[CI/Tests ]   | FAILED tests/pool_test.py::test_maxsize_greater_than_minsize - OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | FAILED tests/pool_test.py::test_0_minsize - OSError: Multiple exceptions: [Errno 111] Connect call failed ('127.0.0.1', 11211), [Errno 99] Cannot assign requested address\n[CI/Tests ]   | =================== 44 failed, 22 passed, 1 skipped in 5.52s ===================\n[CI/Tests ]   \u274c  Failure - Main Run tests\n[CI/Tests ] exitcode '1': failure\n[CI/Tests ] \ud83c\udfc1  Job failed\n",
    "actions_stderr": "Error: malformed index signature file\n"
}