{
    "repository": "fsspec/universal_pathlib",
    "clone_url": "https://github.com/fsspec/universal_pathlib.git",
    "timestamp": "2023-05-29T15:57:00.657208Z",
    "clone_success": true,
    "number of actions": 1,
    "number_of_test_actions": 1,
    "actions_successful": false,
    "actions_stdout": "[Python package/lint ] \ud83d\ude80  Start image=crawlergpt:latest\n[Python package/tests] \ud83d\ude80  Start image=crawlergpt:latest\n[Python package/tests]   \ud83d\udc33  docker pull image=crawlergpt:latest platform= username= forcePull=false\n[Python package/lint ]   \ud83d\udc33  docker pull image=crawlergpt:latest platform= username= forcePull=false\n[Python package/lint ]   \ud83d\udc33  docker create image=crawlergpt:latest platform= entrypoint=[\"tail\" \"-f\" \"/dev/null\"] cmd=[]\n[Python package/tests]   \ud83d\udc33  docker create image=crawlergpt:latest platform= entrypoint=[\"tail\" \"-f\" \"/dev/null\"] cmd=[]\n[Python package/lint ]   \ud83d\udc33  docker run image=crawlergpt:latest platform= entrypoint=[\"tail\" \"-f\" \"/dev/null\"] cmd=[]\n[Python package/tests]   \ud83d\udc33  docker run image=crawlergpt:latest platform= entrypoint=[\"tail\" \"-f\" \"/dev/null\"] cmd=[]\n[Python package/lint ]   \ud83d\udc33  docker exec cmd=[chown -R 1012:1000 /tmp/de65f406-fe28-11ed-a890-af2cc187fc11/fsspec-universal_pathlib] user=0 workdir=\n[Python package/tests]   \ud83d\udc33  docker exec cmd=[chown -R 1012:1000 /tmp/de65f406-fe28-11ed-a890-af2cc187fc11/fsspec-universal_pathlib] user=0 workdir=\n[Python package/tests]   \u2601  git clone 'https://github.com/actions/setup-python' # ref=v4\n[Python package/lint ]   \u2601  git clone 'https://github.com/actions/setup-python' # ref=v4\n[Python package/tests] \ud83e\uddea  Matrix: map[os:ubuntu-latest python-version:3.7]\n[Python package/tests] \u2b50 Run Main actions/checkout@v3\n[Python package/tests]   \u2705  Success - Main actions/checkout@v3\n[Python package/lint ] \u2b50 Run Main actions/checkout@v3\n[Python package/lint ]   \u2705  Success - Main actions/checkout@v3\n[Python package/tests] \u2b50 Run Main Set up Python 3.7\n[Python package/tests]   \ud83d\udc33  docker cp src=/home/andre-silva/.cache/act/actions-setup-python@v4/ dst=/var/run/act/actions/actions-setup-python@v4/\n[Python package/lint ] \u2b50 Run Main Set up Python \n[Python package/tests]   \ud83d\udc33  docker exec cmd=[chown -R 1012:1000 /var/run/act/actions/actions-setup-python@v4/] user=0 workdir=\n[Python package/lint ]   \ud83d\udc33  docker cp src=/home/andre-silva/.cache/act/actions-setup-python@v4/ dst=/var/run/act/actions/actions-setup-python@v4/\n[Python package/lint ]   \ud83d\udc33  docker exec cmd=[chown -R 1012:1000 /var/run/act/actions/actions-setup-python@v4/] user=0 workdir=\n[Python package/tests]   \ud83d\udc33  docker exec cmd=[node /var/run/act/actions/actions-setup-python@v4/dist/setup/index.js] user= workdir=\n[Python package/lint ]   \ud83d\udc33  docker exec cmd=[node /var/run/act/actions/actions-setup-python@v4/dist/setup/index.js] user= workdir=\n[Python package/tests]   \ud83d\udcac  ::debug::Python is expected to be installed into /opt/hostedtoolcache\n[Python package/tests]   \u2753  ::group::Installed versions\n[Python package/tests]   \ud83d\udcac  ::debug::Semantic version spec of 3.7 is 3.7\n[Python package/tests]   \ud83d\udcac  ::debug::isExplicit: \n[Python package/tests]   \ud83d\udcac  ::debug::explicit? false\n[Python package/tests]   \ud83d\udcac  ::debug::isExplicit: 2.7.18\n[Python package/tests]   \ud83d\udcac  ::debug::explicit? true\n[Python package/tests]   \ud83d\udcac  ::debug::isExplicit: 3.5.10\n[Python package/tests]   \ud83d\udcac  ::debug::explicit? true\n[Python package/tests]   \ud83d\udcac  ::debug::isExplicit: 3.6.14\n[Python package/tests]   \ud83d\udcac  ::debug::explicit? true\n[Python package/tests]   \ud83d\udcac  ::debug::isExplicit: 3.7.11\n[Python package/tests]   \ud83d\udcac  ::debug::explicit? true\n[Python package/tests]   \ud83d\udcac  ::debug::isExplicit: 3.8.11\n[Python package/tests]   \ud83d\udcac  ::debug::explicit? true\n[Python package/tests]   \ud83d\udcac  ::debug::isExplicit: 3.9.6\n[Python package/tests]   \ud83d\udcac  ::debug::explicit? true\n[Python package/tests]   \ud83d\udcac  ::debug::evaluating 6 versions\n[Python package/lint ]   \ud83d\udcac  ::debug::Python is expected to be installed into /opt/hostedtoolcache\n[Python package/tests]   \ud83d\udcac  ::debug::matched: 3.7.11\n[Python package/tests]   \ud83d\udcac  ::debug::checking cache: /opt/hostedtoolcache/Python/3.7.11/x64\n[Python package/tests]   \ud83d\udcac  ::debug::Found tool in cache Python 3.7.11 x64\n[Python package/lint ]   | [warning]Neither 'python-version' nor 'python-version-file' inputs were supplied. Attempting to find '.python-version' file.\n[Python package/lint ]   | [warning].python-version doesn't exist.\n[Python package/lint ]   \ud83d\udea7  ::warning::The `python-version` input is not set.  The version of Python currently in `PATH` will be used.\n[Python package/lint ]   \u2753 add-matcher /run/act/actions/actions-setup-python@v4/.github/python.json\n[Python package/tests]   | Successfully set up CPython (3.7.11)\n[Python package/tests]   \u2753  ::endgroup::\n[Python package/tests]   \u2753 add-matcher /run/act/actions/actions-setup-python@v4/.github/python.json\n[Python package/lint ]   \u2705  Success - Main Set up Python \n[Python package/tests]   \u2705  Success - Main Set up Python 3.7\n[Python package/tests]   \u2699  ::set-env:: LD_LIBRARY_PATH=/opt/hostedtoolcache/Python/3.7.11/x64/lib\n[Python package/tests]   \u2699  ::set-env:: pythonLocation=/opt/hostedtoolcache/Python/3.7.11/x64\n[Python package/tests]   \u2699  ::set-env:: PKG_CONFIG_PATH=/opt/hostedtoolcache/Python/3.7.11/x64/lib/pkgconfig\n[Python package/tests]   \u2699  ::set-env:: Python_ROOT_DIR=/opt/hostedtoolcache/Python/3.7.11/x64\n[Python package/tests]   \u2699  ::set-env:: Python2_ROOT_DIR=/opt/hostedtoolcache/Python/3.7.11/x64\n[Python package/tests]   \u2699  ::set-env:: Python3_ROOT_DIR=/opt/hostedtoolcache/Python/3.7.11/x64\n[Python package/tests]   \u2699  ::set-output:: python-version=3.7.11\n[Python package/tests]   \u2699  ::set-output:: python-path=/opt/hostedtoolcache/Python/3.7.11/x64/bin/python\n[Python package/tests]   \u2699  ::add-path:: /opt/hostedtoolcache/Python/3.7.11/x64\n[Python package/tests]   \u2699  ::add-path:: /opt/hostedtoolcache/Python/3.7.11/x64/bin\n[Python package/tests] \u2b50 Run Main Install dependencies\n[Python package/lint ] \u2b50 Run Main Install dependencies\n[Python package/tests]   \ud83d\udc33  docker exec cmd=[bash --noprofile --norc -e -o pipefail /var/run/act/workflow/2] user= workdir=\n[Python package/lint ]   \ud83d\udc33  docker exec cmd=[bash --noprofile --norc -e -o pipefail /var/run/act/workflow/2] user= workdir=\n[Python package/tests]   | Requirement already satisfied: pip in /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/site-packages (21.2.4)\n[Python package/tests]   | Collecting pip\n[Python package/tests]   |   Downloading pip-23.1.2-py3-none-any.whl (2.1 MB)\n[Python package/tests]   | Collecting nox\n[Python package/tests]   |   Downloading nox-2023.4.22-py3-none-any.whl (54 kB)\n[Python package/tests]   | Collecting packaging>=20.9\n[Python package/tests]   |   Downloading packaging-23.1-py3-none-any.whl (48 kB)\n[Python package/tests]   | Collecting argcomplete<4.0,>=1.9.4\n[Python package/tests]   |   Downloading argcomplete-3.0.8-py3-none-any.whl (40 kB)\n[Python package/tests]   | Collecting typing-extensions>=3.7.4\n[Python package/tests]   |   Downloading typing_extensions-4.6.2-py3-none-any.whl (31 kB)\n[Python package/tests]   | Collecting colorlog<7.0.0,>=2.6.1\n[Python package/tests]   |   Downloading colorlog-6.7.0-py2.py3-none-any.whl (11 kB)\n[Python package/lint ]   | Collecting pip\n[Python package/lint ]   |   Downloading pip-23.1.2-py3-none-any.whl (2.1 MB)\n[Python package/tests]   | Collecting virtualenv>=14\n[Python package/tests]   |   Downloading virtualenv-20.23.0-py3-none-any.whl (3.3 MB)\n[Python package/tests]   | Collecting importlib-metadata\n[Python package/tests]   |   Downloading importlib_metadata-6.6.0-py3-none-any.whl (22 kB)\n[Python package/lint ]   | Collecting nox\n[Python package/lint ]   |   Downloading nox-2023.4.22-py3-none-any.whl (54 kB)\n[Python package/tests]   | Collecting zipp>=0.5\n[Python package/tests]   |   Downloading zipp-3.15.0-py3-none-any.whl (6.8 kB)\n[Python package/tests]   | Collecting distlib<1,>=0.3.6\n[Python package/tests]   |   Downloading distlib-0.3.6-py2.py3-none-any.whl (468 kB)\n[Python package/lint ]   | Collecting virtualenv>=14\n[Python package/lint ]   |   Downloading virtualenv-20.23.0-py3-none-any.whl (3.3 MB)\n[Python package/tests]   | Collecting filelock<4,>=3.11\n[Python package/tests]   |   Downloading filelock-3.12.0-py3-none-any.whl (10 kB)\n[Python package/tests]   | Collecting platformdirs<4,>=3.2\n[Python package/tests]   |   Downloading platformdirs-3.5.1-py3-none-any.whl (15 kB)\n[Python package/lint ]   | Requirement already satisfied, skipping upgrade: packaging>=20.9 in /usr/local/lib/python3.8/dist-packages (from nox) (21.0)\n[Python package/lint ]   | Collecting colorlog<7.0.0,>=2.6.1\n[Python package/lint ]   |   Downloading colorlog-6.7.0-py2.py3-none-any.whl (11 kB)\n[Python package/lint ]   | Requirement already satisfied, skipping upgrade: argcomplete<4.0,>=1.9.4 in /usr/local/lib/python3.8/dist-packages (from nox) (1.12.3)\n[Python package/lint ]   | Collecting filelock<4,>=3.11\n[Python package/lint ]   |   Downloading filelock-3.12.0-py3-none-any.whl (10 kB)\n[Python package/lint ]   | Collecting distlib<1,>=0.3.6\n[Python package/lint ]   |   Downloading distlib-0.3.6-py2.py3-none-any.whl (468 kB)\n[Python package/tests]   | Installing collected packages: zipp, typing-extensions, platformdirs, importlib-metadata, filelock, distlib, virtualenv, packaging, colorlog, argcomplete, pip, nox\n[Python package/lint ]   | Collecting platformdirs<4,>=3.2\n[Python package/lint ]   |   Downloading platformdirs-3.5.1-py3-none-any.whl (15 kB)\n[Python package/lint ]   | Requirement already satisfied, skipping upgrade: pyparsing>=2.0.2 in /usr/local/lib/python3.8/dist-packages (from packaging>=20.9->nox) (2.4.7)\n[Python package/lint ]   | Installing collected packages: pip, filelock, distlib, platformdirs, virtualenv, colorlog, nox\n[Python package/tests]   |   Attempting uninstall: pip\n[Python package/tests]   |     Found existing installation: pip 21.2.4\n[Python package/tests]   |     Uninstalling pip-21.2.4:\n[Python package/lint ]   |   WARNING: The scripts pip, pip3, pip3.10 and pip3.8 are installed in '/home/runneradmin/.local/bin' which is not on PATH.\n[Python package/lint ]   |   Consider adding this directory to PATH or, if you prefer to suppress this warning, use --no-warn-script-location.\n[Python package/lint ]   |   WARNING: The script virtualenv is installed in '/home/runneradmin/.local/bin' which is not on PATH.\n[Python package/lint ]   |   Consider adding this directory to PATH or, if you prefer to suppress this warning, use --no-warn-script-location.\n[Python package/tests]   |       Successfully uninstalled pip-21.2.4\n[Python package/lint ]   |   WARNING: The scripts nox and tox-to-nox are installed in '/home/runneradmin/.local/bin' which is not on PATH.\n[Python package/lint ]   |   Consider adding this directory to PATH or, if you prefer to suppress this warning, use --no-warn-script-location.\n[Python package/lint ]   | Successfully installed colorlog-6.7.0 distlib-0.3.6 filelock-3.12.0 nox-2023.4.22 pip-23.1.2 platformdirs-3.5.1 virtualenv-20.23.0\n[Python package/lint ]   \u2705  Success - Main Install dependencies\n[Python package/lint ] \u2b50 Run Main Lint\n[Python package/lint ]   \ud83d\udc33  docker exec cmd=[bash --noprofile --norc -e -o pipefail /var/run/act/workflow/3] user= workdir=\n[Python package/tests]   | Successfully installed argcomplete-3.0.8 colorlog-6.7.0 distlib-0.3.6 filelock-3.12.0 importlib-metadata-6.6.0 nox-2023.4.22 packaging-23.1 pip-23.1.2 platformdirs-3.5.1 typing-extensions-4.6.2 virtualenv-20.23.0 zipp-3.15.0\n[Python package/tests]   | nox > Running session install\n[Python package/tests]   | nox > Creating virtual environment (virtualenv) using python in .nox/install\n[Python package/tests]   | nox > python -m pip install .\n[Python package/tests]   | nox > Session install was successful.\n[Python package/tests]   \u2705  Success - Main Install dependencies\n[Python package/tests] \u2b50 Run Main Test with pytest\n[Python package/tests]   \ud83d\udc33  docker exec cmd=[bash --noprofile --norc -e -o pipefail /var/run/act/workflow/3] user= workdir=\n[Python package/lint ]   | /var/run/act/workflow/3: line 2: nox: command not found\n[Python package/lint ]   \u274c  Failure - Main Lint\n[Python package/tests]   | nox > Running session smoke\n[Python package/tests]   | nox > Creating virtual environment (virtualenv) using python in .nox/smoke\n[Python package/lint ] exitcode '127': command not found, please refer to https://github.com/nektos/act/issues/107 for more information\n[Python package/tests]   | nox > python -m pip install pytest adlfs aiohttp requests gcsfs s3fs 'moto[s3,server]' 'webdav4[fsspec]' wsgidav cheroot\n[Python package/lint ] \ud83c\udfc1  Job failed\n[Python package/tests]   | nox > pytest --skiphdfs -vv upath\n[Python package/tests]   | ============================= test session starts ==============================\n[Python package/tests]   | platform linux -- Python 3.7.11, pytest-7.3.1, pluggy-1.0.0 -- /tmp/de65f406-fe28-11ed-a890-af2cc187fc11/fsspec-universal_pathlib/.nox/smoke/bin/python\n[Python package/tests]   | cachedir: .pytest_cache\n[Python package/tests]   | rootdir: /tmp/de65f406-fe28-11ed-a890-af2cc187fc11/fsspec-universal_pathlib\n[Python package/tests]   | plugins: anyio-3.7.0\n[Python package/tests]   | collecting ... collected 616 items\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/test_core.py::test_posix_path PASSED                         [  0%]\n[Python package/tests]   | upath/tests/test_core.py::test_windows_path SKIPPED (Only run on Windows) [  0%]\n[Python package/tests]   | upath/tests/test_core.py::test_UPath_untested_protocol_warning PASSED    [  0%]\n[Python package/tests]   | upath/tests/test_core.py::test_UPath_file_protocol_no_warning PASSED     [  0%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_cwd <- upath/tests/cases.py PASSED [  0%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_home <- upath/tests/cases.py PASSED [  0%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_stat <- upath/tests/cases.py PASSED [  1%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_chmod <- upath/tests/cases.py PASSED [  1%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_exists[file1.txt-True] <- upath/tests/cases.py PASSED [  1%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_exists[fakefile.txt-False] <- upath/tests/cases.py PASSED [  1%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_expanduser <- upath/tests/cases.py PASSED [  1%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_glob <- upath/tests/cases.py PASSED [  1%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_group <- upath/tests/cases.py PASSED [  2%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_is_dir <- upath/tests/cases.py PASSED [  2%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_is_file <- upath/tests/cases.py PASSED [  2%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_is_mount <- upath/tests/cases.py PASSED [  2%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_is_symlink <- upath/tests/cases.py PASSED [  2%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_is_socket <- upath/tests/cases.py PASSED [  2%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_is_fifo <- upath/tests/cases.py PASSED [  3%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_is_block_device <- upath/tests/cases.py PASSED [  3%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_is_char_device <- upath/tests/cases.py PASSED [  3%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_iterdir <- upath/tests/cases.py PASSED [  3%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_iterdir2 <- upath/tests/cases.py PASSED [  3%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_parents <- upath/tests/cases.py PASSED [  3%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_lchmod <- upath/tests/cases.py PASSED [  4%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_lstat <- upath/tests/cases.py PASSED [  4%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_mkdir <- upath/tests/cases.py PASSED [  4%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_mkdir_exists_ok_true <- upath/tests/cases.py PASSED [  4%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_mkdir_exists_ok_false <- upath/tests/cases.py PASSED [  4%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_mkdir_parents_true_exists_ok_true <- upath/tests/cases.py PASSED [  4%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_mkdir_parents_true_exists_ok_false <- upath/tests/cases.py PASSED [  5%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_makedirs_exist_ok_true <- upath/tests/cases.py PASSED [  5%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_makedirs_exist_ok_false <- upath/tests/cases.py PASSED [  5%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_open <- upath/tests/cases.py PASSED [  5%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_owner <- upath/tests/cases.py PASSED [  5%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_read_bytes <- upath/tests/cases.py PASSED [  5%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_read_text <- upath/tests/cases.py PASSED [  6%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_readlink <- upath/tests/cases.py PASSED [  6%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_rename <- upath/tests/cases.py PASSED [  6%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_rename2 <- upath/tests/cases.py PASSED [  6%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_replace <- upath/tests/cases.py PASSED [  6%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_resolve <- upath/tests/cases.py PASSED [  6%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_rglob <- upath/tests/cases.py PASSED [  6%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_samefile <- upath/tests/cases.py PASSED [  7%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_symlink_to <- upath/tests/cases.py PASSED [  7%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_touch_unlink <- upath/tests/cases.py PASSED [  7%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_link_to <- upath/tests/cases.py PASSED [  7%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_write_bytes <- upath/tests/cases.py PASSED [  7%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_write_text <- upath/tests/cases.py PASSED [  7%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_pickling <- upath/tests/cases.py PASSED [  8%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_pickling_child_path <- upath/tests/cases.py PASSED [  8%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_child_path <- upath/tests/cases.py PASSED [  8%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_copy_path <- upath/tests/cases.py PASSED [  8%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_with_name <- upath/tests/cases.py PASSED [  8%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_with_suffix <- upath/tests/cases.py PASSED [  8%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_with_stem <- upath/tests/cases.py SKIPPED (with_stem only available on py3.9+) [  9%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_repr_after_with_name <- upath/tests/cases.py PASSED [  9%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_repr_after_with_suffix <- upath/tests/cases.py PASSED [  9%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_rmdir_no_dir <- upath/tests/cases.py PASSED [  9%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_iterdir_no_dir <- upath/tests/cases.py PASSED [  9%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_rmdir_not_empty <- upath/tests/cases.py PASSED [  9%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_private_url_attr_in_sync <- upath/tests/cases.py PASSED [ 10%]\n[Python package/tests]   | upath/tests/test_core.py::TestUpath::test_fsspec_compat PASSED           [ 10%]\n[Python package/tests]   | upath/tests/test_core.py::test_multiple_backend_paths SKIPPED (skipping hdfs) [ 10%]\n[Python package/tests]   | upath/tests/test_core.py::test_constructor_accept_path PASSED            [ 10%]\n[Python package/tests]   | upath/tests/test_core.py::test_constructor_accept_upath PASSED           [ 10%]\n[Python package/tests]   | upath/tests/test_core.py::test_subclass PASSED                           [ 10%]\n[Python package/tests]   | upath/tests/test_core.py::test_subclass_with_gcs PASSED                  [ 11%]\n[Python package/tests]   | upath/tests/test_core.py::test_instance_check PASSED                     [ 11%]\n[Python package/tests]   | upath/tests/test_core.py::test_new_method PASSED                         [ 11%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_cwd <- upath/tests/cases.py PASSED [ 11%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_home <- upath/tests/cases.py PASSED [ 11%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_stat <- upath/tests/cases.py PASSED [ 11%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_chmod <- upath/tests/cases.py PASSED [ 12%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_exists[file1.txt-True] <- upath/tests/cases.py PASSED [ 12%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_exists[fakefile.txt-False] <- upath/tests/cases.py PASSED [ 12%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_expanduser <- upath/tests/cases.py PASSED [ 12%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_glob <- upath/tests/cases.py PASSED [ 12%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_group <- upath/tests/cases.py PASSED [ 12%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_is_dir <- upath/tests/cases.py PASSED [ 12%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_is_file <- upath/tests/cases.py PASSED [ 13%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_is_mount <- upath/tests/cases.py PASSED [ 13%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_is_symlink <- upath/tests/cases.py PASSED [ 13%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_is_socket <- upath/tests/cases.py PASSED [ 13%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_is_fifo <- upath/tests/cases.py PASSED [ 13%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_is_block_device <- upath/tests/cases.py PASSED [ 13%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_is_char_device <- upath/tests/cases.py PASSED [ 14%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_iterdir <- upath/tests/cases.py PASSED [ 14%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_iterdir2 <- upath/tests/cases.py PASSED [ 14%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_parents <- upath/tests/cases.py PASSED [ 14%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_lchmod <- upath/tests/cases.py PASSED [ 14%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_lstat <- upath/tests/cases.py PASSED [ 14%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_mkdir <- upath/tests/cases.py PASSED [ 15%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_mkdir_exists_ok_true <- upath/tests/cases.py PASSED [ 15%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_mkdir_exists_ok_false <- upath/tests/cases.py PASSED [ 15%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_mkdir_parents_true_exists_ok_true <- upath/tests/cases.py PASSED [ 15%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_mkdir_parents_true_exists_ok_false <- upath/tests/cases.py PASSED [ 15%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_makedirs_exist_ok_true <- upath/tests/cases.py PASSED [ 15%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_makedirs_exist_ok_false <- upath/tests/cases.py PASSED [ 16%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_open <- upath/tests/cases.py PASSED [ 16%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_owner <- upath/tests/cases.py PASSED [ 16%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_read_bytes <- upath/tests/cases.py PASSED [ 16%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_read_text <- upath/tests/cases.py PASSED [ 16%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_readlink <- upath/tests/cases.py PASSED [ 16%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_rename <- upath/tests/cases.py PASSED [ 17%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_rename2 <- upath/tests/cases.py PASSED [ 17%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_replace <- upath/tests/cases.py PASSED [ 17%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_resolve <- upath/tests/cases.py PASSED [ 17%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_rglob <- upath/tests/cases.py PASSED [ 17%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_samefile <- upath/tests/cases.py PASSED [ 17%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_symlink_to <- upath/tests/cases.py PASSED [ 18%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_touch_unlink <- upath/tests/cases.py PASSED [ 18%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_link_to <- upath/tests/cases.py PASSED [ 18%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_write_bytes <- upath/tests/cases.py PASSED [ 18%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_write_text <- upath/tests/cases.py PASSED [ 18%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_fsspec_compat <- upath/tests/cases.py PASSED [ 18%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_pickling <- upath/tests/cases.py PASSED [ 18%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_pickling_child_path <- upath/tests/cases.py PASSED [ 19%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_child_path <- upath/tests/cases.py PASSED [ 19%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_copy_path <- upath/tests/cases.py PASSED [ 19%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_with_name <- upath/tests/cases.py PASSED [ 19%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_with_suffix <- upath/tests/cases.py PASSED [ 19%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_with_stem <- upath/tests/cases.py SKIPPED (with_stem only available on py3.9+) [ 19%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_repr_after_with_name <- upath/tests/cases.py PASSED [ 20%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_repr_after_with_suffix <- upath/tests/cases.py PASSED [ 20%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_rmdir_no_dir <- upath/tests/cases.py PASSED [ 20%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_iterdir_no_dir <- upath/tests/cases.py PASSED [ 20%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_rmdir_not_empty <- upath/tests/cases.py PASSED [ 20%]\n[Python package/tests]   | upath/tests/test_core.py::TestFSSpecLocal::test_private_url_attr_in_sync <- upath/tests/cases.py PASSED [ 20%]\n[Python package/tests]   | upath/tests/test_core.py::test_create_from_type[/tmp/abc-storage_options0-None-Path] PASSED [ 21%]\n[Python package/tests]   | upath/tests/test_core.py::test_create_from_type[s3://bucket/folder-storage_options1-s3fs-S3Path] PASSED [ 21%]\n[Python package/tests]   | upath/tests/test_core.py::test_create_from_type[gs://bucket/folder-storage_options2-gcsfs-GCSPath] PASSED [ 21%]\n[Python package/tests]   | upath/tests/test_core.py::test_list_args PASSED                          [ 21%]\n[Python package/tests]   | upath/tests/test_core.py::test_child_path PASSED                         [ 21%]\n[Python package/tests]   | upath/tests/test_core.py::test_pickling PASSED                           [ 21%]\n[Python package/tests]   | upath/tests/test_core.py::test_pickling_child_path PASSED                [ 22%]\n[Python package/tests]   | upath/tests/test_core.py::test_copy_path PASSED                          [ 22%]\n[Python package/tests]   | upath/tests/test_core.py::test_copy_path_posix PASSED                    [ 22%]\n[Python package/tests]   | upath/tests/test_core.py::test_copy_path_append PASSED                   [ 22%]\n[Python package/tests]   | upath/tests/test_core.py::test_copy_path_append_kwargs PASSED            [ 22%]\n[Python package/tests]   | upath/tests/test_core.py::test_relative_to PASSED                        [ 22%]\n[Python package/tests]   | upath/tests/test_core.py::test_uri_parsing PASSED                        [ 23%]\n[Python package/tests]   | upath/tests/test_core.py::test_normalize[http://example.com-http://example.com/] PASSED [ 23%]\n[Python package/tests]   | upath/tests/test_core.py::test_normalize[http://example.com/-http://example.com/] PASSED [ 23%]\n[Python package/tests]   | upath/tests/test_core.py::test_normalize[http://example.com/a-http://example.com/a] PASSED [ 23%]\n[Python package/tests]   | upath/tests/test_core.py::test_normalize[http://example.com//a-http://example.com//a] PASSED [ 23%]\n[Python package/tests]   | upath/tests/test_core.py::test_normalize[http://example.com///a-http://example.com///a] PASSED [ 23%]\n[Python package/tests]   | upath/tests/test_core.py::test_normalize[http://example.com////a-http://example.com////a] PASSED [ 24%]\n[Python package/tests]   | upath/tests/test_core.py::test_normalize[http://example.com/a/.-http://example.com/a/] PASSED [ 24%]\n[Python package/tests]   | upath/tests/test_core.py::test_normalize[http://example.com/a/./-http://example.com/a/] PASSED [ 24%]\n[Python package/tests]   | upath/tests/test_core.py::test_normalize[http://example.com/a/./b-http://example.com/a/b] PASSED [ 24%]\n[Python package/tests]   | upath/tests/test_core.py::test_normalize[http://example.com/a/.//-http://example.com/a//] PASSED [ 24%]\n[Python package/tests]   | upath/tests/test_core.py::test_normalize[http://example.com/a/.//b-http://example.com/a//b] PASSED [ 24%]\n[Python package/tests]   | upath/tests/test_core.py::test_normalize[http://example.com/a//.-http://example.com/a//] PASSED [ 25%]\n[Python package/tests]   | upath/tests/test_core.py::test_normalize[http://example.com/a//./-http://example.com/a//] PASSED [ 25%]\n[Python package/tests]   | upath/tests/test_core.py::test_normalize[http://example.com/a//./b-http://example.com/a//b] PASSED [ 25%]\n[Python package/tests]   | upath/tests/test_core.py::test_normalize[http://example.com/a//.//-http://example.com/a///] PASSED [ 25%]\n[Python package/tests]   | upath/tests/test_core.py::test_normalize[http://example.com/a//.//b-http://example.com/a///b] PASSED [ 25%]\n[Python package/tests]   | upath/tests/test_core.py::test_normalize[http://example.com/a/..-http://example.com/] PASSED [ 25%]\n[Python package/tests]   | upath/tests/test_core.py::test_normalize[http://example.com/a/../-http://example.com/] PASSED [ 25%]\n[Python package/tests]   | upath/tests/test_core.py::test_normalize[http://example.com/a/../.-http://example.com/] PASSED [ 26%]\n[Python package/tests]   | upath/tests/test_core.py::test_normalize[http://example.com/a/../..-http://example.com/] PASSED [ 26%]\n[Python package/tests]   | upath/tests/test_core.py::test_normalize[http://example.com/a/../../-http://example.com/] PASSED [ 26%]\n[Python package/tests]   | upath/tests/test_core.py::test_normalize[http://example.com/a/../..//-http://example.com//] PASSED [ 26%]\n[Python package/tests]   | upath/tests/test_core.py::test_normalize[http://example.com/a/..//-http://example.com//] PASSED [ 26%]\n[Python package/tests]   | upath/tests/test_core.py::test_normalize[http://example.com/a/..//.-http://example.com//] PASSED [ 26%]\n[Python package/tests]   | upath/tests/test_core.py::test_normalize[http://example.com/a/..//..-http://example.com/] PASSED [ 27%]\n[Python package/tests]   | upath/tests/test_core.py::test_normalize[http://example.com/a/../b-http://example.com/b] PASSED [ 27%]\n[Python package/tests]   | upath/tests/test_core.py::test_normalize[http://example.com/a/..//b-http://example.com//b] PASSED [ 27%]\n[Python package/tests]   | upath/tests/test_core.py::test_normalize[http://example.com/a//..-http://example.com/a/] PASSED [ 27%]\n[Python package/tests]   | upath/tests/test_core.py::test_normalize[http://example.com/a//../-http://example.com/a/] PASSED [ 27%]\n[Python package/tests]   | upath/tests/test_core.py::test_normalize[http://example.com/a//../.-http://example.com/a/] PASSED [ 27%]\n[Python package/tests]   | upath/tests/test_core.py::test_normalize[http://example.com/a//../..-http://example.com/] PASSED [ 28%]\n[Python package/tests]   | upath/tests/test_core.py::test_normalize[http://example.com/a//../../-http://example.com/] PASSED [ 28%]\n[Python package/tests]   | upath/tests/test_core.py::test_normalize[http://example.com/a//../..//-http://example.com//] PASSED [ 28%]\n[Python package/tests]   | upath/tests/test_core.py::test_normalize[http://example.com/a//..//..-http://example.com/a/] PASSED [ 28%]\n[Python package/tests]   | upath/tests/test_core.py::test_normalize[http://example.com/a//../b-http://example.com/a/b] PASSED [ 28%]\n[Python package/tests]   | upath/tests/test_core.py::test_normalize[http://example.com/a//..//-http://example.com/a//] PASSED [ 28%]\n[Python package/tests]   | upath/tests/test_core.py::test_normalize[http://example.com/a//..//.-http://example.com/a//] PASSED [ 29%]\n[Python package/tests]   | upath/tests/test_core.py::test_normalize[http://example.com/a//..//b-http://example.com/a//b] PASSED [ 29%]\n[Python package/tests]   | upath/tests/test_core.py::test_normalize[memory:/a/b/..-memory:/a/] PASSED [ 29%]\n[Python package/tests]   | upath/tests/test_core.py::test_normalize[memory:/a/b/../..-memory:/] PASSED [ 29%]\n[Python package/tests]   | upath/tests/test_core.py::test_normalize[memory:/a/b/../../..-memory:/] PASSED [ 29%]\n[Python package/tests]   | upath/tests/test_core.py::test_normalize[memory://a/b/..-memory://a/] PASSED [ 29%]\n[Python package/tests]   | upath/tests/test_core.py::test_normalize[memory://a/b/../..-memory://a/] PASSED [ 30%]\n[Python package/tests]   | upath/tests/test_core.py::test_normalize[memory://a/b/../../..-memory://a/] PASSED [ 30%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_cwd <- upath/tests/cases.py ERROR [ 30%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_home <- upath/tests/cases.py ERROR [ 30%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_stat <- upath/tests/cases.py ERROR [ 30%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_chmod <- upath/tests/cases.py ERROR [ 30%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_exists[file1.txt-True] <- upath/tests/cases.py ERROR [ 31%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_exists[fakefile.txt-False] <- upath/tests/cases.py ERROR [ 31%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_expanduser <- upath/tests/cases.py ERROR [ 31%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_glob <- upath/tests/cases.py ERROR [ 31%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_group <- upath/tests/cases.py ERROR [ 31%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_is_dir <- upath/tests/cases.py ERROR [ 31%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_is_file <- upath/tests/cases.py ERROR [ 31%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_is_mount <- upath/tests/cases.py ERROR [ 32%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_is_symlink <- upath/tests/cases.py ERROR [ 32%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_is_socket <- upath/tests/cases.py ERROR [ 32%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_is_fifo <- upath/tests/cases.py ERROR [ 32%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_is_block_device <- upath/tests/cases.py ERROR [ 32%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_is_char_device <- upath/tests/cases.py ERROR [ 32%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_iterdir <- upath/tests/cases.py ERROR [ 33%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_iterdir2 <- upath/tests/cases.py ERROR [ 33%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_parents <- upath/tests/cases.py ERROR [ 33%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_lchmod <- upath/tests/cases.py ERROR [ 33%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_lstat <- upath/tests/cases.py ERROR [ 33%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_mkdir <- upath/tests/cases.py ERROR [ 33%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_mkdir_exists_ok_true <- upath/tests/cases.py ERROR [ 34%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_mkdir_exists_ok_false <- upath/tests/cases.py ERROR [ 34%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_mkdir_parents_true_exists_ok_true <- upath/tests/cases.py ERROR [ 34%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_mkdir_parents_true_exists_ok_false <- upath/tests/cases.py ERROR [ 34%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_makedirs_exist_ok_true <- upath/tests/cases.py ERROR [ 34%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_open <- upath/tests/cases.py ERROR [ 34%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_owner <- upath/tests/cases.py ERROR [ 35%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_read_bytes <- upath/tests/cases.py ERROR [ 35%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_read_text <- upath/tests/cases.py ERROR [ 35%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_readlink <- upath/tests/cases.py ERROR [ 35%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_rename <- upath/tests/cases.py ERROR [ 35%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_rename2 <- upath/tests/cases.py ERROR [ 35%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_replace <- upath/tests/cases.py ERROR [ 36%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_resolve <- upath/tests/cases.py ERROR [ 36%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_samefile <- upath/tests/cases.py ERROR [ 36%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_symlink_to <- upath/tests/cases.py ERROR [ 36%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_touch_unlink <- upath/tests/cases.py ERROR [ 36%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_link_to <- upath/tests/cases.py ERROR [ 36%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_write_bytes <- upath/tests/cases.py ERROR [ 37%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_write_text <- upath/tests/cases.py ERROR [ 37%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_fsspec_compat <- upath/tests/cases.py ERROR [ 37%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_pickling <- upath/tests/cases.py ERROR [ 37%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_pickling_child_path <- upath/tests/cases.py ERROR [ 37%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_child_path <- upath/tests/cases.py ERROR [ 37%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_copy_path <- upath/tests/cases.py ERROR [ 37%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_with_name <- upath/tests/cases.py ERROR [ 38%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_with_suffix <- upath/tests/cases.py ERROR [ 38%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_with_stem <- upath/tests/cases.py ERROR [ 38%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_repr_after_with_name <- upath/tests/cases.py ERROR [ 38%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_repr_after_with_suffix <- upath/tests/cases.py ERROR [ 38%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_rmdir_no_dir <- upath/tests/cases.py ERROR [ 38%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_iterdir_no_dir <- upath/tests/cases.py ERROR [ 39%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_rmdir_not_empty <- upath/tests/cases.py ERROR [ 39%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_private_url_attr_in_sync <- upath/tests/cases.py ERROR [ 39%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_is_AzurePath ERROR [ 39%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_rmdir ERROR [ 39%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_makedirs_exist_ok_false SKIPPED (unconditional skip) [ 39%]\n[Python package/tests]   | upath/tests/implementations/test_azure.py::TestAzurePath::test_rglob XFAIL (test interaction) [ 40%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_cwd <- upath/tests/cases.py ERROR [ 40%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_home <- upath/tests/cases.py ERROR [ 40%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_stat <- upath/tests/cases.py ERROR [ 40%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_chmod <- upath/tests/cases.py ERROR [ 40%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_exists[file1.txt-True] <- upath/tests/cases.py ERROR [ 40%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_exists[fakefile.txt-False] <- upath/tests/cases.py ERROR [ 41%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_expanduser <- upath/tests/cases.py ERROR [ 41%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_glob <- upath/tests/cases.py ERROR [ 41%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_group <- upath/tests/cases.py ERROR [ 41%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_is_dir <- upath/tests/cases.py ERROR [ 41%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_is_file <- upath/tests/cases.py ERROR [ 41%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_is_mount <- upath/tests/cases.py ERROR [ 42%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_is_symlink <- upath/tests/cases.py ERROR [ 42%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_is_socket <- upath/tests/cases.py ERROR [ 42%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_is_fifo <- upath/tests/cases.py ERROR [ 42%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_is_block_device <- upath/tests/cases.py ERROR [ 42%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_is_char_device <- upath/tests/cases.py ERROR [ 42%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_iterdir <- upath/tests/cases.py ERROR [ 43%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_iterdir2 <- upath/tests/cases.py ERROR [ 43%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_parents <- upath/tests/cases.py ERROR [ 43%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_lchmod <- upath/tests/cases.py ERROR [ 43%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_lstat <- upath/tests/cases.py ERROR [ 43%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_mkdir <- upath/tests/cases.py ERROR [ 43%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_mkdir_exists_ok_true <- upath/tests/cases.py ERROR [ 43%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_mkdir_exists_ok_false <- upath/tests/cases.py ERROR [ 44%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_mkdir_parents_true_exists_ok_true <- upath/tests/cases.py ERROR [ 44%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_mkdir_parents_true_exists_ok_false <- upath/tests/cases.py ERROR [ 44%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_makedirs_exist_ok_true <- upath/tests/cases.py ERROR [ 44%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_open <- upath/tests/cases.py ERROR [ 44%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_owner <- upath/tests/cases.py ERROR [ 44%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_read_bytes <- upath/tests/cases.py ERROR [ 45%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_read_text <- upath/tests/cases.py ERROR [ 45%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_readlink <- upath/tests/cases.py ERROR [ 45%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_rename <- upath/tests/cases.py ERROR [ 45%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_rename2 <- upath/tests/cases.py ERROR [ 45%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_replace <- upath/tests/cases.py ERROR [ 45%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_resolve <- upath/tests/cases.py ERROR [ 46%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_rglob <- upath/tests/cases.py ERROR [ 46%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_samefile <- upath/tests/cases.py ERROR [ 46%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_symlink_to <- upath/tests/cases.py ERROR [ 46%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_touch_unlink <- upath/tests/cases.py ERROR [ 46%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_link_to <- upath/tests/cases.py ERROR [ 46%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_write_bytes <- upath/tests/cases.py ERROR [ 47%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_write_text <- upath/tests/cases.py ERROR [ 47%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_fsspec_compat <- upath/tests/cases.py ERROR [ 47%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_pickling <- upath/tests/cases.py ERROR [ 47%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_pickling_child_path <- upath/tests/cases.py ERROR [ 47%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_child_path <- upath/tests/cases.py ERROR [ 47%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_copy_path <- upath/tests/cases.py ERROR [ 48%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_with_name <- upath/tests/cases.py ERROR [ 48%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_with_suffix <- upath/tests/cases.py ERROR [ 48%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_with_stem <- upath/tests/cases.py ERROR [ 48%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_repr_after_with_name <- upath/tests/cases.py ERROR [ 48%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_repr_after_with_suffix <- upath/tests/cases.py ERROR [ 48%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_rmdir_no_dir <- upath/tests/cases.py ERROR [ 49%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_iterdir_no_dir <- upath/tests/cases.py ERROR [ 49%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_rmdir_not_empty <- upath/tests/cases.py ERROR [ 49%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_private_url_attr_in_sync <- upath/tests/cases.py ERROR [ 49%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_is_GCSPath ERROR [ 49%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_rmdir ERROR   [ 49%]\n[Python package/tests]   | upath/tests/implementations/test_gcs.py::TestGCSPath::test_makedirs_exist_ok_false SKIPPED (unconditional skip) [ 50%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_cwd <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 50%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_home <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 50%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_stat <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 50%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_exists[file1.txt-True] <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 50%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_exists[fakefile.txt-False] <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 50%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_expanduser <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 50%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_glob <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 51%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_group <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 51%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_is_dir <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 51%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_is_file <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 51%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_is_mount <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 51%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_is_symlink <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 51%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_is_socket <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 52%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_is_fifo <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 52%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_is_block_device <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 52%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_is_char_device <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 52%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_iterdir <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 52%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_iterdir2 <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 52%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_parents <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 53%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_lchmod <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 53%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_lstat <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 53%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_mkdir <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 53%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_mkdir_exists_ok_true <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 53%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_mkdir_exists_ok_false <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 53%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_mkdir_parents_true_exists_ok_true <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 54%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_mkdir_parents_true_exists_ok_false <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 54%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_makedirs_exist_ok_true <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 54%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_makedirs_exist_ok_false <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 54%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_open <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 54%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_owner <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 54%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_read_bytes <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 55%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_read_text <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 55%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_readlink <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 55%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_rename <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 55%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_rename2 <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 55%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_replace <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 55%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_resolve <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 56%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_rglob <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 56%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_samefile <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 56%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_symlink_to <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 56%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_touch_unlink <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 56%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_link_to <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 56%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_write_bytes <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 56%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_write_text <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 57%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_pickling <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 57%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_pickling_child_path <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 57%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_child_path <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 57%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_copy_path <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 57%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_with_name <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 57%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_with_suffix <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 58%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_with_stem <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 58%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_repr_after_with_name <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 58%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_repr_after_with_suffix <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 58%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_rmdir_no_dir <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 58%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_iterdir_no_dir <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 58%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_rmdir_not_empty <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 59%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_private_url_attr_in_sync <- upath/tests/cases.py SKIPPED (skipping hdfs) [ 59%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_is_HDFSPath SKIPPED (skipping hdfs) [ 59%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_chmod SKIPPED (skipping hdfs) [ 59%]\n[Python package/tests]   | upath/tests/implementations/test_hdfs.py::TestUPathHDFS::test_fsspec_compat SKIPPED (skipping hdfs) [ 59%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::test_httppath PASSED           [ 59%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::test_httpspath PASSED          [ 60%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_cwd <- upath/tests/cases.py PASSED [ 60%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_home <- upath/tests/cases.py PASSED [ 60%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_stat <- upath/tests/cases.py PASSED [ 60%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_chmod <- upath/tests/cases.py PASSED [ 60%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_exists[file1.txt-True] <- upath/tests/cases.py PASSED [ 60%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_exists[fakefile.txt-False] <- upath/tests/cases.py PASSED [ 61%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_expanduser <- upath/tests/cases.py PASSED [ 61%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_glob <- upath/tests/cases.py PASSED [ 61%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_group <- upath/tests/cases.py PASSED [ 61%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_is_dir <- upath/tests/cases.py PASSED [ 61%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_is_file <- upath/tests/cases.py PASSED [ 61%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_is_mount <- upath/tests/cases.py PASSED [ 62%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_is_symlink <- upath/tests/cases.py PASSED [ 62%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_is_socket <- upath/tests/cases.py PASSED [ 62%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_is_fifo <- upath/tests/cases.py PASSED [ 62%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_is_block_device <- upath/tests/cases.py PASSED [ 62%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_is_char_device <- upath/tests/cases.py PASSED [ 62%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_iterdir <- upath/tests/cases.py PASSED [ 62%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_iterdir2 <- upath/tests/cases.py PASSED [ 63%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_parents <- upath/tests/cases.py PASSED [ 63%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_lchmod <- upath/tests/cases.py PASSED [ 63%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_lstat <- upath/tests/cases.py PASSED [ 63%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_open <- upath/tests/cases.py PASSED [ 63%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_owner <- upath/tests/cases.py PASSED [ 63%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_read_bytes <- upath/tests/cases.py PASSED [ 64%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_read_text <- upath/tests/cases.py PASSED [ 64%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_readlink <- upath/tests/cases.py PASSED [ 64%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_replace <- upath/tests/cases.py PASSED [ 64%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_rglob <- upath/tests/cases.py PASSED [ 64%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_samefile <- upath/tests/cases.py PASSED [ 64%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_symlink_to <- upath/tests/cases.py PASSED [ 65%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_link_to <- upath/tests/cases.py PASSED [ 65%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_pickling <- upath/tests/cases.py PASSED [ 65%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_pickling_child_path <- upath/tests/cases.py PASSED [ 65%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_child_path <- upath/tests/cases.py PASSED [ 65%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_copy_path <- upath/tests/cases.py PASSED [ 65%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_with_name <- upath/tests/cases.py PASSED [ 66%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_with_suffix <- upath/tests/cases.py PASSED [ 66%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_with_stem <- upath/tests/cases.py SKIPPED (with_stem only available on py3.9+) [ 66%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_repr_after_with_name <- upath/tests/cases.py PASSED [ 66%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_repr_after_with_suffix <- upath/tests/cases.py PASSED [ 66%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_rmdir_no_dir <- upath/tests/cases.py PASSED [ 66%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_iterdir_no_dir <- upath/tests/cases.py PASSED [ 67%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_rmdir_not_empty <- upath/tests/cases.py PASSED [ 67%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_private_url_attr_in_sync <- upath/tests/cases.py PASSED [ 67%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_work_at_root PASSED [ 67%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_mkdir SKIPPED (unconditional skip) [ 67%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_mkdir_exists_ok_false SKIPPED (unconditional skip) [ 67%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_mkdir_exists_ok_true SKIPPED (unconditional skip) [ 68%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_mkdir_parents_true_exists_ok_true SKIPPED (unconditional skip) [ 68%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_mkdir_parents_true_exists_ok_false SKIPPED (unconditional skip) [ 68%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_makedirs_exist_ok_true SKIPPED (unconditional skip) [ 68%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_makedirs_exist_ok_false SKIPPED (unconditional skip) [ 68%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_touch_unlink SKIPPED (unconditional skip) [ 68%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_write_bytes SKIPPED (unconditional skip) [ 68%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_write_text SKIPPED (unconditional skip) [ 69%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_fsspec_compat PASSED [ 69%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_resolve PASSED [ 69%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_rename PASSED [ 69%]\n[Python package/tests]   | upath/tests/implementations/test_http.py::TestUPathHttp::test_rename2 PASSED [ 69%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_cwd <- upath/tests/cases.py PASSED [ 69%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_home <- upath/tests/cases.py PASSED [ 70%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_stat <- upath/tests/cases.py PASSED [ 70%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_chmod <- upath/tests/cases.py PASSED [ 70%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_exists[file1.txt-True] <- upath/tests/cases.py PASSED [ 70%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_exists[fakefile.txt-False] <- upath/tests/cases.py PASSED [ 70%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_expanduser <- upath/tests/cases.py PASSED [ 70%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_glob <- upath/tests/cases.py PASSED [ 71%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_group <- upath/tests/cases.py PASSED [ 71%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_is_dir <- upath/tests/cases.py PASSED [ 71%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_is_file <- upath/tests/cases.py PASSED [ 71%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_is_mount <- upath/tests/cases.py PASSED [ 71%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_is_symlink <- upath/tests/cases.py PASSED [ 71%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_is_socket <- upath/tests/cases.py PASSED [ 72%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_is_fifo <- upath/tests/cases.py PASSED [ 72%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_is_block_device <- upath/tests/cases.py PASSED [ 72%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_is_char_device <- upath/tests/cases.py PASSED [ 72%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_iterdir <- upath/tests/cases.py PASSED [ 72%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_iterdir2 <- upath/tests/cases.py PASSED [ 72%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_parents <- upath/tests/cases.py PASSED [ 73%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_lchmod <- upath/tests/cases.py PASSED [ 73%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_lstat <- upath/tests/cases.py PASSED [ 73%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_mkdir <- upath/tests/cases.py PASSED [ 73%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_mkdir_exists_ok_true <- upath/tests/cases.py PASSED [ 73%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_mkdir_exists_ok_false <- upath/tests/cases.py PASSED [ 73%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_mkdir_parents_true_exists_ok_true <- upath/tests/cases.py PASSED [ 74%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_mkdir_parents_true_exists_ok_false <- upath/tests/cases.py PASSED [ 74%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_makedirs_exist_ok_true <- upath/tests/cases.py PASSED [ 74%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_makedirs_exist_ok_false <- upath/tests/cases.py PASSED [ 74%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_open <- upath/tests/cases.py PASSED [ 74%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_owner <- upath/tests/cases.py PASSED [ 74%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_read_bytes <- upath/tests/cases.py PASSED [ 75%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_read_text <- upath/tests/cases.py PASSED [ 75%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_readlink <- upath/tests/cases.py PASSED [ 75%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_rename <- upath/tests/cases.py PASSED [ 75%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_rename2 <- upath/tests/cases.py PASSED [ 75%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_replace <- upath/tests/cases.py PASSED [ 75%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_resolve <- upath/tests/cases.py PASSED [ 75%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_rglob <- upath/tests/cases.py PASSED [ 76%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_samefile <- upath/tests/cases.py PASSED [ 76%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_symlink_to <- upath/tests/cases.py PASSED [ 76%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_touch_unlink <- upath/tests/cases.py PASSED [ 76%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_link_to <- upath/tests/cases.py PASSED [ 76%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_write_bytes <- upath/tests/cases.py PASSED [ 76%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_write_text <- upath/tests/cases.py PASSED [ 77%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_fsspec_compat <- upath/tests/cases.py PASSED [ 77%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_pickling <- upath/tests/cases.py PASSED [ 77%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_pickling_child_path <- upath/tests/cases.py PASSED [ 77%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_child_path <- upath/tests/cases.py PASSED [ 77%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_copy_path <- upath/tests/cases.py PASSED [ 77%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_with_name <- upath/tests/cases.py PASSED [ 78%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_with_suffix <- upath/tests/cases.py PASSED [ 78%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_with_stem <- upath/tests/cases.py SKIPPED (with_stem only available on py3.9+) [ 78%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_repr_after_with_name <- upath/tests/cases.py PASSED [ 78%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_repr_after_with_suffix <- upath/tests/cases.py PASSED [ 78%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_rmdir_no_dir <- upath/tests/cases.py PASSED [ 78%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_iterdir_no_dir <- upath/tests/cases.py PASSED [ 79%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_rmdir_not_empty <- upath/tests/cases.py PASSED [ 79%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_private_url_attr_in_sync <- upath/tests/cases.py PASSED [ 79%]\n[Python package/tests]   | upath/tests/implementations/test_memory.py::TestMemoryPath::test_is_MemoryPath PASSED [ 79%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_cwd <- upath/tests/cases.py PASSED [ 79%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_home <- upath/tests/cases.py PASSED [ 79%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_stat <- upath/tests/cases.py PASSED [ 80%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_exists[file1.txt-True] <- upath/tests/cases.py PASSED [ 80%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_exists[fakefile.txt-False] <- upath/tests/cases.py PASSED [ 80%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_expanduser <- upath/tests/cases.py PASSED [ 80%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_glob <- upath/tests/cases.py PASSED [ 80%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_group <- upath/tests/cases.py PASSED [ 80%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_is_dir <- upath/tests/cases.py PASSED [ 81%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_is_file <- upath/tests/cases.py PASSED [ 81%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_is_mount <- upath/tests/cases.py PASSED [ 81%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_is_symlink <- upath/tests/cases.py PASSED [ 81%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_is_socket <- upath/tests/cases.py PASSED [ 81%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_is_fifo <- upath/tests/cases.py PASSED [ 81%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_is_block_device <- upath/tests/cases.py PASSED [ 81%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_is_char_device <- upath/tests/cases.py PASSED [ 82%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_iterdir <- upath/tests/cases.py PASSED [ 82%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_iterdir2 <- upath/tests/cases.py PASSED [ 82%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_parents <- upath/tests/cases.py PASSED [ 82%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_lchmod <- upath/tests/cases.py PASSED [ 82%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_lstat <- upath/tests/cases.py PASSED [ 82%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_mkdir <- upath/tests/cases.py PASSED [ 83%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_mkdir_exists_ok_true <- upath/tests/cases.py PASSED [ 83%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_mkdir_exists_ok_false <- upath/tests/cases.py PASSED [ 83%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_mkdir_parents_true_exists_ok_true <- upath/tests/cases.py PASSED [ 83%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_mkdir_parents_true_exists_ok_false <- upath/tests/cases.py PASSED [ 83%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_makedirs_exist_ok_true <- upath/tests/cases.py PASSED [ 83%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_open <- upath/tests/cases.py PASSED [ 84%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_owner <- upath/tests/cases.py PASSED [ 84%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_read_bytes <- upath/tests/cases.py PASSED [ 84%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_read_text <- upath/tests/cases.py PASSED [ 84%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_readlink <- upath/tests/cases.py PASSED [ 84%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_rename <- upath/tests/cases.py PASSED [ 84%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_rename2 <- upath/tests/cases.py PASSED [ 85%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_replace <- upath/tests/cases.py PASSED [ 85%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_resolve <- upath/tests/cases.py PASSED [ 85%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_rglob <- upath/tests/cases.py PASSED [ 85%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_samefile <- upath/tests/cases.py PASSED [ 85%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_symlink_to <- upath/tests/cases.py PASSED [ 85%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_link_to <- upath/tests/cases.py PASSED [ 86%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_write_bytes <- upath/tests/cases.py PASSED [ 86%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_write_text <- upath/tests/cases.py PASSED [ 86%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_fsspec_compat <- upath/tests/cases.py PASSED [ 86%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_pickling <- upath/tests/cases.py PASSED [ 86%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_pickling_child_path <- upath/tests/cases.py PASSED [ 86%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_child_path <- upath/tests/cases.py PASSED [ 87%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_copy_path <- upath/tests/cases.py PASSED [ 87%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_with_name <- upath/tests/cases.py PASSED [ 87%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_with_suffix <- upath/tests/cases.py PASSED [ 87%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_with_stem <- upath/tests/cases.py SKIPPED (with_stem only available on py3.9+) [ 87%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_repr_after_with_name <- upath/tests/cases.py PASSED [ 87%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_repr_after_with_suffix <- upath/tests/cases.py PASSED [ 87%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_rmdir_no_dir <- upath/tests/cases.py PASSED [ 88%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_iterdir_no_dir <- upath/tests/cases.py PASSED [ 88%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_rmdir_not_empty <- upath/tests/cases.py PASSED [ 88%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_private_url_attr_in_sync <- upath/tests/cases.py PASSED [ 88%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_is_S3Path PASSED [ 88%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_chmod PASSED   [ 88%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_rmdir PASSED   [ 89%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_relative_to PASSED [ 89%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_iterdir_root PASSED [ 89%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_touch_unlink PASSED [ 89%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_no_bucket_joinpath[joiner0] PASSED [ 89%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_no_bucket_joinpath[bucket/path/file] PASSED [ 89%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_creating_s3path_with_bucket PASSED [ 90%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_iterdir_with_plus_in_name PASSED [ 90%]\n[Python package/tests]   | upath/tests/implementations/test_s3.py::TestUPathS3::test_makedirs_exist_ok_false SKIPPED (unconditional skip) [ 90%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_cwd <- upath/tests/cases.py PASSED [ 90%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_home <- upath/tests/cases.py PASSED [ 90%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_stat <- upath/tests/cases.py PASSED [ 90%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_chmod <- upath/tests/cases.py PASSED [ 91%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_exists[file1.txt-True] <- upath/tests/cases.py PASSED [ 91%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_exists[fakefile.txt-False] <- upath/tests/cases.py PASSED [ 91%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_expanduser <- upath/tests/cases.py PASSED [ 91%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_glob <- upath/tests/cases.py PASSED [ 91%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_group <- upath/tests/cases.py PASSED [ 91%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_is_dir <- upath/tests/cases.py PASSED [ 92%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_is_file <- upath/tests/cases.py PASSED [ 92%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_is_mount <- upath/tests/cases.py PASSED [ 92%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_is_symlink <- upath/tests/cases.py PASSED [ 92%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_is_socket <- upath/tests/cases.py PASSED [ 92%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_is_fifo <- upath/tests/cases.py PASSED [ 92%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_is_block_device <- upath/tests/cases.py PASSED [ 93%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_is_char_device <- upath/tests/cases.py PASSED [ 93%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_iterdir <- upath/tests/cases.py PASSED [ 93%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_iterdir2 <- upath/tests/cases.py PASSED [ 93%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_parents <- upath/tests/cases.py PASSED [ 93%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_lchmod <- upath/tests/cases.py PASSED [ 93%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_lstat <- upath/tests/cases.py PASSED [ 93%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_mkdir <- upath/tests/cases.py PASSED [ 94%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_mkdir_exists_ok_true <- upath/tests/cases.py PASSED [ 94%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_mkdir_exists_ok_false <- upath/tests/cases.py PASSED [ 94%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_mkdir_parents_true_exists_ok_true <- upath/tests/cases.py PASSED [ 94%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_mkdir_parents_true_exists_ok_false <- upath/tests/cases.py PASSED [ 94%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_makedirs_exist_ok_true <- upath/tests/cases.py PASSED [ 94%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_makedirs_exist_ok_false <- upath/tests/cases.py PASSED [ 95%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_open <- upath/tests/cases.py PASSED [ 95%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_owner <- upath/tests/cases.py PASSED [ 95%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_read_bytes <- upath/tests/cases.py PASSED [ 95%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_read_text <- upath/tests/cases.py PASSED [ 95%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_readlink <- upath/tests/cases.py PASSED [ 95%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_rename <- upath/tests/cases.py PASSED [ 96%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_rename2 <- upath/tests/cases.py PASSED [ 96%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_replace <- upath/tests/cases.py PASSED [ 96%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_resolve <- upath/tests/cases.py PASSED [ 96%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_rglob <- upath/tests/cases.py PASSED [ 96%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_samefile <- upath/tests/cases.py PASSED [ 96%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_symlink_to <- upath/tests/cases.py PASSED [ 97%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_touch_unlink <- upath/tests/cases.py PASSED [ 97%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_link_to <- upath/tests/cases.py PASSED [ 97%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_write_bytes <- upath/tests/cases.py PASSED [ 97%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_write_text <- upath/tests/cases.py PASSED [ 97%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_pickling <- upath/tests/cases.py PASSED [ 97%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_pickling_child_path <- upath/tests/cases.py PASSED [ 98%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_child_path <- upath/tests/cases.py PASSED [ 98%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_copy_path <- upath/tests/cases.py PASSED [ 98%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_with_name <- upath/tests/cases.py PASSED [ 98%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_with_suffix <- upath/tests/cases.py PASSED [ 98%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_with_stem <- upath/tests/cases.py SKIPPED (with_stem only available on py3.9+) [ 98%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_repr_after_with_name <- upath/tests/cases.py PASSED [ 99%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_repr_after_with_suffix <- upath/tests/cases.py PASSED [ 99%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_rmdir_no_dir <- upath/tests/cases.py PASSED [ 99%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_iterdir_no_dir <- upath/tests/cases.py PASSED [ 99%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_rmdir_not_empty <- upath/tests/cases.py PASSED [ 99%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_private_url_attr_in_sync <- upath/tests/cases.py PASSED [ 99%]\n[Python package/tests]   | upath/tests/implementations/test_webdav.py::TestUPathWebdav::test_fsspec_compat PASSED [100%]\n[Python package/tests]   | \n[Python package/tests]   | ==================================== ERRORS ====================================\n[Python package/tests]   | ___________________ ERROR at setup of TestAzurePath.test_cwd ___________________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ---------------------------- Captured stderr setup -----------------------------\n[Python package/tests]   | Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get \"http://%2Fvar%2Frun%2Fdocker.sock/v1.24/containers/json?all=1&filters=%7B%22name%22%3A%7B%22azure_test%22%3Atrue%7D%7D\": dial unix /var/run/docker.sock: connect: permission denied\n[Python package/tests]   | __________________ ERROR at setup of TestAzurePath.test_home ___________________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | __________________ ERROR at setup of TestAzurePath.test_stat ___________________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | __________________ ERROR at setup of TestAzurePath.test_chmod __________________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | _________ ERROR at setup of TestAzurePath.test_exists[file1.txt-True] __________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | _______ ERROR at setup of TestAzurePath.test_exists[fakefile.txt-False] ________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | _______________ ERROR at setup of TestAzurePath.test_expanduser ________________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | __________________ ERROR at setup of TestAzurePath.test_glob ___________________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | __________________ ERROR at setup of TestAzurePath.test_group __________________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | _________________ ERROR at setup of TestAzurePath.test_is_dir __________________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | _________________ ERROR at setup of TestAzurePath.test_is_file _________________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ________________ ERROR at setup of TestAzurePath.test_is_mount _________________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | _______________ ERROR at setup of TestAzurePath.test_is_symlink ________________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ________________ ERROR at setup of TestAzurePath.test_is_socket ________________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | _________________ ERROR at setup of TestAzurePath.test_is_fifo _________________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | _____________ ERROR at setup of TestAzurePath.test_is_block_device _____________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | _____________ ERROR at setup of TestAzurePath.test_is_char_device ______________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | _________________ ERROR at setup of TestAzurePath.test_iterdir _________________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ________________ ERROR at setup of TestAzurePath.test_iterdir2 _________________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | _________________ ERROR at setup of TestAzurePath.test_parents _________________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | _________________ ERROR at setup of TestAzurePath.test_lchmod __________________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | __________________ ERROR at setup of TestAzurePath.test_lstat __________________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | __________________ ERROR at setup of TestAzurePath.test_mkdir __________________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | __________ ERROR at setup of TestAzurePath.test_mkdir_exists_ok_true ___________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | __________ ERROR at setup of TestAzurePath.test_mkdir_exists_ok_false __________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ____ ERROR at setup of TestAzurePath.test_mkdir_parents_true_exists_ok_true ____\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ___ ERROR at setup of TestAzurePath.test_mkdir_parents_true_exists_ok_false ____\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | _________ ERROR at setup of TestAzurePath.test_makedirs_exist_ok_true __________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | __________________ ERROR at setup of TestAzurePath.test_open ___________________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | __________________ ERROR at setup of TestAzurePath.test_owner __________________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | _______________ ERROR at setup of TestAzurePath.test_read_bytes ________________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ________________ ERROR at setup of TestAzurePath.test_read_text ________________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ________________ ERROR at setup of TestAzurePath.test_readlink _________________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | _________________ ERROR at setup of TestAzurePath.test_rename __________________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | _________________ ERROR at setup of TestAzurePath.test_rename2 _________________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | _________________ ERROR at setup of TestAzurePath.test_replace _________________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | _________________ ERROR at setup of TestAzurePath.test_resolve _________________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ________________ ERROR at setup of TestAzurePath.test_samefile _________________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | _______________ ERROR at setup of TestAzurePath.test_symlink_to ________________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ______________ ERROR at setup of TestAzurePath.test_touch_unlink _______________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | _________________ ERROR at setup of TestAzurePath.test_link_to _________________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | _______________ ERROR at setup of TestAzurePath.test_write_bytes _______________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | _______________ ERROR at setup of TestAzurePath.test_write_text ________________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ______________ ERROR at setup of TestAzurePath.test_fsspec_compat ______________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ________________ ERROR at setup of TestAzurePath.test_pickling _________________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ___________ ERROR at setup of TestAzurePath.test_pickling_child_path ___________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | _______________ ERROR at setup of TestAzurePath.test_child_path ________________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ________________ ERROR at setup of TestAzurePath.test_copy_path ________________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ________________ ERROR at setup of TestAzurePath.test_with_name ________________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | _______________ ERROR at setup of TestAzurePath.test_with_suffix _______________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ________________ ERROR at setup of TestAzurePath.test_with_stem ________________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | __________ ERROR at setup of TestAzurePath.test_repr_after_with_name ___________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | _________ ERROR at setup of TestAzurePath.test_repr_after_with_suffix __________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ______________ ERROR at setup of TestAzurePath.test_rmdir_no_dir _______________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | _____________ ERROR at setup of TestAzurePath.test_iterdir_no_dir ______________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | _____________ ERROR at setup of TestAzurePath.test_rmdir_not_empty _____________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ________ ERROR at setup of TestAzurePath.test_private_url_attr_in_sync _________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ______________ ERROR at setup of TestAzurePath.test_is_AzurePath _______________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | __________________ ERROR at setup of TestAzurePath.test_rmdir __________________\n[Python package/tests]   | \n[Python package/tests]   | azurite_credentials = ('devstoreaccount1', 'DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:10000/devstoreaccount1;')\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_azurite(azurite_credentials):\n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |     \n[Python package/tests]   |         image = \"mcr.microsoft.com/azure-storage/azurite\"\n[Python package/tests]   |         container_name = \"azure_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             f\"docker run --rm -d -p 10000:10000 --name {container_name} {image}\"  # noqa: E501\n[Python package/tests]   |             \" azurite-blob --loose --blobHost 0.0.0.0\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   |         url = \"http://localhost:10000\"\n[Python package/tests]   |     \n[Python package/tests]   | >       stop_docker(container_name)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:370: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe7194a3050>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ____________________ ERROR at setup of TestGCSPath.test_cwd ____________________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ---------------------------- Captured stderr setup -----------------------------\n[Python package/tests]   | Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get \"http://%2Fvar%2Frun%2Fdocker.sock/v1.24/containers/json?all=1&filters=%7B%22name%22%3A%7B%22gcsfs_test%22%3Atrue%7D%7D\": dial unix /var/run/docker.sock: connect: permission denied\n[Python package/tests]   | ___________________ ERROR at setup of TestGCSPath.test_home ____________________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ___________________ ERROR at setup of TestGCSPath.test_stat ____________________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ___________________ ERROR at setup of TestGCSPath.test_chmod ___________________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | __________ ERROR at setup of TestGCSPath.test_exists[file1.txt-True] ___________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ________ ERROR at setup of TestGCSPath.test_exists[fakefile.txt-False] _________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ________________ ERROR at setup of TestGCSPath.test_expanduser _________________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ___________________ ERROR at setup of TestGCSPath.test_glob ____________________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ___________________ ERROR at setup of TestGCSPath.test_group ___________________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | __________________ ERROR at setup of TestGCSPath.test_is_dir ___________________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | __________________ ERROR at setup of TestGCSPath.test_is_file __________________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | _________________ ERROR at setup of TestGCSPath.test_is_mount __________________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ________________ ERROR at setup of TestGCSPath.test_is_symlink _________________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | _________________ ERROR at setup of TestGCSPath.test_is_socket _________________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | __________________ ERROR at setup of TestGCSPath.test_is_fifo __________________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ______________ ERROR at setup of TestGCSPath.test_is_block_device ______________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ______________ ERROR at setup of TestGCSPath.test_is_char_device _______________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | __________________ ERROR at setup of TestGCSPath.test_iterdir __________________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | _________________ ERROR at setup of TestGCSPath.test_iterdir2 __________________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | __________________ ERROR at setup of TestGCSPath.test_parents __________________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | __________________ ERROR at setup of TestGCSPath.test_lchmod ___________________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ___________________ ERROR at setup of TestGCSPath.test_lstat ___________________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ___________________ ERROR at setup of TestGCSPath.test_mkdir ___________________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ___________ ERROR at setup of TestGCSPath.test_mkdir_exists_ok_true ____________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ___________ ERROR at setup of TestGCSPath.test_mkdir_exists_ok_false ___________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | _____ ERROR at setup of TestGCSPath.test_mkdir_parents_true_exists_ok_true _____\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ____ ERROR at setup of TestGCSPath.test_mkdir_parents_true_exists_ok_false _____\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | __________ ERROR at setup of TestGCSPath.test_makedirs_exist_ok_true ___________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ___________________ ERROR at setup of TestGCSPath.test_open ____________________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ___________________ ERROR at setup of TestGCSPath.test_owner ___________________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ________________ ERROR at setup of TestGCSPath.test_read_bytes _________________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | _________________ ERROR at setup of TestGCSPath.test_read_text _________________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | _________________ ERROR at setup of TestGCSPath.test_readlink __________________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | __________________ ERROR at setup of TestGCSPath.test_rename ___________________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | __________________ ERROR at setup of TestGCSPath.test_rename2 __________________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | __________________ ERROR at setup of TestGCSPath.test_replace __________________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | __________________ ERROR at setup of TestGCSPath.test_resolve __________________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ___________________ ERROR at setup of TestGCSPath.test_rglob ___________________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | _________________ ERROR at setup of TestGCSPath.test_samefile __________________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ________________ ERROR at setup of TestGCSPath.test_symlink_to _________________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | _______________ ERROR at setup of TestGCSPath.test_touch_unlink ________________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | __________________ ERROR at setup of TestGCSPath.test_link_to __________________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ________________ ERROR at setup of TestGCSPath.test_write_bytes ________________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ________________ ERROR at setup of TestGCSPath.test_write_text _________________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | _______________ ERROR at setup of TestGCSPath.test_fsspec_compat _______________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | _________________ ERROR at setup of TestGCSPath.test_pickling __________________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ____________ ERROR at setup of TestGCSPath.test_pickling_child_path ____________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ________________ ERROR at setup of TestGCSPath.test_child_path _________________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | _________________ ERROR at setup of TestGCSPath.test_copy_path _________________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | _________________ ERROR at setup of TestGCSPath.test_with_name _________________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ________________ ERROR at setup of TestGCSPath.test_with_suffix ________________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | _________________ ERROR at setup of TestGCSPath.test_with_stem _________________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ___________ ERROR at setup of TestGCSPath.test_repr_after_with_name ____________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | __________ ERROR at setup of TestGCSPath.test_repr_after_with_suffix ___________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | _______________ ERROR at setup of TestGCSPath.test_rmdir_no_dir ________________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ______________ ERROR at setup of TestGCSPath.test_iterdir_no_dir _______________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ______________ ERROR at setup of TestGCSPath.test_rmdir_not_empty ______________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | _________ ERROR at setup of TestGCSPath.test_private_url_attr_in_sync __________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ________________ ERROR at setup of TestGCSPath.test_is_GCSPath _________________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | ___________________ ERROR at setup of TestGCSPath.test_rmdir ___________________\n[Python package/tests]   | \n[Python package/tests]   |     @pytest.fixture(scope=\"session\")\n[Python package/tests]   |     def docker_gcs():\n[Python package/tests]   |         if \"STORAGE_EMULATOR_HOST\" in os.environ:\n[Python package/tests]   |             # assume using real API or otherwise have a server already set up\n[Python package/tests]   |             yield os.environ[\"STORAGE_EMULATOR_HOST\"]\n[Python package/tests]   |             return\n[Python package/tests]   |     \n[Python package/tests]   |         requests = pytest.importorskip(\"requests\")\n[Python package/tests]   |         if shutil.which(\"docker\") is None:\n[Python package/tests]   |             pytest.skip(\"docker not installed\")\n[Python package/tests]   |     \n[Python package/tests]   |         container = \"gcsfs_test\"\n[Python package/tests]   |         cmd = (\n[Python package/tests]   |             \"docker run -d -p 4443:4443 --name gcsfs_test fsouza/fake-gcs-server:latest -scheme \"  # noqa: E501\n[Python package/tests]   |             \"http -public-host http://localhost:4443 -external-url http://localhost:4443\"  # noqa: E501\n[Python package/tests]   |         )\n[Python package/tests]   | >       stop_docker(container)\n[Python package/tests]   | \n[Python package/tests]   | upath/tests/conftest.py:227: \n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | upath/tests/conftest.py:206: in stop_docker\n[Python package/tests]   |     cid = subprocess.check_output(cmd).strip().decode()\n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:411: in check_output\n[Python package/tests]   |     **kwargs).stdout\n[Python package/tests]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python package/tests]   | \n[Python package/tests]   | input = None, capture_output = False, timeout = None, check = True\n[Python package/tests]   | popenargs = (['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test'],)\n[Python package/tests]   | kwargs = {'stdout': -1}, process = <subprocess.Popen object at 0x7fe719583310>\n[Python package/tests]   | stdout = b'', stderr = None, retcode = 1\n[Python package/tests]   | \n[Python package/tests]   |     def run(*popenargs,\n[Python package/tests]   |             input=None, capture_output=False, timeout=None, check=False, **kwargs):\n[Python package/tests]   |         \"\"\"Run command with arguments and return a CompletedProcess instance.\n[Python package/tests]   |     \n[Python package/tests]   |         The returned instance will have attributes args, returncode, stdout and\n[Python package/tests]   |         stderr. By default, stdout and stderr are not captured, and those attributes\n[Python package/tests]   |         will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n[Python package/tests]   |     \n[Python package/tests]   |         If check is True and the exit code was non-zero, it raises a\n[Python package/tests]   |         CalledProcessError. The CalledProcessError object will have the return code\n[Python package/tests]   |         in the returncode attribute, and output & stderr attributes if those streams\n[Python package/tests]   |         were captured.\n[Python package/tests]   |     \n[Python package/tests]   |         If timeout is given, and the process takes too long, a TimeoutExpired\n[Python package/tests]   |         exception will be raised.\n[Python package/tests]   |     \n[Python package/tests]   |         There is an optional argument \"input\", allowing you to\n[Python package/tests]   |         pass bytes or a string to the subprocess's stdin.  If you use this argument\n[Python package/tests]   |         you may not also use the Popen constructor's \"stdin\" argument, as\n[Python package/tests]   |         it will be used internally.\n[Python package/tests]   |     \n[Python package/tests]   |         By default, all communication is in bytes, and therefore any \"input\" should\n[Python package/tests]   |         be bytes, and the stdout and stderr will be bytes. If in text mode, any\n[Python package/tests]   |         \"input\" should be a string, and stdout and stderr will be strings decoded\n[Python package/tests]   |         according to locale encoding, or by \"encoding\" if set. Text mode is\n[Python package/tests]   |         triggered by setting any of text, encoding, errors or universal_newlines.\n[Python package/tests]   |     \n[Python package/tests]   |         The other arguments are the same as for the Popen constructor.\n[Python package/tests]   |         \"\"\"\n[Python package/tests]   |         if input is not None:\n[Python package/tests]   |             if kwargs.get('stdin') is not None:\n[Python package/tests]   |                 raise ValueError('stdin and input arguments may not both be used.')\n[Python package/tests]   |             kwargs['stdin'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         if capture_output:\n[Python package/tests]   |             if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:\n[Python package/tests]   |                 raise ValueError('stdout and stderr arguments may not be used '\n[Python package/tests]   |                                  'with capture_output.')\n[Python package/tests]   |             kwargs['stdout'] = PIPE\n[Python package/tests]   |             kwargs['stderr'] = PIPE\n[Python package/tests]   |     \n[Python package/tests]   |         with Popen(*popenargs, **kwargs) as process:\n[Python package/tests]   |             try:\n[Python package/tests]   |                 stdout, stderr = process.communicate(input, timeout=timeout)\n[Python package/tests]   |             except TimeoutExpired as exc:\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 if _mswindows:\n[Python package/tests]   |                     # Windows accumulates the output in a single blocking\n[Python package/tests]   |                     # read() call run on child threads, with the timeout\n[Python package/tests]   |                     # being done in a join() on those threads.  communicate()\n[Python package/tests]   |                     # _after_ kill() is required to collect that and add it\n[Python package/tests]   |                     # to the exception.\n[Python package/tests]   |                     exc.stdout, exc.stderr = process.communicate()\n[Python package/tests]   |                 else:\n[Python package/tests]   |                     # POSIX _communicate already populated the output so\n[Python package/tests]   |                     # far into the TimeoutExpired exception.\n[Python package/tests]   |                     process.wait()\n[Python package/tests]   |                 raise\n[Python package/tests]   |             except:  # Including KeyboardInterrupt, communicate handled that.\n[Python package/tests]   |                 process.kill()\n[Python package/tests]   |                 # We don't call process.wait() as .__exit__ does that for us.\n[Python package/tests]   |                 raise\n[Python package/tests]   |             retcode = process.poll()\n[Python package/tests]   |             if check and retcode:\n[Python package/tests]   |                 raise CalledProcessError(retcode, process.args,\n[Python package/tests]   | >                                        output=stdout, stderr=stderr)\n[Python package/tests]   | E               subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | \n[Python package/tests]   | /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/subprocess.py:512: CalledProcessError\n[Python package/tests]   | =========================== short test summary info ============================\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_cwd - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_home - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_stat - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_chmod - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_exists[file1.txt-True] - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_exists[fakefile.txt-False] - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_expanduser - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_glob - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_group - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_is_dir - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_is_file - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_is_mount - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_is_symlink - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_is_socket - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_is_fifo - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_is_block_device - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_is_char_device - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_iterdir - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_iterdir2 - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_parents - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_lchmod - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_lstat - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_mkdir - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_mkdir_exists_ok_true - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_mkdir_exists_ok_false - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_mkdir_parents_true_exists_ok_true - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_mkdir_parents_true_exists_ok_false - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_makedirs_exist_ok_true - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_open - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_owner - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_read_bytes - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_read_text - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_readlink - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_rename - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_rename2 - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_replace - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_resolve - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_samefile - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_symlink_to - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_touch_unlink - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_link_to - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_write_bytes - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_write_text - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_fsspec_compat - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_pickling - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_pickling_child_path - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_child_path - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_copy_path - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_with_name - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_with_suffix - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_with_stem - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_repr_after_with_name - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_repr_after_with_suffix - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_rmdir_no_dir - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_iterdir_no_dir - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_rmdir_not_empty - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_private_url_attr_in_sync - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_is_AzurePath - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_azure.py::TestAzurePath::test_rmdir - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=azure_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_cwd - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_home - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_stat - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_chmod - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_exists[file1.txt-True] - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_exists[fakefile.txt-False] - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_expanduser - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_glob - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_group - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_is_dir - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_is_file - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_is_mount - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_is_symlink - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_is_socket - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_is_fifo - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_is_block_device - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_is_char_device - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_iterdir - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_iterdir2 - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_parents - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_lchmod - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_lstat - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_mkdir - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_mkdir_exists_ok_true - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_mkdir_exists_ok_false - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_mkdir_parents_true_exists_ok_true - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_mkdir_parents_true_exists_ok_false - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_makedirs_exist_ok_true - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_open - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_owner - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_read_bytes - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_read_text - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_readlink - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_rename - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_rename2 - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_replace - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_resolve - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_rglob - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_samefile - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_symlink_to - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_touch_unlink - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_link_to - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_write_bytes - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_write_text - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_fsspec_compat - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_pickling - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_pickling_child_path - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_child_path - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_copy_path - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_with_name - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_with_suffix - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_with_stem - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_repr_after_with_name - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_repr_after_with_suffix - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_rmdir_no_dir - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_iterdir_no_dir - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_rmdir_not_empty - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_private_url_attr_in_sync - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_is_GCSPath - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | ERROR upath/tests/implementations/test_gcs.py::TestGCSPath::test_rmdir - subprocess.CalledProcessError: Command '['docker', 'ps', '-a', '-q', '--filter', 'name=gcsfs_test']' returned non-zero exit status 1.\n[Python package/tests]   | =========== 415 passed, 81 skipped, 1 xfailed, 119 errors in 56.51s ============\n[Python package/tests]   | nox > Command pytest --skiphdfs -vv upath failed with exit code 1\n[Python package/tests]   | nox > Session smoke failed.\n[Python package/tests]   \u274c  Failure - Main Test with pytest\n[Python package/tests] exitcode '1': failure\n[Python package/tests] \ud83c\udfc1  Job failed\n",
    "actions_stderr": "Error: Job 'lint' failed\n"
}