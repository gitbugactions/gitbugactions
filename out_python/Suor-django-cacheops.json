{
    "repository": "Suor/django-cacheops",
    "clone_url": "https://github.com/Suor/django-cacheops.git",
    "timestamp": "2023-05-29T14:12:17.526035Z",
    "clone_success": true,
    "number of actions": 1,
    "number_of_test_actions": 1,
    "actions_successful": false,
    "actions_stdout": "[CI/lint                      ] \ud83d\ude80  Start image=crawlergpt:latest\n[CI/Python 3.7-1              ] \ud83d\ude80  Start image=crawlergpt:latest\n[CI/Django main [ok to fail]-2] \ud83d\ude80  Start image=crawlergpt:latest\n[CI/Django main [ok to fail]-2]   \ud83d\udc33  docker pull image=crawlergpt:latest platform= username= forcePull=false\n[CI/Python 3.7-1              ]   \ud83d\udc33  docker pull image=crawlergpt:latest platform= username= forcePull=false\n[CI/lint                      ]   \ud83d\udc33  docker pull image=crawlergpt:latest platform= username= forcePull=false\n[CI/Django main [ok to fail]-2]   \ud83d\udc33  docker create image=crawlergpt:latest platform= entrypoint=[\"tail\" \"-f\" \"/dev/null\"] cmd=[]\n[CI/Python 3.7-1              ]   \ud83d\udc33  docker create image=crawlergpt:latest platform= entrypoint=[\"tail\" \"-f\" \"/dev/null\"] cmd=[]\n[CI/lint                      ]   \ud83d\udc33  docker create image=crawlergpt:latest platform= entrypoint=[\"tail\" \"-f\" \"/dev/null\"] cmd=[]\n[CI/lint                      ]   \ud83d\udc33  docker run image=crawlergpt:latest platform= entrypoint=[\"tail\" \"-f\" \"/dev/null\"] cmd=[]\n[CI/Django main [ok to fail]-2]   \ud83d\udc33  docker run image=crawlergpt:latest platform= entrypoint=[\"tail\" \"-f\" \"/dev/null\"] cmd=[]\n[CI/Python 3.7-1              ]   \ud83d\udc33  docker run image=crawlergpt:latest platform= entrypoint=[\"tail\" \"-f\" \"/dev/null\"] cmd=[]\n[CI/lint                      ]   \ud83d\udc33  docker exec cmd=[chown -R 1012:1000 /tmp/de65f406-fe28-11ed-a890-af2cc187fc11/Suor-django-cacheops] user=0 workdir=\n[CI/lint                      ]   \u2601  git clone 'https://github.com/actions/setup-python' # ref=v4\n[CI/lint                      ] \u2b50 Run Main actions/checkout@v3\n[CI/lint                      ]   \u2705  Success - Main actions/checkout@v3\n[CI/lint                      ] \u2b50 Run Main Set up Python 3.10\n[CI/Python 3.7-1              ]   \ud83d\udc33  docker exec cmd=[chown -R 1012:1000 /tmp/de65f406-fe28-11ed-a890-af2cc187fc11/Suor-django-cacheops] user=0 workdir=\n[CI/Django main [ok to fail]-2]   \ud83d\udc33  docker exec cmd=[chown -R 1012:1000 /tmp/de65f406-fe28-11ed-a890-af2cc187fc11/Suor-django-cacheops] user=0 workdir=\n[CI/lint                      ]   \ud83d\udc33  docker cp src=/home/andre-silva/.cache/act/actions-setup-python@v4/ dst=/var/run/act/actions/actions-setup-python@v4/\n[CI/lint                      ]   \ud83d\udc33  docker exec cmd=[chown -R 1012:1000 /var/run/act/actions/actions-setup-python@v4/] user=0 workdir=\n[CI/Python 3.7-1              ]   \u2601  git clone 'https://github.com/actions/setup-python' # ref=v4\n[CI/Django main [ok to fail]-2]   \u2601  git clone 'https://github.com/actions/setup-python' # ref=v4\n[CI/Python 3.7-1              ] \ud83e\uddea  Matrix: map[experimental:false python-version:3.7]\n[CI/Python 3.7-1              ] \u2b50 Run Main actions/checkout@v3\n[CI/Python 3.7-1              ]   \u2705  Success - Main actions/checkout@v3\n[CI/Django main [ok to fail]-2] \ud83e\uddea  Matrix: map[experimental:true python-version:3.10]\n[CI/Django main [ok to fail]-2] \u2b50 Run Main actions/checkout@v3\n[CI/Django main [ok to fail]-2]   \u2705  Success - Main actions/checkout@v3\n[CI/lint                      ]   \ud83d\udc33  docker exec cmd=[node /var/run/act/actions/actions-setup-python@v4/dist/setup/index.js] user= workdir=\n[CI/Python 3.7-1              ] \u2b50 Run Main Setup python\n[CI/Python 3.7-1              ]   \ud83d\udc33  docker cp src=/home/andre-silva/.cache/act/actions-setup-python@v4/ dst=/var/run/act/actions/actions-setup-python@v4/\n[CI/Django main [ok to fail]-2] \u2b50 Run Main Setup python\n[CI/Python 3.7-1              ]   \ud83d\udc33  docker exec cmd=[chown -R 1012:1000 /var/run/act/actions/actions-setup-python@v4/] user=0 workdir=\n[CI/Django main [ok to fail]-2]   \ud83d\udc33  docker cp src=/home/andre-silva/.cache/act/actions-setup-python@v4/ dst=/var/run/act/actions/actions-setup-python@v4/\n[CI/Django main [ok to fail]-2]   \ud83d\udc33  docker exec cmd=[chown -R 1012:1000 /var/run/act/actions/actions-setup-python@v4/] user=0 workdir=\n[CI/Django main [ok to fail]-2]   \ud83d\udc33  docker exec cmd=[node /var/run/act/actions/actions-setup-python@v4/dist/setup/index.js] user= workdir=\n[CI/Python 3.7-1              ]   \ud83d\udc33  docker exec cmd=[node /var/run/act/actions/actions-setup-python@v4/dist/setup/index.js] user= workdir=\n[CI/lint                      ]   \ud83d\udcac  ::debug::Python is expected to be installed into /opt/hostedtoolcache\n[CI/lint                      ]   \u2753  ::group::Installed versions\n[CI/lint                      ]   \ud83d\udcac  ::debug::Semantic version spec of 3.10 is 3.10\n[CI/lint                      ]   \ud83d\udcac  ::debug::isExplicit: \n[CI/lint                      ]   \ud83d\udcac  ::debug::explicit? false\n[CI/lint                      ]   \ud83d\udcac  ::debug::isExplicit: 2.7.18\n[CI/lint                      ]   \ud83d\udcac  ::debug::explicit? true\n[CI/lint                      ]   \ud83d\udcac  ::debug::isExplicit: 3.5.10\n[CI/lint                      ]   \ud83d\udcac  ::debug::explicit? true\n[CI/lint                      ]   \ud83d\udcac  ::debug::isExplicit: 3.6.14\n[CI/lint                      ]   \ud83d\udcac  ::debug::explicit? true\n[CI/lint                      ]   \ud83d\udcac  ::debug::isExplicit: 3.7.11\n[CI/lint                      ]   \ud83d\udcac  ::debug::explicit? true\n[CI/lint                      ]   \ud83d\udcac  ::debug::isExplicit: 3.8.11\n[CI/lint                      ]   \ud83d\udcac  ::debug::explicit? true\n[CI/lint                      ]   \ud83d\udcac  ::debug::isExplicit: 3.9.6\n[CI/lint                      ]   \ud83d\udcac  ::debug::explicit? true\n[CI/lint                      ]   \ud83d\udcac  ::debug::evaluating 6 versions\n[CI/lint                      ]   \ud83d\udcac  ::debug::match not found\n[CI/lint                      ]   | Version 3.10 was not found in the local cache\n[CI/lint                      ]   \ud83d\udcac  ::debug::Getting manifest from actions/python-versions@main\n[CI/Python 3.7-1              ]   \ud83d\udcac  ::debug::Python is expected to be installed into /opt/hostedtoolcache\n[CI/Python 3.7-1              ]   \u2753  ::group::Installed versions\n[CI/Python 3.7-1              ]   \ud83d\udcac  ::debug::Semantic version spec of 3.7 is 3.7\n[CI/Python 3.7-1              ]   \ud83d\udcac  ::debug::isExplicit: \n[CI/Python 3.7-1              ]   \ud83d\udcac  ::debug::explicit? false\n[CI/Python 3.7-1              ]   \ud83d\udcac  ::debug::isExplicit: 2.7.18\n[CI/Python 3.7-1              ]   \ud83d\udcac  ::debug::explicit? true\n[CI/Python 3.7-1              ]   \ud83d\udcac  ::debug::isExplicit: 3.5.10\n[CI/Python 3.7-1              ]   \ud83d\udcac  ::debug::explicit? true\n[CI/Python 3.7-1              ]   \ud83d\udcac  ::debug::isExplicit: 3.6.14\n[CI/Python 3.7-1              ]   \ud83d\udcac  ::debug::explicit? true\n[CI/Python 3.7-1              ]   \ud83d\udcac  ::debug::isExplicit: 3.7.11\n[CI/Python 3.7-1              ]   \ud83d\udcac  ::debug::explicit? true\n[CI/Python 3.7-1              ]   \ud83d\udcac  ::debug::isExplicit: 3.8.11\n[CI/Python 3.7-1              ]   \ud83d\udcac  ::debug::explicit? true\n[CI/Python 3.7-1              ]   \ud83d\udcac  ::debug::isExplicit: 3.9.6\n[CI/Python 3.7-1              ]   \ud83d\udcac  ::debug::explicit? true\n[CI/Python 3.7-1              ]   \ud83d\udcac  ::debug::evaluating 6 versions\n[CI/Python 3.7-1              ]   \ud83d\udcac  ::debug::matched: 3.7.11\n[CI/Python 3.7-1              ]   \ud83d\udcac  ::debug::checking cache: /opt/hostedtoolcache/Python/3.7.11/x64\n[CI/Python 3.7-1              ]   \ud83d\udcac  ::debug::Found tool in cache Python 3.7.11 x64\n[CI/Python 3.7-1              ]   | Successfully set up CPython (3.7.11)\n[CI/Python 3.7-1              ]   \u2753  ::endgroup::\n[CI/Python 3.7-1              ]   \u2753 add-matcher /run/act/actions/actions-setup-python@v4/.github/python.json\n[CI/Django main [ok to fail]-2]   \ud83d\udcac  ::debug::Python is expected to be installed into /opt/hostedtoolcache\n[CI/Django main [ok to fail]-2]   \u2753  ::group::Installed versions\n[CI/Django main [ok to fail]-2]   \ud83d\udcac  ::debug::Semantic version spec of 3.10 is 3.10\n[CI/Django main [ok to fail]-2]   \ud83d\udcac  ::debug::isExplicit: \n[CI/Django main [ok to fail]-2]   \ud83d\udcac  ::debug::explicit? false\n[CI/Django main [ok to fail]-2]   \ud83d\udcac  ::debug::isExplicit: 2.7.18\n[CI/Django main [ok to fail]-2]   \ud83d\udcac  ::debug::explicit? true\n[CI/Django main [ok to fail]-2]   \ud83d\udcac  ::debug::isExplicit: 3.5.10\n[CI/Django main [ok to fail]-2]   \ud83d\udcac  ::debug::explicit? true\n[CI/Django main [ok to fail]-2]   \ud83d\udcac  ::debug::isExplicit: 3.6.14\n[CI/Django main [ok to fail]-2]   \ud83d\udcac  ::debug::explicit? true\n[CI/Django main [ok to fail]-2]   \ud83d\udcac  ::debug::isExplicit: 3.7.11\n[CI/Django main [ok to fail]-2]   \ud83d\udcac  ::debug::explicit? true\n[CI/Django main [ok to fail]-2]   \ud83d\udcac  ::debug::isExplicit: 3.8.11\n[CI/Django main [ok to fail]-2]   \ud83d\udcac  ::debug::explicit? true\n[CI/Django main [ok to fail]-2]   \ud83d\udcac  ::debug::isExplicit: 3.9.6\n[CI/Django main [ok to fail]-2]   \ud83d\udcac  ::debug::explicit? true\n[CI/Django main [ok to fail]-2]   \ud83d\udcac  ::debug::evaluating 6 versions\n[CI/Django main [ok to fail]-2]   \ud83d\udcac  ::debug::match not found\n[CI/Django main [ok to fail]-2]   | Version 3.10 was not found in the local cache\n[CI/Django main [ok to fail]-2]   \ud83d\udcac  ::debug::Getting manifest from actions/python-versions@main\n[CI/Python 3.7-1              ]   \u2705  Success - Main Setup python\n[CI/Django main [ok to fail]-2]   \u2757  ::error::API rate limit exceeded for 130.242.72.40. (But here's the good news: Authenticated requests get a higher rate limit. Check out the documentation for more details.)\n[CI/Django main [ok to fail]-2]   \u274c  Failure - Main Setup python\n[CI/lint                      ]   \u2757  ::error::API rate limit exceeded for 130.242.72.40. (But here's the good news: Authenticated requests get a higher rate limit. Check out the documentation for more details.)\n[CI/lint                      ]   \u274c  Failure - Main Set up Python 3.10\n[CI/Python 3.7-1              ]   \u2699  ::set-env:: PKG_CONFIG_PATH=/opt/hostedtoolcache/Python/3.7.11/x64/lib/pkgconfig\n[CI/Python 3.7-1              ]   \u2699  ::set-env:: Python_ROOT_DIR=/opt/hostedtoolcache/Python/3.7.11/x64\n[CI/Python 3.7-1              ]   \u2699  ::set-env:: Python2_ROOT_DIR=/opt/hostedtoolcache/Python/3.7.11/x64\n[CI/Python 3.7-1              ]   \u2699  ::set-env:: Python3_ROOT_DIR=/opt/hostedtoolcache/Python/3.7.11/x64\n[CI/Python 3.7-1              ]   \u2699  ::set-env:: LD_LIBRARY_PATH=/opt/hostedtoolcache/Python/3.7.11/x64/lib\n[CI/Python 3.7-1              ]   \u2699  ::set-env:: pythonLocation=/opt/hostedtoolcache/Python/3.7.11/x64\n[CI/Python 3.7-1              ]   \u2699  ::set-output:: python-version=3.7.11\n[CI/Python 3.7-1              ]   \u2699  ::set-output:: python-path=/opt/hostedtoolcache/Python/3.7.11/x64/bin/python\n[CI/Django main [ok to fail]-2] exitcode '1': failure\n[CI/Python 3.7-1              ]   \u2699  ::add-path:: /opt/hostedtoolcache/Python/3.7.11/x64\n[CI/Python 3.7-1              ]   \u2699  ::add-path:: /opt/hostedtoolcache/Python/3.7.11/x64/bin\n[CI/lint                      ] exitcode '1': failure\n[CI/Python 3.7-1              ] \u2b50 Run Main Install Dependencies\n[CI/Python 3.7-1              ]   \ud83d\udc33  docker exec cmd=[bash --noprofile --norc -e -o pipefail /var/run/act/workflow/2] user= workdir=\n[CI/lint                      ] \ud83c\udfc1  Job failed\n[CI/Django main [ok to fail]-2] \ud83c\udfc1  Job failed\n[CI/Python 3.7-1              ]   | Collecting tox\n[CI/Python 3.7-1              ]   |   Downloading tox-4.5.2-py3-none-any.whl (148 kB)\n[CI/Python 3.7-1              ]   | Collecting tox-gh-actions\n[CI/Python 3.7-1              ]   |   Downloading tox_gh_actions-3.1.1-py2.py3-none-any.whl (9.8 kB)\n[CI/Python 3.7-1              ]   | Collecting filelock>=3.12\n[CI/Python 3.7-1              ]   |   Downloading filelock-3.12.0-py3-none-any.whl (10 kB)\n[CI/Python 3.7-1              ]   | Collecting tomli>=2.0.1\n[CI/Python 3.7-1              ]   |   Downloading tomli-2.0.1-py3-none-any.whl (12 kB)\n[CI/Python 3.7-1              ]   | Collecting virtualenv>=20.23\n[CI/Python 3.7-1              ]   |   Downloading virtualenv-20.23.0-py3-none-any.whl (3.3 MB)\n[CI/Python 3.7-1              ]   | Collecting colorama>=0.4.6\n[CI/Python 3.7-1              ]   |   Downloading colorama-0.4.6-py2.py3-none-any.whl (25 kB)\n[CI/Python 3.7-1              ]   | Collecting cachetools>=5.3\n[CI/Python 3.7-1              ]   |   Downloading cachetools-5.3.1-py3-none-any.whl (9.3 kB)\n[CI/Python 3.7-1              ]   | Collecting chardet>=5.1\n[CI/Python 3.7-1              ]   |   Downloading chardet-5.1.0-py3-none-any.whl (199 kB)\n[CI/Python 3.7-1              ]   | Collecting importlib-metadata>=6.6\n[CI/Python 3.7-1              ]   |   Downloading importlib_metadata-6.6.0-py3-none-any.whl (22 kB)\n[CI/Python 3.7-1              ]   | Collecting platformdirs>=3.5.1\n[CI/Python 3.7-1              ]   |   Downloading platformdirs-3.5.1-py3-none-any.whl (15 kB)\n[CI/Python 3.7-1              ]   | Collecting pluggy>=1\n[CI/Python 3.7-1              ]   |   Downloading pluggy-1.0.0-py2.py3-none-any.whl (13 kB)\n[CI/Python 3.7-1              ]   | Collecting pyproject-api>=1.5.1\n[CI/Python 3.7-1              ]   |   Downloading pyproject_api-1.5.1-py3-none-any.whl (12 kB)\n[CI/Python 3.7-1              ]   | Collecting typing-extensions>=4.6.2\n[CI/Python 3.7-1              ]   |   Downloading typing_extensions-4.6.2-py3-none-any.whl (31 kB)\n[CI/Python 3.7-1              ]   | Collecting packaging>=23.1\n[CI/Python 3.7-1              ]   |   Downloading packaging-23.1-py3-none-any.whl (48 kB)\n[CI/Python 3.7-1              ]   | Collecting zipp>=0.5\n[CI/Python 3.7-1              ]   |   Downloading zipp-3.15.0-py3-none-any.whl (6.8 kB)\n[CI/Python 3.7-1              ]   | Collecting distlib<1,>=0.3.6\n[CI/Python 3.7-1              ]   |   Downloading distlib-0.3.6-py2.py3-none-any.whl (468 kB)\n[CI/Python 3.7-1              ]   | Installing collected packages: zipp, typing-extensions, tomli, platformdirs, packaging, importlib-metadata, filelock, distlib, virtualenv, pyproject-api, pluggy, colorama, chardet, cachetools, tox, tox-gh-actions\n[CI/Python 3.7-1              ]   | Successfully installed cachetools-5.3.1 chardet-5.1.0 colorama-0.4.6 distlib-0.3.6 filelock-3.12.0 importlib-metadata-6.6.0 packaging-23.1 platformdirs-3.5.1 pluggy-1.0.0 pyproject-api-1.5.1 tomli-2.0.1 tox-4.5.2 tox-gh-actions-3.1.1 typing-extensions-4.6.2 virtualenv-20.23.0 zipp-3.15.0\n[CI/Python 3.7-1              ]   | WARNING: You are using pip version 21.2.4; however, version 23.1.2 is available.\n[CI/Python 3.7-1              ]   | You should consider upgrading via the '/opt/hostedtoolcache/Python/3.7.11/x64/bin/python -m pip install --upgrade pip' command.\n[CI/Python 3.7-1              ]   \u2705  Success - Main Install Dependencies\n[CI/Python 3.7-1              ] \u2b50 Run Main Run tests\n[CI/Python 3.7-1              ]   \ud83d\udc33  docker exec cmd=[bash --noprofile --norc -e -o pipefail /var/run/act/workflow/3] user= workdir=\n[CI/Python 3.7-1              ]   | ROOT: tox-gh-actions couldn't understand the parallel option. ignoring the given option: 0\n[CI/Python 3.7-1              ]   | py37-dj32: install_deps> python -I -m pip install before_after==1.0.0 dill 'Django<3.3,>=3.2' 'jinja2>=2.10' mysqlclient psycopg2-binary pytest pytest-django\n[CI/Python 3.7-1              ]   | .pkg: install_requires> python -I -m pip install 'setuptools>=40.8.0' wheel\n[CI/Python 3.7-1              ]   | .pkg: _optional_hooks> python /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/site-packages/pyproject_api/_backend.py True setuptools.build_meta __legacy__\n[CI/Python 3.7-1              ]   | .pkg: get_requires_for_build_sdist> python /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/site-packages/pyproject_api/_backend.py True setuptools.build_meta __legacy__\n[CI/Python 3.7-1              ]   | .pkg: freeze> python -m pip freeze --all\n[CI/Python 3.7-1              ]   | .pkg: pip==23.1.2,setuptools==67.7.2,wheel==0.40.0\n[CI/Python 3.7-1              ]   | .pkg: prepare_metadata_for_build_wheel> python /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/site-packages/pyproject_api/_backend.py True setuptools.build_meta __legacy__\n[CI/Python 3.7-1              ]   | .pkg: build_sdist> python /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/site-packages/pyproject_api/_backend.py True setuptools.build_meta __legacy__\n[CI/Python 3.7-1              ]   | py37-dj32: install_package_deps> python -I -m pip install 'django>=3.2' 'funcy<3.0,>=1.8' 'redis>=3.0.0'\n[CI/Python 3.7-1              ]   | py37-dj32: install_package> python -I -m pip install --force-reinstall --no-deps /tmp/de65f406-fe28-11ed-a890-af2cc187fc11/Suor-django-cacheops/.tox/.tmp/package/1/django-cacheops-7.0.1.tar.gz\n[CI/Python 3.7-1              ]   | py37-dj32: freeze> python -m pip freeze --all\n[CI/Python 3.7-1              ]   | py37-dj32: asgiref==3.7.2,async-timeout==4.0.2,before-after==1.0.0,dill==0.3.6,Django==3.2.19,django-cacheops @ file:///tmp/de65f406-fe28-11ed-a890-af2cc187fc11/Suor-django-cacheops/.tox/.tmp/package/1/django-cacheops-7.0.1.tar.gz#sha256=b3186042ae82eaf429fbf0283e3c8f1be5340dedfdbf34e8957be837f89d367d,exceptiongroup==1.1.1,funcy==2.0,importlib-metadata==6.6.0,iniconfig==2.0.0,Jinja2==3.1.2,MarkupSafe==2.1.2,mock==1.0.1,mysqlclient==2.1.1,packaging==23.1,pip==23.1.2,pluggy==1.0.0,psycopg2-binary==2.9.6,pytest==7.3.1,pytest-django==4.5.2,pytz==2023.3,redis==4.5.5,setuptools==67.7.2,sqlparse==0.4.4,tomli==2.0.1,typing_extensions==4.6.2,wheel==0.40.0,zipp==3.15.0\n[CI/Python 3.7-1              ]   | py37-dj32: tox-gh-actions couldn't understand the parallel option. ignoring the given option: 0\n[CI/Python 3.7-1              ]   \u2753  ::group::tox: py37-dj32\n[CI/Python 3.7-1              ]   | py37-dj32: commands[0]> pytest\n[CI/Python 3.7-1              ]   | ============================= test session starts ==============================\n[CI/Python 3.7-1              ]   | platform linux -- Python 3.7.11, pytest-7.3.1, pluggy-1.0.0\n[CI/Python 3.7-1              ]   | cachedir: .tox/py37-dj32/.pytest_cache\n[CI/Python 3.7-1              ]   | django: settings: tests.settings (from ini)\n[CI/Python 3.7-1              ]   | rootdir: /tmp/de65f406-fe28-11ed-a890-af2cc187fc11/Suor-django-cacheops\n[CI/Python 3.7-1              ]   | configfile: pytest.ini\n[CI/Python 3.7-1              ]   | plugins: django-4.5.2\n[CI/Python 3.7-1              ]   | collected 158 items\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/test_extras.py ...FFFFFFFFFFFF                                     [  9%]\n[CI/Python 3.7-1              ]   | tests/tests.py FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFsssFFFFFFFFFFFFFF [ 45%]\n[CI/Python 3.7-1              ]   | FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFsFFFFF  [ 90%]\n[CI/Python 3.7-1              ]   | tests/tests_sharding.py FFFFFF                                           [ 94%]\n[CI/Python 3.7-1              ]   | tests/tests_transactions.py FFFFFFFF                                     [ 99%]\n[CI/Python 3.7-1              ]   | tests/test_extras.py .                                                   [100%]\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | =================================== FAILURES ===================================\n[CI/Python 3.7-1              ]   | _________________________ SignalsTests.test_cached_as __________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab4a9bd40>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab4a9b0e0>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.test_extras.SignalsTests testMethod=test_cached_as>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   | >       super(SignalsTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/test_extras.py:32: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ____________________ SignalsTests.test_invalidation_signal _____________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab35217a0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3521830>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.test_extras.SignalsTests testMethod=test_invalidation_signal>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   | >       super(SignalsTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/test_extras.py:32: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | __________________________ SignalsTests.test_queryset __________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3904ef0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab394d050>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.test_extras.SignalsTests testMethod=test_queryset>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   | >       super(SignalsTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/test_extras.py:32: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _______________________ SignalsTests.test_queryset_empty _______________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab394d5f0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab394d680>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.test_extras.SignalsTests testMethod=test_queryset_empty>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   | >       super(SignalsTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/test_extras.py:32: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ____________________________ LockingTests.test_lock ____________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab394d9e0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab394da70>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ___________________ NoInvalidationTests.test_context_manager ___________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3954f80>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3c5f050>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ______________________ NoInvalidationTests.test_decorator ______________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3c5f710>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3c5f7a0>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ___________________ NoInvalidationTests.test_in_transaction ____________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3c5fb90>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3c5fc20>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _______________________ NoInvalidationTests.test_nested ________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3c5f050>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3c5fd40>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ______________________ LocalGetTests.test_unhashable_args ______________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3c5f440>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3c5fb00>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.test_extras.LocalGetTests testMethod=test_unhashable_args>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         Local.objects.create(pk=1)\n[CI/Python 3.7-1              ]   | >       super(LocalGetTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/test_extras.py:166: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _________________ DbAgnosticTests.test_db_agnostic_by_default __________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3c14ef0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3c14f80>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | __________________ DbAgnosticTests.test_db_agnostic_disabled ___________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3c5f710>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3c5f050>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _________________________ BasicTests.test_bulk_create __________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3c12200>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3c12290>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ___________________________ BasicTests.test_combine ____________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3c12830>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3c128c0>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | __________________________ BasicTests.test_db_column ___________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3c124d0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3c125f0>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ____________________________ BasicTests.test_empty _____________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3c12710>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3c129e0>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ____________________________ BasicTests.test_exact _____________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3c12e60>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3c12170>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ____________________________ BasicTests.test_exists ____________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38e58c0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38e5950>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _________________________ BasicTests.test_expressions __________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3c12290>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3c12950>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _______________________ BasicTests.test_expressions_save _______________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38e5440>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38e54d0>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ________________________ BasicTests.test_first_and_last ________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38e5f80>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38e53b0>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _______________________ BasicTests.test_fk_to_db_column ________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab344f710>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab344f8c0>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ___________________________ BasicTests.test_granular ___________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38e5440>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38e5680>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ____________________ BasicTests.test_invalidate_by_boolean _____________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab344f050>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab344f950>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | __________________ BasicTests.test_invalidate_by_foreign_key ___________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab344ff80>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab344f9e0>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ___________________ BasicTests.test_invalidate_by_one_to_one ___________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab344fe60>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab344fef0>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ______________________ BasicTests.test_invalidated_update ______________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38f3dd0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38f3050>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _________________________ BasicTests.test_invalidation _________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab344f200>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38f3e60>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ___________________________ BasicTests.test_it_works ___________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38f3b90>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38f3c20>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ____________________________ BasicTests.test_rawsql ____________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38f3290>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38f38c0>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _____________________________ BasicTests.test_some _____________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab345ba70>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab345bb00>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ___________________________ BasicTests.test_subquery ___________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab345b440>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab345bc20>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ____________________________ BasicTests.test_union _____________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38f3050>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38f39e0>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _____________________ ValuesTests.test_it_varies_on_class ______________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab344f320>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab344fb90>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ______________________ ValuesTests.test_it_varies_on_flat ______________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab345bef0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab345b0e0>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | __________________________ ValuesTests.test_it_works ___________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38f3950>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38f3290>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ______________________ DecoratorTests.test_cached_as_cond ______________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3c5f0e0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab345bf80>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ________________ DecoratorTests.test_cached_as_depends_on_args _________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab345bd40>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab345b5f0>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _____________ DecoratorTests.test_cached_as_depends_on_two_models ______________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38f3950>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab345b0e0>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ___________________ DecoratorTests.test_cached_as_keep_fresh ___________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab345b4d0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab345b320>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _____________________ DecoratorTests.test_cached_as_model ______________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38cd7a0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38cd830>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ______________________ DecoratorTests.test_cached_as_obj _______________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab345b5f0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab345bd40>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ______________________ DecoratorTests.test_cached_view_as ______________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38cddd0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38cd440>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _____________ DecoratorTests.test_cached_view_on_template_response _____________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38cd680>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38cdc20>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ____________________________ WeirdTests.test_binary ____________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38cddd0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38cd9e0>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ____________________________ WeirdTests.test_custom ____________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3c5fa70>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38cdb90>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _________________________ WeirdTests.test_custom_query _________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3b2d0e0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3b2d170>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _____________________________ WeirdTests.test_date _____________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38cdb90>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38cddd0>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ___________________________ WeirdTests.test_datetime ___________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3b2d290>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3b2dc20>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _____________________________ WeirdTests.test_list _____________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3b2d5f0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3b2d320>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _____________________________ WeirdTests.test_time _____________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3458b90>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3458c20>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _________________________ WeirdTests.test_weird_custom _________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3458440>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab34584d0>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | __________________________ TemplateTests.test_cached ___________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab34589e0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3458a70>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _________________________ TemplateTests.test_cached_as _________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3458cb0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3458050>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _______________________ TemplateTests.test_decorator_tag _______________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38b7950>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38b79e0>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ___________________ TemplateTests.test_decorator_tag_context ___________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3458dd0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3458b00>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ____________________ TemplateTests.test_invalidate_fragment ____________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38b7f80>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38b75f0>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | __________________________ TemplateTests.test_jinja2 ___________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3458710>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3458050>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _____________________________ IssueTests.test_114 ______________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3458dd0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3458cb0>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.IssueTests testMethod=test_114>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.user = User.objects.create(pk=1, username='Suor')\n[CI/Python 3.7-1              ]   |         Profile.objects.create(pk=2, user=self.user, tag=10)\n[CI/Python 3.7-1              ]   | >       super(IssueTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:451: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _____________________________ IssueTests.test_145 ______________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3ae99e0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3ae9a70>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.IssueTests testMethod=test_145>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.user = User.objects.create(pk=1, username='Suor')\n[CI/Python 3.7-1              ]   |         Profile.objects.create(pk=2, user=self.user, tag=10)\n[CI/Python 3.7-1              ]   | >       super(IssueTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:451: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _____________________________ IssueTests.test_159 ______________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3a5f320>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3ae9440>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.IssueTests testMethod=test_159>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.user = User.objects.create(pk=1, username='Suor')\n[CI/Python 3.7-1              ]   |         Profile.objects.create(pk=2, user=self.user, tag=10)\n[CI/Python 3.7-1              ]   | >       super(IssueTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:451: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ______________________________ IssueTests.test_16 ______________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3ae9950>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3ae9e60>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.IssueTests testMethod=test_16>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.user = User.objects.create(pk=1, username='Suor')\n[CI/Python 3.7-1              ]   |         Profile.objects.create(pk=2, user=self.user, tag=10)\n[CI/Python 3.7-1              ]   | >       super(IssueTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:451: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _____________________________ IssueTests.test_161 ______________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3ae95f0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3ae9440>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.IssueTests testMethod=test_161>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.user = User.objects.create(pk=1, username='Suor')\n[CI/Python 3.7-1              ]   |         Profile.objects.create(pk=2, user=self.user, tag=10)\n[CI/Python 3.7-1              ]   | >       super(IssueTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:451: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ________________________ IssueTests.test_161_non_ascii _________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38b09e0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38b0a70>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.IssueTests testMethod=test_161_non_ascii>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.user = User.objects.create(pk=1, username='Suor')\n[CI/Python 3.7-1              ]   |         Profile.objects.create(pk=2, user=self.user, tag=10)\n[CI/Python 3.7-1              ]   | >       super(IssueTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:451: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _____________________________ IssueTests.test_169 ______________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3ae9c20>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38b05f0>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.IssueTests testMethod=test_169>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.user = User.objects.create(pk=1, username='Suor')\n[CI/Python 3.7-1              ]   |         Profile.objects.create(pk=2, user=self.user, tag=10)\n[CI/Python 3.7-1              ]   | >       super(IssueTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:451: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _____________________________ IssueTests.test_173 ______________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38b0f80>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38b0320>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.IssueTests testMethod=test_173>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.user = User.objects.create(pk=1, username='Suor')\n[CI/Python 3.7-1              ]   |         Profile.objects.create(pk=2, user=self.user, tag=10)\n[CI/Python 3.7-1              ]   | >       super(IssueTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:451: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _____________________________ IssueTests.test_177 ______________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38b0a70>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3ae95f0>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.IssueTests testMethod=test_177>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.user = User.objects.create(pk=1, username='Suor')\n[CI/Python 3.7-1              ]   |         Profile.objects.create(pk=2, user=self.user, tag=10)\n[CI/Python 3.7-1              ]   | >       super(IssueTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:451: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _____________________________ IssueTests.test_217 ______________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38b05f0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38b0c20>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.IssueTests testMethod=test_217>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.user = User.objects.create(pk=1, username='Suor')\n[CI/Python 3.7-1              ]   |         Profile.objects.create(pk=2, user=self.user, tag=10)\n[CI/Python 3.7-1              ]   | >       super(IssueTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:451: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _____________________________ IssueTests.test_232 ______________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38df950>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38df9e0>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.IssueTests testMethod=test_232>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.user = User.objects.create(pk=1, username='Suor')\n[CI/Python 3.7-1              ]   |         Profile.objects.create(pk=2, user=self.user, tag=10)\n[CI/Python 3.7-1              ]   | >       super(IssueTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:451: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _____________________________ IssueTests.test_265 ______________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38df0e0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38df710>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.IssueTests testMethod=test_265>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.user = User.objects.create(pk=1, username='Suor')\n[CI/Python 3.7-1              ]   |         Profile.objects.create(pk=2, user=self.user, tag=10)\n[CI/Python 3.7-1              ]   | >       super(IssueTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:451: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ______________________________ IssueTests.test_29 ______________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38df290>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38df830>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.IssueTests testMethod=test_29>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.user = User.objects.create(pk=1, username='Suor')\n[CI/Python 3.7-1              ]   |         Profile.objects.create(pk=2, user=self.user, tag=10)\n[CI/Python 3.7-1              ]   | >       super(IssueTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:451: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _____________________________ IssueTests.test_312 ______________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab33ca8c0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab33ca950>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.IssueTests testMethod=test_312>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.user = User.objects.create(pk=1, username='Suor')\n[CI/Python 3.7-1              ]   |         Profile.objects.create(pk=2, user=self.user, tag=10)\n[CI/Python 3.7-1              ]   | >       super(IssueTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:451: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _____________________________ IssueTests.test_316 ______________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38df0e0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38dfc20>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.IssueTests testMethod=test_316>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.user = User.objects.create(pk=1, username='Suor')\n[CI/Python 3.7-1              ]   |         Profile.objects.create(pk=2, user=self.user, tag=10)\n[CI/Python 3.7-1              ]   | >       super(IssueTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:451: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _____________________________ IssueTests.test_348 ______________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab33ca5f0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab33cac20>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.IssueTests testMethod=test_348>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.user = User.objects.create(pk=1, username='Suor')\n[CI/Python 3.7-1              ]   |         Profile.objects.create(pk=2, user=self.user, tag=10)\n[CI/Python 3.7-1              ]   | >       super(IssueTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:451: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _____________________________ IssueTests.test_352 ______________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab33ca560>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab33cae60>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.IssueTests testMethod=test_352>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.user = User.objects.create(pk=1, username='Suor')\n[CI/Python 3.7-1              ]   |         Profile.objects.create(pk=2, user=self.user, tag=10)\n[CI/Python 3.7-1              ]   | >       super(IssueTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:451: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _____________________________ IssueTests.test_353 ______________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab33ca290>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab33cab90>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.IssueTests testMethod=test_353>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.user = User.objects.create(pk=1, username='Suor')\n[CI/Python 3.7-1              ]   |         Profile.objects.create(pk=2, user=self.user, tag=10)\n[CI/Python 3.7-1              ]   | >       super(IssueTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:451: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _____________________________ IssueTests.test_359 ______________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab33caef0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab33cae60>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.IssueTests testMethod=test_359>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.user = User.objects.create(pk=1, username='Suor')\n[CI/Python 3.7-1              ]   |         Profile.objects.create(pk=2, user=self.user, tag=10)\n[CI/Python 3.7-1              ]   | >       super(IssueTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:451: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _____________________________ IssueTests.test_365 ______________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab32e2950>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab32e29e0>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.IssueTests testMethod=test_365>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.user = User.objects.create(pk=1, username='Suor')\n[CI/Python 3.7-1              ]   |         Profile.objects.create(pk=2, user=self.user, tag=10)\n[CI/Python 3.7-1              ]   | >       super(IssueTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:451: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _____________________________ IssueTests.test_385 ______________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab32e20e0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab32e2830>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.IssueTests testMethod=test_385>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.user = User.objects.create(pk=1, username='Suor')\n[CI/Python 3.7-1              ]   |         Profile.objects.create(pk=2, user=self.user, tag=10)\n[CI/Python 3.7-1              ]   | >       super(IssueTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:451: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _____________________________ IssueTests.test_387 ______________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab32e2050>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab33ca8c0>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.IssueTests testMethod=test_387>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.user = User.objects.create(pk=1, username='Suor')\n[CI/Python 3.7-1              ]   |         Profile.objects.create(pk=2, user=self.user, tag=10)\n[CI/Python 3.7-1              ]   | >       super(IssueTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:451: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _____________________________ IssueTests.test_407 ______________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab33ca9e0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab33ca4d0>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.IssueTests testMethod=test_407>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.user = User.objects.create(pk=1, username='Suor')\n[CI/Python 3.7-1              ]   |         Profile.objects.create(pk=2, user=self.user, tag=10)\n[CI/Python 3.7-1              ]   | >       super(IssueTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:451: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _________________________ IssueTests.test_407_reverse __________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab39b9a70>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab39b9b00>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.IssueTests testMethod=test_407_reverse>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.user = User.objects.create(pk=1, username='Suor')\n[CI/Python 3.7-1              ]   |         Profile.objects.create(pk=2, user=self.user, tag=10)\n[CI/Python 3.7-1              ]   | >       super(IssueTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:451: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _____________________________ IssueTests.test_430 ______________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab39b9e60>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab39b9c20>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.IssueTests testMethod=test_430>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.user = User.objects.create(pk=1, username='Suor')\n[CI/Python 3.7-1              ]   |         Profile.objects.create(pk=2, user=self.user, tag=10)\n[CI/Python 3.7-1              ]   | >       super(IssueTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:451: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _____________________ IssueTests.test_430_no_error_raises ______________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab39b9cb0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab39b9b90>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.IssueTests testMethod=test_430_no_error_raises>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.user = User.objects.create(pk=1, username='Suor')\n[CI/Python 3.7-1              ]   |         Profile.objects.create(pk=2, user=self.user, tag=10)\n[CI/Python 3.7-1              ]   | >       super(IssueTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:451: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ______________________________ IssueTests.test_45 ______________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab33cad40>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab33cae60>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.IssueTests testMethod=test_45>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.user = User.objects.create(pk=1, username='Suor')\n[CI/Python 3.7-1              ]   |         Profile.objects.create(pk=2, user=self.user, tag=10)\n[CI/Python 3.7-1              ]   | >       super(IssueTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:451: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ______________________________ IssueTests.test_57 ______________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab33ca8c0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab33ca560>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.IssueTests testMethod=test_57>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.user = User.objects.create(pk=1, username='Suor')\n[CI/Python 3.7-1              ]   |         Profile.objects.create(pk=2, user=self.user, tag=10)\n[CI/Python 3.7-1              ]   | >       super(IssueTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:451: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ____________________ RelatedTests.test_related_invalidation ____________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3a5f5f0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3a5f560>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _________________________ RelatedTests.test_reverse_fk _________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3a5f440>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3a5f710>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ______________________ RelatedTests.test_reverse_fk_same _______________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab33ca4d0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab33cab90>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ____________________ RelatedTests.test_reverse_fk_separate _____________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab39b9830>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3a5fe60>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _______________________ AggregationTests.test_aggregate ________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38df8c0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38dfc20>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ___________________ AggregationTests.test_aggregate_granular ___________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3a5f5f0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3a5f050>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ________________________ AggregationTests.test_annotate ________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab33caa70>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab33ca8c0>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _________________________ AggregationTests.test_filter _________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3a5fe60>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3a5f5f0>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _______________________ AggregationTests.test_new_alias ________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab384a680>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab384a0e0>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ____________________ M2MTests.test_base_invalidates_on_add _____________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3b2dc20>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab384ab90>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.M2MTests testMethod=test_base_invalidates_on_add>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.bf = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |         self.bs = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.fast = self.label_cls.objects.create(text='fast')\n[CI/Python 3.7-1              ]   |         self.slow = self.label_cls.objects.create(text='slow')\n[CI/Python 3.7-1              ]   |         self.furious = self.label_cls.objects.create(text='furios')\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.setup_m2m()\n[CI/Python 3.7-1              ]   | >       super(M2MTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:821: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ___________________ M2MTests.test_base_invalidates_on_clear ____________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3862440>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3862830>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.M2MTests testMethod=test_base_invalidates_on_clear>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.bf = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |         self.bs = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.fast = self.label_cls.objects.create(text='fast')\n[CI/Python 3.7-1              ]   |         self.slow = self.label_cls.objects.create(text='slow')\n[CI/Python 3.7-1              ]   |         self.furious = self.label_cls.objects.create(text='furios')\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.setup_m2m()\n[CI/Python 3.7-1              ]   | >       super(M2MTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:821: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ___________________ M2MTests.test_base_invalidates_on_remove ___________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab384ac20>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3862d40>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.M2MTests testMethod=test_base_invalidates_on_remove>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.bf = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |         self.bs = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.fast = self.label_cls.objects.create(text='fast')\n[CI/Python 3.7-1              ]   |         self.slow = self.label_cls.objects.create(text='slow')\n[CI/Python 3.7-1              ]   |         self.furious = self.label_cls.objects.create(text='furios')\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.setup_m2m()\n[CI/Python 3.7-1              ]   | >       super(M2MTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:821: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ____________________ M2MTests.test_granular_target_on_clear ____________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38df290>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3862c20>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.M2MTests testMethod=test_granular_target_on_clear>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.bf = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |         self.bs = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.fast = self.label_cls.objects.create(text='fast')\n[CI/Python 3.7-1              ]   |         self.slow = self.label_cls.objects.create(text='slow')\n[CI/Python 3.7-1              ]   |         self.furious = self.label_cls.objects.create(text='furios')\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.setup_m2m()\n[CI/Python 3.7-1              ]   | >       super(M2MTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:821: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ___________________ M2MTests.test_granular_through_on_clear ____________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab371b050>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab371bc20>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.M2MTests testMethod=test_granular_through_on_clear>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.bf = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |         self.bs = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.fast = self.label_cls.objects.create(text='fast')\n[CI/Python 3.7-1              ]   |         self.slow = self.label_cls.objects.create(text='slow')\n[CI/Python 3.7-1              ]   |         self.furious = self.label_cls.objects.create(text='furios')\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.setup_m2m()\n[CI/Python 3.7-1              ]   | >       super(M2MTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:821: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ___________________ M2MTests.test_target_invalidates_on_add ____________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab384a170>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3862cb0>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.M2MTests testMethod=test_target_invalidates_on_add>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.bf = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |         self.bs = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.fast = self.label_cls.objects.create(text='fast')\n[CI/Python 3.7-1              ]   |         self.slow = self.label_cls.objects.create(text='slow')\n[CI/Python 3.7-1              ]   |         self.furious = self.label_cls.objects.create(text='furios')\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.setup_m2m()\n[CI/Python 3.7-1              ]   | >       super(M2MTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:821: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | __________________ M2MTests.test_target_invalidates_on_clear ___________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38df290>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab371b4d0>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.M2MTests testMethod=test_target_invalidates_on_clear>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.bf = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |         self.bs = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.fast = self.label_cls.objects.create(text='fast')\n[CI/Python 3.7-1              ]   |         self.slow = self.label_cls.objects.create(text='slow')\n[CI/Python 3.7-1              ]   |         self.furious = self.label_cls.objects.create(text='furios')\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.setup_m2m()\n[CI/Python 3.7-1              ]   | >       super(M2MTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:821: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | __________________ M2MTests.test_target_invalidates_on_remove __________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab371b050>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab371ba70>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.M2MTests testMethod=test_target_invalidates_on_remove>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.bf = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |         self.bs = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.fast = self.label_cls.objects.create(text='fast')\n[CI/Python 3.7-1              ]   |         self.slow = self.label_cls.objects.create(text='slow')\n[CI/Python 3.7-1              ]   |         self.furious = self.label_cls.objects.create(text='furios')\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.setup_m2m()\n[CI/Python 3.7-1              ]   | >       super(M2MTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:821: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ________ MultiTableInheritanceWithM2MTest.test_base_invalidates_on_add _________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab371bd40>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab371b200>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.MultiTableInheritanceWithM2MTest testMethod=test_base_invalidates_on_add>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.bf = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |         self.bs = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.fast = self.label_cls.objects.create(text='fast')\n[CI/Python 3.7-1              ]   |         self.slow = self.label_cls.objects.create(text='slow')\n[CI/Python 3.7-1              ]   |         self.furious = self.label_cls.objects.create(text='furios')\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.setup_m2m()\n[CI/Python 3.7-1              ]   | >       super(M2MTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:821: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _______ MultiTableInheritanceWithM2MTest.test_base_invalidates_on_clear ________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab371b050>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab38df290>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.MultiTableInheritanceWithM2MTest testMethod=test_base_invalidates_on_clear>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.bf = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |         self.bs = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.fast = self.label_cls.objects.create(text='fast')\n[CI/Python 3.7-1              ]   |         self.slow = self.label_cls.objects.create(text='slow')\n[CI/Python 3.7-1              ]   |         self.furious = self.label_cls.objects.create(text='furios')\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.setup_m2m()\n[CI/Python 3.7-1              ]   | >       super(M2MTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:821: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _______ MultiTableInheritanceWithM2MTest.test_base_invalidates_on_remove _______\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3718ef0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3718440>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.MultiTableInheritanceWithM2MTest testMethod=test_base_invalidates_on_remove>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.bf = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |         self.bs = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.fast = self.label_cls.objects.create(text='fast')\n[CI/Python 3.7-1              ]   |         self.slow = self.label_cls.objects.create(text='slow')\n[CI/Python 3.7-1              ]   |         self.furious = self.label_cls.objects.create(text='furios')\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.setup_m2m()\n[CI/Python 3.7-1              ]   | >       super(M2MTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:821: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ________ MultiTableInheritanceWithM2MTest.test_granular_target_on_clear ________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab371ba70>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3718c20>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.MultiTableInheritanceWithM2MTest testMethod=test_granular_target_on_clear>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.bf = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |         self.bs = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.fast = self.label_cls.objects.create(text='fast')\n[CI/Python 3.7-1              ]   |         self.slow = self.label_cls.objects.create(text='slow')\n[CI/Python 3.7-1              ]   |         self.furious = self.label_cls.objects.create(text='furios')\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.setup_m2m()\n[CI/Python 3.7-1              ]   | >       super(M2MTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:821: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _______ MultiTableInheritanceWithM2MTest.test_granular_through_on_clear ________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3259830>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab32599e0>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.MultiTableInheritanceWithM2MTest testMethod=test_granular_through_on_clear>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.bf = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |         self.bs = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.fast = self.label_cls.objects.create(text='fast')\n[CI/Python 3.7-1              ]   |         self.slow = self.label_cls.objects.create(text='slow')\n[CI/Python 3.7-1              ]   |         self.furious = self.label_cls.objects.create(text='furios')\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.setup_m2m()\n[CI/Python 3.7-1              ]   | >       super(M2MTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:821: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _______ MultiTableInheritanceWithM2MTest.test_target_invalidates_on_add ________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab32593b0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3259c20>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.MultiTableInheritanceWithM2MTest testMethod=test_target_invalidates_on_add>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.bf = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |         self.bs = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.fast = self.label_cls.objects.create(text='fast')\n[CI/Python 3.7-1              ]   |         self.slow = self.label_cls.objects.create(text='slow')\n[CI/Python 3.7-1              ]   |         self.furious = self.label_cls.objects.create(text='furios')\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.setup_m2m()\n[CI/Python 3.7-1              ]   | >       super(M2MTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:821: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ______ MultiTableInheritanceWithM2MTest.test_target_invalidates_on_clear _______\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3259dd0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab37189e0>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.MultiTableInheritanceWithM2MTest testMethod=test_target_invalidates_on_clear>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.bf = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |         self.bs = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.fast = self.label_cls.objects.create(text='fast')\n[CI/Python 3.7-1              ]   |         self.slow = self.label_cls.objects.create(text='slow')\n[CI/Python 3.7-1              ]   |         self.furious = self.label_cls.objects.create(text='furios')\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.setup_m2m()\n[CI/Python 3.7-1              ]   | >       super(M2MTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:821: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ______ MultiTableInheritanceWithM2MTest.test_target_invalidates_on_remove ______\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab37187a0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3718170>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.MultiTableInheritanceWithM2MTest testMethod=test_target_invalidates_on_remove>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.bf = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |         self.bs = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.fast = self.label_cls.objects.create(text='fast')\n[CI/Python 3.7-1              ]   |         self.slow = self.label_cls.objects.create(text='slow')\n[CI/Python 3.7-1              ]   |         self.furious = self.label_cls.objects.create(text='furios')\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.setup_m2m()\n[CI/Python 3.7-1              ]   | >       super(M2MTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:821: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ________________ M2MThroughTests.test_base_invalidates_on_clear ________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3718d40>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab371b710>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.M2MThroughTests testMethod=test_base_invalidates_on_clear>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.bf = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |         self.bs = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.fast = self.label_cls.objects.create(text='fast')\n[CI/Python 3.7-1              ]   |         self.slow = self.label_cls.objects.create(text='slow')\n[CI/Python 3.7-1              ]   |         self.furious = self.label_cls.objects.create(text='furios')\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.setup_m2m()\n[CI/Python 3.7-1              ]   | >       super(M2MTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:821: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _______________ M2MThroughTests.test_base_invalidates_on_create ________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab32598c0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3259320>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.M2MThroughTests testMethod=test_base_invalidates_on_create>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.bf = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |         self.bs = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.fast = self.label_cls.objects.create(text='fast')\n[CI/Python 3.7-1              ]   |         self.slow = self.label_cls.objects.create(text='slow')\n[CI/Python 3.7-1              ]   |         self.furious = self.label_cls.objects.create(text='furios')\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.setup_m2m()\n[CI/Python 3.7-1              ]   | >       super(M2MTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:821: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _______________ M2MThroughTests.test_base_invalidates_on_delete ________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab371b200>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab37e88c0>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.M2MThroughTests testMethod=test_base_invalidates_on_delete>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.bf = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |         self.bs = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.fast = self.label_cls.objects.create(text='fast')\n[CI/Python 3.7-1              ]   |         self.slow = self.label_cls.objects.create(text='slow')\n[CI/Python 3.7-1              ]   |         self.furious = self.label_cls.objects.create(text='furios')\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.setup_m2m()\n[CI/Python 3.7-1              ]   | >       super(M2MTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:821: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ________________ M2MThroughTests.test_granular_target_on_clear _________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab37180e0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3259f80>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.M2MThroughTests testMethod=test_granular_target_on_clear>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.bf = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |         self.bs = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.fast = self.label_cls.objects.create(text='fast')\n[CI/Python 3.7-1              ]   |         self.slow = self.label_cls.objects.create(text='slow')\n[CI/Python 3.7-1              ]   |         self.furious = self.label_cls.objects.create(text='furios')\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.setup_m2m()\n[CI/Python 3.7-1              ]   | >       super(M2MTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:821: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ________________ M2MThroughTests.test_granular_through_on_clear ________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab32599e0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab37e8b00>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.M2MThroughTests testMethod=test_granular_through_on_clear>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.bf = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |         self.bs = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.fast = self.label_cls.objects.create(text='fast')\n[CI/Python 3.7-1              ]   |         self.slow = self.label_cls.objects.create(text='slow')\n[CI/Python 3.7-1              ]   |         self.furious = self.label_cls.objects.create(text='furios')\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.setup_m2m()\n[CI/Python 3.7-1              ]   | >       super(M2MTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:821: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _______________ M2MThroughTests.test_target_invalidates_on_clear _______________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab37185f0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab37e8320>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.M2MThroughTests testMethod=test_target_invalidates_on_clear>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.bf = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |         self.bs = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.fast = self.label_cls.objects.create(text='fast')\n[CI/Python 3.7-1              ]   |         self.slow = self.label_cls.objects.create(text='slow')\n[CI/Python 3.7-1              ]   |         self.furious = self.label_cls.objects.create(text='furios')\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.setup_m2m()\n[CI/Python 3.7-1              ]   | >       super(M2MTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:821: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ______________ M2MThroughTests.test_target_invalidates_on_create _______________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab37187a0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab33899e0>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.M2MThroughTests testMethod=test_target_invalidates_on_create>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.bf = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |         self.bs = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.fast = self.label_cls.objects.create(text='fast')\n[CI/Python 3.7-1              ]   |         self.slow = self.label_cls.objects.create(text='slow')\n[CI/Python 3.7-1              ]   |         self.furious = self.label_cls.objects.create(text='furios')\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.setup_m2m()\n[CI/Python 3.7-1              ]   | >       super(M2MTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:821: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ______________ M2MThroughTests.test_target_invalidates_on_delete _______________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab32599e0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3389f80>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests.M2MThroughTests testMethod=test_target_invalidates_on_delete>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def setUp(self):\n[CI/Python 3.7-1              ]   |         self.bf = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |         self.bs = self.brand_cls.objects.create()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.fast = self.label_cls.objects.create(text='fast')\n[CI/Python 3.7-1              ]   |         self.slow = self.label_cls.objects.create(text='slow')\n[CI/Python 3.7-1              ]   |         self.furious = self.label_cls.objects.create(text='furios')\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         self.setup_m2m()\n[CI/Python 3.7-1              ]   | >       super(M2MTests, self).setUp()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | tests/tests.py:821: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _____________ ProxyTests.test_148_invalidate_from_non_cached_proxy _____________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3259ef0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3718170>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _________________________ ProxyTests.test_148_reverse __________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab37e88c0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab37e87a0>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ______________________________ ProxyTests.test_30 ______________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3718560>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab37189e0>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _________________________ ProxyTests.test_30_reversed __________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3718ef0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3718290>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _________________________ ProxyTests.test_interchange __________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab37e9ef0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab37e9170>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ________________________ ProxyTests.test_proxy_caching _________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab37e9830>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab37e98c0>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ____________________ ProxyTests.test_proxy_caching_reversed ____________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab37e9dd0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab37e9e60>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ___________________________ ProxyTests.test_siblings ___________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab37e9cb0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab37e9d40>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _________________ MultitableInheritanceTests.test_base_changed _________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab333c9e0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab333ca70>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | __________________ MultitableInheritanceTests.test_sub_added ___________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab333cb90>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3389a70>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _________________________ SimpleCacheTests.test_cached _________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab33893b0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3389f80>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ______________________ SimpleCacheTests.test_cached_view _______________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab333c8c0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab333c830>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | __________________ MultiDBInvalidationTests.test_bulk_create ___________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab37bab00>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab37bab90>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _____________________ MultiDBInvalidationTests.test_delete _____________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab37ba4d0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab37bacb0>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _______________ MultiDBInvalidationTests.test_invalidated_update _______________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab37badd0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab37bac20>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | __________ MultiDBInvalidationTests.test_m2m_changed_call_invalidate ___________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab37ba9e0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab37c5680>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ______________________ MultiDBInvalidationTests.test_save ______________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab37c5710>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab37c5a70>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ___________________________ PrefixTests.test_context ___________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab37c5680>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab37c5830>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _____________________________ PrefixTests.test_db ______________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab325b7a0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab325b830>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ______________________ PrefixTests.test_self_join_tables _______________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab325bc20>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab325bd40>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ____________________________ PrefixTests.test_table ____________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab325ba70>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab37c5c20>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ________________________ PrefixTests.test_union_tables _________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab37c54d0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab37c5a70>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _________________________ SimpleCacheTests.test_prefix _________________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab36d83b0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab36d8440>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | tests/utils.py:16: in setUp\n[CI/Python 3.7-1              ]   |     invalidate_all()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:47: in wrapper\n[CI/Python 3.7-1              ]   |     return deco(call, *dargs, **dkwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:21: in skip_on_no_invalidation\n[CI/Python 3.7-1              ]   |     return call()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:80: in invalidate_all\n[CI/Python 3.7-1              ]   |     redis_client.flushdb()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:934: in flushdb\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"FLUSHDB\", *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _____________________ TransactionSupportTests.test_atomic ______________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | args = ('invalidate',), kwargs = {}, key = ('invalidate',)\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     @wraps(func)\n[CI/Python 3.7-1              ]   |     def wrapper(*args, **kwargs):\n[CI/Python 3.7-1              ]   |         # We inline this here since @memoize also targets microoptimizations\n[CI/Python 3.7-1              ]   |         key = key_func(*args, **kwargs) if key_func else \\\n[CI/Python 3.7-1              ]   |               args + tuple(sorted(kwargs.items())) if kwargs else args\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   | >           return memory[key]\n[CI/Python 3.7-1              ]   | E           KeyError: ('invalidate',)\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/calc.py:52: KeyError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | args = (), kwargs = {}, key = ()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     @wraps(func)\n[CI/Python 3.7-1              ]   |     def wrapper(*args, **kwargs):\n[CI/Python 3.7-1              ]   |         # We inline this here since @memoize also targets microoptimizations\n[CI/Python 3.7-1              ]   |         key = key_func(*args, **kwargs) if key_func else \\\n[CI/Python 3.7-1              ]   |               args + tuple(sorted(kwargs.items())) if kwargs else args\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   | >           return memory[key]\n[CI/Python 3.7-1              ]   | E           KeyError: ()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/calc.py:52: KeyError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab37c50e0>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab37c54d0>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests_transactions.TransactionSupportTests testMethod=test_atomic>\n[CI/Python 3.7-1              ]   | result = <TestCaseFunction test_atomic>, debug = False\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _setup_and_call(self, result, debug=False):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Perform the following in order: pre-setup, run test, post-teardown,\n[CI/Python 3.7-1              ]   |         skipping pre/post hooks if test is set to be skipped.\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         If debug=True, reraise any errors in setup and use super().debug()\n[CI/Python 3.7-1              ]   |         instead of __call__() to run the test.\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         testMethod = getattr(self, self._testMethodName)\n[CI/Python 3.7-1              ]   |         skipped = (\n[CI/Python 3.7-1              ]   |             getattr(self.__class__, \"__unittest_skip__\", False) or\n[CI/Python 3.7-1              ]   |             getattr(testMethod, \"__unittest_skip__\", False)\n[CI/Python 3.7-1              ]   |         )\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         # Convert async test methods.\n[CI/Python 3.7-1              ]   |         if asyncio.iscoroutinefunction(testMethod):\n[CI/Python 3.7-1              ]   |             setattr(self, self._testMethodName, async_to_sync(testMethod))\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if not skipped:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               self._pre_setup()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/test/testcases.py:272: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/test/testcases.py:935: in _pre_setup\n[CI/Python 3.7-1              ]   |     self._fixture_setup()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/test/testcases.py:993: in _fixture_setup\n[CI/Python 3.7-1              ]   |     **{'verbosity': 0, 'database': db_name})\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/core/management/__init__.py:181: in call_command\n[CI/Python 3.7-1              ]   |     return command.execute(*args, **defaults)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/core/management/base.py:398: in execute\n[CI/Python 3.7-1              ]   |     output = self.handle(*args, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/core/management/commands/loaddata.py:78: in handle\n[CI/Python 3.7-1              ]   |     self.loaddata(fixture_labels)\n[CI/Python 3.7-1              ]   | cacheops/transaction.py:77: in __exit__\n[CI/Python 3.7-1              ]   |     self._no_monkey.__exit__(self, exc_type, exc_value, traceback)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/db/transaction.py:290: in __exit__\n[CI/Python 3.7-1              ]   |     connection.set_autocommit(True)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/db/backends/base/base.py:420: in set_autocommit\n[CI/Python 3.7-1              ]   |     self.run_and_clear_commit_hooks()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/db/backends/base/base.py:653: in run_and_clear_commit_hooks\n[CI/Python 3.7-1              ]   |     func()\n[CI/Python 3.7-1              ]   | cacheops/transaction.py:30: in commit\n[CI/Python 3.7-1              ]   |     func(*args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:40: in invalidate_dict\n[CI/Python 3.7-1              ]   |     load_script(script)(keys=[prefix], args=[model._meta.db_table, serialized_dict])\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/calc.py:55: in wrapper\n[CI/Python 3.7-1              ]   |     value = memory[key] = func(*args, **kwargs)\n[CI/Python 3.7-1              ]   | cacheops/redis.py:65: in load_script\n[CI/Python 3.7-1              ]   |     if is_redis_7():\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/calc.py:55: in wrapper\n[CI/Python 3.7-1              ]   |     value = memory[key] = func(*args, **kwargs)\n[CI/Python 3.7-1              ]   | cacheops/redis.py:74: in is_redis_7\n[CI/Python 3.7-1              ]   |     redis_version = redis_client.info('server')['redis_version']\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:993: in info\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"INFO\", section, *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _____ TransactionSupportTests.test_call_cacheops_cbs_before_on_commit_cbs ______\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | args = ('invalidate',), kwargs = {}, key = ('invalidate',)\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     @wraps(func)\n[CI/Python 3.7-1              ]   |     def wrapper(*args, **kwargs):\n[CI/Python 3.7-1              ]   |         # We inline this here since @memoize also targets microoptimizations\n[CI/Python 3.7-1              ]   |         key = key_func(*args, **kwargs) if key_func else \\\n[CI/Python 3.7-1              ]   |               args + tuple(sorted(kwargs.items())) if kwargs else args\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   | >           return memory[key]\n[CI/Python 3.7-1              ]   | E           KeyError: ('invalidate',)\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/calc.py:52: KeyError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | args = (), kwargs = {}, key = ()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     @wraps(func)\n[CI/Python 3.7-1              ]   |     def wrapper(*args, **kwargs):\n[CI/Python 3.7-1              ]   |         # We inline this here since @memoize also targets microoptimizations\n[CI/Python 3.7-1              ]   |         key = key_func(*args, **kwargs) if key_func else \\\n[CI/Python 3.7-1              ]   |               args + tuple(sorted(kwargs.items())) if kwargs else args\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   | >           return memory[key]\n[CI/Python 3.7-1              ]   | E           KeyError: ()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/calc.py:52: KeyError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab320dc20>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab320dcb0>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests_transactions.TransactionSupportTests testMethod=test_call_cacheops_cbs_before_on_commit_cbs>\n[CI/Python 3.7-1              ]   | result = <TestCaseFunction test_call_cacheops_cbs_before_on_commit_cbs>\n[CI/Python 3.7-1              ]   | debug = False\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _setup_and_call(self, result, debug=False):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Perform the following in order: pre-setup, run test, post-teardown,\n[CI/Python 3.7-1              ]   |         skipping pre/post hooks if test is set to be skipped.\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         If debug=True, reraise any errors in setup and use super().debug()\n[CI/Python 3.7-1              ]   |         instead of __call__() to run the test.\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         testMethod = getattr(self, self._testMethodName)\n[CI/Python 3.7-1              ]   |         skipped = (\n[CI/Python 3.7-1              ]   |             getattr(self.__class__, \"__unittest_skip__\", False) or\n[CI/Python 3.7-1              ]   |             getattr(testMethod, \"__unittest_skip__\", False)\n[CI/Python 3.7-1              ]   |         )\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         # Convert async test methods.\n[CI/Python 3.7-1              ]   |         if asyncio.iscoroutinefunction(testMethod):\n[CI/Python 3.7-1              ]   |             setattr(self, self._testMethodName, async_to_sync(testMethod))\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if not skipped:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               self._pre_setup()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/test/testcases.py:272: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/test/testcases.py:935: in _pre_setup\n[CI/Python 3.7-1              ]   |     self._fixture_setup()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/test/testcases.py:993: in _fixture_setup\n[CI/Python 3.7-1              ]   |     **{'verbosity': 0, 'database': db_name})\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/core/management/__init__.py:181: in call_command\n[CI/Python 3.7-1              ]   |     return command.execute(*args, **defaults)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/core/management/base.py:398: in execute\n[CI/Python 3.7-1              ]   |     output = self.handle(*args, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/core/management/commands/loaddata.py:78: in handle\n[CI/Python 3.7-1              ]   |     self.loaddata(fixture_labels)\n[CI/Python 3.7-1              ]   | cacheops/transaction.py:77: in __exit__\n[CI/Python 3.7-1              ]   |     self._no_monkey.__exit__(self, exc_type, exc_value, traceback)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/db/transaction.py:290: in __exit__\n[CI/Python 3.7-1              ]   |     connection.set_autocommit(True)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/db/backends/base/base.py:420: in set_autocommit\n[CI/Python 3.7-1              ]   |     self.run_and_clear_commit_hooks()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/db/backends/base/base.py:653: in run_and_clear_commit_hooks\n[CI/Python 3.7-1              ]   |     func()\n[CI/Python 3.7-1              ]   | cacheops/transaction.py:30: in commit\n[CI/Python 3.7-1              ]   |     func(*args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:40: in invalidate_dict\n[CI/Python 3.7-1              ]   |     load_script(script)(keys=[prefix], args=[model._meta.db_table, serialized_dict])\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/calc.py:55: in wrapper\n[CI/Python 3.7-1              ]   |     value = memory[key] = func(*args, **kwargs)\n[CI/Python 3.7-1              ]   | cacheops/redis.py:65: in load_script\n[CI/Python 3.7-1              ]   |     if is_redis_7():\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/calc.py:55: in wrapper\n[CI/Python 3.7-1              ]   |     value = memory[key] = func(*args, **kwargs)\n[CI/Python 3.7-1              ]   | cacheops/redis.py:74: in is_redis_7\n[CI/Python 3.7-1              ]   |     redis_version = redis_client.info('server')['redis_version']\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:993: in info\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"INFO\", section, *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _____________________ TransactionSupportTests.test_multidb _____________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | args = ('invalidate',), kwargs = {}, key = ('invalidate',)\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     @wraps(func)\n[CI/Python 3.7-1              ]   |     def wrapper(*args, **kwargs):\n[CI/Python 3.7-1              ]   |         # We inline this here since @memoize also targets microoptimizations\n[CI/Python 3.7-1              ]   |         key = key_func(*args, **kwargs) if key_func else \\\n[CI/Python 3.7-1              ]   |               args + tuple(sorted(kwargs.items())) if kwargs else args\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   | >           return memory[key]\n[CI/Python 3.7-1              ]   | E           KeyError: ('invalidate',)\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/calc.py:52: KeyError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | args = (), kwargs = {}, key = ()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     @wraps(func)\n[CI/Python 3.7-1              ]   |     def wrapper(*args, **kwargs):\n[CI/Python 3.7-1              ]   |         # We inline this here since @memoize also targets microoptimizations\n[CI/Python 3.7-1              ]   |         key = key_func(*args, **kwargs) if key_func else \\\n[CI/Python 3.7-1              ]   |               args + tuple(sorted(kwargs.items())) if kwargs else args\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   | >           return memory[key]\n[CI/Python 3.7-1              ]   | E           KeyError: ()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/calc.py:52: KeyError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab36bcc20>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab36bcd40>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests_transactions.TransactionSupportTests testMethod=test_multidb>\n[CI/Python 3.7-1              ]   | result = <TestCaseFunction test_multidb>, debug = False\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _setup_and_call(self, result, debug=False):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Perform the following in order: pre-setup, run test, post-teardown,\n[CI/Python 3.7-1              ]   |         skipping pre/post hooks if test is set to be skipped.\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         If debug=True, reraise any errors in setup and use super().debug()\n[CI/Python 3.7-1              ]   |         instead of __call__() to run the test.\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         testMethod = getattr(self, self._testMethodName)\n[CI/Python 3.7-1              ]   |         skipped = (\n[CI/Python 3.7-1              ]   |             getattr(self.__class__, \"__unittest_skip__\", False) or\n[CI/Python 3.7-1              ]   |             getattr(testMethod, \"__unittest_skip__\", False)\n[CI/Python 3.7-1              ]   |         )\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         # Convert async test methods.\n[CI/Python 3.7-1              ]   |         if asyncio.iscoroutinefunction(testMethod):\n[CI/Python 3.7-1              ]   |             setattr(self, self._testMethodName, async_to_sync(testMethod))\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if not skipped:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               self._pre_setup()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/test/testcases.py:272: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/test/testcases.py:935: in _pre_setup\n[CI/Python 3.7-1              ]   |     self._fixture_setup()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/test/testcases.py:993: in _fixture_setup\n[CI/Python 3.7-1              ]   |     **{'verbosity': 0, 'database': db_name})\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/core/management/__init__.py:181: in call_command\n[CI/Python 3.7-1              ]   |     return command.execute(*args, **defaults)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/core/management/base.py:398: in execute\n[CI/Python 3.7-1              ]   |     output = self.handle(*args, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/core/management/commands/loaddata.py:78: in handle\n[CI/Python 3.7-1              ]   |     self.loaddata(fixture_labels)\n[CI/Python 3.7-1              ]   | cacheops/transaction.py:77: in __exit__\n[CI/Python 3.7-1              ]   |     self._no_monkey.__exit__(self, exc_type, exc_value, traceback)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/db/transaction.py:290: in __exit__\n[CI/Python 3.7-1              ]   |     connection.set_autocommit(True)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/db/backends/base/base.py:420: in set_autocommit\n[CI/Python 3.7-1              ]   |     self.run_and_clear_commit_hooks()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/db/backends/base/base.py:653: in run_and_clear_commit_hooks\n[CI/Python 3.7-1              ]   |     func()\n[CI/Python 3.7-1              ]   | cacheops/transaction.py:30: in commit\n[CI/Python 3.7-1              ]   |     func(*args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:40: in invalidate_dict\n[CI/Python 3.7-1              ]   |     load_script(script)(keys=[prefix], args=[model._meta.db_table, serialized_dict])\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/calc.py:55: in wrapper\n[CI/Python 3.7-1              ]   |     value = memory[key] = func(*args, **kwargs)\n[CI/Python 3.7-1              ]   | cacheops/redis.py:65: in load_script\n[CI/Python 3.7-1              ]   |     if is_redis_7():\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/calc.py:55: in wrapper\n[CI/Python 3.7-1              ]   |     value = memory[key] = func(*args, **kwargs)\n[CI/Python 3.7-1              ]   | cacheops/redis.py:74: in is_redis_7\n[CI/Python 3.7-1              ]   |     redis_version = redis_client.info('server')['redis_version']\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:993: in info\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"INFO\", section, *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _____________________ TransactionSupportTests.test_nested ______________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | args = ('invalidate',), kwargs = {}, key = ('invalidate',)\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     @wraps(func)\n[CI/Python 3.7-1              ]   |     def wrapper(*args, **kwargs):\n[CI/Python 3.7-1              ]   |         # We inline this here since @memoize also targets microoptimizations\n[CI/Python 3.7-1              ]   |         key = key_func(*args, **kwargs) if key_func else \\\n[CI/Python 3.7-1              ]   |               args + tuple(sorted(kwargs.items())) if kwargs else args\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   | >           return memory[key]\n[CI/Python 3.7-1              ]   | E           KeyError: ('invalidate',)\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/calc.py:52: KeyError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | args = (), kwargs = {}, key = ()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     @wraps(func)\n[CI/Python 3.7-1              ]   |     def wrapper(*args, **kwargs):\n[CI/Python 3.7-1              ]   |         # We inline this here since @memoize also targets microoptimizations\n[CI/Python 3.7-1              ]   |         key = key_func(*args, **kwargs) if key_func else \\\n[CI/Python 3.7-1              ]   |               args + tuple(sorted(kwargs.items())) if kwargs else args\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   | >           return memory[key]\n[CI/Python 3.7-1              ]   | E           KeyError: ()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/calc.py:52: KeyError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab39e8e60>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab36bc7a0>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests_transactions.TransactionSupportTests testMethod=test_nested>\n[CI/Python 3.7-1              ]   | result = <TestCaseFunction test_nested>, debug = False\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _setup_and_call(self, result, debug=False):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Perform the following in order: pre-setup, run test, post-teardown,\n[CI/Python 3.7-1              ]   |         skipping pre/post hooks if test is set to be skipped.\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         If debug=True, reraise any errors in setup and use super().debug()\n[CI/Python 3.7-1              ]   |         instead of __call__() to run the test.\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         testMethod = getattr(self, self._testMethodName)\n[CI/Python 3.7-1              ]   |         skipped = (\n[CI/Python 3.7-1              ]   |             getattr(self.__class__, \"__unittest_skip__\", False) or\n[CI/Python 3.7-1              ]   |             getattr(testMethod, \"__unittest_skip__\", False)\n[CI/Python 3.7-1              ]   |         )\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         # Convert async test methods.\n[CI/Python 3.7-1              ]   |         if asyncio.iscoroutinefunction(testMethod):\n[CI/Python 3.7-1              ]   |             setattr(self, self._testMethodName, async_to_sync(testMethod))\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if not skipped:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               self._pre_setup()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/test/testcases.py:272: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/test/testcases.py:935: in _pre_setup\n[CI/Python 3.7-1              ]   |     self._fixture_setup()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/test/testcases.py:993: in _fixture_setup\n[CI/Python 3.7-1              ]   |     **{'verbosity': 0, 'database': db_name})\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/core/management/__init__.py:181: in call_command\n[CI/Python 3.7-1              ]   |     return command.execute(*args, **defaults)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/core/management/base.py:398: in execute\n[CI/Python 3.7-1              ]   |     output = self.handle(*args, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/core/management/commands/loaddata.py:78: in handle\n[CI/Python 3.7-1              ]   |     self.loaddata(fixture_labels)\n[CI/Python 3.7-1              ]   | cacheops/transaction.py:77: in __exit__\n[CI/Python 3.7-1              ]   |     self._no_monkey.__exit__(self, exc_type, exc_value, traceback)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/db/transaction.py:290: in __exit__\n[CI/Python 3.7-1              ]   |     connection.set_autocommit(True)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/db/backends/base/base.py:420: in set_autocommit\n[CI/Python 3.7-1              ]   |     self.run_and_clear_commit_hooks()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/db/backends/base/base.py:653: in run_and_clear_commit_hooks\n[CI/Python 3.7-1              ]   |     func()\n[CI/Python 3.7-1              ]   | cacheops/transaction.py:30: in commit\n[CI/Python 3.7-1              ]   |     func(*args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:40: in invalidate_dict\n[CI/Python 3.7-1              ]   |     load_script(script)(keys=[prefix], args=[model._meta.db_table, serialized_dict])\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/calc.py:55: in wrapper\n[CI/Python 3.7-1              ]   |     value = memory[key] = func(*args, **kwargs)\n[CI/Python 3.7-1              ]   | cacheops/redis.py:65: in load_script\n[CI/Python 3.7-1              ]   |     if is_redis_7():\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/calc.py:55: in wrapper\n[CI/Python 3.7-1              ]   |     value = memory[key] = func(*args, **kwargs)\n[CI/Python 3.7-1              ]   | cacheops/redis.py:74: in is_redis_7\n[CI/Python 3.7-1              ]   |     redis_version = redis_client.info('server')['redis_version']\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:993: in info\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"INFO\", section, *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _________________ TransactionSupportTests.test_nested_rollback _________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | args = ('invalidate',), kwargs = {}, key = ('invalidate',)\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     @wraps(func)\n[CI/Python 3.7-1              ]   |     def wrapper(*args, **kwargs):\n[CI/Python 3.7-1              ]   |         # We inline this here since @memoize also targets microoptimizations\n[CI/Python 3.7-1              ]   |         key = key_func(*args, **kwargs) if key_func else \\\n[CI/Python 3.7-1              ]   |               args + tuple(sorted(kwargs.items())) if kwargs else args\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   | >           return memory[key]\n[CI/Python 3.7-1              ]   | E           KeyError: ('invalidate',)\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/calc.py:52: KeyError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | args = (), kwargs = {}, key = ()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     @wraps(func)\n[CI/Python 3.7-1              ]   |     def wrapper(*args, **kwargs):\n[CI/Python 3.7-1              ]   |         # We inline this here since @memoize also targets microoptimizations\n[CI/Python 3.7-1              ]   |         key = key_func(*args, **kwargs) if key_func else \\\n[CI/Python 3.7-1              ]   |               args + tuple(sorted(kwargs.items())) if kwargs else args\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   | >           return memory[key]\n[CI/Python 3.7-1              ]   | E           KeyError: ()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/calc.py:52: KeyError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3694a70>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab36949e0>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests_transactions.TransactionSupportTests testMethod=test_nested_rollback>\n[CI/Python 3.7-1              ]   | result = <TestCaseFunction test_nested_rollback>, debug = False\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _setup_and_call(self, result, debug=False):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Perform the following in order: pre-setup, run test, post-teardown,\n[CI/Python 3.7-1              ]   |         skipping pre/post hooks if test is set to be skipped.\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         If debug=True, reraise any errors in setup and use super().debug()\n[CI/Python 3.7-1              ]   |         instead of __call__() to run the test.\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         testMethod = getattr(self, self._testMethodName)\n[CI/Python 3.7-1              ]   |         skipped = (\n[CI/Python 3.7-1              ]   |             getattr(self.__class__, \"__unittest_skip__\", False) or\n[CI/Python 3.7-1              ]   |             getattr(testMethod, \"__unittest_skip__\", False)\n[CI/Python 3.7-1              ]   |         )\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         # Convert async test methods.\n[CI/Python 3.7-1              ]   |         if asyncio.iscoroutinefunction(testMethod):\n[CI/Python 3.7-1              ]   |             setattr(self, self._testMethodName, async_to_sync(testMethod))\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if not skipped:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               self._pre_setup()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/test/testcases.py:272: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/test/testcases.py:935: in _pre_setup\n[CI/Python 3.7-1              ]   |     self._fixture_setup()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/test/testcases.py:993: in _fixture_setup\n[CI/Python 3.7-1              ]   |     **{'verbosity': 0, 'database': db_name})\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/core/management/__init__.py:181: in call_command\n[CI/Python 3.7-1              ]   |     return command.execute(*args, **defaults)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/core/management/base.py:398: in execute\n[CI/Python 3.7-1              ]   |     output = self.handle(*args, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/core/management/commands/loaddata.py:78: in handle\n[CI/Python 3.7-1              ]   |     self.loaddata(fixture_labels)\n[CI/Python 3.7-1              ]   | cacheops/transaction.py:77: in __exit__\n[CI/Python 3.7-1              ]   |     self._no_monkey.__exit__(self, exc_type, exc_value, traceback)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/db/transaction.py:290: in __exit__\n[CI/Python 3.7-1              ]   |     connection.set_autocommit(True)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/db/backends/base/base.py:420: in set_autocommit\n[CI/Python 3.7-1              ]   |     self.run_and_clear_commit_hooks()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/db/backends/base/base.py:653: in run_and_clear_commit_hooks\n[CI/Python 3.7-1              ]   |     func()\n[CI/Python 3.7-1              ]   | cacheops/transaction.py:30: in commit\n[CI/Python 3.7-1              ]   |     func(*args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:40: in invalidate_dict\n[CI/Python 3.7-1              ]   |     load_script(script)(keys=[prefix], args=[model._meta.db_table, serialized_dict])\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/calc.py:55: in wrapper\n[CI/Python 3.7-1              ]   |     value = memory[key] = func(*args, **kwargs)\n[CI/Python 3.7-1              ]   | cacheops/redis.py:65: in load_script\n[CI/Python 3.7-1              ]   |     if is_redis_7():\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/calc.py:55: in wrapper\n[CI/Python 3.7-1              ]   |     value = memory[key] = func(*args, **kwargs)\n[CI/Python 3.7-1              ]   | cacheops/redis.py:74: in is_redis_7\n[CI/Python 3.7-1              ]   |     redis_version = redis_client.info('server')['redis_version']\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:993: in info\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"INFO\", section, *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | ____________________ TransactionSupportTests.test_rollback _____________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | args = ('invalidate',), kwargs = {}, key = ('invalidate',)\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     @wraps(func)\n[CI/Python 3.7-1              ]   |     def wrapper(*args, **kwargs):\n[CI/Python 3.7-1              ]   |         # We inline this here since @memoize also targets microoptimizations\n[CI/Python 3.7-1              ]   |         key = key_func(*args, **kwargs) if key_func else \\\n[CI/Python 3.7-1              ]   |               args + tuple(sorted(kwargs.items())) if kwargs else args\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   | >           return memory[key]\n[CI/Python 3.7-1              ]   | E           KeyError: ('invalidate',)\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/calc.py:52: KeyError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | args = (), kwargs = {}, key = ()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     @wraps(func)\n[CI/Python 3.7-1              ]   |     def wrapper(*args, **kwargs):\n[CI/Python 3.7-1              ]   |         # We inline this here since @memoize also targets microoptimizations\n[CI/Python 3.7-1              ]   |         key = key_func(*args, **kwargs) if key_func else \\\n[CI/Python 3.7-1              ]   |               args + tuple(sorted(kwargs.items())) if kwargs else args\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   | >           return memory[key]\n[CI/Python 3.7-1              ]   | E           KeyError: ()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/calc.py:52: KeyError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3931b00>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3931b90>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests_transactions.TransactionSupportTests testMethod=test_rollback>\n[CI/Python 3.7-1              ]   | result = <TestCaseFunction test_rollback>, debug = False\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _setup_and_call(self, result, debug=False):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Perform the following in order: pre-setup, run test, post-teardown,\n[CI/Python 3.7-1              ]   |         skipping pre/post hooks if test is set to be skipped.\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         If debug=True, reraise any errors in setup and use super().debug()\n[CI/Python 3.7-1              ]   |         instead of __call__() to run the test.\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         testMethod = getattr(self, self._testMethodName)\n[CI/Python 3.7-1              ]   |         skipped = (\n[CI/Python 3.7-1              ]   |             getattr(self.__class__, \"__unittest_skip__\", False) or\n[CI/Python 3.7-1              ]   |             getattr(testMethod, \"__unittest_skip__\", False)\n[CI/Python 3.7-1              ]   |         )\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         # Convert async test methods.\n[CI/Python 3.7-1              ]   |         if asyncio.iscoroutinefunction(testMethod):\n[CI/Python 3.7-1              ]   |             setattr(self, self._testMethodName, async_to_sync(testMethod))\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if not skipped:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               self._pre_setup()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/test/testcases.py:272: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/test/testcases.py:935: in _pre_setup\n[CI/Python 3.7-1              ]   |     self._fixture_setup()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/test/testcases.py:993: in _fixture_setup\n[CI/Python 3.7-1              ]   |     **{'verbosity': 0, 'database': db_name})\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/core/management/__init__.py:181: in call_command\n[CI/Python 3.7-1              ]   |     return command.execute(*args, **defaults)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/core/management/base.py:398: in execute\n[CI/Python 3.7-1              ]   |     output = self.handle(*args, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/core/management/commands/loaddata.py:78: in handle\n[CI/Python 3.7-1              ]   |     self.loaddata(fixture_labels)\n[CI/Python 3.7-1              ]   | cacheops/transaction.py:77: in __exit__\n[CI/Python 3.7-1              ]   |     self._no_monkey.__exit__(self, exc_type, exc_value, traceback)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/db/transaction.py:290: in __exit__\n[CI/Python 3.7-1              ]   |     connection.set_autocommit(True)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/db/backends/base/base.py:420: in set_autocommit\n[CI/Python 3.7-1              ]   |     self.run_and_clear_commit_hooks()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/db/backends/base/base.py:653: in run_and_clear_commit_hooks\n[CI/Python 3.7-1              ]   |     func()\n[CI/Python 3.7-1              ]   | cacheops/transaction.py:30: in commit\n[CI/Python 3.7-1              ]   |     func(*args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:40: in invalidate_dict\n[CI/Python 3.7-1              ]   |     load_script(script)(keys=[prefix], args=[model._meta.db_table, serialized_dict])\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/calc.py:55: in wrapper\n[CI/Python 3.7-1              ]   |     value = memory[key] = func(*args, **kwargs)\n[CI/Python 3.7-1              ]   | cacheops/redis.py:65: in load_script\n[CI/Python 3.7-1              ]   |     if is_redis_7():\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/calc.py:55: in wrapper\n[CI/Python 3.7-1              ]   |     value = memory[key] = func(*args, **kwargs)\n[CI/Python 3.7-1              ]   | cacheops/redis.py:74: in is_redis_7\n[CI/Python 3.7-1              ]   |     redis_version = redis_client.info('server')['redis_version']\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:993: in info\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"INFO\", section, *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _________ TransactionSupportTests.test_rollback_during_integrity_error _________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | args = ('invalidate',), kwargs = {}, key = ('invalidate',)\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     @wraps(func)\n[CI/Python 3.7-1              ]   |     def wrapper(*args, **kwargs):\n[CI/Python 3.7-1              ]   |         # We inline this here since @memoize also targets microoptimizations\n[CI/Python 3.7-1              ]   |         key = key_func(*args, **kwargs) if key_func else \\\n[CI/Python 3.7-1              ]   |               args + tuple(sorted(kwargs.items())) if kwargs else args\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   | >           return memory[key]\n[CI/Python 3.7-1              ]   | E           KeyError: ('invalidate',)\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/calc.py:52: KeyError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | args = (), kwargs = {}, key = ()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     @wraps(func)\n[CI/Python 3.7-1              ]   |     def wrapper(*args, **kwargs):\n[CI/Python 3.7-1              ]   |         # We inline this here since @memoize also targets microoptimizations\n[CI/Python 3.7-1              ]   |         key = key_func(*args, **kwargs) if key_func else \\\n[CI/Python 3.7-1              ]   |               args + tuple(sorted(kwargs.items())) if kwargs else args\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   | >           return memory[key]\n[CI/Python 3.7-1              ]   | E           KeyError: ()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/calc.py:52: KeyError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab39e8e60>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab39e8dd0>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests_transactions.TransactionSupportTests testMethod=test_rollback_during_integrity_error>\n[CI/Python 3.7-1              ]   | result = <TestCaseFunction test_rollback_during_integrity_error>, debug = False\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _setup_and_call(self, result, debug=False):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Perform the following in order: pre-setup, run test, post-teardown,\n[CI/Python 3.7-1              ]   |         skipping pre/post hooks if test is set to be skipped.\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         If debug=True, reraise any errors in setup and use super().debug()\n[CI/Python 3.7-1              ]   |         instead of __call__() to run the test.\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         testMethod = getattr(self, self._testMethodName)\n[CI/Python 3.7-1              ]   |         skipped = (\n[CI/Python 3.7-1              ]   |             getattr(self.__class__, \"__unittest_skip__\", False) or\n[CI/Python 3.7-1              ]   |             getattr(testMethod, \"__unittest_skip__\", False)\n[CI/Python 3.7-1              ]   |         )\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         # Convert async test methods.\n[CI/Python 3.7-1              ]   |         if asyncio.iscoroutinefunction(testMethod):\n[CI/Python 3.7-1              ]   |             setattr(self, self._testMethodName, async_to_sync(testMethod))\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if not skipped:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               self._pre_setup()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/test/testcases.py:272: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/test/testcases.py:935: in _pre_setup\n[CI/Python 3.7-1              ]   |     self._fixture_setup()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/test/testcases.py:993: in _fixture_setup\n[CI/Python 3.7-1              ]   |     **{'verbosity': 0, 'database': db_name})\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/core/management/__init__.py:181: in call_command\n[CI/Python 3.7-1              ]   |     return command.execute(*args, **defaults)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/core/management/base.py:398: in execute\n[CI/Python 3.7-1              ]   |     output = self.handle(*args, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/core/management/commands/loaddata.py:78: in handle\n[CI/Python 3.7-1              ]   |     self.loaddata(fixture_labels)\n[CI/Python 3.7-1              ]   | cacheops/transaction.py:77: in __exit__\n[CI/Python 3.7-1              ]   |     self._no_monkey.__exit__(self, exc_type, exc_value, traceback)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/db/transaction.py:290: in __exit__\n[CI/Python 3.7-1              ]   |     connection.set_autocommit(True)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/db/backends/base/base.py:420: in set_autocommit\n[CI/Python 3.7-1              ]   |     self.run_and_clear_commit_hooks()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/db/backends/base/base.py:653: in run_and_clear_commit_hooks\n[CI/Python 3.7-1              ]   |     func()\n[CI/Python 3.7-1              ]   | cacheops/transaction.py:30: in commit\n[CI/Python 3.7-1              ]   |     func(*args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:40: in invalidate_dict\n[CI/Python 3.7-1              ]   |     load_script(script)(keys=[prefix], args=[model._meta.db_table, serialized_dict])\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/calc.py:55: in wrapper\n[CI/Python 3.7-1              ]   |     value = memory[key] = func(*args, **kwargs)\n[CI/Python 3.7-1              ]   | cacheops/redis.py:65: in load_script\n[CI/Python 3.7-1              ]   |     if is_redis_7():\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/calc.py:55: in wrapper\n[CI/Python 3.7-1              ]   |     value = memory[key] = func(*args, **kwargs)\n[CI/Python 3.7-1              ]   | cacheops/redis.py:74: in is_redis_7\n[CI/Python 3.7-1              ]   |     redis_version = redis_client.info('server')['redis_version']\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:993: in info\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"INFO\", section, *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | _______________ TransactionSupportTests.test_smart_transactions ________________\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | args = ('invalidate',), kwargs = {}, key = ('invalidate',)\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     @wraps(func)\n[CI/Python 3.7-1              ]   |     def wrapper(*args, **kwargs):\n[CI/Python 3.7-1              ]   |         # We inline this here since @memoize also targets microoptimizations\n[CI/Python 3.7-1              ]   |         key = key_func(*args, **kwargs) if key_func else \\\n[CI/Python 3.7-1              ]   |               args + tuple(sorted(kwargs.items())) if kwargs else args\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   | >           return memory[key]\n[CI/Python 3.7-1              ]   | E           KeyError: ('invalidate',)\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/calc.py:52: KeyError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | args = (), kwargs = {}, key = ()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     @wraps(func)\n[CI/Python 3.7-1              ]   |     def wrapper(*args, **kwargs):\n[CI/Python 3.7-1              ]   |         # We inline this here since @memoize also targets microoptimizations\n[CI/Python 3.7-1              ]   |         key = key_func(*args, **kwargs) if key_func else \\\n[CI/Python 3.7-1              ]   |               args + tuple(sorted(kwargs.items())) if kwargs else args\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   | >           return memory[key]\n[CI/Python 3.7-1              ]   | E           KeyError: ()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/calc.py:52: KeyError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   | >               lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <redis.retry.Retry object at 0x7fdab3cb0a90>\n[CI/Python 3.7-1              ]   | do = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3694c20>\n[CI/Python 3.7-1              ]   | fail = <function AbstractConnection.connect.<locals>.<lambda> at 0x7fdab3694f80>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def call_with_retry(self, do, fail):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Execute an operation that might fail and returns its result, or\n[CI/Python 3.7-1              ]   |         raise the exception that was thrown depending on the `Backoff` object.\n[CI/Python 3.7-1              ]   |         `do`: the operation to call. Expects no argument.\n[CI/Python 3.7-1              ]   |         `fail`: the failure handler, expects the last error that was thrown\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         self._backoff.reset()\n[CI/Python 3.7-1              ]   |         failures = 0\n[CI/Python 3.7-1              ]   |         while True:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               return do()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/retry.py:46: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | >       lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |     )\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:700: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   |                 sock.connect(socket_address)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_timeout now that we're connected\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_timeout)\n[CI/Python 3.7-1              ]   |                 return sock\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |             except OSError as _:\n[CI/Python 3.7-1              ]   |                 err = _\n[CI/Python 3.7-1              ]   |                 if sock is not None:\n[CI/Python 3.7-1              ]   |                     sock.close()\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if err is not None:\n[CI/Python 3.7-1              ]   | >           raise err\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1002: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _connect(self):\n[CI/Python 3.7-1              ]   |         \"Create a TCP socket connection\"\n[CI/Python 3.7-1              ]   |         # we want to mimic what socket.create_connection does to support\n[CI/Python 3.7-1              ]   |         # ipv4/ipv6, but we want to set options prior to calling\n[CI/Python 3.7-1              ]   |         # socket.connect()\n[CI/Python 3.7-1              ]   |         err = None\n[CI/Python 3.7-1              ]   |         for res in socket.getaddrinfo(\n[CI/Python 3.7-1              ]   |             self.host, self.port, self.socket_type, socket.SOCK_STREAM\n[CI/Python 3.7-1              ]   |         ):\n[CI/Python 3.7-1              ]   |             family, socktype, proto, canonname, socket_address = res\n[CI/Python 3.7-1              ]   |             sock = None\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   |                 sock = socket.socket(family, socktype, proto)\n[CI/Python 3.7-1              ]   |                 # TCP_NODELAY\n[CI/Python 3.7-1              ]   |                 sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # TCP_KEEPALIVE\n[CI/Python 3.7-1              ]   |                 if self.socket_keepalive:\n[CI/Python 3.7-1              ]   |                     sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n[CI/Python 3.7-1              ]   |                     for k, v in self.socket_keepalive_options.items():\n[CI/Python 3.7-1              ]   |                         sock.setsockopt(socket.IPPROTO_TCP, k, v)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # set the socket_connect_timeout before we connect\n[CI/Python 3.7-1              ]   |                 sock.settimeout(self.socket_connect_timeout)\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |                 # connect\n[CI/Python 3.7-1              ]   | >               sock.connect(socket_address)\n[CI/Python 3.7-1              ]   | E               ConnectionRefusedError: [Errno 111] Connection refused\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:990: ConnectionRefusedError\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | During handling of the above exception, another exception occurred:\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = <tests.tests_transactions.TransactionSupportTests testMethod=test_smart_transactions>\n[CI/Python 3.7-1              ]   | result = <TestCaseFunction test_smart_transactions>, debug = False\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def _setup_and_call(self, result, debug=False):\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         Perform the following in order: pre-setup, run test, post-teardown,\n[CI/Python 3.7-1              ]   |         skipping pre/post hooks if test is set to be skipped.\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         If debug=True, reraise any errors in setup and use super().debug()\n[CI/Python 3.7-1              ]   |         instead of __call__() to run the test.\n[CI/Python 3.7-1              ]   |         \"\"\"\n[CI/Python 3.7-1              ]   |         testMethod = getattr(self, self._testMethodName)\n[CI/Python 3.7-1              ]   |         skipped = (\n[CI/Python 3.7-1              ]   |             getattr(self.__class__, \"__unittest_skip__\", False) or\n[CI/Python 3.7-1              ]   |             getattr(testMethod, \"__unittest_skip__\", False)\n[CI/Python 3.7-1              ]   |         )\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         # Convert async test methods.\n[CI/Python 3.7-1              ]   |         if asyncio.iscoroutinefunction(testMethod):\n[CI/Python 3.7-1              ]   |             setattr(self, self._testMethodName, async_to_sync(testMethod))\n[CI/Python 3.7-1              ]   |     \n[CI/Python 3.7-1              ]   |         if not skipped:\n[CI/Python 3.7-1              ]   |             try:\n[CI/Python 3.7-1              ]   | >               self._pre_setup()\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/test/testcases.py:272: \n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/test/testcases.py:935: in _pre_setup\n[CI/Python 3.7-1              ]   |     self._fixture_setup()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/test/testcases.py:993: in _fixture_setup\n[CI/Python 3.7-1              ]   |     **{'verbosity': 0, 'database': db_name})\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/core/management/__init__.py:181: in call_command\n[CI/Python 3.7-1              ]   |     return command.execute(*args, **defaults)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/core/management/base.py:398: in execute\n[CI/Python 3.7-1              ]   |     output = self.handle(*args, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/core/management/commands/loaddata.py:78: in handle\n[CI/Python 3.7-1              ]   |     self.loaddata(fixture_labels)\n[CI/Python 3.7-1              ]   | cacheops/transaction.py:77: in __exit__\n[CI/Python 3.7-1              ]   |     self._no_monkey.__exit__(self, exc_type, exc_value, traceback)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/db/transaction.py:290: in __exit__\n[CI/Python 3.7-1              ]   |     connection.set_autocommit(True)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/db/backends/base/base.py:420: in set_autocommit\n[CI/Python 3.7-1              ]   |     self.run_and_clear_commit_hooks()\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/django/db/backends/base/base.py:653: in run_and_clear_commit_hooks\n[CI/Python 3.7-1              ]   |     func()\n[CI/Python 3.7-1              ]   | cacheops/transaction.py:30: in commit\n[CI/Python 3.7-1              ]   |     func(*args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/decorators.py:68: in __call__\n[CI/Python 3.7-1              ]   |     return self._func(*self._args, **self._kwargs)\n[CI/Python 3.7-1              ]   | cacheops/invalidation.py:40: in invalidate_dict\n[CI/Python 3.7-1              ]   |     load_script(script)(keys=[prefix], args=[model._meta.db_table, serialized_dict])\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/calc.py:55: in wrapper\n[CI/Python 3.7-1              ]   |     value = memory[key] = func(*args, **kwargs)\n[CI/Python 3.7-1              ]   | cacheops/redis.py:65: in load_script\n[CI/Python 3.7-1              ]   |     if is_redis_7():\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/funcy/calc.py:55: in wrapper\n[CI/Python 3.7-1              ]   |     value = memory[key] = func(*args, **kwargs)\n[CI/Python 3.7-1              ]   | cacheops/redis.py:74: in is_redis_7\n[CI/Python 3.7-1              ]   |     redis_version = redis_client.info('server')['redis_version']\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/commands/core.py:993: in info\n[CI/Python 3.7-1              ]   |     return self.execute_command(\"INFO\", section, *args, **kwargs)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/client.py:1266: in execute_command\n[CI/Python 3.7-1              ]   |     conn = self.connection or pool.get_connection(command_name, **options)\n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:1457: in get_connection\n[CI/Python 3.7-1              ]   |     connection.connect()\n[CI/Python 3.7-1              ]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | self = Connection<host=127.0.0.1,port=6379,db=13>\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   |     def connect(self):\n[CI/Python 3.7-1              ]   |         \"Connects to the Redis server if not already connected\"\n[CI/Python 3.7-1              ]   |         if self._sock:\n[CI/Python 3.7-1              ]   |             return\n[CI/Python 3.7-1              ]   |         try:\n[CI/Python 3.7-1              ]   |             sock = self.retry.call_with_retry(\n[CI/Python 3.7-1              ]   |                 lambda: self._connect(), lambda error: self.disconnect(error)\n[CI/Python 3.7-1              ]   |             )\n[CI/Python 3.7-1              ]   |         except socket.timeout:\n[CI/Python 3.7-1              ]   |             raise TimeoutError(\"Timeout connecting to server\")\n[CI/Python 3.7-1              ]   |         except OSError as e:\n[CI/Python 3.7-1              ]   | >           raise ConnectionError(self._error_message(e))\n[CI/Python 3.7-1              ]   | E           redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | \n[CI/Python 3.7-1              ]   | .tox/py37-dj32/lib/python3.7/site-packages/redis/connection.py:705: ConnectionError\n[CI/Python 3.7-1              ]   | =========================== short test summary info ============================\n[CI/Python 3.7-1              ]   | FAILED tests/test_extras.py::SignalsTests::test_cached_as - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/test_extras.py::SignalsTests::test_invalidation_signal - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/test_extras.py::SignalsTests::test_queryset - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/test_extras.py::SignalsTests::test_queryset_empty - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/test_extras.py::LockingTests::test_lock - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/test_extras.py::NoInvalidationTests::test_context_manager - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/test_extras.py::NoInvalidationTests::test_decorator - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/test_extras.py::NoInvalidationTests::test_in_transaction - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/test_extras.py::NoInvalidationTests::test_nested - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/test_extras.py::LocalGetTests::test_unhashable_args - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/test_extras.py::DbAgnosticTests::test_db_agnostic_by_default - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/test_extras.py::DbAgnosticTests::test_db_agnostic_disabled - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::BasicTests::test_bulk_create - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::BasicTests::test_combine - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::BasicTests::test_db_column - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::BasicTests::test_empty - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::BasicTests::test_exact - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::BasicTests::test_exists - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::BasicTests::test_expressions - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::BasicTests::test_expressions_save - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::BasicTests::test_first_and_last - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::BasicTests::test_fk_to_db_column - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::BasicTests::test_granular - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::BasicTests::test_invalidate_by_boolean - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::BasicTests::test_invalidate_by_foreign_key - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::BasicTests::test_invalidate_by_one_to_one - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::BasicTests::test_invalidated_update - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::BasicTests::test_invalidation - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::BasicTests::test_it_works - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::BasicTests::test_rawsql - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::BasicTests::test_some - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::BasicTests::test_subquery - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::BasicTests::test_union - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::ValuesTests::test_it_varies_on_class - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::ValuesTests::test_it_varies_on_flat - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::ValuesTests::test_it_works - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::DecoratorTests::test_cached_as_cond - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::DecoratorTests::test_cached_as_depends_on_args - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::DecoratorTests::test_cached_as_depends_on_two_models - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::DecoratorTests::test_cached_as_keep_fresh - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::DecoratorTests::test_cached_as_model - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::DecoratorTests::test_cached_as_obj - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::DecoratorTests::test_cached_view_as - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::DecoratorTests::test_cached_view_on_template_response - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::WeirdTests::test_binary - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::WeirdTests::test_custom - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::WeirdTests::test_custom_query - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::WeirdTests::test_date - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::WeirdTests::test_datetime - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::WeirdTests::test_list - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::WeirdTests::test_time - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::WeirdTests::test_weird_custom - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::TemplateTests::test_cached - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::TemplateTests::test_cached_as - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::TemplateTests::test_decorator_tag - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::TemplateTests::test_decorator_tag_context - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::TemplateTests::test_invalidate_fragment - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::TemplateTests::test_jinja2 - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::IssueTests::test_114 - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::IssueTests::test_145 - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::IssueTests::test_159 - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::IssueTests::test_16 - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::IssueTests::test_161 - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::IssueTests::test_161_non_ascii - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::IssueTests::test_169 - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::IssueTests::test_173 - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::IssueTests::test_177 - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::IssueTests::test_217 - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::IssueTests::test_232 - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::IssueTests::test_265 - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::IssueTests::test_29 - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::IssueTests::test_312 - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::IssueTests::test_316 - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::IssueTests::test_348 - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::IssueTests::test_352 - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::IssueTests::test_353 - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::IssueTests::test_359 - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::IssueTests::test_365 - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::IssueTests::test_385 - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::IssueTests::test_387 - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::IssueTests::test_407 - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::IssueTests::test_407_reverse - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::IssueTests::test_430 - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::IssueTests::test_430_no_error_raises - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::IssueTests::test_45 - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::IssueTests::test_57 - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::RelatedTests::test_related_invalidation - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::RelatedTests::test_reverse_fk - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::RelatedTests::test_reverse_fk_same - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::RelatedTests::test_reverse_fk_separate - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::AggregationTests::test_aggregate - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::AggregationTests::test_aggregate_granular - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::AggregationTests::test_annotate - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::AggregationTests::test_filter - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::AggregationTests::test_new_alias - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::M2MTests::test_base_invalidates_on_add - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::M2MTests::test_base_invalidates_on_clear - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::M2MTests::test_base_invalidates_on_remove - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::M2MTests::test_granular_target_on_clear - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::M2MTests::test_granular_through_on_clear - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::M2MTests::test_target_invalidates_on_add - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::M2MTests::test_target_invalidates_on_clear - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::M2MTests::test_target_invalidates_on_remove - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::MultiTableInheritanceWithM2MTest::test_base_invalidates_on_add - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::MultiTableInheritanceWithM2MTest::test_base_invalidates_on_clear - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::MultiTableInheritanceWithM2MTest::test_base_invalidates_on_remove - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::MultiTableInheritanceWithM2MTest::test_granular_target_on_clear - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::MultiTableInheritanceWithM2MTest::test_granular_through_on_clear - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::MultiTableInheritanceWithM2MTest::test_target_invalidates_on_add - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::MultiTableInheritanceWithM2MTest::test_target_invalidates_on_clear - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::MultiTableInheritanceWithM2MTest::test_target_invalidates_on_remove - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::M2MThroughTests::test_base_invalidates_on_clear - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::M2MThroughTests::test_base_invalidates_on_create - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::M2MThroughTests::test_base_invalidates_on_delete - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::M2MThroughTests::test_granular_target_on_clear - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::M2MThroughTests::test_granular_through_on_clear - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::M2MThroughTests::test_target_invalidates_on_clear - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::M2MThroughTests::test_target_invalidates_on_create - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::M2MThroughTests::test_target_invalidates_on_delete - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::ProxyTests::test_148_invalidate_from_non_cached_proxy - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::ProxyTests::test_148_reverse - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::ProxyTests::test_30 - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::ProxyTests::test_30_reversed - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::ProxyTests::test_interchange - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::ProxyTests::test_proxy_caching - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::ProxyTests::test_proxy_caching_reversed - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::ProxyTests::test_siblings - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::MultitableInheritanceTests::test_base_changed - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::MultitableInheritanceTests::test_sub_added - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::SimpleCacheTests::test_cached - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::SimpleCacheTests::test_cached_view - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::MultiDBInvalidationTests::test_bulk_create - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::MultiDBInvalidationTests::test_delete - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::MultiDBInvalidationTests::test_invalidated_update - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::MultiDBInvalidationTests::test_m2m_changed_call_invalidate - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests.py::MultiDBInvalidationTests::test_save - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests_sharding.py::PrefixTests::test_context - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests_sharding.py::PrefixTests::test_db - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests_sharding.py::PrefixTests::test_self_join_tables - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests_sharding.py::PrefixTests::test_table - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests_sharding.py::PrefixTests::test_union_tables - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests_sharding.py::SimpleCacheTests::test_prefix - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests_transactions.py::TransactionSupportTests::test_atomic - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests_transactions.py::TransactionSupportTests::test_call_cacheops_cbs_before_on_commit_cbs - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests_transactions.py::TransactionSupportTests::test_multidb - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests_transactions.py::TransactionSupportTests::test_nested - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests_transactions.py::TransactionSupportTests::test_nested_rollback - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests_transactions.py::TransactionSupportTests::test_rollback - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests_transactions.py::TransactionSupportTests::test_rollback_during_integrity_error - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | FAILED tests/tests_transactions.py::TransactionSupportTests::test_smart_transactions - redis.exceptions.ConnectionError: Error 111 connecting to 127.0.0.1:6379. Connection refused.\n[CI/Python 3.7-1              ]   | ================== 150 failed, 4 passed, 4 skipped in 47.40s ===================\n[CI/Python 3.7-1              ]   | py37-dj32: exit 1 (48.32 seconds) /tmp/de65f406-fe28-11ed-a890-af2cc187fc11/Suor-django-cacheops> pytest pid=238\n[CI/Python 3.7-1              ]   | py37-dj32: tox-gh-actions couldn't understand the parallel option. ignoring the given option: 0\n[CI/Python 3.7-1              ]   \u2753  ::endgroup::\n[CI/Python 3.7-1              ]   | .pkg: _exit> python /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/site-packages/pyproject_api/_backend.py True setuptools.build_meta __legacy__\n[CI/Python 3.7-1              ]   |   py37-dj32: FAIL code 1 (74.10=setup[25.78]+cmd[48.32] seconds)\n[CI/Python 3.7-1              ]   |   evaluation failed :( (74.28 seconds)\n[CI/Python 3.7-1              ]   \u274c  Failure - Main Run tests\n[CI/Python 3.7-1              ] exitcode '1': failure\n[CI/Python 3.7-1              ] \ud83c\udfc1  Job failed\n",
    "actions_stderr": "Error: Job 'lint' failed\n"
}