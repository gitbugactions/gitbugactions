{
    "repository": "danielfm/pybreaker",
    "clone_url": "https://github.com/danielfm/pybreaker.git",
    "timestamp": "2023-05-29T14:05:15.873363Z",
    "clone_success": true,
    "number of actions": 2,
    "number_of_test_actions": 1,
    "actions_successful": true,
    "actions_stdout": "[pybreaker test matrix/test] \ud83d\ude80  Start image=crawlergpt:latest\n[pybreaker test matrix/test]   \ud83d\udc33  docker pull image=crawlergpt:latest platform= username= forcePull=false\n[pybreaker test matrix/test]   \ud83d\udc33  docker create image=crawlergpt:latest platform= entrypoint=[\"tail\" \"-f\" \"/dev/null\"] cmd=[]\n[pybreaker test matrix/test]   \ud83d\udc33  docker run image=crawlergpt:latest platform= entrypoint=[\"tail\" \"-f\" \"/dev/null\"] cmd=[]\n[pybreaker test matrix/test]   \ud83d\udc33  docker exec cmd=[chown -R 1012:1000 /tmp/de65f406-fe28-11ed-a890-af2cc187fc11/danielfm-pybreaker] user=0 workdir=\n[pybreaker test matrix/test]   \u2601  git clone 'https://github.com/actions/setup-python' # ref=v4\n[pybreaker test matrix/test] \ud83e\uddea  Matrix: map[python-version:3.7]\n[pybreaker test matrix/test] \u2b50 Run Main actions/checkout@v3\n[pybreaker test matrix/test]   \u2705  Success - Main actions/checkout@v3\n[pybreaker test matrix/test] \u2b50 Run Main Set up Python 3.7\n[pybreaker test matrix/test]   \ud83d\udc33  docker cp src=/home/andre-silva/.cache/act/actions-setup-python@v4/ dst=/var/run/act/actions/actions-setup-python@v4/\n[pybreaker test matrix/test]   \ud83d\udc33  docker exec cmd=[chown -R 1012:1000 /var/run/act/actions/actions-setup-python@v4/] user=0 workdir=\n[pybreaker test matrix/test]   \ud83d\udc33  docker exec cmd=[node /var/run/act/actions/actions-setup-python@v4/dist/setup/index.js] user= workdir=\n[pybreaker test matrix/test]   \ud83d\udcac  ::debug::Python is expected to be installed into /opt/hostedtoolcache\n[pybreaker test matrix/test]   \u2753  ::group::Installed versions\n[pybreaker test matrix/test]   \ud83d\udcac  ::debug::Semantic version spec of 3.7 is 3.7\n[pybreaker test matrix/test]   \ud83d\udcac  ::debug::isExplicit: \n[pybreaker test matrix/test]   \ud83d\udcac  ::debug::explicit? false\n[pybreaker test matrix/test]   \ud83d\udcac  ::debug::isExplicit: 2.7.18\n[pybreaker test matrix/test]   \ud83d\udcac  ::debug::explicit? true\n[pybreaker test matrix/test]   \ud83d\udcac  ::debug::isExplicit: 3.5.10\n[pybreaker test matrix/test]   \ud83d\udcac  ::debug::explicit? true\n[pybreaker test matrix/test]   \ud83d\udcac  ::debug::isExplicit: 3.6.14\n[pybreaker test matrix/test]   \ud83d\udcac  ::debug::explicit? true\n[pybreaker test matrix/test]   \ud83d\udcac  ::debug::isExplicit: 3.7.11\n[pybreaker test matrix/test]   \ud83d\udcac  ::debug::explicit? true\n[pybreaker test matrix/test]   \ud83d\udcac  ::debug::isExplicit: 3.8.11\n[pybreaker test matrix/test]   \ud83d\udcac  ::debug::explicit? true\n[pybreaker test matrix/test]   \ud83d\udcac  ::debug::isExplicit: 3.9.6\n[pybreaker test matrix/test]   \ud83d\udcac  ::debug::explicit? true\n[pybreaker test matrix/test]   \ud83d\udcac  ::debug::evaluating 6 versions\n[pybreaker test matrix/test]   \ud83d\udcac  ::debug::matched: 3.7.11\n[pybreaker test matrix/test]   \ud83d\udcac  ::debug::checking cache: /opt/hostedtoolcache/Python/3.7.11/x64\n[pybreaker test matrix/test]   \ud83d\udcac  ::debug::Found tool in cache Python 3.7.11 x64\n[pybreaker test matrix/test]   | Successfully set up CPython (3.7.11)\n[pybreaker test matrix/test]   \u2753  ::endgroup::\n[pybreaker test matrix/test]   \u2753 add-matcher /run/act/actions/actions-setup-python@v4/.github/python.json\n[pybreaker test matrix/test]   \u2705  Success - Main Set up Python 3.7\n[pybreaker test matrix/test]   \u2699  ::set-env:: Python2_ROOT_DIR=/opt/hostedtoolcache/Python/3.7.11/x64\n[pybreaker test matrix/test]   \u2699  ::set-env:: Python3_ROOT_DIR=/opt/hostedtoolcache/Python/3.7.11/x64\n[pybreaker test matrix/test]   \u2699  ::set-env:: LD_LIBRARY_PATH=/opt/hostedtoolcache/Python/3.7.11/x64/lib\n[pybreaker test matrix/test]   \u2699  ::set-env:: pythonLocation=/opt/hostedtoolcache/Python/3.7.11/x64\n[pybreaker test matrix/test]   \u2699  ::set-env:: PKG_CONFIG_PATH=/opt/hostedtoolcache/Python/3.7.11/x64/lib/pkgconfig\n[pybreaker test matrix/test]   \u2699  ::set-env:: Python_ROOT_DIR=/opt/hostedtoolcache/Python/3.7.11/x64\n[pybreaker test matrix/test]   \u2699  ::set-output:: python-version=3.7.11\n[pybreaker test matrix/test]   \u2699  ::set-output:: python-path=/opt/hostedtoolcache/Python/3.7.11/x64/bin/python\n[pybreaker test matrix/test]   \u2699  ::add-path:: /opt/hostedtoolcache/Python/3.7.11/x64\n[pybreaker test matrix/test]   \u2699  ::add-path:: /opt/hostedtoolcache/Python/3.7.11/x64/bin\n[pybreaker test matrix/test] \u2b50 Run Main Upgrade pip version\n[pybreaker test matrix/test]   \ud83d\udc33  docker exec cmd=[bash --noprofile --norc -e -o pipefail /var/run/act/workflow/2] user= workdir=\n[pybreaker test matrix/test]   | Requirement already satisfied: pip in /opt/hostedtoolcache/Python/3.7.11/x64/lib/python3.7/site-packages (21.2.4)\n[pybreaker test matrix/test]   | Collecting pip\n[pybreaker test matrix/test]   |   Downloading pip-23.1.2-py3-none-any.whl (2.1 MB)\n[pybreaker test matrix/test]   | Installing collected packages: pip\n[pybreaker test matrix/test]   |   Attempting uninstall: pip\n[pybreaker test matrix/test]   |     Found existing installation: pip 21.2.4\n[pybreaker test matrix/test]   |     Uninstalling pip-21.2.4:\n[pybreaker test matrix/test]   |       Successfully uninstalled pip-21.2.4\n[pybreaker test matrix/test]   | Successfully installed pip-23.1.2\n[pybreaker test matrix/test]   \u2705  Success - Main Upgrade pip version\n[pybreaker test matrix/test] \u2b50 Run Main Install wheel\n[pybreaker test matrix/test]   \ud83d\udc33  docker exec cmd=[bash --noprofile --norc -e -o pipefail /var/run/act/workflow/3] user= workdir=\n[pybreaker test matrix/test]   | Collecting wheel\n[pybreaker test matrix/test]   |   Downloading wheel-0.40.0-py3-none-any.whl (64 kB)\n[pybreaker test matrix/test]   |      \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 64.5/64.5 kB 2.8 MB/s eta 0:00:00\n[pybreaker test matrix/test]   | Installing collected packages: wheel\n[pybreaker test matrix/test]   | Successfully installed wheel-0.40.0\n[pybreaker test matrix/test]   | \n[pybreaker test matrix/test]   | [notice] A new release of pip is available: 20.1.1 -> 23.1.2\n[pybreaker test matrix/test]   | [notice] To update, run: pip install --upgrade pip\n[pybreaker test matrix/test]   \u2705  Success - Main Install wheel\n[pybreaker test matrix/test] \u2b50 Run Main Python versions\n[pybreaker test matrix/test]   \ud83d\udc33  docker exec cmd=[bash --noprofile --norc -e -o pipefail /var/run/act/workflow/4] user= workdir=\n[pybreaker test matrix/test]   | Python 3.7\n[pybreaker test matrix/test]   | Python 3.7.11\n[pybreaker test matrix/test]   \u2705  Success - Main Python versions\n[pybreaker test matrix/test] \u2b50 Run Main Run tests\n[pybreaker test matrix/test]   \ud83d\udc33  docker exec cmd=[bash --noprofile --norc -e -o pipefail /var/run/act/workflow/5] user= workdir=\n[pybreaker test matrix/test]   | running test\n[pybreaker test matrix/test]   | WARNING: Testing via this command is deprecated and will be removed in a future version. Users looking for a generic test entry point independent of test runner are encouraged to use tox.\n[pybreaker test matrix/test]   | running egg_info\n[pybreaker test matrix/test]   | creating src/pybreaker.egg-info\n[pybreaker test matrix/test]   | writing src/pybreaker.egg-info/PKG-INFO\n[pybreaker test matrix/test]   | writing dependency_links to src/pybreaker.egg-info/dependency_links.txt\n[pybreaker test matrix/test]   | writing requirements to src/pybreaker.egg-info/requires.txt\n[pybreaker test matrix/test]   | writing top-level names to src/pybreaker.egg-info/top_level.txt\n[pybreaker test matrix/test]   | writing manifest file 'src/pybreaker.egg-info/SOURCES.txt'\n[pybreaker test matrix/test]   | reading manifest file 'src/pybreaker.egg-info/SOURCES.txt'\n[pybreaker test matrix/test]   | writing manifest file 'src/pybreaker.egg-info/SOURCES.txt'\n[pybreaker test matrix/test]   | running build_ext\n[pybreaker test matrix/test]   | test_fail_max_thread_safety (tests.CircuitBreakerRedisConcurrencyTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should not allow more failed calls than 'fail_max' ... ok\n[pybreaker test matrix/test]   | test_fail_thread_safety (tests.CircuitBreakerRedisConcurrencyTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should compute a failed call atomically to ... ok\n[pybreaker test matrix/test]   | test_half_open_thread_safety (tests.CircuitBreakerRedisConcurrencyTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should allow only one trial call when the ... ok\n[pybreaker test matrix/test]   | test_success_thread_safety (tests.CircuitBreakerRedisConcurrencyTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should compute a successful call atomically ... ok\n[pybreaker test matrix/test]   | test_call_events (tests.CircuitBreakerRedisTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should call the appropriate functions on every ... ok\n[pybreaker test matrix/test]   | test_close (tests.CircuitBreakerRedisTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should allow the circuit to be closed manually. ... ok\n[pybreaker test matrix/test]   | test_cluster_mode (tests.CircuitBreakerRedisTestCase) ... ok\n[pybreaker test matrix/test]   | test_contextmanager (tests.CircuitBreakerRedisTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should catch in a with statement ... ok\n[pybreaker test matrix/test]   | test_failed_call_after_timeout (tests.CircuitBreakerRedisTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should half-open the circuit after timeout. ... ok\n[pybreaker test matrix/test]   | test_failed_call_when_halfopen (tests.CircuitBreakerRedisTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should open the circuit when a call fails in ... ok\n[pybreaker test matrix/test]   | test_fallback_state (tests.CircuitBreakerRedisTestCase) ... ok\n[pybreaker test matrix/test]   | test_generator (tests.CircuitBreakerRedisTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should inspect generator values. ... ok\n[pybreaker test matrix/test]   | test_missing_state (tests.CircuitBreakerRedisTestCase)\n[pybreaker test matrix/test]   | CircuitBreakerRedis: If state on Redis is missing, it should set the ... ok\n[pybreaker test matrix/test]   | test_namespace (tests.CircuitBreakerRedisTestCase) ... ok\n[pybreaker test matrix/test]   | test_one_failed_call (tests.CircuitBreakerRedisTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should keep the circuit closed after a few ... ok\n[pybreaker test matrix/test]   | test_one_successful_call_after_failed_call (tests.CircuitBreakerRedisTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should keep the circuit closed after few mixed ... ok\n[pybreaker test matrix/test]   | test_several_failed_calls_setting_absent (tests.CircuitBreakerRedisTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should open the circuit after many failures. ... ok\n[pybreaker test matrix/test]   | test_successful_after_timeout (tests.CircuitBreakerRedisTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should close the circuit when a call succeeds ... ok\n[pybreaker test matrix/test]   | test_successful_call (tests.CircuitBreakerRedisTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should keep the circuit closed after a successful ... ok\n[pybreaker test matrix/test]   | test_successful_call_when_halfopen (tests.CircuitBreakerRedisTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should close the circuit when a call succeeds in ... ok\n[pybreaker test matrix/test]   | test_throw_new_error_on_trip_false (tests.CircuitBreakerRedisTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should throw the original exception ... ok\n[pybreaker test matrix/test]   | test_throw_new_error_on_trip_true (tests.CircuitBreakerRedisTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should throw a CircuitBreakerError exception ... ok\n[pybreaker test matrix/test]   | test_traceback_in_circuitbreaker_error (tests.CircuitBreakerRedisTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should open the circuit after many failures. ... ok\n[pybreaker test matrix/test]   | test_transition_events (tests.CircuitBreakerRedisTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should call the appropriate functions on every ... ok\n[pybreaker test matrix/test]   | test_add_excluded_exception (tests.CircuitBreakerTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should allow the user to exclude an exception at a ... ok\n[pybreaker test matrix/test]   | test_add_excluded_exceptions (tests.CircuitBreakerTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should allow the user to exclude exceptions at a ... ok\n[pybreaker test matrix/test]   | test_add_listener (tests.CircuitBreakerTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should allow the user to add a listener at a ... ok\n[pybreaker test matrix/test]   | test_add_listeners (tests.CircuitBreakerTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should allow the user to add listeners at a ... ok\n[pybreaker test matrix/test]   | test_call_async_with_args (tests.CircuitBreakerTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should be able to invoke async functions with args. ... ok\n[pybreaker test matrix/test]   | test_call_async_with_kwargs (tests.CircuitBreakerTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should be able to invoke async functions with kwargs. ... ok\n[pybreaker test matrix/test]   | test_call_async_with_no_args (tests.CircuitBreakerTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should be able to invoke async functions with no-args. ... ok\n[pybreaker test matrix/test]   | test_call_events (tests.CircuitBreakerTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should call the appropriate functions on every ... ok\n[pybreaker test matrix/test]   | test_call_with_args (tests.CircuitBreakerTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should be able to invoke functions with args. ... ok\n[pybreaker test matrix/test]   | test_call_with_kwargs (tests.CircuitBreakerTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should be able to invoke functions with kwargs. ... ok\n[pybreaker test matrix/test]   | test_call_with_no_args (tests.CircuitBreakerTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should be able to invoke functions with no-args. ... ok\n[pybreaker test matrix/test]   | test_close (tests.CircuitBreakerTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should allow the circuit to be closed manually. ... ok\n[pybreaker test matrix/test]   | test_contextmanager (tests.CircuitBreakerTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should catch in a with statement ... ok\n[pybreaker test matrix/test]   | test_create_new_state__bad_state (tests.CircuitBreakerTestCase) ... ok\n[pybreaker test matrix/test]   | test_decorator (tests.CircuitBreakerTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should be a decorator. ... ok\n[pybreaker test matrix/test]   | test_decorator_call_future (tests.CircuitBreakerTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should be a decorator. ... ok\n[pybreaker test matrix/test]   | test_default_params (tests.CircuitBreakerTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should define smart defaults. ... ok\n[pybreaker test matrix/test]   | test_default_state (tests.CircuitBreakerTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should get initial state from state_storage. ... ok\n[pybreaker test matrix/test]   | test_excluded_callable_and_types_exceptions (tests.CircuitBreakerTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should allow a mix of exclusions that includes both filter functions and types. ... ok\n[pybreaker test matrix/test]   | test_excluded_callable_exceptions (tests.CircuitBreakerTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should ignore specific exceptions that return true from a filtering callable. ... ok\n[pybreaker test matrix/test]   | test_excluded_exceptions (tests.CircuitBreakerTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should ignore specific exceptions. ... ok\n[pybreaker test matrix/test]   | test_fail_max_setter (tests.CircuitBreakerTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should allow the user to set a new value for ... ok\n[pybreaker test matrix/test]   | test_failed_call_after_timeout (tests.CircuitBreakerTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should half-open the circuit after timeout. ... ok\n[pybreaker test matrix/test]   | test_failed_call_when_halfopen (tests.CircuitBreakerTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should open the circuit when a call fails in ... ok\n[pybreaker test matrix/test]   | test_failure_count_not_reset_during_creation (tests.CircuitBreakerTestCase) ... ok\n[pybreaker test matrix/test]   | test_generator (tests.CircuitBreakerTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should inspect generator values. ... ok\n[pybreaker test matrix/test]   | test_name (tests.CircuitBreakerTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should allow an optional name to be set and ... ok\n[pybreaker test matrix/test]   | test_new_with_custom_excluded_exceptions (tests.CircuitBreakerTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should support a custom list of excluded ... ok\n[pybreaker test matrix/test]   | test_new_with_custom_fail_max (tests.CircuitBreakerTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should support a custom maximum number of ... ok\n[pybreaker test matrix/test]   | test_new_with_custom_reset_timeout (tests.CircuitBreakerTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should support a custom reset timeout value. ... ok\n[pybreaker test matrix/test]   | test_no_tornado_raises (tests.CircuitBreakerTestCase) ... ok\n[pybreaker test matrix/test]   | test_notify_called_on_state_change (tests.CircuitBreakerTestCase) ... ok\n[pybreaker test matrix/test]   | test_notify_not_called_on_init (tests.CircuitBreakerTestCase) ... ok\n[pybreaker test matrix/test]   | test_one_failed_call (tests.CircuitBreakerTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should keep the circuit closed after a few ... ok\n[pybreaker test matrix/test]   | test_one_successful_call_after_failed_call (tests.CircuitBreakerTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should keep the circuit closed after few mixed ... ok\n[pybreaker test matrix/test]   | test_remove_excluded_exception (tests.CircuitBreakerTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should allow the user to remove an excluded ... ok\n[pybreaker test matrix/test]   | test_remove_listener (tests.CircuitBreakerTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should allow the user to remove a listener. ... ok\n[pybreaker test matrix/test]   | test_reset_timeout_setter (tests.CircuitBreakerTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should allow the user to set a new value for ... ok\n[pybreaker test matrix/test]   | test_several_failed_calls_setting_absent (tests.CircuitBreakerTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should open the circuit after many failures. ... ok\n[pybreaker test matrix/test]   | test_state_opened_at_not_reset_during_creation (tests.CircuitBreakerTestCase) ... ok\n[pybreaker test matrix/test]   | test_successful_after_timeout (tests.CircuitBreakerTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should close the circuit when a call succeeds ... ok\n[pybreaker test matrix/test]   | test_successful_call (tests.CircuitBreakerTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should keep the circuit closed after a successful ... ok\n[pybreaker test matrix/test]   | test_successful_call_when_halfopen (tests.CircuitBreakerTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should close the circuit when a call succeeds in ... ok\n[pybreaker test matrix/test]   | test_throw_new_error_on_trip_false (tests.CircuitBreakerTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should throw the original exception ... ok\n[pybreaker test matrix/test]   | test_throw_new_error_on_trip_true (tests.CircuitBreakerTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should throw a CircuitBreakerError exception ... ok\n[pybreaker test matrix/test]   | test_traceback_in_circuitbreaker_error (tests.CircuitBreakerTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should open the circuit after many failures. ... ok\n[pybreaker test matrix/test]   | test_transition_events (tests.CircuitBreakerTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should call the appropriate functions on every ... ok\n[pybreaker test matrix/test]   | test_fail_max_thread_safety (tests.CircuitBreakerThreadsTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should not allow more failed calls than ... ok\n[pybreaker test matrix/test]   | test_fail_thread_safety (tests.CircuitBreakerThreadsTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should compute a failed call atomically to ... ok\n[pybreaker test matrix/test]   | test_half_open_thread_safety (tests.CircuitBreakerThreadsTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should allow only one trial call when the ... ok\n[pybreaker test matrix/test]   | test_success_thread_safety (tests.CircuitBreakerThreadsTestCase)\n[pybreaker test matrix/test]   | CircuitBreaker: it should compute a successful call atomically ... ok\n[pybreaker test matrix/test]   | \n[pybreaker test matrix/test]   | ----------------------------------------------------------------------\n[pybreaker test matrix/test]   | Ran 75 tests in 7.463s\n[pybreaker test matrix/test]   | \n[pybreaker test matrix/test]   | OK\n[pybreaker test matrix/test]   \u2705  Success - Main Run tests\n[pybreaker test matrix/test] \u2b50 Run Post Set up Python 3.7\n[pybreaker test matrix/test]   \ud83d\udc33  docker exec cmd=[node /var/run/act/actions/actions-setup-python@v4/dist/cache-save/index.js] user= workdir=\n[pybreaker test matrix/test]   \u2705  Success - Post Set up Python 3.7\n[pybreaker test matrix/test] \ud83c\udfc1  Job succeeded\n",
    "actions_stderr": ""
}