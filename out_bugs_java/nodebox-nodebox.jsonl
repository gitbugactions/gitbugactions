{"repository": "nodebox/nodebox", "clone_url": "https://github.com/nodebox/nodebox.git", "timestamp": "2023-05-30T19:52:42.255908Z", "commit_hash": "783ada6d193da8cb2f52e429d48428ba2a2b2ff0", "commit_message": "Removed the geonet node. \nThis fixes #305.\nOld geonet nodes are being replaced by network nodes with their output type set to 'geometry'.\n", "related_issues": "", "bug_patch": "diff --git a/libraries/corevector/corevector.ndbx b/libraries/corevector/corevector.ndbx\nindex 50b87fa..e1c010f 100644\n--- a/libraries/corevector/corevector.ndbx\n+++ b/libraries/corevector/corevector.ndbx\n@@ -112,7 +112,6 @@\n         <node description=\"Draw directly on the canvas using the mouse.\" function=\"corevector/freehand\" handle=\"corevector/freehandHandle\" image=\"freehand.png\" name=\"freehand\" position=\"4.00,5.00\" prototype=\"generator\">\n             <port name=\"path\" range=\"value\" type=\"string\" value=\"\" widget=\"data\" description=\"The internal path data.\"/>\n         </node>\n-        <node category=\"geometry\" description=\"A network of geometry nodes.\" image=\"geonet.png\" name=\"geonet\" outputType=\"geometry\" position=\"14.00,1.00\"/>\n         <node description=\"Create a grid of points.\" function=\"corevector/grid\" handle=\"corevector/fourPointHandle\" image=\"grid.png\" name=\"grid\" outputRange=\"list\" outputType=\"point\" position=\"7.00,5.00\" prototype=\"generator\">\n             <port min=\"1.0\" name=\"columns\" range=\"value\" type=\"int\" value=\"10\" widget=\"int\" description=\"The amount of columns in the grid.\"/>\n             <port min=\"1.0\" name=\"rows\" range=\"value\" type=\"int\" value=\"10\" widget=\"int\" description=\"The amount of rows in the grid.\"/>\ndiff --git a/src/main/java/nodebox/node/NodeLibraryUpgrades.java b/src/main/java/nodebox/node/NodeLibraryUpgrades.java\nindex b158247..ca7614b 100644\n--- a/src/main/java/nodebox/node/NodeLibraryUpgrades.java\n+++ b/src/main/java/nodebox/node/NodeLibraryUpgrades.java\n@@ -267,7 +267,9 @@ public class NodeLibraryUpgrades {\n         UpgradeOp renameNodeOp2 = new ExactRenameNodeOp(\"node\", \"node\");\n         ExactRenameNodeOp renameNodeOp3 = new ExactRenameNodeOp(\"root\", \"node\");\n         renameNodeOp3.skipRootNode();\n-        return transformXml(inputXml, \"16\", renameNodeOp1, renameNodeOp2, renameNodeOp3);\n+        UpgradeOp addAttributeOp = new AddAttributeOp(\"corevector.geonet\", \"outputType\", \"geometry\");\n+        UpgradeOp changePrototypeOp = new ChangePrototypeOp(\"corevector.geonet\", \"core.network\");\n+        return transformXml(inputXml, \"16\", renameNodeOp1, renameNodeOp2, renameNodeOp3, addAttributeOp, changePrototypeOp);\n     }\n \n     private static Set<String> getChildNodeNames(ParentNode parent) {\n@@ -479,6 +481,24 @@ public class NodeLibraryUpgrades {\n         }\n     }\n \n+    private static class AddAttributeOp extends UpgradeOp {\n+        private String prototype;\n+        private String attributeName;\n+        private String attributeValue;\n+\n+        private AddAttributeOp(String prototype, String attributeName, String attributeValue) {\n+            this.prototype = prototype;\n+            this.attributeName = attributeName;\n+            this.attributeValue = attributeValue;\n+        }\n+\n+        public void apply(Element e) {\n+            if (isNodeWithPrototype(e, prototype)) {\n+                e.addAttribute(new Attribute(attributeName, attributeValue));\n+            }\n+        }\n+    }\n+\n     private static class RenameNodeOp extends UpgradeOp {\n         private String oldPrefix;\n         private String newPrefix;\n", "test_patch": "diff --git a/src/test/files/upgrade-v15.ndbx b/src/test/files/upgrade-v15.ndbx\nindex eb3c448..8243b00 100644\n--- a/src/test/files/upgrade-v15.ndbx\n+++ b/src/test/files/upgrade-v15.ndbx\n@@ -22,5 +22,8 @@\n                 </node>\n             </node>\n         </node>\n+        <node name=\"geonet1\" prototype=\"corevector.geonet\" renderedChild=\"ellipse1\">\n+            <node name=\"ellipse1\" prototype=\"corevector.ellipse\"/>\n+        </node>\n     </node>\n </ndbx>\ndiff --git a/src/test/java/nodebox/node/NodeLibraryTest.java b/src/test/java/nodebox/node/NodeLibraryTest.java\nindex 9986652..60e5e48 100644\n--- a/src/test/java/nodebox/node/NodeLibraryTest.java\n+++ b/src/test/java/nodebox/node/NodeLibraryTest.java\n@@ -624,7 +624,8 @@ public class NodeLibraryTest {\n         File version15File = new File(\"src/test/files/upgrade-v15.ndbx\");\n         UpgradeResult result = NodeLibraryUpgrades.upgrade(version15File);\n         NodeLibrary mathLibrary = NodeLibrary.load(new File(\"libraries/math/math.ndbx\"), NodeRepository.of());\n-        NodeLibrary upgradedLibrary = result.getLibrary(version15File, NodeRepository.of(mathLibrary));\n+        NodeLibrary corevectorLibrary = NodeLibrary.load(new File(\"libraries/corevector/corevector.ndbx\"), NodeRepository.of());\n+        NodeLibrary upgradedLibrary = result.getLibrary(version15File, NodeRepository.of(mathLibrary, corevectorLibrary));\n         Node root = upgradedLibrary.getRoot();\n         assertEquals(\"root\", root.getName());\n         assertEquals(\"network2\", root.getRenderedChildName());\n@@ -637,6 +638,8 @@ public class NodeLibraryTest {\n         assertEquals(\"node1\", root.getChild(\"network2\").getRenderedChildName());\n         assertEquals(\"node2\", root.getChild(\"network2\").getChild(\"node1\").getRenderedChildName());\n         assertEquals(17.0, root.getChild(\"network2\").getChild(\"node1\").getChild(\"node2\").getInput(\"value\").getValue());\n+        assertEquals(Node.NETWORK, root.getChild(\"geonet1\").getPrototype());\n+        assertEquals(\"geometry\", root.getChild(\"geonet1\").getOutputType());\n     }\n \n     /**\n"}
{"repository": "nodebox/nodebox", "clone_url": "https://github.com/nodebox/nodebox.git", "timestamp": "2023-05-30T20:02:21.412261Z", "commit_hash": "e1add8e585a7f5fd2fe3694bba231746bd8d3a35", "commit_message": "Fixed issue with having different data types in the same csv column.", "related_issues": "", "bug_patch": "diff --git a/src/main/java/nodebox/function/DataFunctions.java b/src/main/java/nodebox/function/DataFunctions.java\nindex ff7b19d..fe7ec28 100644\n--- a/src/main/java/nodebox/function/DataFunctions.java\n+++ b/src/main/java/nodebox/function/DataFunctions.java\n@@ -74,6 +74,7 @@ public class DataFunctions {\n             String[] headers = reader.readNext();\n \n             Map<String, Integer> headerDuplicates = new HashMap<String, Integer>();\n+            Map<String, Boolean> columnNumerics = new HashMap<String, Boolean>();\n             List<String> tmp = new ArrayList<String>();\n             for (int i = 0; i < headers.length; i++) {\n                 headers[i] = headers[i].trim();\n@@ -91,27 +92,57 @@ public class DataFunctions {\n                     headers[i] = header + \" \" + number;\n                     headerDuplicates.put(header, number);\n                 }\n+                columnNumerics.put(headers[i], null);\n             }\n \n             String[] row;\n \n+            NumberFormat nf = NumberFormat.getNumberInstance(numberSeparator.equals(\"comma\") ? Locale.GERMANY : Locale.US);\n             while ((row = reader.readNext()) != null) {\n                 ImmutableMap.Builder<String, Object> mb = ImmutableMap.builder();\n                 for (int i = 0; i < row.length; i++) {\n                     String header = i < headers.length ? headers[i] : String.format(\"Column %s\", i + 1);\n+                    if (! columnNumerics.containsKey(header))\n+                        columnNumerics.put(header, null);\n+\n                     String v = row[i].trim();\n-                    Object value;\n                     try {\n-                        NumberFormat nf = NumberFormat.getInstance(numberSeparator.equals(\"comma\") ? Locale.GERMANY : Locale.US);\n-                        value = nf.parse(v).doubleValue();\n+                        nf.parse(v).doubleValue();\n+                        if (columnNumerics.get(header) == null)\n+                            columnNumerics.put(header, true);\n                     } catch (ParseException e) {\n-                        value = v;\n+                        columnNumerics.put(header, false);\n                     }\n-                    mb.put(header, value);\n+                    mb.put(header, v);\n                 }\n                 b.add(mb.build());\n             }\n+            List<Map<String, Object>> tempRows = b.build();\n+\n+            List<String> headersNumericCols = new ArrayList<String>();\n+            for (String header : columnNumerics.keySet()) {\n+                if (columnNumerics.get(header) == true)\n+                    headersNumericCols.add(header);\n+            }\n \n+            if (headersNumericCols.isEmpty()) return tempRows;\n+\n+            b = ImmutableList.builder();\n+            for (Map<String, Object> r : tempRows) {\n+                ImmutableMap.Builder<String, Object> mb = ImmutableMap.builder();\n+                for (String header : r.keySet()) {\n+                    if (headersNumericCols.contains(header)) {\n+                        try {\n+                            double d = nf.parse(((String) r.get(header))).doubleValue();\n+                            mb.put(header, d);\n+                        } catch (ParseException e) {\n+                        }\n+                    } else {\n+                        mb.put(header, r.get(header));\n+                    }\n+                }\n+                b.add(mb.build());\n+            }\n             return b.build();\n         } catch (IOException e) {\n             throw new RuntimeException(\"Could not read file \" + fileName + \": \" + e.getMessage(), e);\ndiff --git a/src/test/files/mixed-input.csv b/src/test/files/mixed-input.csv\nnew file mode 100644\nindex 0000000..9bc1a55\n--- /dev/null\n+++ b/src/test/files/mixed-input.csv\n@@ -0,0 +1,3 @@\n+Red,Green,Blue,Alpha\n+100,0,zero,0\n+255,100,0,255\n", "test_patch": "diff --git a/src/test/java/nodebox/function/DataFunctionsTest.java b/src/test/java/nodebox/function/DataFunctionsTest.java\nindex 96daafd..3009604 100644\n--- a/src/test/java/nodebox/function/DataFunctionsTest.java\n+++ b/src/test/java/nodebox/function/DataFunctionsTest.java\n@@ -109,6 +109,14 @@ public class DataFunctionsTest {\n         assertResultsEqual(l.get(1).values(), 2.5, 10.99, 40000.6);\n     }\n \n+    @Test\n+    public void testImportCSVWithMixedInput() {\n+        List<Map<String, Object>> l = importSimpleCSV(\"src/test/files/mixed-input.csv\");\n+        assertEquals(2, l.size());\n+        assertResultsEqual(l.get(0).values(), 100.0, 0.0, \"zero\", 0.0);\n+        assertResultsEqual(l.get(1).values(), 255.0, 100.0, \"0\", 255.0);\n+    }\n+\n     private List<Map<String, Object>> importSimpleCSV(String fileName) {\n         return importCSV(fileName, \"comma\", \"double\", \"period\");\n     }\n"}
{"repository": "nodebox/nodebox", "clone_url": "https://github.com/nodebox/nodebox.git", "timestamp": "2023-05-30T20:06:47.170308Z", "commit_hash": "448306ed0319319bb81bd4c2f94799a63084e55c", "commit_message": "Renamed make_strings node split.\nThis (partially) fixes #264.", "related_issues": "", "bug_patch": "diff --git a/src/main/java/nodebox/node/NodeLibrary.java b/src/main/java/nodebox/node/NodeLibrary.java\nindex a7d3d77..a6ae8fc 100644\n--- a/src/main/java/nodebox/node/NodeLibrary.java\n+++ b/src/main/java/nodebox/node/NodeLibrary.java\n@@ -21,7 +21,7 @@ import static com.google.common.base.Preconditions.*;\n \n public class NodeLibrary {\n \n-    public static final String CURRENT_FORMAT_VERSION = \"14\";\n+    public static final String CURRENT_FORMAT_VERSION = \"15\";\n \n     public static final Splitter PORT_NAME_SPLITTER = Splitter.on(\".\");\n \ndiff --git a/src/main/java/nodebox/node/NodeLibraryUpgrades.java b/src/main/java/nodebox/node/NodeLibraryUpgrades.java\nindex 0424d46..205fd57 100644\n--- a/src/main/java/nodebox/node/NodeLibraryUpgrades.java\n+++ b/src/main/java/nodebox/node/NodeLibraryUpgrades.java\n@@ -55,6 +55,7 @@ public class NodeLibraryUpgrades {\n         upgradeMap.put(\"11\", upgradeMethod(\"upgrade11to12\"));\n         upgradeMap.put(\"12\", upgradeMethod(\"upgrade12to13\"));\n         upgradeMap.put(\"13\", upgradeMethod(\"upgrade13to14\"));\n+        upgradeMap.put(\"14\", upgradeMethod(\"upgrade14to15\"));\n     }\n \n     private static final Pattern formatVersionPattern = Pattern.compile(\"formatVersion=['\\\"]([\\\\d\\\\.]+)['\\\"]\");\n@@ -253,6 +254,11 @@ public class NodeLibraryUpgrades {\n         return transformXml(inputXml, \"14\", renamePortOp1, renamePortOp2);\n     }\n \n+    public static UpgradeStringResult upgrade14to15(String inputXml) throws LoadException {\n+        UpgradeOp renameNodeOp = new RenameNodeOp(\"make_strings\", \"split\");\n+        return transformXml(inputXml, \"15\", renameNodeOp);\n+    }\n+\n     private static Set<String> getChildNodeNames(ParentNode parent) {\n         HashSet<String> names = new HashSet<String>();\n         Nodes children = parent.query(\"node\");\ndiff --git a/src/test/files/upgrade-v14.ndbx b/src/test/files/upgrade-v14.ndbx\nnew file mode 100644\nindex 0000000..a2a835e\n--- /dev/null\n+++ b/src/test/files/upgrade-v14.ndbx\n@@ -0,0 +1,18 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<ndbx formatVersion=\"14\">\n+    <node name=\"root\" outputRange=\"list\" renderedChild=\"length2\">\n+        <node name=\"length1\" prototype=\"string.length\"/>\n+        <node name=\"length2\" prototype=\"string.length\"/>\n+        <node name=\"make_strings1\" prototype=\"string.make_strings\"/>\n+        <node name=\"subnet1\" renderedChild=\"make_strings1\">\n+            <node name=\"make_strings1\" prototype=\"string.make_strings\"/>\n+            <port childReference=\"make_strings1.string\" name=\"string\" range=\"value\" type=\"string\" widget=\"string\"/>\n+        </node>\n+        <node name=\"string1\" prototype=\"string.string\">\n+            <port name=\"value\" type=\"string\" value=\"Kappa;Eta;Theta\"/>\n+        </node>\n+        <conn input=\"length1.string\" output=\"make_strings1\"/>\n+        <conn input=\"subnet1.string\" output=\"string1\"/>\n+        <conn input=\"length2.string\" output=\"subnet1\"/>\n+    </node>\n+</ndbx>\n", "test_patch": "diff --git a/src/test/java/nodebox/node/NodeLibraryTest.java b/src/test/java/nodebox/node/NodeLibraryTest.java\nindex d2a6e16..220566f 100644\n--- a/src/test/java/nodebox/node/NodeLibraryTest.java\n+++ b/src/test/java/nodebox/node/NodeLibraryTest.java\n@@ -595,6 +595,22 @@ public class NodeLibraryTest {\n         assertEquals(20.0, waveNode.getInput(\"offset\").getValue());\n     }\n \n+    @Test\n+    public void testUpgrade14to15() {\n+        File version14File = new File(\"src/test/files/upgrade-v14.ndbx\");\n+        UpgradeResult result = NodeLibraryUpgrades.upgrade(version14File);\n+        NodeLibrary stringLibrary = NodeLibrary.load(new File(\"libraries/string/string.ndbx\"), NodeRepository.of());\n+        NodeLibrary upgradedLibrary = result.getLibrary(version14File, NodeRepository.of(stringLibrary));\n+        Node root = upgradedLibrary.getRoot();\n+        assertTrue(root.hasChild(\"split1\"));\n+        assertEquals(\"split1\", root.getConnection(\"length1\", \"string\").getOutputNode());\n+        Node subnet = root.getChild(\"subnet1\");\n+        assertEquals(\"split1\", subnet.getRenderedChildName());\n+        assertEquals(\"split1.string\", subnet.getInput(\"string\").getChildReference());\n+        assertEquals(\"string1\", root.getConnection(\"subnet1\", \"string\").getOutputNode());\n+        assertEquals(\"subnet1\", root.getConnection(\"length2\", \"string\").getOutputNode());\n+    }\n+\n     /**\n      * Test upgrading from 0.9 files, which should fail since we don't support those conversions.\n      */\n"}
{"repository": "nodebox/nodebox", "clone_url": "https://github.com/nodebox/nodebox.git", "timestamp": "2023-05-30T20:34:31.068306Z", "commit_hash": "900188e434fc6aff7349ec4ba5e3d5179a441ff1", "commit_message": "Clojure libraries no longer need to have a nodes-var at the end.\nThis fixes #292. \n\nThe last statement in the file does still have to be a var though, otherwise the namespace of the file can't be found.", "related_issues": "", "bug_patch": "diff --git a/src/main/java/nodebox/function/ClojureLibrary.java b/src/main/java/nodebox/function/ClojureLibrary.java\nindex 5ff863d..7b7be7b 100644\n--- a/src/main/java/nodebox/function/ClojureLibrary.java\n+++ b/src/main/java/nodebox/function/ClojureLibrary.java\n@@ -59,23 +59,26 @@ final class ClojureLibrary extends FunctionLibrary {\n         // We need a Var as the last statement, because we need to retrieve the current namespace.\n         if (!(returnValue instanceof Var)) {\n             throw new LoadException(file,\n-                    String.format(\"The last statement does not define a var, but %s.\\n\" +\n-                            \"Make sure the last line of your script looks like this:\\n\" +\n-                            \"(def nodes [{:name \\\"foo\\\" :fn inc}])\",\n+                    String.format(\"The last statement does not define a var, but %s.\\n\",\n+                            //\"Make sure the last line of your script looks like this:\\n\" +\n+                            //\"(def nodes [{:name \\\"foo\\\" :fn inc}])\",\n                             returnValue));\n         }\n         Var nodesVar = (Var) returnValue;\n         Namespace ns = nodesVar.ns;\n         String namespace = ns.name.getName();\n-        Object functionMap = nodesVar.deref();\n-        checkStructure(functionMap);\n+\n         ImmutableMap.Builder<String, Function> builder = ImmutableMap.builder();\n-        for (Object item : (Iterable) functionMap) {\n-            Map m = (Map) item;\n-            String name = (String) m.get(NAME);\n-            IFn fn = (IFn) m.get(FN);\n-            Function f = new ClojureFunction(name, fn);\n-            builder.put(name, f);\n+        for (Object item : ns.getMappings()) {\n+            MapEntry entry = (MapEntry) item;\n+            if (entry.getValue() instanceof Var) {\n+                Var var = (Var) entry.getValue();\n+                if (var.ns.toString().equals(namespace) && var instanceof IFn) {\n+                    String name = (String) entry.getKey().toString();\n+                    Function f = new ClojureFunction(name, var.fn());\n+                    builder.put(name, f);\n+                }\n+            }\n         }\n         return new ClojureLibrary(namespace, file, builder.build());\n     }\n@@ -131,23 +134,6 @@ final class ClojureLibrary extends FunctionLibrary {\n         this.functionMap = reloadedLibrary.functionMap;\n     }\n \n-    /**\n-     * We expect a list of maps, each containing name and fn.\n-     *\n-     * @param v The Clojure data structure contained in all-nodes.\n-     */\n-    private static void checkStructure(Object v) {\n-        checkArgument(v instanceof Iterable, \"The function map is not a list of maps but a %s\", v);\n-        Iterable iterable = (Iterable) v;\n-        for (Object item : iterable) {\n-            checkArgument(item instanceof Map, \"The function map is not a list of maps but a %s\", v);\n-            Map m = (Map) item;\n-            checkArgument(m.containsKey(NAME), \"The function map item %s does not contain a name.\", m);\n-            checkArgument(m.containsKey(FN), \"The function map item %s does not contain a fn.\", m);\n-            checkArgument(m.get(FN) instanceof IFn, \"The function map item %s does not point to a Clojure function.\", m.get(\"name\"));\n-        }\n-    }\n-\n     private static final class ClojureFunction implements Function {\n \n         private final String name;\n", "test_patch": "diff --git a/src/test/clojure/math.clj b/src/test/clojure/math.clj\nindex 771760d..9d1abab 100644\n--- a/src/test/clojure/math.clj\n+++ b/src/test/clojure/math.clj\n@@ -1,8 +1,4 @@\n ; Clojure math library for testing.\n (ns clojure-math)\n \n-; The last statement in the file is a var containing a vector with maps for each node.\n-; The name of the var is not important, but it *is* important that it is part of the namespace.\n-(def nodes [{:name \"add\" :fn +}])\n-\n-\n+(def add +)\ndiff --git a/src/test/clojure/strings.clj b/src/test/clojure/strings.clj\nindex 8f5ce2a..9565c37 100644\n--- a/src/test/clojure/strings.clj\n+++ b/src/test/clojure/strings.clj\n@@ -4,7 +4,3 @@\n (defn str-reverse [s]\n   \"Reverse a string\"\n   (apply str (reverse s)))\n-\n-; The last statement in the file is a var containing a vector with maps for each node.\n-; The name of the var is not important, but it *is* important that it is part of the namespace.\n-(def nodes [{:name \"reverse\" :fn str-reverse}])\ndiff --git a/src/test/java/nodebox/function/ClojureLibraryTest.java b/src/test/java/nodebox/function/ClojureLibraryTest.java\nindex bf4a9dc..2e8945f 100644\n--- a/src/test/java/nodebox/function/ClojureLibraryTest.java\n+++ b/src/test/java/nodebox/function/ClojureLibraryTest.java\n@@ -43,5 +43,4 @@ public class ClojureLibraryTest {\n     public void testNoVarAtEnd() {\n         ClojureLibrary.loadScript(\"src/test/clojure/no-var-at-end.clj\");\n     }\n-\n }\n\\ No newline at end of file\n"}
{"repository": "nodebox/nodebox", "clone_url": "https://github.com/nodebox/nodebox.git", "timestamp": "2023-05-30T20:39:20.084250Z", "commit_hash": "b373610b857f2c30a3d770b435a010f4caa5682a", "commit_message": "FunctionLibary also searches inherited methods.\n\nThis fixes a bug in Clojure's way of creating classes from function\nobjects, specifically with relation to memoization.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/nodebox/function/Functions.java b/src/main/java/nodebox/function/Functions.java\nindex 6c26421..2a3ecee 100644\n--- a/src/main/java/nodebox/function/Functions.java\n+++ b/src/main/java/nodebox/function/Functions.java\n@@ -40,7 +40,7 @@ public final class Functions {\n     }\n \n     public static Method findMethod(Class c, String methodName, boolean allowMultiple) {\n-        Method[] methods = c.getDeclaredMethods();\n+        Method[] methods = c.getMethods();\n         Method foundMethod = null;\n         for (Method method : methods) {\n             if (method.getName().equals(methodName)) {\ndiff --git a/src/test/java/nodebox/function/AbstractTestFunctions.java b/src/test/java/nodebox/function/AbstractTestFunctions.java\nnew file mode 100644\nindex 0000000..4723b8e\n--- /dev/null\n+++ b/src/test/java/nodebox/function/AbstractTestFunctions.java\n@@ -0,0 +1,12 @@\n+package nodebox.function;\n+\n+/**\n+ * Abstract base class to test inherited methods.\n+ */\n+public abstract class AbstractTestFunctions {\n+\n+    public static String baseReverse(String s) {\n+        return new StringBuffer(s).reverse().toString();\n+    }\n+\n+}\ndiff --git a/src/test/java/nodebox/function/FunctionsTest.java b/src/test/java/nodebox/function/FunctionsTest.java\nnew file mode 100644\nindex 0000000..570591a\n--- /dev/null\n+++ b/src/test/java/nodebox/function/FunctionsTest.java\n@@ -0,0 +1,18 @@\n+package nodebox.function;\n+\n+import org.junit.Test;\n+\n+import java.lang.reflect.Method;\n+\n+import static junit.framework.Assert.assertEquals;\n+\n+public class FunctionsTest {\n+\n+    @Test\n+    public void testInheritedMethods() {\n+        Method m = Functions.findMethod(TestFunctions.class, \"baseReverse\");\n+        assertEquals(\"baseReverse\", m.getName());\n+        assertEquals(AbstractTestFunctions.class, m.getDeclaringClass());\n+    }\n+\n+}\n", "test_patch": "diff --git a/src/test/java/nodebox/function/TestFunctions.java b/src/test/java/nodebox/function/TestFunctions.java\nindex 446b614..d217e6f 100644\n--- a/src/test/java/nodebox/function/TestFunctions.java\n+++ b/src/test/java/nodebox/function/TestFunctions.java\n@@ -9,12 +9,12 @@ import java.util.List;\n /**\n  * A function library containing special functions for testing.\n  */\n-public class TestFunctions {\n+public class TestFunctions extends AbstractTestFunctions {\n \n     public static final FunctionLibrary LIBRARY;\n \n     static {\n-        LIBRARY = JavaLibrary.ofClass(\"test\", TestFunctions.class, \"allTypes\", \"makeNull\", \"fileExists\", \"makeNestedWords\");\n+        LIBRARY = JavaLibrary.ofClass(\"test\", TestFunctions.class, \"allTypes\", \"baseReverse\", \"makeNull\", \"fileExists\", \"makeNestedWords\");\n     }\n \n     public static String allTypes(int i, float f, String s, Point pt) {\n"}
{"repository": "nodebox/nodebox", "clone_url": "https://github.com/nodebox/nodebox.git", "timestamp": "2023-05-30T20:54:13.105462Z", "commit_hash": "1a08a2149374aa9633ab6ffc3191cc2a1162464d", "commit_message": "The proposed network prefix is now by default 'network' instead of 'subnet'.", "related_issues": "", "bug_patch": "diff --git a/src/main/java/nodebox/node/NodeLibraryController.java b/src/main/java/nodebox/node/NodeLibraryController.java\nindex 014f557..52cdd49 100644\n--- a/src/main/java/nodebox/node/NodeLibraryController.java\n+++ b/src/main/java/nodebox/node/NodeLibraryController.java\n@@ -157,7 +157,7 @@ public class NodeLibraryController {\n             newParent = newParent.withChildRemoved(node.getName());\n         }\n         Node subnet = Node.NETWORK\n-                .withName(newParent.uniqueName(\"subnet\"))\n+                .withName(newParent.uniqueName(\"network\"))\n                 .withChildrenAdded(parent, nodes);\n         List<String> nodeNames = new ArrayList<String>();\n \n", "test_patch": "diff --git a/src/test/java/nodebox/node/NodeLibraryControllerTest.java b/src/test/java/nodebox/node/NodeLibraryControllerTest.java\nindex 1ae2b24..d0385b6 100644\n--- a/src/test/java/nodebox/node/NodeLibraryControllerTest.java\n+++ b/src/test/java/nodebox/node/NodeLibraryControllerTest.java\n@@ -388,8 +388,8 @@ public class NodeLibraryControllerTest {\n         assertTrue(subnet.hasChild(\"negate\"));\n         assertEquals(1, subnet.getConnections().size());\n         assertEquals(1, controller.getRootNode().getChildren().size());\n-        assertSame(subnet, controller.getRootNode().getChild(\"subnet1\"));\n-        assertResultsEqual(controller.getRootNode(), controller.getNode(\"/subnet1\"), -15.0);\n+        assertSame(subnet, controller.getRootNode().getChild(\"network1\"));\n+        assertResultsEqual(controller.getRootNode(), controller.getNode(\"/network1\"), -15.0);\n     }\n \n     @Test\n@@ -418,7 +418,7 @@ public class NodeLibraryControllerTest {\n         assertEquals(1, subnet1.getInputs().size());\n         assertEquals(\"value1\", subnet1.getInputs().get(0).getName());\n         assertEquals(1, root.getConnections().size());\n-        assertEquals(\"radius\", root.getConnection(\"subnet1\", \"value1\").getOutputNode());\n+        assertEquals(\"radius\", root.getConnection(\"network1\", \"value1\").getOutputNode());\n     }\n \n     @Test\n@@ -456,9 +456,9 @@ public class NodeLibraryControllerTest {\n         assertEquals(\"value1_2\", inputs.get(1).getName());\n \n         assertEquals(2, root.getConnections().size());\n-        assertEquals(\"number1\", root.getConnection(\"subnet1\", \"value1_1\").getOutputNode());\n-        assertEquals(\"number1\", root.getConnection(\"subnet1\", \"value1_2\").getOutputNode());\n-        assertResultsEqual(controller.getRootNode(), controller.getNode(\"/subnet1\"), 1.2);\n+        assertEquals(\"number1\", root.getConnection(\"network1\", \"value1_1\").getOutputNode());\n+        assertEquals(\"number1\", root.getConnection(\"network1\", \"value1_2\").getOutputNode());\n+        assertResultsEqual(controller.getRootNode(), controller.getNode(\"/network1\"), 1.2);\n     }\n \n     /**\n@@ -477,7 +477,7 @@ public class NodeLibraryControllerTest {\n         controller.connect(\"/\", numberNode, invert2Node, invert2Node.getInput(\"value\"));\n         controller.setRenderedChild(\"/\", \"number\");\n         controller.groupIntoNetwork(\"/\", ImmutableList.of(numberNode, invert1Node, invert2Node));\n-        assertResultsEqual(controller.getRootNode(), controller.getNode(\"/subnet1\"), 20.0);\n+        assertResultsEqual(controller.getRootNode(), controller.getNode(\"/network1\"), 20.0);\n     }\n \n     private void createSimpleConnection() {\n"}
{"repository": "nodebox/nodebox", "clone_url": "https://github.com/nodebox/nodebox.git", "timestamp": "2023-05-30T20:59:21.905423Z", "commit_hash": "c587486c24bf1390cb20977f85c9fbd5f72c0dbe", "commit_message": "Got rid of excess wiggle nodes. There is now only one.\nThis fixes #227.", "related_issues": "", "bug_patch": "diff --git a/libraries/corevector/corevector.ndbx b/libraries/corevector/corevector.ndbx\nindex f451f16..4b4ff50 100644\n--- a/libraries/corevector/corevector.ndbx\n+++ b/libraries/corevector/corevector.ndbx\n@@ -267,11 +267,5 @@\n             <port name=\"offset\" range=\"value\" type=\"point\" value=\"10.00,10.00\" widget=\"point\" description=\"The maximum amount of translation.\"/>\n             <port name=\"seed\" range=\"value\" type=\"int\" value=\"0\" widget=\"int\" description=\"The random variation.\"/>\n         </node>\n-        <node description=\"Shift points by a random amount.\" function=\"pyvector/wiggle_points\" handle=\"pyvector/handle_wiggle\" image=\"wiggle.png\" name=\"wiggle_points\" position=\"16.00,10.00\" prototype=\"filter\">\n-            <port name=\"offset\" range=\"value\" type=\"point\" value=\"10.00,10.00\" widget=\"point\" description=\"The maximum amount of translation.\"/>\n-            <port name=\"seed\" range=\"value\" type=\"int\" value=\"0\" widget=\"int\" description=\"The random variation.\"/>\n-        </node>\n-        <node description=\"Shift paths by a random amount.\" function=\"pyvector/wiggle_contours\" name=\"wiggle_contours\" position=\"13.00,15.00\" prototype=\"wiggle_points\"/>\n-        <node description=\"Shift paths by a random amount.\" function=\"pyvector/wiggle_paths\" name=\"wiggle_paths\" position=\"10.00,15.00\" prototype=\"wiggle_points\"/>\n     </node>\n </ndbx>\ndiff --git a/src/main/java/nodebox/node/NodeLibrary.java b/src/main/java/nodebox/node/NodeLibrary.java\nindex 6fe01e1..8d7365e 100644\n--- a/src/main/java/nodebox/node/NodeLibrary.java\n+++ b/src/main/java/nodebox/node/NodeLibrary.java\n@@ -21,7 +21,7 @@ import static com.google.common.base.Preconditions.*;\n \n public class NodeLibrary {\n \n-    public static final String CURRENT_FORMAT_VERSION = \"9\";\n+    public static final String CURRENT_FORMAT_VERSION = \"10\";\n \n     public static final Splitter PORT_NAME_SPLITTER = Splitter.on(\".\");\n \ndiff --git a/src/main/java/nodebox/node/NodeLibraryUpgrades.java b/src/main/java/nodebox/node/NodeLibraryUpgrades.java\nindex f58c84c..b4ca5eb 100644\n--- a/src/main/java/nodebox/node/NodeLibraryUpgrades.java\n+++ b/src/main/java/nodebox/node/NodeLibraryUpgrades.java\n@@ -49,6 +49,7 @@ public class NodeLibraryUpgrades {\n         upgradeMap.put(\"6\", upgradeMethod(\"upgrade6to7\"));\n         upgradeMap.put(\"7\", upgradeMethod(\"upgrade7to8\"));\n         upgradeMap.put(\"8\", upgradeMethod(\"upgrade8to9\"));\n+        upgradeMap.put(\"9\", upgradeMethod(\"upgrade9to10\"));\n     }\n \n     private static final Pattern formatVersionPattern = Pattern.compile(\"formatVersion=['\\\"]([\\\\d\\\\.]+)['\\\"]\");\n@@ -198,6 +199,27 @@ public class NodeLibraryUpgrades {\n                 addInputOp2, changePrototypeOp2, renameOp2);\n     }\n \n+    public static UpgradeStringResult upgrade9to10(String inputXml) throws LoadException {\n+        // Version 10: corevector's wiggle_contours, wiggle_paths and wiggle_points nodes\n+        // are replaced by the more generic wiggle node.\n+        UpgradeOp addInputOp1 = new AddInputOp(\"corevector.wiggle_contours\", \"scope\", \"string\", \"contours\");\n+        UpgradeOp changePrototypeOp1 = new ChangePrototypeOp(\"corevector.wiggle_contours\", \"corevector.wiggle\");\n+        UpgradeOp renameOp1 = new RenameNodeOp(\"wiggle_contours\", \"wiggle\");\n+\n+        UpgradeOp addInputOp2 = new AddInputOp(\"corevector.wiggle_paths\", \"scope\", \"string\", \"paths\");\n+        UpgradeOp changePrototypeOp2 = new ChangePrototypeOp(\"corevector.wiggle_paths\", \"corevector.wiggle\");\n+        UpgradeOp renameOp2 = new RenameNodeOp(\"wiggle_paths\", \"wiggle\");\n+\n+        UpgradeOp addInputOp3 = new AddInputOp(\"corevector.wiggle_points\", \"scope\", \"string\", \"points\");\n+        UpgradeOp changePrototypeOp3 = new ChangePrototypeOp(\"corevector.wiggle_points\", \"corevector.wiggle\");\n+        UpgradeOp renameOp3 = new RenameNodeOp(\"wiggle_points\", \"wiggle\");\n+\n+        return transformXml(inputXml, \"10\",\n+                addInputOp1, changePrototypeOp1, renameOp1,\n+                addInputOp2, changePrototypeOp2, renameOp2,\n+                addInputOp3, changePrototypeOp3, renameOp3);\n+    }\n+\n     private static Set<String> getChildNodeNames(ParentNode parent) {\n         HashSet<String> names = new HashSet<String>();\n         Nodes children = parent.query(\"node\");\ndiff --git a/src/test/files/upgrade-v9.ndbx b/src/test/files/upgrade-v9.ndbx\nnew file mode 100644\nindex 0000000..307ea2e\n--- /dev/null\n+++ b/src/test/files/upgrade-v9.ndbx\n@@ -0,0 +1,32 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<ndbx formatVersion=\"9\">\n+    <node name=\"root\">\n+        <node name=\"subnet1\" outputRange=\"list\" renderedChild=\"wiggle_contours2\">\n+            <node name=\"wiggle_contours2\" prototype=\"corevector.wiggle_contours\"/>\n+            <port childReference=\"wiggle_contours2.shape\" name=\"shape\" range=\"value\" type=\"geometry\" widget=\"none\"/>\n+        </node>\n+        <node name=\"subnet2\" outputRange=\"list\" renderedChild=\"wiggle_paths2\">\n+            <node name=\"wiggle_paths2\" prototype=\"corevector.wiggle_paths\"/>\n+            <port childReference=\"wiggle_paths2.shape\" name=\"shape\" range=\"value\" type=\"geometry\" widget=\"none\"/>\n+        </node>\n+        <node name=\"subnet3\" outputRange=\"list\" renderedChild=\"wiggle_points2\">\n+            <node name=\"wiggle_points2\" prototype=\"corevector.wiggle_points\"/>\n+            <port childReference=\"wiggle_points2.shape\" name=\"shape\" range=\"value\" type=\"geometry\" widget=\"none\"/>\n+        </node>\n+        <node name=\"textpath1\" prototype=\"corevector.textpath\">\n+            <port name=\"text\" type=\"string\" value=\"ae\"/>\n+            <port name=\"font_size\" type=\"float\" value=\"100.0\"/>\n+        </node>\n+        <node name=\"wiggle1\" prototype=\"corevector.wiggle\"/>\n+        <node name=\"wiggle_contours1\" prototype=\"corevector.wiggle_contours\"/>\n+        <node name=\"wiggle_paths1\" prototype=\"corevector.wiggle_paths\"/>\n+        <node name=\"wiggle_points1\" prototype=\"corevector.wiggle_points\"/>\n+        <conn input=\"wiggle1.shape\" output=\"textpath1\"/>\n+        <conn input=\"wiggle_contours1.shape\" output=\"textpath1\"/>\n+        <conn input=\"wiggle_paths1.shape\" output=\"textpath1\"/>\n+        <conn input=\"wiggle_points1.shape\" output=\"textpath1\"/>\n+        <conn input=\"subnet1.shape\" output=\"textpath1\"/>\n+        <conn input=\"subnet2.shape\" output=\"textpath1\"/>\n+        <conn input=\"subnet3.shape\" output=\"textpath1\"/>\n+    </node>\n+</ndbx>\n", "test_patch": "diff --git a/src/test/java/nodebox/node/NodeLibraryTest.java b/src/test/java/nodebox/node/NodeLibraryTest.java\nindex 33a95b5..d1f38f5 100644\n--- a/src/test/java/nodebox/node/NodeLibraryTest.java\n+++ b/src/test/java/nodebox/node/NodeLibraryTest.java\n@@ -485,6 +485,31 @@ public class NodeLibraryTest {\n         assertEquals(\"resample1.shape\", subnet2.getInput(\"shape\").getChildReference());\n     }\n \n+    @Test\n+    public void testUpgrade9to10() {\n+        File version9File = new File(\"src/test/files/upgrade-v9.ndbx\");\n+        UpgradeResult result = NodeLibraryUpgrades.upgrade(version9File);\n+        NodeLibrary corevectorLibrary = NodeLibrary.load(new File(\"libraries/corevector/corevector.ndbx\"), NodeRepository.of());\n+        NodeLibrary upgradedLibrary = result.getLibrary(version9File, NodeRepository.of(corevectorLibrary));\n+        Node root = upgradedLibrary.getRoot();\n+        assertTrue(root.hasChild(\"wiggle2\"));\n+        assertTrue(root.hasChild(\"wiggle3\"));\n+        assertTrue(root.hasChild(\"wiggle4\"));\n+        assertEquals(\"wiggle\", root.getChild(\"wiggle2\").getPrototype().getName());\n+        assertEquals(\"contours\", root.getChild(\"wiggle2\").getInput(\"scope\").getValue());\n+        assertEquals(\"paths\", root.getChild(\"wiggle3\").getInput(\"scope\").getValue());\n+        assertEquals(\"points\", root.getChild(\"wiggle4\").getInput(\"scope\").getValue());\n+        assertEquals(7, root.getConnections().size());\n+        assertEquals(\"textpath1\", root.getConnection(\"wiggle2\", \"shape\").getOutputNode());\n+        assertTrue(root.hasChild(\"subnet1\"));\n+        assertEquals(\"wiggle1\", root.getChild(\"subnet1\").getRenderedChildName());\n+        assertEquals(\"wiggle\", root.getChild(\"subnet2\").getChild(\"wiggle1\").getPrototype().getName());\n+        assertEquals(\"contours\", root.getChild(\"subnet1\").getChild(\"wiggle1\").getInput(\"scope\").getValue());\n+        assertEquals(\"paths\", root.getChild(\"subnet2\").getChild(\"wiggle1\").getInput(\"scope\").getValue());\n+        assertEquals(\"points\", root.getChild(\"subnet3\").getChild(\"wiggle1\").getInput(\"scope\").getValue());\n+        assertEquals(\"wiggle1.shape\", root.getChild(\"subnet3\").getInput(\"shape\").getChildReference());\n+    }\n+\n     /**\n      * Test upgrading from 0.9 files, which should fail since we don't support those conversions.\n      */\n"}
{"repository": "nodebox/nodebox", "clone_url": "https://github.com/nodebox/nodebox.git", "timestamp": "2023-05-30T21:03:46.979194Z", "commit_hash": "917779224a7be8c85b04148f4e9057c8f8e7c259", "commit_message": "There is now only one resample node.\nThere were just too many. This fixes #246.\n", "related_issues": "", "bug_patch": "diff --git a/libraries/corevector/corevector.ndbx b/libraries/corevector/corevector.ndbx\nindex f8bfece..f451f16 100644\n--- a/libraries/corevector/corevector.ndbx\n+++ b/libraries/corevector/corevector.ndbx\n@@ -192,13 +192,6 @@\n             <port min=\"1.0\" name=\"points\" range=\"value\" type=\"int\" value=\"10\" widget=\"int\" description=\"The amount of output points.\"/>\n             <port name=\"per_contour\" range=\"value\" type=\"boolean\" value=\"false\" widget=\"toggle\" description=\"If true, the given amount is per contour, not for the whole path.\"/>\n         </node>\n-        <node description=\"Distribute a number of points along a shape.\" function=\"pyvector/resample_by_amount\" image=\"resample.png\" name=\"resample_by_amount\" position=\"4.00,15.00\" prototype=\"filter\">\n-            <port min=\"1.0\" name=\"points\" range=\"value\" type=\"int\" value=\"10\" widget=\"int\" description=\"The amount of output points.\"/>\n-            <port name=\"per_contour\" range=\"value\" type=\"boolean\" value=\"false\" widget=\"toggle\" description=\"If true, the given amount is per contour, not for the whole path.\"/>\n-        </node>\n-        <node description=\"Distribute points evenly along a shape.\" function=\"pyvector/resample_by_length\" image=\"resample.png\" name=\"resample_by_length\" position=\"4.00,14.00\" prototype=\"filter\">\n-            <port min=\"1.0\" name=\"length\" range=\"value\" type=\"float\" value=\"10.0\" widget=\"float\" description=\"The maximum length of each segment.\"/>\n-        </node>\n         <node description=\"Rotate the shape according to the given angle.\" function=\"pyvector/rotate\" handle=\"pyvector/handle_rotate\" image=\"rotate.png\" name=\"rotate\" position=\"16.00,11.00\" prototype=\"filter\">\n             <port name=\"angle\" range=\"value\" type=\"float\" value=\"0.0\" widget=\"float\" description=\"The rotation angle (in degrees).\"/>\n             <port name=\"origin\" range=\"value\" type=\"point\" value=\"0.0,0.0\" widget=\"point\" description=\"The point around which to rotate.\"/>\ndiff --git a/libraries/corevector/pyvector.py b/libraries/corevector/pyvector.py\nindex 141905b..06fc7e1 100644\n--- a/libraries/corevector/pyvector.py\n+++ b/libraries/corevector/pyvector.py\n@@ -551,20 +551,12 @@ def reflect(shape, position, _angle, keep_original):\n         \n     return new_shape\n \n-def resample_by_length(shape, length):\n-    if shape is None: return None\n-    return shape.resampleByLength(length)\n-\n-def resample_by_amount(shape, points, per_contour=False):\n-    if shape is None: return None\n-    return shape.resampleByAmount(points, per_contour)\n-\n def resample(shape, method, length, points, per_contour=False):\n     if shape is None: return None\n     if method == 'length':\n-        return resample_by_length(shape, length)\n+        return shape.resampleByLength(length)\n     else:\n-        return resample_by_amount(shape, points, per_contour)\n+        return shape.resampleByAmount(points, per_contour)\n \n def scatter(shape, amount, seed):\n     \"\"\"Generate points within the boundaries of a shape.\"\"\"\ndiff --git a/src/main/java/nodebox/node/NodeLibrary.java b/src/main/java/nodebox/node/NodeLibrary.java\nindex 2a1a2f4..6fe01e1 100644\n--- a/src/main/java/nodebox/node/NodeLibrary.java\n+++ b/src/main/java/nodebox/node/NodeLibrary.java\n@@ -21,7 +21,7 @@ import static com.google.common.base.Preconditions.*;\n \n public class NodeLibrary {\n \n-    public static final String CURRENT_FORMAT_VERSION = \"8\";\n+    public static final String CURRENT_FORMAT_VERSION = \"9\";\n \n     public static final Splitter PORT_NAME_SPLITTER = Splitter.on(\".\");\n \ndiff --git a/src/main/java/nodebox/node/NodeLibraryUpgrades.java b/src/main/java/nodebox/node/NodeLibraryUpgrades.java\nindex cc99e8e..f58c84c 100644\n--- a/src/main/java/nodebox/node/NodeLibraryUpgrades.java\n+++ b/src/main/java/nodebox/node/NodeLibraryUpgrades.java\n@@ -48,6 +48,7 @@ public class NodeLibraryUpgrades {\n         upgradeMap.put(\"5\", upgradeMethod(\"upgrade5to6\"));\n         upgradeMap.put(\"6\", upgradeMethod(\"upgrade6to7\"));\n         upgradeMap.put(\"7\", upgradeMethod(\"upgrade7to8\"));\n+        upgradeMap.put(\"8\", upgradeMethod(\"upgrade8to9\"));\n     }\n \n     private static final Pattern formatVersionPattern = Pattern.compile(\"formatVersion=['\\\"]([\\\\d\\\\.]+)['\\\"]\");\n@@ -181,6 +182,22 @@ public class NodeLibraryUpgrades {\n         return transformXml(inputXml, \"8\", removeInputOp);\n     }\n \n+    public static UpgradeStringResult upgrade8to9(String inputXml) throws LoadException {\n+        // Version 9: corevector's resample_by_amount and resample_by_length nodes\n+        // are replaced by the more generic resample node.\n+        UpgradeOp addInputOp1 = new AddInputOp(\"corevector.resample_by_amount\", \"method\", \"string\", \"amount\");\n+        UpgradeOp changePrototypeOp1 = new ChangePrototypeOp(\"corevector.resample_by_amount\", \"corevector.resample\");\n+        UpgradeOp renameOp1 = new RenameNodeOp(\"resample_by_amount\", \"resample\");\n+\n+        UpgradeOp addInputOp2 = new AddInputOp(\"corevector.resample_by_length\", \"method\", \"string\", \"length\");\n+        UpgradeOp changePrototypeOp2 = new ChangePrototypeOp(\"corevector.resample_by_length\", \"corevector.resample\");\n+        UpgradeOp renameOp2 = new RenameNodeOp(\"resample_by_length\", \"resample\");\n+\n+        return transformXml(inputXml, \"9\",\n+                addInputOp1, changePrototypeOp1, renameOp1,\n+                addInputOp2, changePrototypeOp2, renameOp2);\n+    }\n+\n     private static Set<String> getChildNodeNames(ParentNode parent) {\n         HashSet<String> names = new HashSet<String>();\n         Nodes children = parent.query(\"node\");\n@@ -469,6 +486,30 @@ public class NodeLibraryUpgrades {\n         }\n     }\n \n+    private static class AddInputOp extends UpgradeOp {\n+        private String nodePrototype;\n+        private String name;\n+        private String type;\n+        private String value;\n+\n+        private AddInputOp(String nodePrototype, String name, String type, String value) {\n+            this.nodePrototype = nodePrototype;\n+            this.name = name;\n+            this.type = type;\n+            this.value = value;\n+        }\n+\n+        @Override\n+        public void apply(Element e) {\n+            if (isNodeWithPrototype(e, nodePrototype)) {\n+                Element port = new Element(\"port\");\n+                port.addAttribute(new Attribute(\"name\", this.name));\n+                port.addAttribute(new Attribute(\"type\", this.type));\n+                port.addAttribute(new Attribute(\"value\", this.value));\n+                e.insertChild(port, 0);\n+            }\n+        }\n+    }\n \n     private static UpgradeStringResult transformXml(String xml, String newFormatVersion, UpgradeOp... ops) {\n         try {\ndiff --git a/src/test/files/upgrade-v8.ndbx b/src/test/files/upgrade-v8.ndbx\nnew file mode 100644\nindex 0000000..f6e3a39\n--- /dev/null\n+++ b/src/test/files/upgrade-v8.ndbx\n@@ -0,0 +1,22 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<ndbx formatVersion=\"8\">\n+    <node name=\"root\">\n+        <node name=\"rect1\" prototype=\"corevector.rect\"/>\n+        <node name=\"resample1\" prototype=\"corevector.resample\"/>\n+        <node name=\"resample_by_amount1\" prototype=\"corevector.resample_by_amount\"/>\n+        <node name=\"resample_by_length1\" prototype=\"corevector.resample_by_length\"/>\n+        <node name=\"subnet1\" outputRange=\"list\" renderedChild=\"resample_by_amount2\">\n+            <node name=\"resample_by_amount2\" prototype=\"corevector.resample_by_amount\"/>\n+            <port childReference=\"resample_by_amount2.shape\" name=\"shape\" range=\"value\" type=\"geometry\" widget=\"none\"/>\n+        </node>\n+        <node name=\"subnet2\" outputRange=\"list\" renderedChild=\"resample_by_length2\">\n+            <node name=\"resample_by_length2\" prototype=\"corevector.resample_by_length\"/>\n+            <port childReference=\"resample_by_length2.shape\" name=\"shape\" range=\"value\" type=\"geometry\" widget=\"none\"/>\n+        </node>\n+        <conn input=\"resample1.shape\" output=\"rect1\"/>\n+        <conn input=\"resample_by_amount1.shape\" output=\"rect1\"/>\n+        <conn input=\"resample_by_length1.shape\" output=\"rect1\"/>\n+        <conn input=\"subnet1.shape\" output=\"rect1\"/>\n+        <conn input=\"subnet2.shape\" output=\"rect1\"/>\n+    </node>\n+</ndbx>\n", "test_patch": "diff --git a/src/test/java/nodebox/node/NodeLibraryTest.java b/src/test/java/nodebox/node/NodeLibraryTest.java\nindex 4f207ee..33a95b5 100644\n--- a/src/test/java/nodebox/node/NodeLibraryTest.java\n+++ b/src/test/java/nodebox/node/NodeLibraryTest.java\n@@ -457,6 +457,34 @@ public class NodeLibraryTest {\n         assertFalse(subnet1.hasInput(\"range\"));\n     }\n \n+    @Test\n+    public void testUpgrade8to9() {\n+        File version8File = new File(\"src/test/files/upgrade-v8.ndbx\");\n+        UpgradeResult result = NodeLibraryUpgrades.upgrade(version8File);\n+        NodeLibrary corevectorLibrary = NodeLibrary.load(new File(\"libraries/corevector/corevector.ndbx\"), NodeRepository.of());\n+        NodeLibrary upgradedLibrary = result.getLibrary(version8File, NodeRepository.of(corevectorLibrary));\n+        Node root = upgradedLibrary.getRoot();\n+        assertTrue(root.hasChild(\"resample2\"));\n+        assertTrue(root.hasChild(\"resample3\"));\n+        assertEquals(\"resample\", root.getChild(\"resample2\").getPrototype().getName());\n+        assertEquals(\"amount\", root.getChild(\"resample2\").getInput(\"method\").getValue());\n+        assertEquals(\"resample\", root.getChild(\"resample3\").getPrototype().getName());\n+        assertEquals(\"length\", root.getChild(\"resample3\").getInput(\"method\").getValue());\n+        assertEquals(\"rect1\", root.getConnection(\"resample2\", \"shape\").getOutputNode());\n+        assertEquals(\"rect1\", root.getConnection(\"resample3\", \"shape\").getOutputNode());\n+        assertTrue(root.hasChild(\"subnet1\"));\n+        Node subnet1 = root.getChild(\"subnet1\");\n+        assertEquals(\"resample1\", subnet1.getRenderedChildName());\n+        assertEquals(\"resample\", subnet1.getChild(\"resample1\").getPrototype().getName());\n+        assertEquals(\"amount\", subnet1.getChild(\"resample1\").getInput(\"method\").getValue());\n+        assertEquals(\"resample1.shape\", subnet1.getInput(\"shape\").getChildReference());\n+        Node subnet2 = root.getChild(\"subnet2\");\n+        assertEquals(\"resample1\", subnet2.getRenderedChildName());\n+        assertEquals(\"resample\", subnet2.getChild(\"resample1\").getPrototype().getName());\n+        assertEquals(\"length\", subnet2.getChild(\"resample1\").getInput(\"method\").getValue());\n+        assertEquals(\"resample1.shape\", subnet2.getInput(\"shape\").getChildReference());\n+    }\n+\n     /**\n      * Test upgrading from 0.9 files, which should fail since we don't support those conversions.\n      */\n"}
{"repository": "nodebox/nodebox", "clone_url": "https://github.com/nodebox/nodebox.git", "timestamp": "2023-05-30T21:08:53.277407Z", "commit_hash": "d7d2351339584c7799654ef03346ea770601ecf1", "commit_message": "point_on_path uses a standard range value of 100.\n\nThis fixes #251.", "related_issues": "", "bug_patch": "diff --git a/libraries/corevector/corevector.ndbx b/libraries/corevector/corevector.ndbx\nindex f6e45df..f8bfece 100644\n--- a/libraries/corevector/corevector.ndbx\n+++ b/libraries/corevector/corevector.ndbx\n@@ -158,8 +158,7 @@\n         </node>\n         <node description=\"Calculate a point on a path.\" function=\"corevector/pointOnPath\" image=\"point_on_path.png\" name=\"point_on_path\" position=\"13.00,11.00\" prototype=\"generator\">\n             <port name=\"shape\" range=\"value\" type=\"geometry\" widget=\"none\" description=\"The input shape.\"/>\n-            <port name=\"t\" range=\"value\" type=\"float\" value=\"0.0\" widget=\"float\" description=\"The relative position on the shape (0 - range).\"/>\n-            <port name=\"range\" range=\"value\" type=\"float\" value=\"100.0\" widget=\"float\" description=\"The upper limit of t.\"/>\n+            <port name=\"t\" range=\"value\" type=\"float\" value=\"0.0\" widget=\"float\" description=\"The relative position on the shape (0 - 100).\"/>\n         </node>\n         <node description=\"Create a multi-sided polygon.\" function=\"pyvector/polygon\" handle=\"pyvector/handle_polygon\" image=\"polygon.png\" name=\"polygon\" position=\"4.00,4.00\" prototype=\"generator\">\n             <port name=\"position\" range=\"value\" type=\"point\" value=\"0.00,0.00\" widget=\"point\" description=\"The center point of the polygon.\"/>\ndiff --git a/src/main/java/nodebox/function/CoreVectorFunctions.java b/src/main/java/nodebox/function/CoreVectorFunctions.java\nindex deb3dda..ce17ce2 100644\n--- a/src/main/java/nodebox/function/CoreVectorFunctions.java\n+++ b/src/main/java/nodebox/function/CoreVectorFunctions.java\n@@ -448,14 +448,13 @@ public class CoreVectorFunctions {\n      * Calculate a point on the given shape.\n      *\n      * @param shape The shape.\n-     * @param t     The position of the point, going from 0.0-range\n-     * @param range The range of the path. If you use 100.0, t=50.0 will be the middle of the path.\n+     * @param t     The position of the point, going from 0.0-100.0\n      * @return The point on the given location of the path.\n      */\n-    public static Point pointOnPath(AbstractGeometry shape, double t, double range) {\n+    public static Point pointOnPath(AbstractGeometry shape, double t) {\n         if (shape == null) return null;\n-        t = Math.abs(t % range);\n-        return shape.pointAt(t / range);\n+        t = Math.abs(t % 100);\n+        return shape.pointAt(t / 100);\n     }\n \n     @SuppressWarnings(\"unchecked\")\ndiff --git a/src/main/java/nodebox/node/NodeLibrary.java b/src/main/java/nodebox/node/NodeLibrary.java\nindex c368ef7..2a1a2f4 100644\n--- a/src/main/java/nodebox/node/NodeLibrary.java\n+++ b/src/main/java/nodebox/node/NodeLibrary.java\n@@ -21,7 +21,7 @@ import static com.google.common.base.Preconditions.*;\n \n public class NodeLibrary {\n \n-    public static final String CURRENT_FORMAT_VERSION = \"7\";\n+    public static final String CURRENT_FORMAT_VERSION = \"8\";\n \n     public static final Splitter PORT_NAME_SPLITTER = Splitter.on(\".\");\n \ndiff --git a/src/main/java/nodebox/node/NodeLibraryUpgrades.java b/src/main/java/nodebox/node/NodeLibraryUpgrades.java\nindex f939e97..cc99e8e 100644\n--- a/src/main/java/nodebox/node/NodeLibraryUpgrades.java\n+++ b/src/main/java/nodebox/node/NodeLibraryUpgrades.java\n@@ -47,6 +47,7 @@ public class NodeLibraryUpgrades {\n         upgradeMap.put(\"4\", upgradeMethod(\"upgrade4to5\"));\n         upgradeMap.put(\"5\", upgradeMethod(\"upgrade5to6\"));\n         upgradeMap.put(\"6\", upgradeMethod(\"upgrade6to7\"));\n+        upgradeMap.put(\"7\", upgradeMethod(\"upgrade7to8\"));\n     }\n \n     private static final Pattern formatVersionPattern = Pattern.compile(\"formatVersion=['\\\"]([\\\\d\\\\.]+)['\\\"]\");\n@@ -174,6 +175,12 @@ public class NodeLibraryUpgrades {\n         return transformXml(inputXml, \"7\", changePrototypeOp, renameOp);\n     }\n \n+    public static UpgradeStringResult upgrade7to8(String inputXml) throws LoadException {\n+        // Version 8: The corevector.point_on_path node loses the range port.\n+        UpgradeOp removeInputOp = new RemoveInputOp(\"corevector.point_on_path\", \"range\");\n+        return transformXml(inputXml, \"8\", removeInputOp);\n+    }\n+\n     private static Set<String> getChildNodeNames(ParentNode parent) {\n         HashSet<String> names = new HashSet<String>();\n         Nodes children = parent.query(\"node\");\ndiff --git a/src/test/files/upgrade-v7.ndbx b/src/test/files/upgrade-v7.ndbx\nnew file mode 100644\nindex 0000000..a5d3e68\n--- /dev/null\n+++ b/src/test/files/upgrade-v7.ndbx\n@@ -0,0 +1,17 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<ndbx formatVersion=\"4\">\n+    <node name=\"root\">\n+        <node name=\"number1\" prototype=\"math.number\">\n+            <port name=\"value\" type=\"float\" value=\"50.0\"/>\n+        </node>\n+        <node name=\"subnet1\" renderedChild=\"point_on_path3\">\n+            <node name=\"point_on_path3\" prototype=\"corevector.point_on_path\"/>\n+            <port childReference=\"point_on_path3.range\" min=\"0.0\" name=\"range\" range=\"value\" type=\"float\" value=\"0.0\" widget=\"float\"/>\n+        </node>\n+        <node name=\"point_on_path1\" prototype=\"corevector.point_on_path\">\n+            <port name=\"range\" type=\"float\" value=\"50.0\"/>\n+        </node>\n+        <node name=\"point_on_path2\" prototype=\"corevector.point_on_path\"/>\n+        <conn input=\"point_on_path2.range\" output=\"number1\"/>\n+    </node>\n+</ndbx>\n", "test_patch": "diff --git a/src/test/java/nodebox/node/NodeLibraryTest.java b/src/test/java/nodebox/node/NodeLibraryTest.java\nindex c7d3ec6..4f207ee 100644\n--- a/src/test/java/nodebox/node/NodeLibraryTest.java\n+++ b/src/test/java/nodebox/node/NodeLibraryTest.java\n@@ -443,6 +443,20 @@ public class NodeLibraryTest {\n         assertResultsEqual(root, 0.0, 2.0, 4.0, 6.0, 8.0);\n     }\n \n+    @Test\n+    public void testUpgrade7to8() {\n+        File version7File = new File(\"src/test/files/upgrade-v7.ndbx\");\n+        UpgradeResult result = NodeLibraryUpgrades.upgrade(version7File);\n+        NodeLibrary corevectorLibrary = NodeLibrary.load(new File(\"libraries/corevector/corevector.ndbx\"), NodeRepository.of());\n+        NodeLibrary mathLibrary = NodeLibrary.load(new File(\"libraries/math/math.ndbx\"), NodeRepository.of());\n+        NodeLibrary upgradedLibrary = result.getLibrary(version7File, NodeRepository.of(corevectorLibrary, mathLibrary));\n+        Node root = upgradedLibrary.getRoot();\n+        assertFalse(root.getChild(\"point_on_path1\").hasInput(\"range\"));\n+        assertNull(root.getConnection(\"point_on_path2\", \"range\"));\n+        Node subnet1 = root.getChild(\"subnet1\");\n+        assertFalse(subnet1.hasInput(\"range\"));\n+    }\n+\n     /**\n      * Test upgrading from 0.9 files, which should fail since we don't support those conversions.\n      */\n"}
{"repository": "nodebox/nodebox", "clone_url": "https://github.com/nodebox/nodebox.git", "timestamp": "2023-05-30T21:14:47.173070Z", "commit_hash": "5606225497efe36b1946b665fcbd54101358228e", "commit_message": "'first', 'second' and 'last' nodes return a single Object instead of a one element list.\nThis fixes #231.", "related_issues": "", "bug_patch": "diff --git a/libraries/list/list.ndbx b/libraries/list/list.ndbx\nindex 67ee32e..981b688 100644\n--- a/libraries/list/list.ndbx\n+++ b/libraries/list/list.ndbx\n@@ -21,10 +21,10 @@\n             <port name=\"list\" range=\"list\" type=\"list\" widget=\"none\" description=\"The input list.\"/>\n             <port name=\"booleans\" range=\"list\" type=\"list\" widget=\"none\" description=\"A list of boolean values. If the corresponding value is true, the item will be retained.\"/>\n         </node>\n-        <node description=\"Take the first item of the list.\" function=\"list/first\" image=\"first.png\" name=\"first\" outputType=\"list\" position=\"1.00,4.00\" category=\"list\">\n+        <node description=\"Take the first item of the list.\" function=\"list/first\" image=\"first.png\" name=\"first\" outputType=\"data\" position=\"1.00,4.00\" category=\"list\">\n             <port name=\"list\" range=\"list\" type=\"list\" widget=\"none\" description=\"The input list.\"/>\n         </node>\n-        <node description=\"Take the last item of the list.\" function=\"list/last\" image=\"last.png\" name=\"last\" outputType=\"list\" position=\"1.00,7.00\" category=\"list\">\n+        <node description=\"Take the last item of the list.\" function=\"list/last\" image=\"last.png\" name=\"last\" outputType=\"data\" position=\"1.00,7.00\" category=\"list\">\n             <port name=\"list\" range=\"list\" type=\"list\" widget=\"none\" description=\"The input list.\"/>\n         </node>\n         <node description=\"Pick items from the list in random order.\" function=\"list/pick\" image=\"generic.png\" name=\"pick\" outputRange=\"list\" outputType=\"list\" position=\"7.00,3.00\" category=\"list\">\n@@ -43,7 +43,7 @@\n         <node description=\"Reverse the list.\" function=\"list/reverse\" image=\"generic.png\" name=\"reverse\" outputRange=\"list\" outputType=\"list\" position=\"4.00,5.00\" category=\"list\">\n             <port name=\"list\" range=\"list\" type=\"list\" widget=\"none\" description=\"The input list.\"/>\n         </node>\n-        <node description=\"Take the second item of the list.\" function=\"list/second\" image=\"second.png\" name=\"second\" outputType=\"list\" position=\"1.00,5.00\" category=\"list\">\n+        <node description=\"Take the second item of the list.\" function=\"list/second\" image=\"second.png\" name=\"second\" outputType=\"data\" position=\"1.00,5.00\" category=\"list\">\n             <port name=\"list\" range=\"list\" type=\"list\" widget=\"none\" description=\"The input list.\"/>\n         </node>\n         <node description=\"Move items at the beginning of the list to the end.\" function=\"list/shift\" image=\"generic.png\" name=\"shift\" outputRange=\"list\" outputType=\"list\" position=\"7.00,4.00\" category=\"list\">\ndiff --git a/src/main/java/nodebox/function/ListFunctions.java b/src/main/java/nodebox/function/ListFunctions.java\nindex bd40799..02d98f4 100644\n--- a/src/main/java/nodebox/function/ListFunctions.java\n+++ b/src/main/java/nodebox/function/ListFunctions.java\n@@ -52,33 +52,33 @@ public class ListFunctions {\n      * Take the first item of the list.\n      *\n      * @param iterable The list items.\n-     * @return A new list with only the first item.\n+     * @return The first item of the list.\n      */\n-    public static List<?> first(Iterable<?> iterable) {\n-        if (iterable == null) return ImmutableList.of();\n+    public static Object first(Iterable<?> iterable) {\n+        if (iterable == null) return null;\n         Iterator iterator = iterable.iterator();\n         if (iterator.hasNext()) {\n-            return ImmutableList.of(iterator.next());\n+            return iterator.next();\n         }\n-        return ImmutableList.of();\n+        return null;\n     }\n \n     /**\n      * Take the second item of the list.\n      *\n      * @param iterable The list items.\n-     * @return A new list with only the second item.\n+     * @return The second item of the list.\n      */\n-    public static List<?> second(Iterable<?> iterable) {\n-        if (iterable == null) return ImmutableList.of();\n+    public static Object second(Iterable<?> iterable) {\n+        if (iterable == null) return null;\n         Iterator iterator = iterable.iterator();\n         if (iterator.hasNext()) {\n             iterator.next();\n             if (iterator.hasNext()) {\n-                return ImmutableList.of(iterator.next());\n+                return iterator.next();\n             }\n         }\n-        return ImmutableList.of();\n+        return null;\n     }\n \n     /**\n@@ -97,14 +97,14 @@ public class ListFunctions {\n      * Take the last item of the list.\n      *\n      * @param iterable The list items.\n-     * @return A new list with only the last item.\n+     * @return The last item of the list.\n      */\n-    public static List<?> last(Iterable<?> iterable) {\n-        if (iterable == null) return ImmutableList.of();\n+    public static Object last(Iterable<?> iterable) {\n+        if (iterable == null) return null;\n         try {\n-            return ImmutableList.of(Iterables.getLast(iterable));\n+            return Iterables.getLast(iterable);\n         } catch (NoSuchElementException e) {\n-            return ImmutableList.of();\n+            return null;\n         }\n     }\n \n", "test_patch": "diff --git a/src/test/java/nodebox/function/ListFunctionsTest.java b/src/test/java/nodebox/function/ListFunctionsTest.java\nindex 2e46bb7..f1464a1 100644\n--- a/src/test/java/nodebox/function/ListFunctionsTest.java\n+++ b/src/test/java/nodebox/function/ListFunctionsTest.java\n@@ -6,6 +6,7 @@ import nodebox.node.polygraph.Point;\n import org.junit.Test;\n \n import static junit.framework.Assert.assertEquals;\n+import static junit.framework.Assert.assertNull;\n \n public class ListFunctionsTest {\n \n@@ -18,18 +19,18 @@ public class ListFunctionsTest {\n \n     @Test\n     public void testFirst() {\n-        assertElements(ListFunctions.first(ImmutableList.of()));\n-        assertElements(ListFunctions.first(ImmutableList.of(1)), 1);\n-        assertElements(ListFunctions.first(ImmutableList.of(1, 2)), 1);\n-        assertElements(ListFunctions.first(ImmutableList.of(1, 2, 3)), 1);\n+        assertNull(ListFunctions.first(ImmutableList.of()));\n+        assertEquals(ListFunctions.first(ImmutableList.of(1)), 1);\n+        assertEquals(ListFunctions.first(ImmutableList.of(1, 2)), 1);\n+        assertEquals(ListFunctions.first(ImmutableList.of(1, 2, 3)), 1);\n     }\n \n     @Test\n     public void testSecond() {\n-        assertElements(ListFunctions.second(ImmutableList.of()));\n-        assertElements(ListFunctions.second(ImmutableList.of(1)));\n-        assertElements(ListFunctions.second(ImmutableList.of(1, 2)), 2);\n-        assertElements(ListFunctions.second(ImmutableList.of(1, 2, 3)), 2);\n+        assertNull(ListFunctions.second(ImmutableList.of()));\n+        assertNull(ListFunctions.second(ImmutableList.of(1)));\n+        assertEquals(ListFunctions.second(ImmutableList.of(1, 2)), 2);\n+        assertEquals(ListFunctions.second(ImmutableList.of(1, 2, 3)), 2);\n     }\n \n     @Test\n@@ -42,10 +43,10 @@ public class ListFunctionsTest {\n \n     @Test\n     public void testLast() {\n-        assertElements(ListFunctions.last(ImmutableList.of()));\n-        assertElements(ListFunctions.last(ImmutableList.of(1)), 1);\n-        assertElements(ListFunctions.last(ImmutableList.of(1, 2)), 2);\n-        assertElements(ListFunctions.last(ImmutableList.of(1, 2, 3)), 3);\n+        assertNull(ListFunctions.last(ImmutableList.of()));\n+        assertEquals(ListFunctions.last(ImmutableList.of(1)), 1);\n+        assertEquals(ListFunctions.last(ImmutableList.of(1, 2)), 2);\n+        assertEquals(ListFunctions.last(ImmutableList.of(1, 2, 3)), 3);\n     }\n \n     @Test\n"}
{"repository": "nodebox/nodebox", "clone_url": "https://github.com/nodebox/nodebox.git", "timestamp": "2023-05-30T21:18:56.143080Z", "commit_hash": "75c9b4948c4c7d517a8747e3b3b242a61917a049", "commit_message": "Remove the filter node.\n\nThe behavior of the filter node and the cull node is nearly identical.\nSince we prefer having the filter name available for when we support\nhigher-order functions, we'll remove it now and replace it with cull.\n\nUpgrade existing files to change all instances of the filter node with\nthe cull node.\n\nThis fixes #242.\n", "related_issues": "", "bug_patch": "diff --git a/libraries/list/list.ndbx b/libraries/list/list.ndbx\nindex 67ee32e..29b65da 100644\n--- a/libraries/list/list.ndbx\n+++ b/libraries/list/list.ndbx\n@@ -17,10 +17,6 @@\n         <node description=\"Remove all duplicate items from the list.\" function=\"list/distinct\" image=\"generic.png\" name=\"distinct\" outputRange=\"list\" outputType=\"list\" position=\"7.00,5.00\" category=\"list\">\n             <port name=\"list\" range=\"list\" type=\"list\" widget=\"none\" description=\"The input list.\"/>\n         </node>\n-        <node description=\"Filter the list.\" function=\"list/filter\" image=\"generic.png\" name=\"filter\" outputRange=\"list\" outputType=\"list\" position=\"1.00,2.00\" category=\"list\">\n-            <port name=\"list\" range=\"list\" type=\"list\" widget=\"none\" description=\"The input list.\"/>\n-            <port name=\"booleans\" range=\"list\" type=\"list\" widget=\"none\" description=\"A list of boolean values. If the corresponding value is true, the item will be retained.\"/>\n-        </node>\n         <node description=\"Take the first item of the list.\" function=\"list/first\" image=\"first.png\" name=\"first\" outputType=\"list\" position=\"1.00,4.00\" category=\"list\">\n             <port name=\"list\" range=\"list\" type=\"list\" widget=\"none\" description=\"The input list.\"/>\n         </node>\ndiff --git a/libraries/math/math.ndbx b/libraries/math/math.ndbx\nindex 888bfb8..27d6afd 100644\n--- a/libraries/math/math.ndbx\n+++ b/libraries/math/math.ndbx\n@@ -70,6 +70,9 @@\n         <node category=\"math\" description=\"Round down the value of a number.\" function=\"math/floor\" image=\"generic.png\" name=\"floor\" position=\"7.00,3.00\">\n             <port name=\"value\" range=\"value\" type=\"float\" value=\"0.0\" widget=\"float\" description=\"The input value.\"/>\n         </node>\n+        <node category=\"math\" description=\"Determine if a number is even.\" function=\"math/even\" image=\"generic.png\" name=\"even\" position=\"7.00,3.00\">\n+            <port name=\"value\" range=\"value\" type=\"int\" value=\"0\" widget=\"int\" description=\"The input value.\"/>\n+        </node>\n         <node category=\"math\" description=\"Create an integer value that can be used as a variable.\" function=\"math/integer\" image=\"generic.png\" name=\"integer\" outputType=\"int\" position=\"4.00,7.00\">\n             <port name=\"value\" range=\"value\" type=\"int\" value=\"0\" widget=\"int\" description=\"The input value.\"/>\n         </node>\n@@ -100,6 +103,9 @@\n         <node category=\"math\" description=\"Create a floating-point value that can be used as a variable.\" function=\"math/number\" image=\"generic.png\" name=\"number\" position=\"1.00,1.00\">\n             <port name=\"value\" range=\"value\" type=\"float\" value=\"0.0\" widget=\"float\" description=\"The input value.\"/>\n         </node>\n+        <node category=\"math\" description=\"Determine if a number is odd.\" function=\"math/odd\" image=\"generic.png\" name=\"odd\" position=\"7.00,3.00\">\n+            <port name=\"value\" range=\"value\" type=\"int\" value=\"0\" widget=\"int\" description=\"The input value.\"/>\n+        </node>\n         <node category=\"math\" description=\"The value of the mathematical constant pi.\" function=\"math/pi\" name=\"pi\" image=\"generic.png\" position=\"13.00,6.00\"/>\n         <node category=\"math\" description=\"Calculate the power of a number.\" function=\"math/pow\" image=\"generic.png\" name=\"pow\" position=\"7.00,7.00\">\n             <port name=\"value1\" range=\"value\" type=\"float\" value=\"0.0\" widget=\"float\" description=\"The first value.\"/>\ndiff --git a/src/main/java/nodebox/function/ListFunctions.java b/src/main/java/nodebox/function/ListFunctions.java\nindex bd40799..b555d6e 100644\n--- a/src/main/java/nodebox/function/ListFunctions.java\n+++ b/src/main/java/nodebox/function/ListFunctions.java\n@@ -32,7 +32,7 @@ public class ListFunctions {\n                 \"count\",\n                 \"first\", \"second\", \"rest\", \"last\",\n                 \"combine\", \"slice\", \"shift\", \"doSwitch\",\n-                \"distinct\", \"repeat\", \"reverse\", \"sort\", \"shuffle\", \"pick\", \"filter\", \"cull\", \"takeEvery\");\n+                \"distinct\", \"repeat\", \"reverse\", \"sort\", \"shuffle\", \"pick\", \"cull\", \"takeEvery\");\n     }\n \n     /**\n@@ -309,36 +309,6 @@ public class ListFunctions {\n     }\n \n     /**\n-     * Filter a list of elements using a true/false pattern.\n-     *\n-     * @param iterable The list to filter.\n-     * @param booleans The pattern that determines which elements are retained and which are not.\n-     * @return The filtered list.\n-     */\n-    public static List<?> filter(Iterable<?> iterable, Iterable<Boolean> booleans) {\n-        if (iterable == null) return ImmutableList.of();\n-        if (booleans == null) return ImmutableList.copyOf(iterable);\n-        if (Iterables.size(booleans) == 1) {\n-            if (Iterables.getFirst(booleans, false))\n-                return ImmutableList.copyOf(iterable);\n-            else\n-                return ImmutableList.of();\n-        }\n-        List<?> l = Lists.newArrayList(iterable);\n-        List<Boolean> b = Lists.newArrayList(booleans);\n-        List<Object> newList = new ArrayList<Object>();\n-        int min = Math.min(l.size(), b.size());\n-        for (int i = 0; i < min; i++) {\n-            boolean keep = b.get(i);\n-            if (keep)\n-                newList.add(l.get(i));\n-        }\n-        if (b.size() < l.size())\n-            newList.addAll(l.subList(b.size(), l.size()));\n-        return ImmutableList.copyOf(newList);\n-    }\n-\n-    /**\n      * Cull a list of elements using a true/false pattern.\n      *\n      * @param iterable The list to filter.\ndiff --git a/src/main/java/nodebox/node/NodeLibrary.java b/src/main/java/nodebox/node/NodeLibrary.java\nindex 0ff7ba8..c368ef7 100644\n--- a/src/main/java/nodebox/node/NodeLibrary.java\n+++ b/src/main/java/nodebox/node/NodeLibrary.java\n@@ -21,7 +21,7 @@ import static com.google.common.base.Preconditions.*;\n \n public class NodeLibrary {\n \n-    public static final String CURRENT_FORMAT_VERSION = \"6\";\n+    public static final String CURRENT_FORMAT_VERSION = \"7\";\n \n     public static final Splitter PORT_NAME_SPLITTER = Splitter.on(\".\");\n \ndiff --git a/src/main/java/nodebox/node/NodeLibraryUpgrades.java b/src/main/java/nodebox/node/NodeLibraryUpgrades.java\nindex 7366b0f..f939e97 100644\n--- a/src/main/java/nodebox/node/NodeLibraryUpgrades.java\n+++ b/src/main/java/nodebox/node/NodeLibraryUpgrades.java\n@@ -46,6 +46,7 @@ public class NodeLibraryUpgrades {\n         upgradeMap.put(\"3\", upgradeMethod(\"upgrade3to4\"));\n         upgradeMap.put(\"4\", upgradeMethod(\"upgrade4to5\"));\n         upgradeMap.put(\"5\", upgradeMethod(\"upgrade5to6\"));\n+        upgradeMap.put(\"6\", upgradeMethod(\"upgrade6to7\"));\n     }\n \n     private static final Pattern formatVersionPattern = Pattern.compile(\"formatVersion=['\\\"]([\\\\d\\\\.]+)['\\\"]\");\n@@ -159,13 +160,20 @@ public class NodeLibraryUpgrades {\n     }\n \n     public static UpgradeStringResult upgrade5to6(String inputXml) throws LoadException {\n-        // Version 6: change delete.delete_selected boolean to menu options.\n+        // Version 6: Change delete.delete_selected boolean to menu options.\n         Map<String, String> mappings = ImmutableMap.of(\"true\", \"selected\", \"false\", \"non-selected\");\n         UpgradeOp renamePortOp = new RenamePortOp(\"corevector.delete\", \"delete_selected\", \"operation\");\n         UpgradeOp changePortTypeOp = new ChangePortTypeOp(\"corevector.delete\", \"operation\", \"string\", mappings);\n         return transformXml(inputXml, \"6\", renamePortOp, changePortTypeOp);\n     }\n \n+    public static UpgradeStringResult upgrade6to7(String inputXml) throws LoadException {\n+        // Version 7: Replace instances of list.filter with list.cull.\n+        UpgradeOp changePrototypeOp = new ChangePrototypeOp(\"list.filter\", \"list.cull\");\n+        UpgradeOp renameOp = new RenameNodeOp(\"filter\", \"cull\");\n+        return transformXml(inputXml, \"7\", changePrototypeOp, renameOp);\n+    }\n+\n     private static Set<String> getChildNodeNames(ParentNode parent) {\n         HashSet<String> names = new HashSet<String>();\n         Nodes children = parent.query(\"node\");\ndiff --git a/src/test/files/upgrade-v6.ndbx b/src/test/files/upgrade-v6.ndbx\nnew file mode 100644\nindex 0000000..4eb78bc\n--- /dev/null\n+++ b/src/test/files/upgrade-v6.ndbx\n@@ -0,0 +1,1 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r<ndbx formatVersion=\"6\" type=\"file\" uuid=\"6b02dc73-194e-465f-b0fe-aed92a109404\">\r    <node name=\"root\" outputRange=\"list\" renderedChild=\"filter1\">\r        <node name=\"even1\" position=\"3.00,3.00\" prototype=\"math.even\"/>\r        <node name=\"filter1\" position=\"2.00,5.00\" prototype=\"list.filter\"/>\r        <node name=\"range1\" position=\"2.00,1.00\" prototype=\"math.range\"/>\r        <conn input=\"even1.value\" output=\"range1\"/>\r        <conn input=\"filter1.list\" output=\"range1\"/>\r        <conn input=\"filter1.booleans\" output=\"even1\"/>\r    </node>\r</ndbx>\r\n\\ No newline at end of file\n", "test_patch": "diff --git a/src/test/java/nodebox/function/ListFunctionsTest.java b/src/test/java/nodebox/function/ListFunctionsTest.java\nindex 2e46bb7..32ebef8 100644\n--- a/src/test/java/nodebox/function/ListFunctionsTest.java\n+++ b/src/test/java/nodebox/function/ListFunctionsTest.java\n@@ -113,16 +113,6 @@ public class ListFunctionsTest {\n     }\n \n     @Test\n-    public void testFilter() {\n-        assertElements(ListFunctions.filter(ImmutableList.of(), ImmutableList.<Boolean>of()));\n-        assertElements(ListFunctions.filter(ImmutableList.of(1, 2, 3, 4, 5), ImmutableList.of(true, false, false, true, true)), 1, 4, 5);\n-        assertElements(ListFunctions.filter(ImmutableList.of(1, 2, 3, 4, 5), ImmutableList.of(true, false, true, false, true, false, true)), 1, 3, 5);\n-        assertElements(ListFunctions.filter(ImmutableList.of(1, 2, 3), ImmutableList.<Boolean>of()), 1, 2, 3);\n-        assertElements(ListFunctions.filter(ImmutableList.of(1, 2, 3), ImmutableList.of(true)), 1, 2, 3);\n-        assertElements(ListFunctions.filter(ImmutableList.of(1, 2, 3), ImmutableList.of(false)));\n-    }\n-\n-    @Test\n     public void testCull() {\n         assertElements(ListFunctions.cull(ImmutableList.of(), ImmutableList.<Boolean>of()));\n         assertElements(ListFunctions.cull(ImmutableList.of(1, 2, 3), ImmutableList.<Boolean>of()), 1, 2, 3);\ndiff --git a/src/test/java/nodebox/node/NodeLibraryTest.java b/src/test/java/nodebox/node/NodeLibraryTest.java\nindex 6c98bf2..c7d3ec6 100644\n--- a/src/test/java/nodebox/node/NodeLibraryTest.java\n+++ b/src/test/java/nodebox/node/NodeLibraryTest.java\n@@ -429,6 +429,20 @@ public class NodeLibraryTest {\n         assertEquals(\"non-selected\", delete2.getInput(\"operation\").stringValue());\n     }\n \n+    @Test\n+    public void testUpgrade6to7() {\n+        File version6File = new File(\"src/test/files/upgrade-v6.ndbx\");\n+        UpgradeResult result = NodeLibraryUpgrades.upgrade(version6File);\n+        NodeLibrary listLibrary = NodeLibrary.load(new File(\"libraries/list/list.ndbx\"), NodeRepository.of());\n+        NodeLibrary mathLibrary = NodeLibrary.load(new File(\"libraries/math/math.ndbx\"), NodeRepository.of());\n+        NodeLibrary upgradedLibrary = result.getLibrary(version6File, NodeRepository.of(listLibrary, mathLibrary));\n+        Node root = upgradedLibrary.getRoot();\n+        assertFalse(root.hasChild(\"filter1\"));\n+        assertTrue(root.hasChild(\"cull1\"));\n+        assertEquals(\"cull1\", root.getRenderedChildName());\n+        assertResultsEqual(root, 0.0, 2.0, 4.0, 6.0, 8.0);\n+    }\n+\n     /**\n      * Test upgrading from 0.9 files, which should fail since we don't support those conversions.\n      */\n"}
{"repository": "nodebox/nodebox", "clone_url": "https://github.com/nodebox/nodebox.git", "timestamp": "2023-05-30T21:24:33.387768Z", "commit_hash": "e5c38d6b803deaad93f4238ca2277c1863fae0e7", "commit_message": "Replace \"delete_selected\" flag with option menu.\n\nIt's hard to understand the meaning of the \"delete_selected\" flag, and\ncertainly the inverse. Change the flag to an \"operation\" menu with\noptions \"delete selected\" and \"delete non-selected\".\n\nThis fixes #257.\n", "related_issues": "", "bug_patch": "diff --git a/libraries/corevector/corevector.ndbx b/libraries/corevector/corevector.ndbx\nindex 21fbaa0..f6e45df 100644\n--- a/libraries/corevector/corevector.ndbx\n+++ b/libraries/corevector/corevector.ndbx\n@@ -74,7 +74,10 @@\n                 <menu key=\"points\" label=\"Points\"/>\n                 <menu key=\"paths\" label=\"Paths\"/>\n             </port>\n-            <port name=\"delete_selected\" range=\"value\" type=\"boolean\" value=\"true\" widget=\"toggle\" description=\"Invert the operation of the node.\"/>\n+            <port name=\"operation\" range=\"value\" type=\"string\" widget=\"menu\" value=\"selected\" description=\"Whether to delete the selected or non-selected points or paths.\">\n+                <menu key=\"selected\" label=\"Delete Selected\"/>\n+                <menu key=\"non-selected\" label=\"Delete Non-selected\"/>\n+            </port>\n         </node>\n         <node description=\"Distribute shapes on a horizontal or vertical axis.\" function=\"pyvector/distribute\" image=\"distribute.png\" name=\"distribute\" position=\"10.00,12.00\" prototype=\"generator\" outputRange=\"list\">\n             <port name=\"shapes\" range=\"list\" type=\"geometry\" widget=\"none\" description=\"The list of shapes to distribute.\"/>\ndiff --git a/libraries/corevector/pyvector.py b/libraries/corevector/pyvector.py\nindex 27c27f6..141905b 100644\n--- a/libraries/corevector/pyvector.py\n+++ b/libraries/corevector/pyvector.py\n@@ -238,9 +238,10 @@ def delete_paths(geo, bounding, delete_selected=True):\n             new_geo.add(old_path.clone())\n     return new_geo\n     \n-def delete(shape, bounding, scope=\"points\", delete_selected=True):\n+def delete(shape, bounding, scope=\"points\", operation=\"selected\"):\n     \"\"\"Delete points or paths that lie within the given bounds.\"\"\"\n     if shape is None or bounding is None: return None\n+    delete_selected = operation == \"selected\"\n     if scope == \"points\": return delete_points(shape, bounding, delete_selected)\n     if scope == \"paths\": return delete_paths(shape, bounding, delete_selected)\n \ndiff --git a/src/main/java/nodebox/node/NodeLibrary.java b/src/main/java/nodebox/node/NodeLibrary.java\nindex d188c1c..0ff7ba8 100644\n--- a/src/main/java/nodebox/node/NodeLibrary.java\n+++ b/src/main/java/nodebox/node/NodeLibrary.java\n@@ -21,7 +21,7 @@ import static com.google.common.base.Preconditions.*;\n \n public class NodeLibrary {\n \n-    public static final String CURRENT_FORMAT_VERSION = \"5\";\n+    public static final String CURRENT_FORMAT_VERSION = \"6\";\n \n     public static final Splitter PORT_NAME_SPLITTER = Splitter.on(\".\");\n \ndiff --git a/src/main/java/nodebox/node/NodeLibraryUpgrades.java b/src/main/java/nodebox/node/NodeLibraryUpgrades.java\nindex bb7b3b1..7366b0f 100644\n--- a/src/main/java/nodebox/node/NodeLibraryUpgrades.java\n+++ b/src/main/java/nodebox/node/NodeLibraryUpgrades.java\n@@ -1,6 +1,7 @@\n package nodebox.node;\n \n import com.google.common.base.Charsets;\n+import com.google.common.collect.ImmutableMap;\n import com.google.common.io.Files;\n import nodebox.graphics.Point;\n import nodebox.util.LoadException;\n@@ -14,6 +15,7 @@ import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n \n /**\n  * Helper class that contains all NodeLibrary upgrade migrations.\n@@ -43,6 +45,7 @@ public class NodeLibraryUpgrades {\n         upgradeMap.put(\"2\", upgradeMethod(\"upgrade2to3\"));\n         upgradeMap.put(\"3\", upgradeMethod(\"upgrade3to4\"));\n         upgradeMap.put(\"4\", upgradeMethod(\"upgrade4to5\"));\n+        upgradeMap.put(\"5\", upgradeMethod(\"upgrade5to6\"));\n     }\n \n     private static final Pattern formatVersionPattern = Pattern.compile(\"formatVersion=['\\\"]([\\\\d\\\\.]+)['\\\"]\");\n@@ -155,6 +158,14 @@ public class NodeLibraryUpgrades {\n         return transformXml(inputXml, \"5\", removeInputOp);\n     }\n \n+    public static UpgradeStringResult upgrade5to6(String inputXml) throws LoadException {\n+        // Version 6: change delete.delete_selected boolean to menu options.\n+        Map<String, String> mappings = ImmutableMap.of(\"true\", \"selected\", \"false\", \"non-selected\");\n+        UpgradeOp renamePortOp = new RenamePortOp(\"corevector.delete\", \"delete_selected\", \"operation\");\n+        UpgradeOp changePortTypeOp = new ChangePortTypeOp(\"corevector.delete\", \"operation\", \"string\", mappings);\n+        return transformXml(inputXml, \"6\", renamePortOp, changePortTypeOp);\n+    }\n+\n     private static Set<String> getChildNodeNames(ParentNode parent) {\n         HashSet<String> names = new HashSet<String>();\n         Nodes children = parent.query(\"node\");\n@@ -202,6 +213,20 @@ public class NodeLibraryUpgrades {\n         }\n     }\n \n+    private static void renamePortInElements(Elements elements, String attributeName, String nodeName, String oldPortName, String newPortName) {\n+        for (int i = 0; i < elements.size(); i++) {\n+            Element c = elements.get(i);\n+            Attribute portReference = c.getAttribute(attributeName);\n+            if (portReference == null) continue;\n+            Iterator<String> portRefIterator = NodeLibrary.PORT_NAME_SPLITTER.split(portReference.getValue()).iterator();\n+            String nodeRef = portRefIterator.next();\n+            String portRef = portRefIterator.next();\n+            if (nodeRef.equals(nodeName) && portRef.equals(oldPortName)) {\n+                portReference.setValue(String.format(\"%s.%s\", nodeName, newPortName));\n+            }\n+        }\n+    }\n+\n     private static void renameNodeReference(Elements elements, String attributeName, String oldNodeName, String newNodeName) {\n         for (int i = 0; i < elements.size(); i++) {\n             Element c = elements.get(i);\n@@ -258,6 +283,28 @@ public class NodeLibraryUpgrades {\n         return null;\n     }\n \n+    private static boolean isNodeWithPrototype(Element e, String nodePrototype) {\n+        if (e.getLocalName().equals(\"node\")) {\n+            Attribute prototype = e.getAttribute(\"prototype\");\n+            if (prototype != null && prototype.getValue().equals(nodePrototype)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static Element portWithName(Element nodeElement, String portName) {\n+        Elements ports = nodeElement.getChildElements(\"port\");\n+        for (int i = 0; i < ports.size(); i++) {\n+            Element port = ports.get(i);\n+            Attribute name = port.getAttribute(\"name\");\n+            if (name != null && name.getValue().equals(portName)) {\n+                return port;\n+            }\n+        }\n+        return null;\n+    }\n+\n     private static abstract class UpgradeOp {\n         private List<String> warnings = new ArrayList<String>();\n \n@@ -288,11 +335,9 @@ public class NodeLibraryUpgrades {\n         }\n \n         public void apply(Element e) {\n-            if (e.getLocalName().equals(\"node\")) {\n+            if (isNodeWithPrototype(e, oldPrototype)) {\n                 Attribute prototype = e.getAttribute(\"prototype\");\n-                if (prototype != null && prototype.getValue().equals(oldPrototype)) {\n-                    prototype.setValue(newPrototype);\n-                }\n+                prototype.setValue(newPrototype);\n             }\n         }\n     }\n@@ -340,15 +385,76 @@ public class NodeLibraryUpgrades {\n \n         @Override\n         public void apply(Element e) {\n-            if (e.getLocalName().equals(\"node\")) {\n-                Attribute prototype = e.getAttribute(\"prototype\");\n-                if (prototype != null && prototype.getValue().equals(nodePrototype)) {\n-                    removeNodeInput(e, inputToRemove);\n+            if (isNodeWithPrototype(e, nodePrototype)) {\n+                removeNodeInput(e, inputToRemove);\n+            }\n+        }\n+    }\n+\n+    private static class RenamePortOp extends UpgradeOp {\n+        private String nodePrototype;\n+        private String oldPortName;\n+        private String newPortName;\n+\n+        private RenamePortOp(String nodePrototype, String oldPortName, String newPortName) {\n+            this.nodePrototype = nodePrototype;\n+            this.oldPortName = oldPortName;\n+            this.newPortName = newPortName;\n+        }\n+\n+        @Override\n+        public void apply(Element e) {\n+            if (isNodeWithPrototype(e, nodePrototype)) {\n+                String nodeName = e.getAttributeValue(\"name\");\n+                Element port = portWithName(e, oldPortName);\n+                if (port != null) {\n+                    port.getAttribute(\"name\").setValue(newPortName);\n+                    Element parent = (Element) e.getParent();\n+                    Elements connections = parent.getChildElements(\"conn\");\n+                    renamePortInElements(connections, \"input\", nodeName, oldPortName, newPortName);\n+                    Elements ports = parent.getChildElements(\"port\");\n+                    renamePortInElements(ports, \"childReference\", nodeName, oldPortName, newPortName);\n                 }\n             }\n         }\n     }\n \n+    private static class ChangePortTypeOp extends UpgradeOp {\n+        private String nodePrototype;\n+        private String portName;\n+        private String newType;\n+        // The value mappings are strings, since that's what's stored in the XML file.\n+        private Map<String, String> valueMappings;\n+\n+\n+        public ChangePortTypeOp(String nodePrototype, String portName, String newType, Map<String, String> valueMappings) {\n+            this.nodePrototype = nodePrototype;\n+            this.portName = portName;\n+            this.newType = newType;\n+            this.valueMappings = valueMappings;\n+        }\n+\n+        @Override\n+        public void apply(Element e) {\n+            if (isNodeWithPrototype(e, nodePrototype)) {\n+                Element port = portWithName(e, portName);\n+                if (port != null) {\n+                    Attribute type = port.getAttribute(\"type\");\n+                    type.setValue(newType);\n+                    Attribute value = port.getAttribute(\"value\");\n+                    if (value != null) {\n+                        String newValue = valueMappings.get(value.getValue());\n+                        checkState(newValue != null,\n+                                \"Change port type (%s.%s -> %s): value %s not found in value mappings.\",\n+                                nodePrototype, portName, newType, value.getValue());\n+                        value.setValue(newValue);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+\n     private static UpgradeStringResult transformXml(String xml, String newFormatVersion, UpgradeOp... ops) {\n         try {\n             Document document = new Builder().build(xml, null);\ndiff --git a/src/test/files/upgrade-v5.ndbx b/src/test/files/upgrade-v5.ndbx\nnew file mode 100644\nindex 0000000..bac10c9\n--- /dev/null\n+++ b/src/test/files/upgrade-v5.ndbx\n@@ -0,0 +1,9 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<ndbx formatVersion=\"5\">\n+    <node name=\"root\" renderedChild=\"delete1\">\n+        <node name=\"delete1\" prototype=\"corevector.delete\"/>\n+        <node name=\"delete2\" prototype=\"corevector.delete\">\n+            <port name=\"delete_selected\" type=\"boolean\" value=\"false\"/>\n+        </node>\n+    </node>\n+</ndbx>\n", "test_patch": "diff --git a/src/test/java/nodebox/node/NodeLibraryTest.java b/src/test/java/nodebox/node/NodeLibraryTest.java\nindex 2d331f5..6c98bf2 100644\n--- a/src/test/java/nodebox/node/NodeLibraryTest.java\n+++ b/src/test/java/nodebox/node/NodeLibraryTest.java\n@@ -414,6 +414,21 @@ public class NodeLibraryTest {\n         assertFalse(subnet2.hasInput(\"height\"));\n     }\n \n+    @Test\n+    public void testUpgrade5to6() {\n+        File version5File = new File(\"src/test/files/upgrade-v5.ndbx\");\n+        UpgradeResult result = NodeLibraryUpgrades.upgrade(version5File);\n+        NodeLibrary corevectorLibrary = NodeLibrary.load(new File(\"libraries/corevector/corevector.ndbx\"), NodeRepository.of());\n+        NodeLibrary upgradedLibrary = result.getLibrary(version5File, NodeRepository.of(corevectorLibrary));\n+        Node root = upgradedLibrary.getRoot();\n+        Node delete1 = root.getChild(\"delete1\");\n+        assertTrue(delete1.hasInput(\"operation\"));\n+        assertFalse(delete1.hasInput(\"delete_selected\"));\n+        assertEquals(\"selected\", delete1.getInput(\"operation\").stringValue());\n+        Node delete2 = root.getChild(\"delete2\");\n+        assertEquals(\"non-selected\", delete2.getInput(\"operation\").stringValue());\n+    }\n+\n     /**\n      * Test upgrading from 0.9 files, which should fail since we don't support those conversions.\n      */\n"}
{"repository": "nodebox/nodebox", "clone_url": "https://github.com/nodebox/nodebox.git", "timestamp": "2023-05-30T21:30:35.524491Z", "commit_hash": "2d216768fb122f73008ad569c7edd3a89b61b666", "commit_message": "Removed \"height\" port from \"textpath\" node.\nThis fixes #250.", "related_issues": "", "bug_patch": "diff --git a/libraries/corevector/corevector.ndbx b/libraries/corevector/corevector.ndbx\nindex 4dd9bf7..21fbaa0 100644\n--- a/libraries/corevector/corevector.ndbx\n+++ b/libraries/corevector/corevector.ndbx\n@@ -258,7 +258,6 @@\n             </port>\n             <port name=\"position\" range=\"value\" type=\"point\" value=\"0.00,0.00\" widget=\"point\" description=\"The center point of the text.\"/>\n             <port min=\"0.0\" name=\"width\" range=\"value\" type=\"float\" value=\"0.0\" widget=\"float\" description=\"The maximum width of the text.\"/>\n-            <port min=\"0.0\" name=\"height\" range=\"value\" type=\"float\" value=\"0.0\" widget=\"float\" description=\"The maximum height of the text. Currently has no effect.\"/>\n         </node>\n         <node description=\"Move the shape, changing its position.\" function=\"pyvector/translate\" handle=\"corevector/translateHandle\" image=\"translate.png\" name=\"translate\" position=\"7.00,12.00\" prototype=\"filter\">\n             <port name=\"translate\" range=\"value\" type=\"point\" value=\"0.00,0.00\" widget=\"point\" description=\"The amount of translation.\"/>\ndiff --git a/src/main/java/nodebox/function/CoreVectorFunctions.java b/src/main/java/nodebox/function/CoreVectorFunctions.java\nindex a2ca7cb..deb3dda 100644\n--- a/src/main/java/nodebox/function/CoreVectorFunctions.java\n+++ b/src/main/java/nodebox/function/CoreVectorFunctions.java\n@@ -549,7 +549,7 @@ public class CoreVectorFunctions {\n      *\n      * @return A new Path.\n      */\n-    public static Path textpath(String text, String fontName, double fontSize, String alignment, Point position, double width, double height) {\n+    public static Path textpath(String text, String fontName, double fontSize, String alignment, Point position, double width) {\n         Text.Align align;\n         try {\n             align = Text.Align.valueOf(alignment);\n@@ -564,7 +564,7 @@ public class CoreVectorFunctions {\n             position = position.moved(-width, 0);\n         }\n \n-        Text t = new Text(text, position.x, position.y, width, height);\n+        Text t = new Text(text, position.x, position.y, width, 0);\n         t.setFontName(fontName);\n         t.setFontSize(fontSize);\n         t.setAlign(align);\ndiff --git a/src/main/java/nodebox/node/NodeLibrary.java b/src/main/java/nodebox/node/NodeLibrary.java\nindex 242ca8d..d188c1c 100644\n--- a/src/main/java/nodebox/node/NodeLibrary.java\n+++ b/src/main/java/nodebox/node/NodeLibrary.java\n@@ -21,7 +21,7 @@ import static com.google.common.base.Preconditions.*;\n \n public class NodeLibrary {\n \n-    public static final String CURRENT_FORMAT_VERSION = \"4\";\n+    public static final String CURRENT_FORMAT_VERSION = \"5\";\n \n     public static final Splitter PORT_NAME_SPLITTER = Splitter.on(\".\");\n \ndiff --git a/src/main/java/nodebox/node/NodeLibraryUpgrades.java b/src/main/java/nodebox/node/NodeLibraryUpgrades.java\nindex 5c8b888..576dd24 100644\n--- a/src/main/java/nodebox/node/NodeLibraryUpgrades.java\n+++ b/src/main/java/nodebox/node/NodeLibraryUpgrades.java\n@@ -1,1 +1,1 @@\n-package nodebox.node;\r\rimport com.google.common.base.Charsets;\rimport com.google.common.io.Files;\rimport nodebox.graphics.Point;\rimport nodebox.util.LoadException;\rimport nu.xom.*;\r\rimport java.io.File;\rimport java.io.IOException;\rimport java.lang.reflect.Method;\rimport java.util.*;\rimport java.util.regex.Matcher;\rimport java.util.regex.Pattern;\r\rimport static com.google.common.base.Preconditions.checkArgument;\r\r/**\r * Helper class that contains all NodeLibrary upgrade migrations.\r */\rpublic class NodeLibraryUpgrades {\r\r    private static Map<String, Method> upgradeMap = new HashMap<String, Method>();\r\r    /**\r     * Lookup an upgrade method by name.\r     * <p/>\r     * This method is not compatible\r     *\r     * @param methodName The upgrade method name.\r     * @return The Method object, to be invoked.\r     */\r    private static Method upgradeMethod(String methodName) {\r        try {\r            return NodeLibraryUpgrades.class.getMethod(methodName, String.class);\r        } catch (NoSuchMethodException e) {\r            throw new RuntimeException(e);\r        }\r    }\r\r    static {\r        upgradeMap.put(\"1.0\", upgradeMethod(\"upgrade1to2\"));\r        upgradeMap.put(\"2\", upgradeMethod(\"upgrade2to3\"));\r        upgradeMap.put(\"3\", upgradeMethod(\"upgrade3to4\"));\r    }\r\r    private static final Pattern formatVersionPattern = Pattern.compile(\"formatVersion=['\\\"]([\\\\d\\\\.]+)['\\\"]\");\r\r    public static String parseFormatVersion(String xml) {\r        Matcher m = formatVersionPattern.matcher(xml);\r        if (!m.find()) throw new RuntimeException(\"Invalid NodeBox file: \" + xml);\r        return m.group(1);\r    }\r\r    private static String readFile(File file) {\r        try {\r            return Files.toString(file, Charsets.UTF_8);\r        } catch (IOException e) {\r            throw new RuntimeException(e);\r        }\r    }\r\r    /**\r     * Upgrade the given file to the latest library version. The file is supposed to be a NDBX file.\r     * <p/>\r     * It is harmless to pass in current version NDBX files.\r     *\r     * @param file The .ndbx file to upgrade.\r     * @return An upgrade result, containing warnings, correct XML code and a NodeLibrary object.\r     * @throws nodebox.util.LoadException If the upgrade fails for some reason.\r     */\r    public static UpgradeResult upgrade(File file) throws LoadException {\r        return upgradeTo(file, NodeLibrary.CURRENT_FORMAT_VERSION);\r    }\r\r    /**\r     * Upgrade the given file to the target version. The file is supposed to be a NDBX file.\r     * <p/>\r     * It is harmless to pass in current version NDBX files.\r     *\r     * @param file The .ndbx file to upgrade.\r     * @return An upgrade result, containing warnings, correct XML code and a NodeLibrary object.\r     * @throws LoadException If the upgrade fails for some reason.\r     */\r    public static UpgradeResult upgradeTo(File file, String targetVersion) throws LoadException {\r        String currentXml = readFile(file);\r        String currentVersion = parseFormatVersion(currentXml);\r        ArrayList<String> warnings = new ArrayList<String>();\r        // Avoid upgrades getting stuck in an infinite loop.\r        int tries = 0;\r        while (!currentVersion.equals(targetVersion) && tries < 100) {\r            Method upgradeMethod = upgradeMap.get(currentVersion);\r            if (upgradeMethod == null) {\r                throw new LoadException(file, \"Unsupported version \" + currentVersion + \": this file is too old or too new.\");\r            }\r            try {\r                UpgradeStringResult result = (UpgradeStringResult) upgradeMethod.invoke(null, currentXml);\r                warnings.addAll(result.warnings);\r                currentXml = result.xml;\r            } catch (Exception e) {\r                throw new LoadException(file, \"Upgrading to \" + currentVersion + \" failed.\", e);\r            }\r            currentVersion = parseFormatVersion(currentXml);\r            tries++;\r        }\r        if (tries >= 100) {\r            throw new LoadException(file, \"Got stuck in an infinite loop when trying to upgrade from \" + currentVersion);\r        }\r        return new UpgradeResult(file, currentXml, warnings);\r    }\r\r    public static UpgradeStringResult upgrade1to2(String inputXml) throws LoadException {\r        // Version 2: Vertical node networks\r        // 1. Rotate all nodes 90 degrees by reversing X and Y positions.\r        // 2. Convert from pixel units to grid units by dividing by GRID_CELL_SIZE.\r        final int GRID_CELL_SIZE = 48;\r        UpgradeOp verticalNodesOp = new UpgradeOp() {\r            @Override\r            public void apply(Element e) {\r                if (!e.getLocalName().equals(\"node\")) return;\r                Attribute position = e.getAttribute(\"position\");\r                if (position == null) return;\r                Point pt = Point.valueOf(position.getValue());\r                Point reversedPoint = new Point(pt.y, pt.x);\r                Point gridPoint = new Point(Math.round(reversedPoint.x / GRID_CELL_SIZE) * 3, Math.round(reversedPoint.y / GRID_CELL_SIZE));\r                position.setValue(String.valueOf(gridPoint));\r            }\r\r            @Override\r            public void end(Element root) {\r                addWarning(\"Nodes have been rotated. Your network will look different.\");\r            }\r        };\r        return transformXml(inputXml, \"2\", verticalNodesOp);\r    }\r\r    public static UpgradeStringResult upgrade2to3(String inputXml) throws LoadException {\r        // Version 3: Rename math.to_integer to math.round.\r        UpgradeOp changePrototypeOp = new ChangePrototypeOp(\"math.to_integer\", \"math.round\");\r        UpgradeOp renameOp = new RenameNodeOp(\"to_integer\", \"round\");\r        return transformXml(inputXml, \"3\", changePrototypeOp, renameOp);\r    }\r\r    public static UpgradeStringResult upgrade3to4(String inputXml) throws LoadException {\r        // Version 4: Convert corevector.to_points nodes to corevector.point nodes.\r        UpgradeOp changePrototypeOp = new ChangePrototypeOp(\"corevector.to_points\", \"corevector.point\");\r        UpgradeOp renameOp = new RenameNodeOp(\"to_points\", \"point\");\r        return transformXml(inputXml, \"4\", changePrototypeOp, renameOp);\r    }\r\r    private static Set<String> getChildNodeNames(ParentNode parent) {\r        HashSet<String> names = new HashSet<String>();\r        Nodes children = parent.query(\"node\");\r        for (int i = 0; i < children.size(); i++) {\r            nu.xom.Node childNode = children.get(i);\r            if (childNode instanceof Element) {\r                Element e = (Element) children.get(i);\r                names.add(e.getAttribute(\"name\").getValue());\r            }\r        }\r        return names;\r    }\r\r    private static String uniqueName(String prefix, Set<String> existingNames) {\r        int counter = 1;\r        while (true) {\r            String suggestedName = prefix + counter;\r            if (!existingNames.contains(suggestedName)) {\r                return suggestedName;\r            }\r            counter++;\r        }\r    }\r\r    private static void renameRenderedChildReference(Element element, String oldNodeName, String newNodeName) {\r        Attribute renderedChildReference = element.getAttribute(\"renderedChild\");\r        if (renderedChildReference == null) return;\r        String oldRenderedChild = renderedChildReference.getValue();\r        if (oldRenderedChild.equals(oldNodeName))\r            renderedChildReference.setValue(newNodeName);\r\r    }\r\r    private static void renamePortReference(Elements elements, String attributeName, String oldNodeName, String newNodeName) {\r        for (int i = 0; i < elements.size(); i++) {\r            Element c = elements.get(i);\r            Attribute portReference = c.getAttribute(attributeName);\r            if (portReference == null) continue;\r            Iterator<String> portRefIterator = NodeLibrary.PORT_NAME_SPLITTER.split(portReference.getValue()).iterator();\r            String nodeName = portRefIterator.next();\r            String portName = portRefIterator.next();\r            if (oldNodeName.equals(nodeName)) {\r                portReference.setValue(String.format(\"%s.%s\", newNodeName, portName));\r            }\r        }\r    }\r\r    private static void renameNodeReference(Elements elements, String attributeName, String oldNodeName, String newNodeName) {\r        for (int i = 0; i < elements.size(); i++) {\r            Element c = elements.get(i);\r            Attribute nodeRef = c.getAttribute(attributeName);\r            String nodeName = nodeRef.getValue();\r            if (oldNodeName.equals(nodeName)) {\r                nodeRef.setValue(newNodeName);\r            }\r        }\r    }\r\r    private static abstract class UpgradeOp {\r        private List<String> warnings = new ArrayList<String>();\r\r        public void start(Element root) {\r        }\r\r        public void end(Element root) {\r        }\r\r        public abstract void apply(Element e);\r\r        public void addWarning(String warning) {\r            warnings.add(warning);\r        }\r\r        public List<String> getWarnings() {\r            return warnings;\r        }\r    }\r\r    private static class ChangePrototypeOp extends UpgradeOp {\r        private String oldPrototype;\r        private String newPrototype;\r\r        private ChangePrototypeOp(String oldPrototype, String newPrototype) {\r            this.oldPrototype = oldPrototype;\r            this.newPrototype = newPrototype;\r        }\r\r        public void apply(Element e) {\r            if (e.getLocalName().equals(\"node\")) {\r                Attribute prototype = e.getAttribute(\"prototype\");\r                if (prototype != null && prototype.getValue().equals(oldPrototype)) {\r                    prototype.setValue(newPrototype);\r                }\r            }\r        }\r    }\r\r    private static class RenameNodeOp extends UpgradeOp {\r        private String oldPrefix;\r        private String newPrefix;\r\r        private RenameNodeOp(String oldPrefix, String newPrefix) {\r            this.oldPrefix = oldPrefix;\r            this.newPrefix = newPrefix;\r        }\r\r        @Override\r        public void apply(Element e) {\r            if (e.getLocalName().equals(\"node\")) {\r                Attribute name = e.getAttribute(\"name\");\r                if (name != null && name.getValue().startsWith(oldPrefix)) {\r                    String oldNodeName = name.getValue();\r                    Set<String> childNames = getChildNodeNames(e.getParent());\r                    String newNodeName = uniqueName(newPrefix, childNames);\r                    name.setValue(newNodeName);\r\r                    Element parent = (Element) e.getParent();\r                    renameRenderedChildReference(parent, oldNodeName, newNodeName);\r                    Elements connections = parent.getChildElements(\"conn\");\r                    renamePortReference(connections, \"input\", oldNodeName, newNodeName);\r                    renameNodeReference(connections, \"output\", oldNodeName, newNodeName);\r\r                    Elements ports = parent.getChildElements(\"port\");\r                    renamePortReference(ports, \"childReference\", oldNodeName, newNodeName);\r                }\r            }\r        }\r    }\r\r    private static UpgradeStringResult transformXml(String xml, String newFormatVersion, UpgradeOp... ops) {\r        try {\r            Document document = new Builder().build(xml, null);\r\r            // Check that this is a NodeBox document and set the new formatVersion.\r            Element root = document.getRootElement();\r            checkArgument(root.getLocalName().equals(\"ndbx\"), \"This is not a valid NodeBox document.\");\r            root.addAttribute(new Attribute(\"formatVersion\", newFormatVersion));\r\r            // Loop through all upgrade operations.\r            ArrayList<String> warnings = new ArrayList<String>();\r            for (UpgradeOp op : ops) {\r                op.start(root);\r                transformXmlRecursive(document.getRootElement(), op);\r                op.end(root);\r                warnings.addAll(op.getWarnings());\r            }\r            return new UpgradeStringResult(document.toXML(), warnings);\r        } catch (Exception e) {\r            throw new RuntimeException(\"Error while upgrading to \" + newFormatVersion + \".\", e);\r        }\r    }\r\r    private static void transformXmlRecursive(Element e, UpgradeOp op) {\r        op.apply(e);\r        Elements children = e.getChildElements();\r        for (int i = 0; i < children.size(); i++) {\r            Element child = children.get(i);\r            transformXmlRecursive(child, op);\r        }\r    }\r\r    private static class UpgradeStringResult {\r        private final String xml;\r        private final List<String> warnings;\r\r        private UpgradeStringResult(String xml, List<String> warnings) {\r            this.xml = xml;\r            this.warnings = warnings;\r        }\r    }\r\r}\r\n\\ No newline at end of file\n+package nodebox.node;\r\rimport com.google.common.base.Charsets;\rimport com.google.common.io.Files;\rimport nodebox.graphics.Point;\rimport nodebox.util.LoadException;\rimport nu.xom.*;\r\rimport java.io.File;\rimport java.io.IOException;\rimport java.lang.reflect.Method;\rimport java.util.*;\rimport java.util.regex.Matcher;\rimport java.util.regex.Pattern;\r\rimport static com.google.common.base.Preconditions.checkArgument;\r\r/**\r * Helper class that contains all NodeLibrary upgrade migrations.\r */\rpublic class NodeLibraryUpgrades {\r\r    private static Map<String, Method> upgradeMap = new HashMap<String, Method>();\r\r    /**\r     * Lookup an upgrade method by name.\r     * <p/>\r     * This method is not compatible\r     *\r     * @param methodName The upgrade method name.\r     * @return The Method object, to be invoked.\r     */\r    private static Method upgradeMethod(String methodName) {\r        try {\r            return NodeLibraryUpgrades.class.getMethod(methodName, String.class);\r        } catch (NoSuchMethodException e) {\r            throw new RuntimeException(e);\r        }\r    }\r\r    static {\r        upgradeMap.put(\"1.0\", upgradeMethod(\"upgrade1to2\"));\r        upgradeMap.put(\"2\", upgradeMethod(\"upgrade2to3\"));\r        upgradeMap.put(\"3\", upgradeMethod(\"upgrade3to4\"));\r        upgradeMap.put(\"4\", upgradeMethod(\"upgrade4to5\"));\r    }\r\r    private static final Pattern formatVersionPattern = Pattern.compile(\"formatVersion=['\\\"]([\\\\d\\\\.]+)['\\\"]\");\r\r    public static String parseFormatVersion(String xml) {\r        Matcher m = formatVersionPattern.matcher(xml);\r        if (!m.find()) throw new RuntimeException(\"Invalid NodeBox file: \" + xml);\r        return m.group(1);\r    }\r\r    private static String readFile(File file) {\r        try {\r            return Files.toString(file, Charsets.UTF_8);\r        } catch (IOException e) {\r            throw new RuntimeException(e);\r        }\r    }\r\r    /**\r     * Upgrade the given file to the latest library version. The file is supposed to be a NDBX file.\r     * <p/>\r     * It is harmless to pass in current version NDBX files.\r     *\r     * @param file The .ndbx file to upgrade.\r     * @return An upgrade result, containing warnings, correct XML code and a NodeLibrary object.\r     * @throws nodebox.util.LoadException If the upgrade fails for some reason.\r     */\r    public static UpgradeResult upgrade(File file) throws LoadException {\r        return upgradeTo(file, NodeLibrary.CURRENT_FORMAT_VERSION);\r    }\r\r    /**\r     * Upgrade the given file to the target version. The file is supposed to be a NDBX file.\r     * <p/>\r     * It is harmless to pass in current version NDBX files.\r     *\r     * @param file The .ndbx file to upgrade.\r     * @return An upgrade result, containing warnings, correct XML code and a NodeLibrary object.\r     * @throws LoadException If the upgrade fails for some reason.\r     */\r    public static UpgradeResult upgradeTo(File file, String targetVersion) throws LoadException {\r        String currentXml = readFile(file);\r        String currentVersion = parseFormatVersion(currentXml);\r        ArrayList<String> warnings = new ArrayList<String>();\r        // Avoid upgrades getting stuck in an infinite loop.\r        int tries = 0;\r        while (!currentVersion.equals(targetVersion) && tries < 100) {\r            Method upgradeMethod = upgradeMap.get(currentVersion);\r            if (upgradeMethod == null) {\r                throw new LoadException(file, \"Unsupported version \" + currentVersion + \": this file is too old or too new.\");\r            }\r            try {\r                UpgradeStringResult result = (UpgradeStringResult) upgradeMethod.invoke(null, currentXml);\r                warnings.addAll(result.warnings);\r                currentXml = result.xml;\r            } catch (Exception e) {\r                throw new LoadException(file, \"Upgrading to \" + currentVersion + \" failed.\", e);\r            }\r            currentVersion = parseFormatVersion(currentXml);\r            tries++;\r        }\r        if (tries >= 100) {\r            throw new LoadException(file, \"Got stuck in an infinite loop when trying to upgrade from \" + currentVersion);\r        }\r        return new UpgradeResult(file, currentXml, warnings);\r    }\r\r    public static UpgradeStringResult upgrade1to2(String inputXml) throws LoadException {\r        // Version 2: Vertical node networks\r        // 1. Rotate all nodes 90 degrees by reversing X and Y positions.\r        // 2. Convert from pixel units to grid units by dividing by GRID_CELL_SIZE.\r        final int GRID_CELL_SIZE = 48;\r        UpgradeOp verticalNodesOp = new UpgradeOp() {\r            @Override\r            public void apply(Element e) {\r                if (!e.getLocalName().equals(\"node\")) return;\r                Attribute position = e.getAttribute(\"position\");\r                if (position == null) return;\r                Point pt = Point.valueOf(position.getValue());\r                Point reversedPoint = new Point(pt.y, pt.x);\r                Point gridPoint = new Point(Math.round(reversedPoint.x / GRID_CELL_SIZE) * 3, Math.round(reversedPoint.y / GRID_CELL_SIZE));\r                position.setValue(String.valueOf(gridPoint));\r            }\r\r            @Override\r            public void end(Element root) {\r                addWarning(\"Nodes have been rotated. Your network will look different.\");\r            }\r        };\r        return transformXml(inputXml, \"2\", verticalNodesOp);\r    }\r\r    public static UpgradeStringResult upgrade2to3(String inputXml) throws LoadException {\r        // Version 3: Rename math.to_integer to math.round.\r        UpgradeOp changePrototypeOp = new ChangePrototypeOp(\"math.to_integer\", \"math.round\");\r        UpgradeOp renameOp = new RenameNodeOp(\"to_integer\", \"round\");\r        return transformXml(inputXml, \"3\", changePrototypeOp, renameOp);\r    }\r\r    public static UpgradeStringResult upgrade3to4(String inputXml) throws LoadException {\r        // Version 4: Convert corevector.to_points nodes to corevector.point nodes.\r        UpgradeOp changePrototypeOp = new ChangePrototypeOp(\"corevector.to_points\", \"corevector.point\");\r        UpgradeOp renameOp = new RenameNodeOp(\"to_points\", \"point\");\r        return transformXml(inputXml, \"4\", changePrototypeOp, renameOp);\r    }\r\r    public static UpgradeStringResult upgrade4to5(String inputXml) throws LoadException {\r        UpgradeOp removeInputOp = new RemoveInputOp(\"corevector.textpath\", \"height\");\r        return transformXml(inputXml, \"5\", removeInputOp);\r    }\r\r    private static Set<String> getChildNodeNames(ParentNode parent) {\r        HashSet<String> names = new HashSet<String>();\r        Nodes children = parent.query(\"node\");\r        for (int i = 0; i < children.size(); i++) {\r            nu.xom.Node childNode = children.get(i);\r            if (childNode instanceof Element) {\r                Element e = (Element) children.get(i);\r                names.add(e.getAttribute(\"name\").getValue());\r            }\r        }\r        return names;\r    }\r\r    private static String uniqueName(String prefix, Set<String> existingNames) {\r        int counter = 1;\r        while (true) {\r            String suggestedName = prefix + counter;\r            if (!existingNames.contains(suggestedName)) {\r                return suggestedName;\r            }\r            counter++;\r        }\r    }\r\r    private static void renameRenderedChildReference(Element element, String oldNodeName, String newNodeName) {\r        Attribute renderedChildReference = element.getAttribute(\"renderedChild\");\r        if (renderedChildReference == null) return;\r        String oldRenderedChild = renderedChildReference.getValue();\r        if (oldRenderedChild.equals(oldNodeName))\r            renderedChildReference.setValue(newNodeName);\r\r    }\r\r    private static void renamePortReference(Elements elements, String attributeName, String oldNodeName, String newNodeName) {\r        for (int i = 0; i < elements.size(); i++) {\r            Element c = elements.get(i);\r            Attribute portReference = c.getAttribute(attributeName);\r            if (portReference == null) continue;\r            Iterator<String> portRefIterator = NodeLibrary.PORT_NAME_SPLITTER.split(portReference.getValue()).iterator();\r            String nodeName = portRefIterator.next();\r            String portName = portRefIterator.next();\r            if (oldNodeName.equals(nodeName)) {\r                portReference.setValue(String.format(\"%s.%s\", newNodeName, portName));\r            }\r        }\r    }\r\r    private static void renameNodeReference(Elements elements, String attributeName, String oldNodeName, String newNodeName) {\r        for (int i = 0; i < elements.size(); i++) {\r            Element c = elements.get(i);\r            Attribute nodeRef = c.getAttribute(attributeName);\r            String nodeName = nodeRef.getValue();\r            if (oldNodeName.equals(nodeName)) {\r                nodeRef.setValue(newNodeName);\r            }\r        }\r    }\r\r    private static void removeNodeInput(Element node, String input) {\r        Elements ports = node.getChildElements(\"port\");\r        for (int i = 0; i < ports.size(); i++) {\r            Element port = ports.get(i);\r            Attribute nameAttr = port.getAttribute(\"name\");\r            String portName = nameAttr.getValue();\r            if (portName.equals(input)) {\r                node.removeChild(port);\r            }\r        }\r        if (node.getAttribute(\"name\") != null) {\r            Element parent = (Element) node.getParent();\r            String child = node.getAttribute(\"name\").getValue();\r            removeConnection(parent, child, input);\r            String publishedInput = getParentPublishedInput(parent, child, input);\r            if (publishedInput != null)\r                removeNodeInput(parent, publishedInput);\r        }\r\r    }\r\r    private static void removeConnection(Element parent, String child, String input) {\r        Elements connections = parent.getChildElements(\"conn\");\r        for (int i = 0; i < connections.size(); i++) {\r            Element conn = connections.get(i);\r            Attribute inputAttr = conn.getAttribute(\"input\");\r            String inputPort = inputAttr.getValue();\r            if (inputPort.equals(String.format(\"%s.%s\", child, input))) {\r                parent.removeChild(conn);\r            }\r        }\r    }\r\r    private static String getParentPublishedInput(Element parent, String child, String input) {\r        Elements ports = parent.getChildElements(\"port\");\r        for (int i = 0; i < ports.size(); i++) {\r            Element port = ports.get(i);\r            Attribute childRef = port.getAttribute(\"childReference\");\r            if (childRef != null && childRef.getValue().equals(String.format(\"%s.%s\", child, input))) {\r                return port.getAttribute(\"name\").getValue();\r            }\r        }\r        return null;\r    }\r\r    private static abstract class UpgradeOp {\r        private List<String> warnings = new ArrayList<String>();\r\r        public void start(Element root) {\r        }\r\r        public void end(Element root) {\r        }\r\r        public abstract void apply(Element e);\r\r        public void addWarning(String warning) {\r            warnings.add(warning);\r        }\r\r        public List<String> getWarnings() {\r            return warnings;\r        }\r    }\r\r    private static class ChangePrototypeOp extends UpgradeOp {\r        private String oldPrototype;\r        private String newPrototype;\r\r        private ChangePrototypeOp(String oldPrototype, String newPrototype) {\r            this.oldPrototype = oldPrototype;\r            this.newPrototype = newPrototype;\r        }\r\r        public void apply(Element e) {\r            if (e.getLocalName().equals(\"node\")) {\r                Attribute prototype = e.getAttribute(\"prototype\");\r                if (prototype != null && prototype.getValue().equals(oldPrototype)) {\r                    prototype.setValue(newPrototype);\r                }\r            }\r        }\r    }\r\r    private static class RenameNodeOp extends UpgradeOp {\r        private String oldPrefix;\r        private String newPrefix;\r\r        private RenameNodeOp(String oldPrefix, String newPrefix) {\r            this.oldPrefix = oldPrefix;\r            this.newPrefix = newPrefix;\r        }\r\r        @Override\r        public void apply(Element e) {\r            if (e.getLocalName().equals(\"node\")) {\r                Attribute name = e.getAttribute(\"name\");\r                if (name != null && name.getValue().startsWith(oldPrefix)) {\r                    String oldNodeName = name.getValue();\r                    Set<String> childNames = getChildNodeNames(e.getParent());\r                    String newNodeName = uniqueName(newPrefix, childNames);\r                    name.setValue(newNodeName);\r\r                    Element parent = (Element) e.getParent();\r                    renameRenderedChildReference(parent, oldNodeName, newNodeName);\r                    Elements connections = parent.getChildElements(\"conn\");\r                    renamePortReference(connections, \"input\", oldNodeName, newNodeName);\r                    renameNodeReference(connections, \"output\", oldNodeName, newNodeName);\r\r                    Elements ports = parent.getChildElements(\"port\");\r                    renamePortReference(ports, \"childReference\", oldNodeName, newNodeName);\r                }\r            }\r        }\r    }\r\r    private static class RemoveInputOp extends UpgradeOp {\r        private String nodePrototype;\r        private String inputToRemove;\r\r        private RemoveInputOp(String nodePrototype, String inputToRemove) {\r            this.nodePrototype = nodePrototype;\r            this.inputToRemove = inputToRemove;\r        }\r\r        @Override\r        public void apply(Element e) {\r            if (e.getLocalName().equals(\"node\")) {\r                Attribute prototype = e.getAttribute(\"prototype\");\r                if (prototype != null && prototype.getValue().equals(nodePrototype)) {\r                    removeNodeInput(e, inputToRemove);\r                }\r            }\r        }\r    }\r\r    private static UpgradeStringResult transformXml(String xml, String newFormatVersion, UpgradeOp... ops) {\r        try {\r            Document document = new Builder().build(xml, null);\r\r            // Check that this is a NodeBox document and set the new formatVersion.\r            Element root = document.getRootElement();\r            checkArgument(root.getLocalName().equals(\"ndbx\"), \"This is not a valid NodeBox document.\");\r            root.addAttribute(new Attribute(\"formatVersion\", newFormatVersion));\r\r            // Loop through all upgrade operations.\r            ArrayList<String> warnings = new ArrayList<String>();\r            for (UpgradeOp op : ops) {\r                op.start(root);\r                transformXmlRecursive(document.getRootElement(), op);\r                op.end(root);\r                warnings.addAll(op.getWarnings());\r            }\r            return new UpgradeStringResult(document.toXML(), warnings);\r        } catch (Exception e) {\r            throw new RuntimeException(\"Error while upgrading to \" + newFormatVersion + \".\", e);\r        }\r    }\r\r    private static void transformXmlRecursive(Element e, UpgradeOp op) {\r        op.apply(e);\r        Elements children = e.getChildElements();\r        for (int i = 0; i < children.size(); i++) {\r            Element child = children.get(i);\r            transformXmlRecursive(child, op);\r        }\r    }\r\r    private static class UpgradeStringResult {\r        private final String xml;\r        private final List<String> warnings;\r\r        private UpgradeStringResult(String xml, List<String> warnings) {\r            this.xml = xml;\r            this.warnings = warnings;\r        }\r    }\r\r}\r\n\\ No newline at end of file\ndiff --git a/src/test/files/upgrade-v4.ndbx b/src/test/files/upgrade-v4.ndbx\nnew file mode 100644\nindex 0000000..c33000d\n--- /dev/null\n+++ b/src/test/files/upgrade-v4.ndbx\n@@ -0,0 +1,25 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<ndbx formatVersion=\"4\">\n+    <node name=\"root\">\n+        <node name=\"number1\" prototype=\"math.number\">\n+            <port name=\"value\" type=\"float\" value=\"35.0\"/>\n+        </node>\n+        <node name=\"subnet1\" renderedChild=\"textpath3\">\n+            <node name=\"textpath3\" prototype=\"corevector.textpath\"/>\n+            <port childReference=\"textpath3.height\" min=\"0.0\" name=\"height\" range=\"value\" type=\"float\" value=\"0.0\" widget=\"float\"/>\n+        </node>\n+        <node name=\"subnet2\" renderedChild=\"subnet1\">\n+            <node name=\"subnet1\" renderedChild=\"textpath3\">\n+                <node name=\"textpath3\" prototype=\"corevector.textpath\"/>\n+                <port childReference=\"textpath3.height\" min=\"0.0\" name=\"height\" range=\"value\" type=\"float\" value=\"0.0\" widget=\"float\"/>\n+            </node>\n+            <port childReference=\"subnet1.height\" min=\"0.0\" name=\"height\" range=\"value\" type=\"float\" value=\"0.0\" widget=\"float\"/>\n+        </node>\n+        <node name=\"textpath1\" prototype=\"corevector.textpath\">\n+            <port name=\"height\" type=\"float\" value=\"35.0\"/>\n+        </node>\n+        <node name=\"textpath2\" prototype=\"corevector.textpath\"/>\n+        <conn input=\"textpath2.height\" output=\"number1\"/>\n+        <conn input=\"subnet2.height\" output=\"number1\"/>\n+    </node>\n+</ndbx>\n", "test_patch": "diff --git a/src/test/java/nodebox/node/NodeLibraryTest.java b/src/test/java/nodebox/node/NodeLibraryTest.java\nindex 97be127..2d331f5 100644\n--- a/src/test/java/nodebox/node/NodeLibraryTest.java\n+++ b/src/test/java/nodebox/node/NodeLibraryTest.java\n@@ -398,6 +398,22 @@ public class NodeLibraryTest {\n         assertEquals(\"point1.shape\", value.getChildReference());\n     }\n \n+    @Test\n+    public void testUpgrade4to5() {\n+        File version4File = new File(\"src/test/files/upgrade-v4.ndbx\");\n+        UpgradeResult result = NodeLibraryUpgrades.upgrade(version4File);\n+        NodeLibrary corevectorLibrary = NodeLibrary.load(new File(\"libraries/corevector/corevector.ndbx\"), NodeRepository.of());\n+        NodeLibrary mathLibrary = NodeLibrary.load(new File(\"libraries/math/math.ndbx\"), NodeRepository.of());\n+        NodeLibrary upgradedLibrary = result.getLibrary(version4File, NodeRepository.of(corevectorLibrary, mathLibrary));\n+        Node root = upgradedLibrary.getRoot();\n+        assertFalse(root.getChild(\"textpath1\").hasInput(\"height\"));\n+        assertNull(root.getConnection(\"textpath2\", \"height\"));\n+        Node subnet1 = root.getChild(\"subnet1\");\n+        assertFalse(subnet1.hasInput(\"height\"));\n+        Node subnet2 = root.getChild(\"subnet2\");\n+        assertFalse(subnet2.hasInput(\"height\"));\n+    }\n+\n     /**\n      * Test upgrading from 0.9 files, which should fail since we don't support those conversions.\n      */\n"}
{"repository": "nodebox/nodebox", "clone_url": "https://github.com/nodebox/nodebox.git", "timestamp": "2023-05-30T21:35:37.137290Z", "commit_hash": "4c446134f14dacc3213c3b52ba8e97d1b8787d2f", "commit_message": "Rename \"to_integer\" to \"round\".\n\nThis fixes #248.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/nodebox/function/MathFunctions.java b/src/main/java/nodebox/function/MathFunctions.java\nindex fdd77d7..4533801 100644\n--- a/src/main/java/nodebox/function/MathFunctions.java\n+++ b/src/main/java/nodebox/function/MathFunctions.java\n@@ -34,7 +34,7 @@ public class MathFunctions {\n                 \"negate\", \"abs\", \"add\", \"subtract\", \"multiply\", \"divide\", \"mod\", \"sqrt\", \"pow\",\n                 \"log\",\"sum\", \"average\", \"compare\", \"min\", \"max\", \"ceil\", \"floor\",\n                 \"even\", \"odd\",\n-                \"makeNumbers\", \"randomNumbers\", \"toInteger\",\n+                \"makeNumbers\", \"randomNumbers\", \"round\",\n                 \"sample\", \"range\",\n                 \"radians\", \"degrees\", \"angle\", \"distance\", \"coordinates\", \"reflect\", \"sin\", \"cos\", \"pi\", \"e\",\n                 \"convertRange\", \"wave\");\n@@ -210,7 +210,7 @@ public class MathFunctions {\n         return numbers.build();\n     }\n \n-    public static long toInteger(double a) {\n+    public static long round(double a) {\n         return (long) a;\n     }\n \ndiff --git a/src/main/java/nodebox/node/NodeLibrary.java b/src/main/java/nodebox/node/NodeLibrary.java\nindex e3f60c7..6a23989 100644\n--- a/src/main/java/nodebox/node/NodeLibrary.java\n+++ b/src/main/java/nodebox/node/NodeLibrary.java\n@@ -28,7 +28,7 @@ import static com.google.common.base.Preconditions.*;\n \n public class NodeLibrary {\n \n-    public static final String CURRENT_FORMAT_VERSION = \"2\";\n+    public static final String CURRENT_FORMAT_VERSION = \"3\";\n \n     public static final Splitter PORT_NAME_SPLITTER = Splitter.on(\".\");\n \n@@ -219,6 +219,7 @@ public class NodeLibrary {\n \n     static {\n         upgradeMap.put(\"1.0\", upgradeMethod(\"upgrade1to2\"));\n+        upgradeMap.put(\"2\", upgradeMethod(\"upgrade2to3\"));\n     }\n \n     private static final Pattern formatVersionPattern = Pattern.compile(\"formatVersion=['\\\"]([\\\\d\\\\.]+)['\\\"]\");\n@@ -271,7 +272,7 @@ public class NodeLibrary {\n                 throw new LoadException(file, \"Unsupported version \" + currentVersion + \": this file is too old or too new.\");\n             }\n             try {\n-                UpgradeStringResult result = (UpgradeStringResult) upgradeMethod.invoke(null, readFile(file));\n+                UpgradeStringResult result = (UpgradeStringResult) upgradeMethod.invoke(null, currentXml);\n                 warnings.addAll(result.warnings);\n                 currentXml = result.xml;\n             } catch (Exception e) {\n@@ -308,6 +309,125 @@ public class NodeLibrary {\n         return result;\n     }\n \n+    private static Set<String> getChildNodeNames(ParentNode parent) {\n+        HashSet<String> names = new HashSet<String>();\n+        Nodes children = parent.query(\"node\");\n+        for (int i = 0; i < children.size(); i++) {\n+            nu.xom.Node childNode = children.get(i);\n+            if (childNode instanceof Element) {\n+                Element e = (Element) children.get(i);\n+                names.add(e.getAttribute(\"name\").getValue());\n+            }\n+        }\n+        return names;\n+    }\n+\n+    private static String uniqueName(String prefix, Set<String> existingNames) {\n+        int counter = 1;\n+        while (true) {\n+            String suggestedName = prefix + counter;\n+            if (!existingNames.contains(suggestedName)) {\n+                return suggestedName;\n+            }\n+            counter++;\n+        }\n+    }\n+\n+    private static void renamePortReference(Elements elements, String attributeName, String oldNodeName, String newNodeName) {\n+        for (int i = 0; i < elements.size(); i++) {\n+            Element c = elements.get(i);\n+            Attribute portReference = c.getAttribute(attributeName);\n+            if (portReference == null) continue;\n+            Iterator<String> portRefIterator = PORT_NAME_SPLITTER.split(portReference.getValue()).iterator();\n+            String nodeName = portRefIterator.next();\n+            String portName = portRefIterator.next();\n+            if (oldNodeName.equals(nodeName)) {\n+                portReference.setValue(String.format(\"%s.%s\", newNodeName, portName));\n+            }\n+        }\n+    }\n+\n+    private static void renameNodeReference(Elements elements, String attributeName, String oldNodeName, String newNodeName) {\n+        for (int i = 0; i < elements.size(); i++) {\n+            Element c = elements.get(i);\n+            Attribute nodeRef = c.getAttribute(attributeName);\n+            String nodeName = nodeRef.getValue();\n+            if (oldNodeName.equals(nodeName)) {\n+                nodeRef.setValue(newNodeName);\n+            }\n+        }\n+    }\n+\n+    private static abstract class UpgradeOp {\n+        private List<String> warnings = new ArrayList<String>();\n+\n+        public abstract void apply(Element e);\n+\n+        public void addWarning(String warning) {\n+            warnings.add(warning);\n+        }\n+\n+        public List<String> getWarnings() {\n+            return warnings;\n+        }\n+    }\n+\n+    private static class ChangePrototypeOp extends UpgradeOp {\n+        private String oldPrototype;\n+        private String newPrototype;\n+\n+        private ChangePrototypeOp(String oldPrototype, String newPrototype) {\n+            this.oldPrototype = oldPrototype;\n+            this.newPrototype = newPrototype;\n+        }\n+\n+        public void apply(Element e) {\n+            if (e.getLocalName().equals(\"node\")) {\n+                Attribute prototype = e.getAttribute(\"prototype\");\n+                if (prototype != null && prototype.getValue().equals(oldPrototype)) {\n+                    prototype.setValue(newPrototype);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static class RenameNodeOp extends UpgradeOp {\n+        private String oldPrefix;\n+        private String newPrefix;\n+\n+        private RenameNodeOp(String oldPrefix, String newPrefix) {\n+            this.oldPrefix = oldPrefix;\n+            this.newPrefix = newPrefix;\n+        }\n+\n+        @Override\n+        public void apply(Element e) {\n+            if (e.getLocalName().equals(\"node\")) {\n+                Attribute name = e.getAttribute(\"name\");\n+                if (name != null && name.getValue().startsWith(oldPrefix)) {\n+                    String oldNodeName = name.getValue();\n+                    Set<String> childNames = getChildNodeNames(e.getParent());\n+                    String newNodeName = uniqueName(newPrefix, childNames);\n+                    name.setValue(newNodeName);\n+\n+                    Element parent = (Element) e.getParent();\n+                    Elements connections = parent.getChildElements(\"conn\");\n+                    renamePortReference(connections, \"input\", oldNodeName, newNodeName);\n+                    renameNodeReference(connections, \"output\", oldNodeName, newNodeName);\n+\n+                    Elements ports = parent.getChildElements(\"port\");\n+                    renamePortReference(ports, \"childReference\", oldNodeName, newNodeName);\n+                }\n+            }\n+        }\n+    }\n+\n+    public static UpgradeStringResult upgrade2to3(String inputXml) throws LoadException {\n+        UpgradeOp op1 = new ChangePrototypeOp(\"math.to_integer\", \"math.round\");\n+        UpgradeOp op2 = new RenameNodeOp(\"to_integer\", \"round\");\n+        return transformXml(inputXml, \"3\", op1, op2);\n+    }\n+\n     private static UpgradeStringResult transformXml(String xml, String newFormatVersion, Function<Element, String> function) {\n         try {\n             Document document = new Builder().build(xml, null);\n@@ -317,6 +437,35 @@ public class NodeLibrary {\n         }\n     }\n \n+    private static UpgradeStringResult transformXml(String xml, String newFormatVersion, UpgradeOp... ops) {\n+        try {\n+            Document document = new Builder().build(xml, null);\n+\n+            // Check that this is a NodeBox document and set the new formatVersion.\n+            Element root = document.getRootElement();\n+            checkArgument(root.getLocalName().equals(\"ndbx\"), \"This is not a valid NodeBox document.\");\n+            root.addAttribute(new Attribute(\"formatVersion\", newFormatVersion));\n+\n+            ArrayList<String> warnings = new ArrayList<String>();\n+            for (UpgradeOp op : ops) {\n+                transformXmlRecursive(document.getRootElement(), op);\n+                warnings.addAll(op.getWarnings());\n+            }\n+            return new UpgradeStringResult(document.toXML(), warnings);\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Error while upgrading to \" + newFormatVersion + \".\", e);\n+        }\n+    }\n+\n+    private static void transformXmlRecursive(Element e, UpgradeOp op) {\n+        op.apply(e);\n+        Elements children = e.getChildElements();\n+        for (int i = 0; i < children.size(); i++) {\n+            Element child = children.get(i);\n+            transformXmlRecursive(child, op);\n+        }\n+    }\n+\n     private static UpgradeStringResult transformDocument(Document document, String newFormatVersion, Function<Element, String> function) {\n         // Check that this is a NodeBox document and set the new formatVersion.\n         Element root = document.getRootElement();\n@@ -325,16 +474,16 @@ public class NodeLibrary {\n \n         // Recursively transform all nodes.\n         ArrayList<String> warnings = new ArrayList<String>();\n-        transformNodesRecursive(root, function, warnings);\n+        transformElementsRecursive(root, \"node\", function, warnings);\n         return new UpgradeStringResult(document.toXML(), warnings);\n     }\n \n-    private static void transformNodesRecursive(Element parent, Function<Element, String> function, List<String> warnings) {\n-        Elements nodes = parent.getChildElements(\"node\");\n+    private static void transformElementsRecursive(Element parent, String elementName, Function<Element, String> function, List<String> warnings) {\n+        Elements nodes = parent.getChildElements(elementName);\n         for (int i = 0; i < nodes.size(); i++) {\n             Element node = nodes.get(i);\n             function.apply(node);\n-            transformNodesRecursive(node, function, warnings);\n+            transformElementsRecursive(node, elementName, function, warnings);\n         }\n     }\n \n@@ -346,7 +495,6 @@ public class NodeLibrary {\n             this.xml = xml;\n             this.warnings = warnings;\n         }\n-\n     }\n \n     //// Loading ////\n", "test_patch": "diff --git a/src/test/java/nodebox/node/NodeLibraryTest.java b/src/test/java/nodebox/node/NodeLibraryTest.java\nindex 198a3d1..cfb58e1 100644\n--- a/src/test/java/nodebox/node/NodeLibraryTest.java\n+++ b/src/test/java/nodebox/node/NodeLibraryTest.java\n@@ -354,7 +354,7 @@ public class NodeLibraryTest {\n     @Test\n     public void testUpgrade1to2() {\n         File version1File = new File(\"src/test/files/upgrade-v1.ndbx\");\n-        UpgradeResult result = NodeLibrary.upgradeTo(version1File, \"2\");\n+        UpgradeResult result = NodeLibrary.upgrade(version1File);\n         assertTrue(\"Result should contain updated position: \" + result.getXml(), result.getXml().contains(\"position=\\\"12.00,2.00\\\"\"));\n         NodeLibrary upgradedLibrary = result.getLibrary(version1File, NodeRepository.of());\n         Node root = upgradedLibrary.getRoot();\n@@ -362,6 +362,22 @@ public class NodeLibraryTest {\n         assertEquals(new Point(12, 2), alpha.getPosition());\n     }\n \n+    @Test\n+    public void testUpgrade2to3() {\n+        File version2File = new File(\"src/test/files/upgrade-v2.ndbx\");\n+        UpgradeResult result = NodeLibrary.upgradeTo(version2File, \"3\");\n+        NodeLibrary mathLibrary = NodeLibrary.load(new File(\"libraries/math/math.ndbx\"), NodeRepository.of());\n+        NodeLibrary upgradedLibrary = result.getLibrary(version2File, NodeRepository.of(mathLibrary));\n+        Node root = upgradedLibrary.getRoot();\n+        assertTrue(root.hasChild(\"round2\"));\n+        Node round2 = root.getChild(\"round2\");\n+        assertEquals(\"round\", round2.getPrototype().getName());\n+        Node subnet1 = root.getChild(\"subnet1\");\n+        assertTrue(subnet1.hasChild(\"round1\"));\n+        Port value = subnet1.getInput(\"value\");\n+        assertEquals(\"round1.value\", value.getChildReference());\n+    }\n+\n     /**\n      * Test upgrading from 0.9 files, which should fail since we don't support those conversions.\n      */\n"}
