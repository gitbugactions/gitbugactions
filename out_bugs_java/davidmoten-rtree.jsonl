{"repository": "davidmoten/rtree", "clone_url": "https://github.com/davidmoten/rtree.git", "timestamp": "2023-05-30T20:40:41.014401Z", "commit_hash": "3cb0490709bb98d49990d49113009a4951aff5d8", "commit_message": "Merge pull request #92 from davidmoten/intersect-with-zero-area-rect\n\nfix intersection with zero area rectangles", "related_issues": "", "bug_patch": "diff --git a/.travis.yml b/.travis.yml\nindex 0ff3ee2..0fb56a1 100644\n--- a/.travis.yml\n+++ b/.travis.yml\n@@ -1,10 +1,6 @@\n language: java\n-dist: precise\n jdk:\n-  - oraclejdk8\n-  - oraclejdk7\n-  - openjdk7\n-  - openjdk6\n+  - openjdk8\n \n # Workaround for buffer overflow with openjdk6\n # https://github.com/travis-ci/travis-ci/issues/5227\ndiff --git a/pom.xml b/pom.xml\nindex dff449f..3d8b641 100644\n--- a/pom.xml\n+++ b/pom.xml\n@@ -160,6 +160,13 @@\n             <optional>true</optional>\n         </dependency>\n \n+        <dependency>\n+            <groupId>javax.annotation</groupId>\n+            <artifactId>javax.annotation-api</artifactId>\n+            <version>1.3.2</version>\n+            <optional>true</optional>\n+        </dependency>\n+\n     </dependencies>\n \n     <profiles>\ndiff --git a/src/main/java/com/github/davidmoten/rtree/internal/RectangleUtil.java b/src/main/java/com/github/davidmoten/rtree/internal/RectangleUtil.java\nindex 597792f..421179b 100644\n--- a/src/main/java/com/github/davidmoten/rtree/internal/RectangleUtil.java\n+++ b/src/main/java/com/github/davidmoten/rtree/internal/RectangleUtil.java\n@@ -1,5 +1,7 @@\n package com.github.davidmoten.rtree.internal;\n \n+import java.awt.geom.Line2D;\n+\n public final class RectangleUtil {\n \n     private RectangleUtil() {\n@@ -37,8 +39,14 @@ public final class RectangleUtil {\n      * @since 1.2\n      */\n     public static final int OUT_BOTTOM = 8;\n-\n-    public static boolean rectangleIntersectsLine(double rectX, double rectY, double rectWidth,\n+    \n+    public static boolean rectangleIntersectsLine(double rectX, double rectY, double rectWidth, double rectHeight,\n+            double x1, double y1, double x2, double y2) {\n+        return _rectangleIntersectsLine(rectX, rectY, rectWidth, rectHeight, x1, y1, x2, y2)\n+                || Line2D.Double.linesIntersect(rectX, rectY, rectX + rectWidth, rectY + rectHeight, x1, y1, x2, y2);\n+    }\n+    \n+    private static boolean _rectangleIntersectsLine(double rectX, double rectY, double rectWidth,\n             double rectHeight, double x1, double y1, double x2, double y2) {\n         if (rectangleCornerOnSegment(rectX, rectY, rectWidth, rectHeight, x1, y1, x2, y2)) {\n             return true;\n", "test_patch": "diff --git a/src/test/java/com/github/davidmoten/rtree/RTreeTest.java b/src/test/java/com/github/davidmoten/rtree/RTreeTest.java\nindex 05de420..624604c 100644\n--- a/src/test/java/com/github/davidmoten/rtree/RTreeTest.java\n+++ b/src/test/java/com/github/davidmoten/rtree/RTreeTest.java\n@@ -1140,5 +1140,5 @@ public class RTreeTest {\n                 .assertValueCount(22) //\n                 .assertCompleted();\n     }\n-\n+    \n }\ndiff --git a/src/test/java/com/github/davidmoten/rtree/geometry/LineTest.java b/src/test/java/com/github/davidmoten/rtree/geometry/LineTest.java\nindex 6ef9991..34766d8 100644\n--- a/src/test/java/com/github/davidmoten/rtree/geometry/LineTest.java\n+++ b/src/test/java/com/github/davidmoten/rtree/geometry/LineTest.java\n@@ -5,6 +5,9 @@ import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertTrue;\n \n+import java.awt.geom.Line2D;\n+import java.awt.geom.Rectangle2D;\n+\n import org.junit.Test;\n \n public final class LineTest {\n@@ -190,6 +193,35 @@ public final class LineTest {\n     @Test\n     public void testLineDoesIntersectPoint() {\n         assertTrue(Geometries.line(1.5, 1.5, 2.5, 2.5).intersects(point(2, 2)));\n+        Rectangle2D d;\n+    }\n+    \n+    @Test\n+    public void testLineDoubleIntersectsWithHorizontalLine() {\n+        {  // test expectation on Line2D.Double.intersectsLine which we depend on \n+            Line2D.Double line = new Line2D.Double(35.0d, -25.0d, 45.0d, -25.0d);\n+            assertTrue(line.intersectsLine(40.0d, -20.0d, 45.0d, -40.0d));\n+        }\n+        {\n+            Line line = Geometries.line(40.0d, -20.0d, 45.0d, -40.0d);\n+            Line horizontalLine = Geometries.line(35.0d, -25.0d, 45.0d, -25.0d);\n+            \n+            assertTrue(line.intersects(horizontalLine.mbr()));\n+        }\n+    }\n+    \n+    @Test\n+    public void testLineFloatIntersectsWithHorizontalLine() {\n+        {  // test expectation on Line2D.Double.intersectsLine which we depend on \n+            Line2D.Float line = new Line2D.Float(35.0f, -25.0f, 45.0f, -25.0f);\n+            assertTrue(line.intersectsLine(40.0f, -20.0f, 45.0f, -40.0f));\n+        }\n+        {\n+            Line line = Geometries.line(40.0f, -20.0f, 45.0f, -40.0f);\n+            Line horizontalLine = Geometries.line(35.0f, -25.0f, 45.0f, -25.0f);\n+            \n+            assertTrue(line.intersects(horizontalLine.mbr()));\n+        }\n     }\n \n }\n"}
{"repository": "davidmoten/rtree", "clone_url": "https://github.com/davidmoten/rtree.git", "timestamp": "2023-05-30T20:47:01.825668Z", "commit_hash": "8786a08157f31ccd61ed75437912a9a4c3b21b48", "commit_message": "fix Line.lineIntersectsRect #91\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/com/github/davidmoten/rtree/internal/RectangleUtil.java b/src/main/java/com/github/davidmoten/rtree/internal/RectangleUtil.java\nindex 597792f..421179b 100644\n--- a/src/main/java/com/github/davidmoten/rtree/internal/RectangleUtil.java\n+++ b/src/main/java/com/github/davidmoten/rtree/internal/RectangleUtil.java\n@@ -1,5 +1,7 @@\n package com.github.davidmoten.rtree.internal;\n \n+import java.awt.geom.Line2D;\n+\n public final class RectangleUtil {\n \n     private RectangleUtil() {\n@@ -37,8 +39,14 @@ public final class RectangleUtil {\n      * @since 1.2\n      */\n     public static final int OUT_BOTTOM = 8;\n-\n-    public static boolean rectangleIntersectsLine(double rectX, double rectY, double rectWidth,\n+    \n+    public static boolean rectangleIntersectsLine(double rectX, double rectY, double rectWidth, double rectHeight,\n+            double x1, double y1, double x2, double y2) {\n+        return _rectangleIntersectsLine(rectX, rectY, rectWidth, rectHeight, x1, y1, x2, y2)\n+                || Line2D.Double.linesIntersect(rectX, rectY, rectX + rectWidth, rectY + rectHeight, x1, y1, x2, y2);\n+    }\n+    \n+    private static boolean _rectangleIntersectsLine(double rectX, double rectY, double rectWidth,\n             double rectHeight, double x1, double y1, double x2, double y2) {\n         if (rectangleCornerOnSegment(rectX, rectY, rectWidth, rectHeight, x1, y1, x2, y2)) {\n             return true;\n", "test_patch": "diff --git a/src/test/java/com/github/davidmoten/rtree/RTreeTest.java b/src/test/java/com/github/davidmoten/rtree/RTreeTest.java\nindex 05de420..624604c 100644\n--- a/src/test/java/com/github/davidmoten/rtree/RTreeTest.java\n+++ b/src/test/java/com/github/davidmoten/rtree/RTreeTest.java\n@@ -1140,5 +1140,5 @@ public class RTreeTest {\n                 .assertValueCount(22) //\n                 .assertCompleted();\n     }\n-\n+    \n }\ndiff --git a/src/test/java/com/github/davidmoten/rtree/geometry/LineTest.java b/src/test/java/com/github/davidmoten/rtree/geometry/LineTest.java\nindex 6ef9991..34766d8 100644\n--- a/src/test/java/com/github/davidmoten/rtree/geometry/LineTest.java\n+++ b/src/test/java/com/github/davidmoten/rtree/geometry/LineTest.java\n@@ -5,6 +5,9 @@ import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertTrue;\n \n+import java.awt.geom.Line2D;\n+import java.awt.geom.Rectangle2D;\n+\n import org.junit.Test;\n \n public final class LineTest {\n@@ -190,6 +193,35 @@ public final class LineTest {\n     @Test\n     public void testLineDoesIntersectPoint() {\n         assertTrue(Geometries.line(1.5, 1.5, 2.5, 2.5).intersects(point(2, 2)));\n+        Rectangle2D d;\n+    }\n+    \n+    @Test\n+    public void testLineDoubleIntersectsWithHorizontalLine() {\n+        {  // test expectation on Line2D.Double.intersectsLine which we depend on \n+            Line2D.Double line = new Line2D.Double(35.0d, -25.0d, 45.0d, -25.0d);\n+            assertTrue(line.intersectsLine(40.0d, -20.0d, 45.0d, -40.0d));\n+        }\n+        {\n+            Line line = Geometries.line(40.0d, -20.0d, 45.0d, -40.0d);\n+            Line horizontalLine = Geometries.line(35.0d, -25.0d, 45.0d, -25.0d);\n+            \n+            assertTrue(line.intersects(horizontalLine.mbr()));\n+        }\n+    }\n+    \n+    @Test\n+    public void testLineFloatIntersectsWithHorizontalLine() {\n+        {  // test expectation on Line2D.Double.intersectsLine which we depend on \n+            Line2D.Float line = new Line2D.Float(35.0f, -25.0f, 45.0f, -25.0f);\n+            assertTrue(line.intersectsLine(40.0f, -20.0f, 45.0f, -40.0f));\n+        }\n+        {\n+            Line line = Geometries.line(40.0f, -20.0f, 45.0f, -40.0f);\n+            Line horizontalLine = Geometries.line(35.0f, -25.0f, 45.0f, -25.0f);\n+            \n+            assertTrue(line.intersects(horizontalLine.mbr()));\n+        }\n     }\n \n }\n"}
{"repository": "davidmoten/rtree", "clone_url": "https://github.com/davidmoten/rtree.git", "timestamp": "2023-05-30T20:52:44.074298Z", "commit_hash": "2beeb6fbe649b3d099004d5b024a085b0b9a90d4", "commit_message": "fix deletion of PointDouble by implementing hashCode and equals #81 (#83)\n\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/com/github/davidmoten/rtree/geometry/internal/PointDouble.java b/src/main/java/com/github/davidmoten/rtree/geometry/internal/PointDouble.java\nindex c0169ca..30d73b2 100644\n--- a/src/main/java/com/github/davidmoten/rtree/geometry/internal/PointDouble.java\n+++ b/src/main/java/com/github/davidmoten/rtree/geometry/internal/PointDouble.java\n@@ -105,4 +105,32 @@ public final class PointDouble implements Point {\n         return true;\n     }\n \n+    @Override\n+    public int hashCode() {\n+        final int prime = 31;\n+        int result = 1;\n+        long temp;\n+        temp = Double.doubleToLongBits(x);\n+        result = prime * result + (int) (temp ^ (temp >>> 32));\n+        temp = Double.doubleToLongBits(y);\n+        result = prime * result + (int) (temp ^ (temp >>> 32));\n+        return result;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj)\n+            return true;\n+        if (obj == null)\n+            return false;\n+        if (getClass() != obj.getClass())\n+            return false;\n+        PointDouble other = (PointDouble) obj;\n+        if (Double.doubleToLongBits(x) != Double.doubleToLongBits(other.x))\n+            return false;\n+        if (Double.doubleToLongBits(y) != Double.doubleToLongBits(other.y))\n+            return false;\n+        return true;\n+    }\n+\n }\n\\ No newline at end of file\n", "test_patch": "diff --git a/src/test/java/com/github/davidmoten/rtree/RTreeTest.java b/src/test/java/com/github/davidmoten/rtree/RTreeTest.java\nindex 9f64ff2..05de420 100644\n--- a/src/test/java/com/github/davidmoten/rtree/RTreeTest.java\n+++ b/src/test/java/com/github/davidmoten/rtree/RTreeTest.java\n@@ -1059,6 +1059,22 @@ public class RTreeTest {\n         assertEquals(6, (int) tree.search(rectangle).count().toBlocking().single());\n \n     }\n+    \n+    @Test\n+    public void testDeleteIssue81d() {\n+         RTree<Object, Point> t = RTree.create();\n+         t = t.add(1, Geometries.pointGeographic(123.4d, 23.3d));\n+         t = t.delete(1, Geometries.pointGeographic(123.4d, 23.3d));\n+         assertEquals(0, t.size());\n+     }\n+    \n+     @Test\n+     public void testDeleteIssue81f() {\n+         RTree<Object, Point> t = RTree.create();\n+         t = t.add(1, Geometries.pointGeographic(123.4f, 23.3f));\n+         t = t.delete(1, Geometries.pointGeographic(123.4f, 23.3f));\n+         assertEquals(0, t.size());\n+     }\n \n     private static Func2<Point, Circle, Double> distanceCircleToPoint = new Func2<Point, Circle, Double>() {\n         @Override\n"}
{"repository": "davidmoten/rtree", "clone_url": "https://github.com/davidmoten/rtree.git", "timestamp": "2023-05-30T21:07:19.792549Z", "commit_hash": "75da48987d7235afe1cfc970df4717c6f1c2f957", "commit_message": "fix #60 Point.contains() not working\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/com/github/davidmoten/rtree/geometry/Point.java b/src/main/java/com/github/davidmoten/rtree/geometry/Point.java\nindex bf16bf1..57b4cb2 100644\n--- a/src/main/java/com/github/davidmoten/rtree/geometry/Point.java\n+++ b/src/main/java/com/github/davidmoten/rtree/geometry/Point.java\n@@ -119,7 +119,7 @@ public final class Point implements Rectangle {\n \n     @Override\n     public boolean contains(double x, double y) {\n-        return x == x && y == y;\n+        return this.x == x && this.y == y;\n     }\n \n     @Override\n", "test_patch": "diff --git a/src/test/java/com/github/davidmoten/rtree/geometry/PointTest.java b/src/test/java/com/github/davidmoten/rtree/geometry/PointTest.java\nindex acd820c..0b309b9 100644\n--- a/src/test/java/com/github/davidmoten/rtree/geometry/PointTest.java\n+++ b/src/test/java/com/github/davidmoten/rtree/geometry/PointTest.java\n@@ -8,72 +8,84 @@ import org.junit.Test;\n \n public class PointTest {\n \n-    private static final double PRECISION = 0.000001;\n+\tprivate static final double PRECISION = 0.000001;\n \n-    @Test\n-    public void testCoordinates() {\n-        Point point = Geometries.point(1, 2);\n-        assertEquals(1, point.x(), PRECISION);\n-        assertEquals(2, point.y(), PRECISION);\n-    }\n+\t@Test\n+\tpublic void testCoordinates() {\n+\t\tPoint point = Geometries.point(1, 2);\n+\t\tassertEquals(1, point.x(), PRECISION);\n+\t\tassertEquals(2, point.y(), PRECISION);\n+\t}\n \n-    @Test\n-    public void testDistanceToRectangle() {\n-        Point p1 = Geometries.point(1, 2);\n-        Rectangle r = Geometries.rectangle(4, 6, 4, 6);\n-        assertEquals(5, p1.distance(r), PRECISION);\n-    }\n+\t@Test\n+\tpublic void testDistanceToRectangle() {\n+\t\tPoint p1 = Geometries.point(1, 2);\n+\t\tRectangle r = Geometries.rectangle(4, 6, 4, 6);\n+\t\tassertEquals(5, p1.distance(r), PRECISION);\n+\t}\n \n-    @Test\n-    public void testDistanceToPoint() {\n-        Point p1 = Geometries.point(1, 2);\n-        Point p2 = Geometries.point(4, 6);\n-        assertEquals(5, p1.distance(p2), PRECISION);\n-    }\n+\t@Test\n+\tpublic void testDistanceToPoint() {\n+\t\tPoint p1 = Geometries.point(1, 2);\n+\t\tPoint p2 = Geometries.point(4, 6);\n+\t\tassertEquals(5, p1.distance(p2), PRECISION);\n+\t}\n \n-    @Test\n-    public void testMbr() {\n-        Point p = Geometries.point(1, 2);\n-        Point p2 = Geometries.point(1, 2);\n-        assertEquals(p, p2);\n-    }\n+\t@Test\n+\tpublic void testMbr() {\n+\t\tPoint p = Geometries.point(1, 2);\n+\t\tPoint p2 = Geometries.point(1, 2);\n+\t\tassertEquals(p, p2);\n+\t}\n \n-    @Test\n-    public void testPointIntersectsItself() {\n-        Point p = Geometries.point(1, 2);\n-        assertTrue(p.distance(p.mbr()) == 0);\n-    }\n+\t@Test\n+\tpublic void testPointIntersectsItself() {\n+\t\tPoint p = Geometries.point(1, 2);\n+\t\tassertTrue(p.distance(p.mbr()) == 0);\n+\t}\n \n-    @Test\n-    public void testIntersectIsFalseWhenPointsDiffer() {\n-        Point p1 = Geometries.point(1, 2);\n-        Point p2 = Geometries.point(1, 2.000001);\n-        assertFalse(p1.distance(p2.mbr()) == 0);\n-    }\n+\t@Test\n+\tpublic void testIntersectIsFalseWhenPointsDiffer() {\n+\t\tPoint p1 = Geometries.point(1, 2);\n+\t\tPoint p2 = Geometries.point(1, 2.000001);\n+\t\tassertFalse(p1.distance(p2.mbr()) == 0);\n+\t}\n \n-    @Test\n-    public void testEquality() {\n-        Point p1 = Geometries.point(1, 2);\n-        Point p2 = Geometries.point(1, 2);\n-        assertTrue(p1.equals(p2));\n-    }\n+\t@Test\n+\tpublic void testEquality() {\n+\t\tPoint p1 = Geometries.point(1, 2);\n+\t\tPoint p2 = Geometries.point(1, 2);\n+\t\tassertTrue(p1.equals(p2));\n+\t}\n \n-    @Test\n-    public void testInequality() {\n-        Point p1 = Geometries.point(1, 2);\n-        Point p2 = Geometries.point(1, 3);\n-        assertFalse(p1.equals(p2));\n-    }\n+\t@Test\n+\tpublic void testInequality() {\n+\t\tPoint p1 = Geometries.point(1, 2);\n+\t\tPoint p2 = Geometries.point(1, 3);\n+\t\tassertFalse(p1.equals(p2));\n+\t}\n \n-    @Test\n-    public void testInequalityToNull() {\n-        Point p1 = Geometries.point(1, 2);\n-        assertFalse(p1.equals(null));\n-    }\n+\t@Test\n+\tpublic void testInequalityToNull() {\n+\t\tPoint p1 = Geometries.point(1, 2);\n+\t\tassertFalse(p1.equals(null));\n+\t}\n \n-    @Test\n-    public void testHashCode() {\n-        Point p = Geometries.point(1, 2);\n-        assertEquals(-260045887, p.hashCode());\n-    }\n+\t@Test\n+\tpublic void testHashCode() {\n+\t\tPoint p = Geometries.point(1, 2);\n+\t\tassertEquals(-260045887, p.hashCode());\n+\t}\n+\n+\t@Test\n+\tpublic void testDoesNotContain() {\n+\t\tPoint p = Geometries.point(1, 2);\n+\t\tassertFalse(p.contains(1, 3));\n+\t}\n+\t\n+\t@Test\n+\tpublic void testContains() {\n+\t\tPoint p = Geometries.point(1, 2);\n+\t\tassertTrue(p.contains(1, 2));\n+\t}\n }\n"}
{"repository": "davidmoten/rtree", "clone_url": "https://github.com/davidmoten/rtree.git", "timestamp": "2023-05-30T21:13:35.796646Z", "commit_hash": "16400fc53d776a352ca65390c5e93e4e479f3d32", "commit_message": "apply fix for #50, deserialization bug where readFully did not retry read into array\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/com/github/davidmoten/rtree/fbs/SerializerFlatBuffers.java b/src/main/java/com/github/davidmoten/rtree/fbs/SerializerFlatBuffers.java\nindex aa1a46c..575a571 100644\n--- a/src/main/java/com/github/davidmoten/rtree/fbs/SerializerFlatBuffers.java\n+++ b/src/main/java/com/github/davidmoten/rtree/fbs/SerializerFlatBuffers.java\n@@ -160,9 +160,15 @@ public final class SerializerFlatBuffers<T, S extends Geometry> implements Seria\n     @VisibleForTesting\n     static byte[] readFully(InputStream is, int numBytes) throws IOException {\n         byte[] b = new byte[numBytes];\n-        int n = is.read(b);\n-        if (n != numBytes)\n-            throw new RuntimeException(\"unexpected\");\n+        int count = 0;\n+        do {\n+            int n = is.read(b, count, numBytes - count);\n+            if (n > 0) {\n+                count += n;\n+            } else {\n+                throw new RuntimeException(\"unexpected\");\n+            }\n+        } while (count < numBytes);\n         return b;\n     }\n \n", "test_patch": "diff --git a/src/test/java/com/github/davidmoten/rtree/fbs/SerializerFlatBuffersTest.java b/src/test/java/com/github/davidmoten/rtree/fbs/SerializerFlatBuffersTest.java\nindex 695957f..12ba447 100644\n--- a/src/test/java/com/github/davidmoten/rtree/fbs/SerializerFlatBuffersTest.java\n+++ b/src/test/java/com/github/davidmoten/rtree/fbs/SerializerFlatBuffersTest.java\n@@ -108,6 +108,30 @@ public class SerializerFlatBuffersTest {\n     public void testInputStreamNotAsLongAsExpected() throws IOException {\n         SerializerFlatBuffers.readFully(new ByteArrayInputStream(new byte[10]), 12);\n     }\n+    \n+    @Test\n+    public void testInputStreamReturnsArrayInSmallChunks() throws IOException {\n+        InputStream is = new InputStream() {\n+\n+            int i = 0;\n+            @Override\n+            public int read() throws IOException {\n+                i +=1;\n+                if (i == 1) {\n+                    return 1;\n+                } else if (i==2){\n+                    throw new IOException();\n+                } else {\n+                    return 1;\n+                }\n+            }\n+            \n+        };\n+        byte[] b = SerializerFlatBuffers.readFully(is, 2);\n+        assertEquals(2, b.length);\n+        assertEquals(1, b[0]);\n+        assertEquals(1, b[0]);\n+    }\n \n     public static void main(String[] args) throws Exception {\n         // use this with jvisualvm and heap dump, find biggest objects to check\n"}
{"repository": "davidmoten/rtree", "clone_url": "https://github.com/davidmoten/rtree.git", "timestamp": "2023-05-30T21:25:45.541630Z", "commit_hash": "116c1c706871c2d84080b647dd452eabe1521d2f", "commit_message": "fix flatbuffers load of small tree and add add test\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/com/github/davidmoten/rtree/fbs/NonLeafFlatBuffers.java b/src/main/java/com/github/davidmoten/rtree/fbs/NonLeafFlatBuffers.java\nindex 16ec83e..b08a0a6 100644\n--- a/src/main/java/com/github/davidmoten/rtree/fbs/NonLeafFlatBuffers.java\n+++ b/src/main/java/com/github/davidmoten/rtree/fbs/NonLeafFlatBuffers.java\n@@ -33,7 +33,7 @@ final class NonLeafFlatBuffers<T, S extends Geometry> implements NonLeaf<T, S> {\n \n     NonLeafFlatBuffers(Node_ node, Context<T, S> context, Func1<byte[], T> deserializer) {\n         Preconditions.checkNotNull(node);\n-        Preconditions.checkArgument(node.childrenLength() > 0 || node.entriesLength() > 0);\n+        Preconditions.checkArgument(node.childrenLength() > 0);\n         this.node = node;\n         this.context = context;\n         this.deserializer = deserializer;\ndiff --git a/src/main/java/com/github/davidmoten/rtree/fbs/SerializerFlatBuffers.java b/src/main/java/com/github/davidmoten/rtree/fbs/SerializerFlatBuffers.java\nindex da3fa41..f269299 100644\n--- a/src/main/java/com/github/davidmoten/rtree/fbs/SerializerFlatBuffers.java\n+++ b/src/main/java/com/github/davidmoten/rtree/fbs/SerializerFlatBuffers.java\n@@ -40,13 +40,16 @@ public final class SerializerFlatBuffers<T, S extends Geometry> implements Seria\n         this.factory = new FactoryFlatBuffers<T, S>(serializer, deserializer);\n     }\n \n-    public static <T, S extends Geometry> Serializer<T, S> create(\n-            Func1<T, byte[]> serializer, Func1<byte[], T> deserializer) {\n+    public static <T, S extends Geometry> Serializer<T, S> create(Func1<T, byte[]> serializer,\n+            Func1<byte[], T> deserializer) {\n         return new SerializerFlatBuffers<T, S>(serializer, deserializer);\n     }\n \n-    /* (non-Javadoc)\n-     * @see com.github.davidmoten.rtree.fbs.Serializer#serialize(com.github.davidmoten.rtree.RTree, java.io.OutputStream)\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see com.github.davidmoten.rtree.fbs.Serializer#serialize(com.github.\n+     * davidmoten.rtree.RTree, java.io.OutputStream)\n      */\n     @Override\n     public void write(RTree<T, S> tree, OutputStream os) throws IOException {\n@@ -88,11 +91,14 @@ public final class SerializerFlatBuffers<T, S extends Geometry> implements Seria\n         }\n     }\n \n-    /* (non-Javadoc)\n-     * @see com.github.davidmoten.rtree.fbs.Serializer#deserialize(long, java.io.InputStream, com.github.davidmoten.rtree.InternalStructure)\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see com.github.davidmoten.rtree.fbs.Serializer#deserialize(long,\n+     * java.io.InputStream, com.github.davidmoten.rtree.InternalStructure)\n      */\n     @Override\n-    public RTree<T, S> read( InputStream is,long sizeBytes, InternalStructure structure)\n+    public RTree<T, S> read(InputStream is, long sizeBytes, InternalStructure structure)\n             throws IOException {\n         byte[] bytes = readFully(is, (int) sizeBytes);\n         Tree_ t = Tree_.getRootAsTree_(ByteBuffer.wrap(bytes));\n@@ -101,7 +107,11 @@ public final class SerializerFlatBuffers<T, S extends Geometry> implements Seria\n                 t.context().maxChildren(), new SelectorRStar(), new SplitterRStar(), factory);\n         final Node<T, S> root;\n         if (structure == InternalStructure.SINGLE_ARRAY) {\n-            root = new NonLeafFlatBuffers<T, S>(node, context, factory.deserializer());\n+            if (node.childrenLength() > 0) {\n+                root = new NonLeafFlatBuffers<T, S>(node, context, factory.deserializer());\n+            } else {\n+                root = new LeafFlatBuffers<T, S>(node, context, factory.deserializer());\n+            }\n         } else {\n             root = toNodeDefault(node, context, factory.deserializer());\n         }\n@@ -131,5 +141,4 @@ public final class SerializerFlatBuffers<T, S extends Geometry> implements Seria\n         return b;\n     }\n \n-\n }\n", "test_patch": "diff --git a/src/test/java/com/github/davidmoten/rtree/SerializersTest.java b/src/test/java/com/github/davidmoten/rtree/SerializersTest.java\nindex 0c24f85..0743b59 100644\n--- a/src/test/java/com/github/davidmoten/rtree/SerializersTest.java\n+++ b/src/test/java/com/github/davidmoten/rtree/SerializersTest.java\n@@ -55,6 +55,26 @@ public class SerializersTest {\n         check(serializer, a, b);\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n+    @Test\n+    public void testAddToFlatBuffers() throws IOException {\n+        Entry<String, Point> a = Entries.entry(\"hello\", Geometries.point(1, 2));\n+        Entry<String, Point> b = Entries.entry(\"there\", Geometries.point(3, 4));\n+        Entry<String, Point> c = Entries.entry(\"you\", Geometries.point(5, 6));\n+        RTree<String, Point> tree = RTree.create();\n+        tree = tree.add(a).add(b);\n+        Serializer<String, Point> serializer = Serializers.flatBuffers().utf8();\n+        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n+        serializer.write(tree, bytes);\n+        bytes.close();\n+        byte[] array = bytes.toByteArray();\n+        RTree<String, Point> tree2 = serializer.read(new ByteArrayInputStream(array), array.length,\n+                InternalStructure.SINGLE_ARRAY);\n+        tree2 = tree2.add(c);\n+        assertEquals(Sets.newHashSet(a, b, c),\n+                Sets.newHashSet(tree2.entries().toList().toBlocking().single()));\n+    }\n+\n     private static void checkRoundTripPoint(Serializer<String, Point> serializer)\n             throws IOException {\n         Entry<String, Point> a = Entries.entry(\"hello\", Geometries.point(1, 2));\n@@ -72,7 +92,7 @@ public class SerializersTest {\n         bytes.close();\n         {\n             ByteArrayInputStream input = new ByteArrayInputStream(bytes.toByteArray());\n-            RTree<String, S> tree2 = serializer.read( input,bytes.size(),\n+            RTree<String, S> tree2 = serializer.read(input, bytes.size(),\n                     InternalStructure.DEFAULT);\n             assertEquals(2, tree2.size());\n             assertEquals(Sets.newHashSet(a, b),\n@@ -80,14 +100,14 @@ public class SerializersTest {\n         }\n         {\n             ByteArrayInputStream input = new ByteArrayInputStream(bytes.toByteArray());\n-            RTree<String, S> tree2 = serializer.read( input,bytes.size(),\n+            RTree<String, S> tree2 = serializer.read(input, bytes.size(),\n                     InternalStructure.SINGLE_ARRAY);\n             assertEquals(2, tree2.size());\n             assertEquals(Sets.newHashSet(a, b),\n                     Sets.newHashSet(tree2.entries().toList().toBlocking().single()));\n         }\n     }\n-    \n+\n     @Test\n     public void isUtilityClass() {\n         Asserts.assertIsUtilityClass(Serializers.class);\n"}
{"repository": "davidmoten/rtree", "clone_url": "https://github.com/davidmoten/rtree.git", "timestamp": "2023-05-30T21:45:17.212406Z", "commit_hash": "178bdb541f90cc0e32da224cc2065c521c4b6ae0", "commit_message": "fix backpressure path\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/com/github/davidmoten/rtree/OnSubscribeSearch.java b/src/main/java/com/github/davidmoten/rtree/OnSubscribeSearch.java\nindex 50009bc..0b3ddae 100644\n--- a/src/main/java/com/github/davidmoten/rtree/OnSubscribeSearch.java\n+++ b/src/main/java/com/github/davidmoten/rtree/OnSubscribeSearch.java\n@@ -47,8 +47,8 @@ final class OnSubscribeSearch<T, S extends Geometry> implements OnSubscribe<Entr\n         @Override\n         public void request(long n) {\n             // TODO remove this patch that exists because of RxJava PR 3727\n-            // if (n == Long.MAX_VALUE - 1)\n-            // n = Long.MAX_VALUE;\n+            if (n == Long.MAX_VALUE - 1)\n+                n = Long.MAX_VALUE;\n             try {\n                 if (n <= 0 || requested.get() == Long.MAX_VALUE)\n                     // none requested or already started with fast path\ndiff --git a/src/main/java/com/github/davidmoten/rtree/fbs/NodeFlatBuffers.java b/src/main/java/com/github/davidmoten/rtree/fbs/NodeFlatBuffers.java\ndeleted file mode 100644\nindex 1417a4b..0000000\n--- a/src/main/java/com/github/davidmoten/rtree/fbs/NodeFlatBuffers.java\n+++ /dev/null\n@@ -1,200 +0,0 @@\n-package com.github.davidmoten.rtree.fbs;\n-\n-import java.nio.ByteBuffer;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-\n-import com.github.davidmoten.guavamini.Preconditions;\n-import com.github.davidmoten.rtree.Context;\n-import com.github.davidmoten.rtree.Entries;\n-import com.github.davidmoten.rtree.Entry;\n-import com.github.davidmoten.rtree.Node;\n-import com.github.davidmoten.rtree.NonLeaf;\n-import com.github.davidmoten.rtree.fbs.generated.Box_;\n-import com.github.davidmoten.rtree.fbs.generated.Entry_;\n-import com.github.davidmoten.rtree.fbs.generated.GeometryType_;\n-import com.github.davidmoten.rtree.fbs.generated.Geometry_;\n-import com.github.davidmoten.rtree.fbs.generated.Node_;\n-import com.github.davidmoten.rtree.geometry.Geometries;\n-import com.github.davidmoten.rtree.geometry.Geometry;\n-import com.github.davidmoten.rtree.geometry.Point;\n-import com.github.davidmoten.rtree.geometry.Rectangle;\n-import com.github.davidmoten.rtree.internal.LeafDefault;\n-import com.github.davidmoten.rtree.internal.NodeAndEntries;\n-\n-import rx.Subscriber;\n-import rx.functions.Func1;\n-\n-final class NodeFlatBuffers<T, S extends Geometry> implements NonLeaf<T, S> {\n-\n-    private final Node_ node;\n-    private final Context<T, S> context;\n-    private final Func1<byte[], T> deserializer;\n-\n-    NodeFlatBuffers(Node_ node, Context<T, S> context, Func1<byte[], T> deserializer) {\n-        Preconditions.checkNotNull(node);\n-        Preconditions.checkArgument(node.childrenLength() > 0 || node.entriesLength() > 0);\n-        this.node = node;\n-        this.context = context;\n-        this.deserializer = deserializer;\n-    }\n-\n-    @Override\n-    public List<Node<T, S>> add(Entry<? extends T, ? extends S> entry) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    @Override\n-    public NodeAndEntries<T, S> delete(Entry<? extends T, ? extends S> entry, boolean all) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    @Override\n-    public void searchWithoutBackpressure(Func1<? super Geometry, Boolean> criterion,\n-            Subscriber<? super Entry<T, S>> subscriber) {\n-        // pass through entry and geometry and box instances to be reused for\n-        // flatbuffers extraction this reduces allocation/gc costs (but of\n-        // course introduces some mutable ugliness into the codebase)\n-        search(node, criterion, subscriber, deserializer, new Entry_(), new Geometry_(),\n-                new Box_());\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private static <T, S extends Geometry> void search(Node_ node,\n-            Func1<? super Geometry, Boolean> criterion, Subscriber<? super Entry<T, S>> subscriber,\n-            Func1<byte[], T> deserializer, Entry_ entry, Geometry_ geometry, Box_ box) {\n-        {\n-            node.mbb(box);\n-            if (!criterion\n-                    .call(Geometries.rectangle(box.minX(), box.minY(), box.maxX(), box.maxY())))\n-                return;\n-        }\n-        int numChildren = node.childrenLength();\n-        // reduce allocations by reusing objects\n-        Node_ child = new Node_();\n-        if (numChildren > 0) {\n-            for (int i = 0; i < numChildren; i++) {\n-                if (subscriber.isUnsubscribed())\n-                    return;\n-                node.children(child, i);\n-                search(child, criterion, subscriber, deserializer, entry, geometry, box);\n-            }\n-        } else {\n-            int numEntries = node.entriesLength();\n-            // reduce allocations by reusing objects\n-            // check all entries\n-            for (int i = 0; i < numEntries; i++) {\n-                if (subscriber.isUnsubscribed())\n-                    return;\n-                // set entry\n-                node.entries(entry, i);\n-                // set geometry\n-                entry.geometry(geometry);\n-                final Geometry g = toGeometry(geometry);\n-                if (criterion.call(g)) {\n-                    T t = parseObject(deserializer, entry);\n-                    Entry<T, S> ent = Entries.entry(t, (S) g);\n-                    subscriber.onNext(ent);\n-                }\n-            }\n-        }\n-\n-    }\n-\n-    private static <T> T parseObject(Func1<byte[], T> deserializer, Entry_ entry) {\n-        ByteBuffer bb = entry.objectAsByteBuffer();\n-        byte[] bytes = Arrays.copyOfRange(bb.array(), bb.position(), bb.limit());\n-        T t = deserializer.call(bytes);\n-        return t;\n-    }\n-\n-    private List<Node<T, S>> createChildren() {\n-        List<Node<T, S>> children = new ArrayList<Node<T, S>>(node.childrenLength());\n-        // reduce allocations by resusing objects\n-        int numChildren = node.childrenLength();\n-        for (int i = 0; i < numChildren; i++) {\n-            Node_ child = node.children(i);\n-            children.add(new NodeFlatBuffers<T, S>(child, context, deserializer));\n-        }\n-        return children;\n-    }\n-\n-    @Override\n-    public int count() {\n-        int childrenCount = node.childrenLength();\n-        if (childrenCount > 0)\n-            return childrenCount;\n-        else\n-            return node.entriesLength();\n-    }\n-\n-    @Override\n-    public Context<T, S> context() {\n-        return context;\n-    }\n-\n-    @Override\n-    public Geometry geometry() {\n-        return createBox(node.mbb());\n-    }\n-\n-    private static Geometry createBox(Box_ b) {\n-        return Rectangle.create(b.minX(), b.minY(), b.maxX(), b.maxY());\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private static <S extends Geometry> S toGeometry(Geometry_ g) {\n-        final Geometry result;\n-        byte type = g.type();\n-        if (type == GeometryType_.Box) {\n-            result = createBox(g.box());\n-        } else if (type == GeometryType_.Point) {\n-            result = Point.create(g.point().x(), g.point().y());\n-        } else\n-            throw new UnsupportedOperationException();\n-        return (S) result;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"Node [\" + (node.childrenLength() > 0 ? \"NonLeaf\" : \"Leaf\") + \",\"\n-                + createBox(node.mbb()).toString() + \"]\";\n-    }\n-\n-    @Override\n-    public int childrenCount() {\n-        return node.childrenLength();\n-    }\n-\n-    @Override\n-    public Node<T, S> child(int i) {\n-        Node_ child = node.children(i);\n-        if (child.childrenLength() > 0)\n-            return new NodeFlatBuffers<T, S>(child, context, deserializer);\n-        else\n-            return new LeafDefault<T, S>(createEntries(), context);\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private List<Entry<T, S>> createEntries() {\n-        List<Entry<T, S>> entries = new ArrayList<Entry<T, S>>();\n-        int numEntries = node.entriesLength();\n-        Preconditions.checkArgument(numEntries > 0);\n-        Entry_ entry = new Entry_();\n-        Geometry_ geom = new Geometry_();\n-        for (int i = 0; i < numEntries; i++) {\n-            node.entries(entry, i);\n-            entry.geometry(geom);\n-            final Geometry g = toGeometry(geom);\n-            entries.add(Entries.entry(parseObject(deserializer, entry), (S) g));\n-        }\n-        return entries;\n-    }\n-\n-    @Override\n-    public List<Node<T, S>> children() {\n-        return createChildren();\n-    }\n-\n-}\ndiff --git a/src/main/java/com/github/davidmoten/rtree/fbs/NonLeafFlatBuffers.java b/src/main/java/com/github/davidmoten/rtree/fbs/NonLeafFlatBuffers.java\nnew file mode 100644\nindex 0000000..52ca1dc\n--- /dev/null\n+++ b/src/main/java/com/github/davidmoten/rtree/fbs/NonLeafFlatBuffers.java\n@@ -0,0 +1,200 @@\n+package com.github.davidmoten.rtree.fbs;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import com.github.davidmoten.guavamini.Preconditions;\n+import com.github.davidmoten.rtree.Context;\n+import com.github.davidmoten.rtree.Entries;\n+import com.github.davidmoten.rtree.Entry;\n+import com.github.davidmoten.rtree.Node;\n+import com.github.davidmoten.rtree.NonLeaf;\n+import com.github.davidmoten.rtree.fbs.generated.Box_;\n+import com.github.davidmoten.rtree.fbs.generated.Entry_;\n+import com.github.davidmoten.rtree.fbs.generated.GeometryType_;\n+import com.github.davidmoten.rtree.fbs.generated.Geometry_;\n+import com.github.davidmoten.rtree.fbs.generated.Node_;\n+import com.github.davidmoten.rtree.geometry.Geometries;\n+import com.github.davidmoten.rtree.geometry.Geometry;\n+import com.github.davidmoten.rtree.geometry.Point;\n+import com.github.davidmoten.rtree.geometry.Rectangle;\n+import com.github.davidmoten.rtree.internal.LeafDefault;\n+import com.github.davidmoten.rtree.internal.NodeAndEntries;\n+\n+import rx.Subscriber;\n+import rx.functions.Func1;\n+\n+final class NonLeafFlatBuffers<T, S extends Geometry> implements NonLeaf<T, S> {\n+\n+    private final Node_ node;\n+    private final Context<T, S> context;\n+    private final Func1<byte[], T> deserializer;\n+\n+    NonLeafFlatBuffers(Node_ node, Context<T, S> context, Func1<byte[], T> deserializer) {\n+        Preconditions.checkNotNull(node);\n+        Preconditions.checkArgument(node.childrenLength() > 0 || node.entriesLength() > 0);\n+        this.node = node;\n+        this.context = context;\n+        this.deserializer = deserializer;\n+    }\n+\n+    @Override\n+    public List<Node<T, S>> add(Entry<? extends T, ? extends S> entry) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public NodeAndEntries<T, S> delete(Entry<? extends T, ? extends S> entry, boolean all) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void searchWithoutBackpressure(Func1<? super Geometry, Boolean> criterion,\n+            Subscriber<? super Entry<T, S>> subscriber) {\n+        // pass through entry and geometry and box instances to be reused for\n+        // flatbuffers extraction this reduces allocation/gc costs (but of\n+        // course introduces some mutable ugliness into the codebase)\n+        search(node, criterion, subscriber, deserializer, new Entry_(), new Geometry_(),\n+                new Box_());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static <T, S extends Geometry> void search(Node_ node,\n+            Func1<? super Geometry, Boolean> criterion, Subscriber<? super Entry<T, S>> subscriber,\n+            Func1<byte[], T> deserializer, Entry_ entry, Geometry_ geometry, Box_ box) {\n+        {\n+            node.mbb(box);\n+            if (!criterion\n+                    .call(Geometries.rectangle(box.minX(), box.minY(), box.maxX(), box.maxY())))\n+                return;\n+        }\n+        int numChildren = node.childrenLength();\n+        // reduce allocations by reusing objects\n+        Node_ child = new Node_();\n+        if (numChildren > 0) {\n+            for (int i = 0; i < numChildren; i++) {\n+                if (subscriber.isUnsubscribed())\n+                    return;\n+                node.children(child, i);\n+                search(child, criterion, subscriber, deserializer, entry, geometry, box);\n+            }\n+        } else {\n+            int numEntries = node.entriesLength();\n+            // reduce allocations by reusing objects\n+            // check all entries\n+            for (int i = 0; i < numEntries; i++) {\n+                if (subscriber.isUnsubscribed())\n+                    return;\n+                // set entry\n+                node.entries(entry, i);\n+                // set geometry\n+                entry.geometry(geometry);\n+                final Geometry g = toGeometry(geometry);\n+                if (criterion.call(g)) {\n+                    T t = parseObject(deserializer, entry);\n+                    Entry<T, S> ent = Entries.entry(t, (S) g);\n+                    subscriber.onNext(ent);\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    private static <T> T parseObject(Func1<byte[], T> deserializer, Entry_ entry) {\n+        ByteBuffer bb = entry.objectAsByteBuffer();\n+        byte[] bytes = Arrays.copyOfRange(bb.array(), bb.position(), bb.limit());\n+        T t = deserializer.call(bytes);\n+        return t;\n+    }\n+\n+    private List<Node<T, S>> createChildren() {\n+        List<Node<T, S>> children = new ArrayList<Node<T, S>>(node.childrenLength());\n+        // reduce allocations by resusing objects\n+        int numChildren = node.childrenLength();\n+        for (int i = 0; i < numChildren; i++) {\n+            Node_ child = node.children(i);\n+            children.add(new NonLeafFlatBuffers<T, S>(child, context, deserializer));\n+        }\n+        return children;\n+    }\n+\n+    @Override\n+    public int count() {\n+        int childrenCount = node.childrenLength();\n+        if (childrenCount > 0)\n+            return childrenCount;\n+        else\n+            return node.entriesLength();\n+    }\n+\n+    @Override\n+    public Context<T, S> context() {\n+        return context;\n+    }\n+\n+    @Override\n+    public Geometry geometry() {\n+        return createBox(node.mbb());\n+    }\n+\n+    private static Geometry createBox(Box_ b) {\n+        return Rectangle.create(b.minX(), b.minY(), b.maxX(), b.maxY());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static <S extends Geometry> S toGeometry(Geometry_ g) {\n+        final Geometry result;\n+        byte type = g.type();\n+        if (type == GeometryType_.Box) {\n+            result = createBox(g.box());\n+        } else if (type == GeometryType_.Point) {\n+            result = Point.create(g.point().x(), g.point().y());\n+        } else\n+            throw new UnsupportedOperationException();\n+        return (S) result;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"Node [\" + (node.childrenLength() > 0 ? \"NonLeaf\" : \"Leaf\") + \",\"\n+                + createBox(node.mbb()).toString() + \"]\";\n+    }\n+\n+    @Override\n+    public int childrenCount() {\n+        return node.childrenLength();\n+    }\n+\n+    @Override\n+    public Node<T, S> child(int i) {\n+        Node_ child = node.children(i);\n+        if (child.childrenLength() > 0)\n+            return new NonLeafFlatBuffers<T, S>(child, context, deserializer);\n+        else\n+            return new LeafDefault<T, S>(createEntries(child), context);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private List<Entry<T, S>> createEntries(Node_ node) {\n+        List<Entry<T, S>> entries = new ArrayList<Entry<T, S>>();\n+        int numEntries = node.entriesLength();\n+        Preconditions.checkArgument(numEntries > 0);\n+        Entry_ entry = new Entry_();\n+        Geometry_ geom = new Geometry_();\n+        for (int i = 0; i < numEntries; i++) {\n+            node.entries(entry, i);\n+            entry.geometry(geom);\n+            final Geometry g = toGeometry(geom);\n+            entries.add(Entries.entry(parseObject(deserializer, entry), (S) g));\n+        }\n+        return entries;\n+    }\n+\n+    @Override\n+    public List<Node<T, S>> children() {\n+        return createChildren();\n+    }\n+\n+}\ndiff --git a/src/main/java/com/github/davidmoten/rtree/fbs/SerializerFlatBuffers.java b/src/main/java/com/github/davidmoten/rtree/fbs/SerializerFlatBuffers.java\nindex 76daa61..e1a217b 100644\n--- a/src/main/java/com/github/davidmoten/rtree/fbs/SerializerFlatBuffers.java\n+++ b/src/main/java/com/github/davidmoten/rtree/fbs/SerializerFlatBuffers.java\n@@ -91,7 +91,7 @@ public final class SerializerFlatBuffers<T, S extends Geometry> {\n                 t.context().maxChildren(), new SelectorRStar(), new SplitterRStar(), factory);\n         final Node<T, S> root;\n         if (structure == InternalStructure.FLATBUFFERS_SINGLE_ARRAY) {\n-            root = new NodeFlatBuffers<T, S>(node, context, factory.deserializer());\n+            root = new NonLeafFlatBuffers<T, S>(node, context, factory.deserializer());\n         } else {\n             root = toNodeDefault(node, context, factory.deserializer());\n         }\n", "test_patch": "diff --git a/src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java b/src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java\nindex c736a22..7efe351 100644\n--- a/src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java\n+++ b/src/test/java/com/github/davidmoten/rtree/BenchmarksRTree.java\n@@ -76,7 +76,7 @@ public class BenchmarksRTree {\n \n     private final RTree<Object, Point> starTreeM10FlatBuffers = createFlatBuffersGreek();\n \n-    //@Benchmark\n+    // @Benchmark\n     public void defaultRTreeInsertOneEntryIntoGreekDataEntriesMaxChildren004() {\n         insertPoint(defaultTreeM4);\n     }\n@@ -103,38 +103,39 @@ public class BenchmarksRTree {\n             fbSerializer.serialize(tree, os);\n             os.close();\n             ByteArrayInputStream is = new ByteArrayInputStream(os.toByteArray());\n-            return fbSerializer.deserialize(os.size(), is, InternalStructure.FLATBUFFERS_SINGLE_ARRAY);\n+            return fbSerializer.deserialize(os.size(), is,\n+                    InternalStructure.FLATBUFFERS_SINGLE_ARRAY);\n         } catch (IOException e) {\n             throw new RuntimeException(e);\n         }\n     }\n \n-    //@Benchmark\n+    // @Benchmark\n     public void defaultRTreeSearchOfGreekDataPointsMaxChildren004() {\n         searchGreek(defaultTreeM4);\n     }\n \n-    //@Benchmark\n+    // @Benchmark\n     public void defaultRTreeInsertOneEntryIntoGreekDataEntriesMaxChildren010() {\n         insertPoint(defaultTreeM10);\n     }\n \n-    //@Benchmark\n+    // @Benchmark\n     public void defaultRTreeSearchOfGreekDataPointsMaxChildren010() {\n         searchGreek(defaultTreeM10);\n     }\n \n-    //@Benchmark\n+    // @Benchmark\n     public void rStarTreeInsertOneEntryIntoGreekDataEntriesMaxChildren004() {\n         insertPoint(starTreeM4);\n     }\n \n-    //@Benchmark\n+    // @Benchmark\n     public void rStarTreeInsertOneEntryIntoGreekDataEntriesMaxChildren010() {\n         insertPoint(starTreeM10);\n     }\n \n-    //@Benchmark\n+    // @Benchmark\n     public void rStarTreeSearchOfGreekDataPointsMaxChildren004() {\n         searchGreek(starTreeM4);\n     }\n@@ -148,138 +149,143 @@ public class BenchmarksRTree {\n     public void rStarTreeSearchOfGreekDataPointsMaxChildren010FlatBuffers() {\n         searchGreek(starTreeM10FlatBuffers);\n     }\n+    \n+    @Benchmark\n+    public void rStarTreeSearchOfGreekDataPointsMaxChildren010FlatBuffersBackpressure() {\n+        searchGreekBackpressure(starTreeM10FlatBuffers);\n+    }\n \n-    //@Benchmark\n+    // @Benchmark\n     public void rStarTreeSearchOfGreekDataPointsMaxChildren010WithBackpressure() {\n         searchGreekWithBackpressure(starTreeM10);\n     }\n \n-    //@Benchmark\n+    // @Benchmark\n     public void defaultRTreeInsertOneEntryIntoGreekDataEntriesMaxChildren032() {\n         insertPoint(defaultTreeM32);\n     }\n \n-    //@Benchmark\n+    // @Benchmark\n     public void defaultRTreeSearchOfGreekDataPointsMaxChildren032() {\n         searchGreek(defaultTreeM32);\n     }\n \n-    //@Benchmark\n+    // @Benchmark\n     public void rStarTreeInsertOneEntryIntoGreekDataEntriesMaxChildren032() {\n         insertPoint(starTreeM32);\n     }\n \n-    //@Benchmark\n+    // @Benchmark\n     public void rStarTreeSearchOfGreekDataPointsMaxChildren032() {\n         searchGreek(starTreeM32);\n     }\n \n-    //@Benchmark\n+    // @Benchmark\n     public void defaultRTreeInsertOneEntryIntoGreekDataEntriesMaxChildren128() {\n         insertPoint(defaultTreeM128);\n     }\n \n-    //@Benchmark\n+    // @Benchmark\n     public void defaultRTreeSearchOfGreekDataPointsMaxChildren128() {\n         searchGreek(defaultTreeM128);\n     }\n \n-    //@Benchmark\n+    // @Benchmark\n     public void rStarTreeInsertOneEntryIntoGreekDataEntriesMaxChildren128() {\n         insertPoint(starTreeM128);\n     }\n \n-    //@Benchmark\n+    // @Benchmark\n     public void rStarTreeSearchOfGreekDataPointsMaxChildren128() {\n         searchGreek(starTreeM128);\n     }\n \n-    //@Benchmark\n+    // @Benchmark\n     public void defaultRTreeInsertOneEntryInto1000EntriesMaxChildren004() {\n         insertRectangle(smallDefaultTreeM4);\n     }\n \n-    //@Benchmark\n+    // @Benchmark\n     public void defaultRTreeSearchOf1000PointsMaxChildren004() {\n         search(smallDefaultTreeM4);\n     }\n \n-    //@Benchmark\n+    // @Benchmark\n     public void defaultRTreeInsertOneEntryInto1000EntriesMaxChildren010() {\n         insertRectangle(smallDefaultTreeM10);\n     }\n \n-    //@Benchmark\n+    // @Benchmark\n     public void defaultRTreeSearchOf1000PointsMaxChildren010() {\n         search(smallDefaultTreeM10);\n     }\n \n-    //@Benchmark\n+    // @Benchmark\n     public void rStarTreeInsertOneEntryInto1000EntriesMaxChildren004() {\n         insertRectangle(smallStarTreeM4);\n     }\n \n-    //@Benchmark\n+    // @Benchmark\n     public void rStarTreeInsertOneEntryInto1000EntriesMaxChildren010() {\n         insertRectangle(smallStarTreeM10);\n     }\n \n-    //@Benchmark\n+    // @Benchmark\n     public void rStarTreeSearchOf1000PointsMaxChildren004() {\n         search(smallStarTreeM4);\n     }\n \n-    //@Benchmark\n+    // @Benchmark\n     public void rStarTreeSearchOf1000PointsMaxChildren010() {\n         search(smallStarTreeM10);\n     }\n \n-    //@Benchmark\n+    // @Benchmark\n     public void defaultRTreeInsertOneEntryInto1000EntriesMaxChildren032() {\n         insertRectangle(smallDefaultTreeM32);\n     }\n \n-    //@Benchmark\n+    // @Benchmark\n     public void defaultRTreeSearchOf1000PointsMaxChildren032() {\n         search(smallDefaultTreeM32);\n     }\n \n-    //@Benchmark\n+    // @Benchmark\n     public void rStarTreeInsertOneEntryInto1000EntriesMaxChildren032() {\n         insertRectangle(smallStarTreeM32);\n     }\n \n-    //@Benchmark\n+    // @Benchmark\n     public void rStarTreeSearchOf1000PointsMaxChildren032() {\n         search(smallStarTreeM32);\n     }\n \n-    //@Benchmark\n+    // @Benchmark\n     public void defaultRTreeInsertOneEntryInto1000EntriesMaxChildren128() {\n         insertRectangle(smallDefaultTreeM128);\n     }\n \n-    //@Benchmark\n+    // @Benchmark\n     public void defaultRTreeSearchOf1000PointsMaxChildren128() {\n         search(smallDefaultTreeM128);\n     }\n \n-    //@Benchmark\n+    // @Benchmark\n     public void rStarTreeInsertOneEntryInto1000EntriesMaxChildren128() {\n         insertRectangle(smallStarTreeM128);\n     }\n \n-    //@Benchmark\n+    // @Benchmark\n     public void rStarTreeSearchOf1000PointsMaxChildren128() {\n         search(smallStarTreeM128);\n     }\n \n-    //@Benchmark\n+    // @Benchmark\n     public void rStarTreeDeleteOneEveryOccurrenceFromGreekDataChildren010() {\n         deleteAll(starTreeM10);\n     }\n \n-    //@Benchmark\n+    // @Benchmark\n     public void searchNearestGreek() {\n         searchNearestGreek(starTreeM4);\n     }\n@@ -298,6 +304,11 @@ public class BenchmarksRTree {\n         tree.search(Geometries.rectangle(40, 27.0, 40.5, 27.5)).subscribe();\n     }\n \n+    private void searchGreekBackpressure(RTree<Object, Point> tree) {\n+        // should return 22 results\n+        tree.search(Geometries.rectangle(40, 27.0, 40.5, 27.5)).take(1000).subscribe();\n+    }\n+\n     private void searchNearestGreek(RTree<Object, Point> tree) {\n         tree.nearest(Point.create(40.0, 27.0), 1, 300).subscribe();\n     }\ndiff --git a/src/test/java/com/github/davidmoten/rtree/fbs/SerializerFlatBuffersTest.java b/src/test/java/com/github/davidmoten/rtree/fbs/SerializerFlatBuffersTest.java\nindex 7327867..332011b 100644\n--- a/src/test/java/com/github/davidmoten/rtree/fbs/SerializerFlatBuffersTest.java\n+++ b/src/test/java/com/github/davidmoten/rtree/fbs/SerializerFlatBuffersTest.java\n@@ -10,12 +10,14 @@ import java.io.InputStream;\n \n import org.junit.Test;\n \n+import com.github.davidmoten.rtree.Entry;\n import com.github.davidmoten.rtree.GreekEarthquakes;\n import com.github.davidmoten.rtree.InternalStructure;\n import com.github.davidmoten.rtree.RTree;\n import com.github.davidmoten.rtree.geometry.Geometries;\n import com.github.davidmoten.rtree.geometry.Point;\n \n+import rx.Observable;\n import rx.functions.Func1;\n \n public class SerializerFlatBuffersTest {\n@@ -24,15 +26,25 @@ public class SerializerFlatBuffersTest {\n \n     @Test\n     public void testSerializeRoundTripToFlatBuffersSingleArray() throws Exception {\n-        roundTrip(InternalStructure.FLATBUFFERS_SINGLE_ARRAY);\n+        roundTrip(InternalStructure.FLATBUFFERS_SINGLE_ARRAY, false);\n     }\n \n     @Test\n     public void testSerializeRoundTripToDefaultStructure() throws Exception {\n-        roundTrip(InternalStructure.DEFAULT);\n+        roundTrip(InternalStructure.DEFAULT, false);\n     }\n \n-    private void roundTrip(InternalStructure structure) throws Exception {\n+    @Test\n+    public void testSerializeRoundTripToFlatBuffersSingleArrayBackpressure() throws Exception {\n+        roundTrip(InternalStructure.FLATBUFFERS_SINGLE_ARRAY, true);\n+    }\n+\n+    @Test\n+    public void testSerializeRoundTripToDefaultStructureBackpressure() throws Exception {\n+        roundTrip(InternalStructure.DEFAULT, true);\n+    }\n+\n+    private void roundTrip(InternalStructure structure, boolean backpressure) throws Exception {\n         RTree<Object, Point> tree = RTree.star().maxChildren(10).create();\n         tree = tree.add(GreekEarthquakes.entries()).last().toBlocking().single();\n         long t = System.currentTimeMillis();\n@@ -42,7 +54,7 @@ public class SerializerFlatBuffersTest {\n \n         serialize(tree, t, file, os, fbSerializer);\n \n-        deserialize(structure, file, fbSerializer);\n+        deserialize(structure, file, fbSerializer, backpressure);\n     }\n \n     private static SerializerFlatBuffers<Object, Point> createSerializer() {\n@@ -73,7 +85,8 @@ public class SerializerFlatBuffersTest {\n     }\n \n     private static void deserialize(InternalStructure structure, File file,\n-            SerializerFlatBuffers<Object, Point> fbSerializer) throws Exception {\n+            SerializerFlatBuffers<Object, Point> fbSerializer, boolean backpressure)\n+                    throws Exception {\n         long t = System.currentTimeMillis();\n         InputStream is = new FileInputStream(file);\n         t = System.currentTimeMillis();\n@@ -81,8 +94,10 @@ public class SerializerFlatBuffersTest {\n         System.out.println(tr.root().get());\n \n         System.out.println(\"read in \" + (System.currentTimeMillis() - t) + \"ms\");\n-        int found = tr.search(Geometries.rectangle(40, 27.0, 40.5, 27.5)).count().toBlocking()\n-                .single();\n+        Observable<Entry<Object, Point>> o = tr.search(Geometries.rectangle(40, 27.0, 40.5, 27.5));\n+        if (backpressure)\n+            o = o.take(10000);\n+        int found = o.count().toBlocking().single();\n         System.out.println(\"found=\" + found);\n         assertEquals(22, found);\n         System.out.println(tr.size());\n@@ -91,8 +106,9 @@ public class SerializerFlatBuffersTest {\n     public static void main(String[] args) throws Exception {\n         // use this with jvisualvm and heap dump, find biggest objects to check\n         // memory usage of rtree\n-        deserialize(InternalStructure.FLATBUFFERS_SINGLE_ARRAY, new File(\"target/file\"),\n-                createSerializer());\n+        // deserialize(InternalStructure.FLATBUFFERS_SINGLE_ARRAY, new\n+        // File(\"target/file\"),\n+        // createSerializer());\n     }\n \n }\n"}
{"repository": "davidmoten/rtree", "clone_url": "https://github.com/davidmoten/rtree.git", "timestamp": "2023-05-30T21:52:32.814826Z", "commit_hash": "02d307d60a82204e712db11159fdd9cc8b5c4e07", "commit_message": "fix precondition check\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/com/github/davidmoten/rtree/internal/util/BoundedPriorityQueue.java b/src/main/java/com/github/davidmoten/rtree/internal/util/BoundedPriorityQueue.java\nindex ebf5784..37ac0cc 100644\n--- a/src/main/java/com/github/davidmoten/rtree/internal/util/BoundedPriorityQueue.java\n+++ b/src/main/java/com/github/davidmoten/rtree/internal/util/BoundedPriorityQueue.java\n@@ -25,7 +25,7 @@ public final class BoundedPriorityQueue<T> {\n      *            queue, must be non-null.\n      */\n     public BoundedPriorityQueue(final int maxSize, final Comparator<? super T> comparator) {\n-        Preconditions.checkArgument(maxSize <= 0, \"maxSize must be > 0\");\n+        Preconditions.checkArgument(maxSize > 0, \"maxSize must be > 0\");\n         Preconditions.checkNotNull(comparator, \"comparator cannot be null\");\n         this.queue = new PriorityQueue<T>(reverse(comparator));\n         this.comparator = comparator;\n", "test_patch": "diff --git a/src/test/java/com/github/davidmoten/rtree/fbs/SerializerFlatBuffersTest.java b/src/test/java/com/github/davidmoten/rtree/fbs/SerializerFlatBuffersTest.java\nindex a58fb2a..7327867 100644\n--- a/src/test/java/com/github/davidmoten/rtree/fbs/SerializerFlatBuffersTest.java\n+++ b/src/test/java/com/github/davidmoten/rtree/fbs/SerializerFlatBuffersTest.java\n@@ -29,7 +29,7 @@ public class SerializerFlatBuffersTest {\n \n     @Test\n     public void testSerializeRoundTripToDefaultStructure() throws Exception {\n-        roundTrip(InternalStructure.FLATBUFFERS_SINGLE_ARRAY);\n+        roundTrip(InternalStructure.DEFAULT);\n     }\n \n     private void roundTrip(InternalStructure structure) throws Exception {\n"}
{"repository": "davidmoten/rtree", "clone_url": "https://github.com/davidmoten/rtree.git", "timestamp": "2023-05-30T22:19:35.173940Z", "commit_hash": "c74e1b397b7caa3771c679eaf48b4d95c18cded4", "commit_message": "fix #40 and prevent request overflow by using BackpressureUtils\n", "related_issues": "", "bug_patch": "diff --git a/pom.xml b/pom.xml\nindex e293bbe..1155907 100644\n--- a/pom.xml\n+++ b/pom.xml\n@@ -119,7 +119,6 @@\n             <groupId>com.github.davidmoten</groupId>\n             <artifactId>rxjava-extras</artifactId>\n             <version>0.7</version>\n-            <scope>test</scope>\n         </dependency>\n \n         <dependency>\ndiff --git a/src/main/java/com/github/davidmoten/rtree/OnSubscribeSearch.java b/src/main/java/com/github/davidmoten/rtree/OnSubscribeSearch.java\nindex 1f23865..8774c37 100644\n--- a/src/main/java/com/github/davidmoten/rtree/OnSubscribeSearch.java\n+++ b/src/main/java/com/github/davidmoten/rtree/OnSubscribeSearch.java\n@@ -4,6 +4,7 @@ import java.util.concurrent.atomic.AtomicLong;\n \n import com.github.davidmoten.guavamini.annotations.VisibleForTesting;\n import com.github.davidmoten.rtree.geometry.Geometry;\n+import com.github.davidmoten.rx.util.BackpressureUtils;\n import com.github.davidmoten.util.ImmutableStack;\n \n import rx.Observable.OnSubscribe;\n@@ -72,17 +73,16 @@ final class OnSubscribeSearch<T, S extends Geometry> implements OnSubscribe<Entr\n \n             // rxjava used AtomicLongFieldUpdater instead of AtomicLong\n             // but benchmarks showed no benefit here so reverted to AtomicLong\n-            long previousCount = requested.getAndAdd(n);\n+            long previousCount = BackpressureUtils.getAndAddRequest(requested, n);\n             if (previousCount == 0) {\n                 // don't touch stack every time during the loop because\n                 // is a volatile and every write forces a thread memory\n                 // cache flush\n                 ImmutableStack<NodePosition<T, S>> st = stack;\n                 while (true) {\n+                    // minimize atomic reads by assigning to a variable here\n                     long r = requested.get();\n-                    long numToEmit = r;\n-\n-                    st = Backpressure.search(condition, subscriber, st, numToEmit);\n+                    st = Backpressure.search(condition, subscriber, st, r);\n                     if (st.isEmpty()) {\n                         if (!subscriber.isUnsubscribed()) {\n                             subscriber.onCompleted();\n", "test_patch": "diff --git a/src/test/java/com/github/davidmoten/rtree/RTreeTest.java b/src/test/java/com/github/davidmoten/rtree/RTreeTest.java\nindex 438b8ef..76d6c81 100644\n--- a/src/test/java/com/github/davidmoten/rtree/RTreeTest.java\n+++ b/src/test/java/com/github/davidmoten/rtree/RTreeTest.java\n@@ -25,6 +25,7 @@ import java.util.HashSet;\n import java.util.List;\n import java.util.Set;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n \n import org.junit.Test;\n \n@@ -903,7 +904,7 @@ public class RTreeTest {\n         assertTrue(Intersects.lineIntersectsPoint.call(line(1, 1, 2, 2), point(1, 1)));\n     }\n \n-    @Test(timeout = 3000)\n+    @Test(timeout = 30000000)\n     public void testGroupByIssue40() {\n         RTree<Integer, Geometry> tree = RTree.star().create();\n \n@@ -915,11 +916,10 @@ public class RTreeTest {\n         tree = tree.add(6, Geometries.point(13.0, 52.0));\n \n         Rectangle rectangle = Geometries.rectangle(12.9, 51.9, 13.1, 52.1);\n-        assertEquals(Integer.valueOf(6), tree.search(rectangle).count().toBlocking().single());\n         assertEquals(Integer.valueOf(2), tree.search(rectangle).doOnRequest(new Action1<Long>() {\n             @Override\n             public void call(Long n) {\n-                System.out.println(n);\n+                System.out.println(\"requestFromGroupBy=\" + n);\n             }\n         }).groupBy(new Func1<Entry<Integer, Geometry>, Boolean>() {\n             @Override\n@@ -927,6 +927,11 @@ public class RTreeTest {\n                 System.out.println(entry);\n                 return entry.value() % 2 == 0;\n             }\n+        }).doOnRequest(new Action1<Long>() {\n+            @Override\n+            public void call(Long n) {\n+                System.out.println(\"requestFromFlatMap=\" + n);\n+            }\n         }).flatMap(\n                 new Func1<GroupedObservable<Boolean, Entry<Integer, Geometry>>, Observable<Integer>>() {\n                     @Override\n@@ -937,8 +942,8 @@ public class RTreeTest {\n                 }).count().toBlocking().single());\n     }\n \n-    @Test(timeout = 3000)\n-    public void testBackpressureSearchWhenLotsRequestedButNotMaxValue() {\n+    @Test\n+    public void testBackpressureForOverflow() {\n         RTree<Integer, Geometry> tree = RTree.star().create();\n \n         tree = tree.add(1, Geometries.point(13.0, 52.0));\n@@ -947,36 +952,34 @@ public class RTreeTest {\n         tree = tree.add(4, Geometries.point(13.0, 52.0));\n         tree = tree.add(5, Geometries.point(13.0, 52.0));\n         tree = tree.add(6, Geometries.point(13.0, 52.0));\n-\n+        final AtomicInteger count = new AtomicInteger();\n         Rectangle rectangle = Geometries.rectangle(12.9, 51.9, 13.1, 52.1);\n-\n-        tree.search(rectangle).doOnRequest(new Action1<Long>() {\n-            @Override\n-            public void call(Long n) {\n-                System.out.println(n);\n-            }\n-        }).subscribe(new Subscriber<Object>() {\n+        tree.search(rectangle).subscribe(new Subscriber<Object>() {\n \n             @Override\n             public void onStart() {\n-                request(Long.MAX_VALUE - 100);\n+                request(4);\n             }\n \n             @Override\n             public void onCompleted() {\n+\n             }\n \n             @Override\n-            public void onError(Throwable arg0) {\n+            public void onError(Throwable e) {\n \n             }\n \n             @Override\n-            public void onNext(Object arg0) {\n-                request(1);\n-                request(1);\n+            public void onNext(Object t) {\n+                request(Long.MAX_VALUE);\n+                count.incrementAndGet();\n             }\n         });\n+        assertEquals(6, count.get());\n+        assertEquals(6, (int) tree.search(rectangle).count().toBlocking().single());\n+\n     }\n \n     private static Func2<Point, Circle, Double> distanceCircleToPoint = new Func2<Point, Circle, Double>() {\n"}
{"repository": "davidmoten/rtree", "clone_url": "https://github.com/davidmoten/rtree.git", "timestamp": "2023-05-30T22:33:27.760532Z", "commit_hash": "7e53efecdebff95c8e3bd6911cee6843e381d0fd", "commit_message": "OperatorBoundedPriorityQueue needs to request Long.MAX_VALUE from upstream, fixes #38\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/com/github/davidmoten/rx/operators/OperatorBoundedPriorityQueue.java b/src/main/java/com/github/davidmoten/rx/operators/OperatorBoundedPriorityQueue.java\nindex 245c24d..47fab81 100644\n--- a/src/main/java/com/github/davidmoten/rx/operators/OperatorBoundedPriorityQueue.java\n+++ b/src/main/java/com/github/davidmoten/rx/operators/OperatorBoundedPriorityQueue.java\n@@ -2,11 +2,11 @@ package com.github.davidmoten.rx.operators;\n \n import java.util.Comparator;\n \n+import com.google.common.collect.MinMaxPriorityQueue;\n+\n import rx.Observable.Operator;\n import rx.Subscriber;\n \n-import com.google.common.collect.MinMaxPriorityQueue;\n-\n public final class OperatorBoundedPriorityQueue<T> implements Operator<T, T> {\n \n     private final int maximumSize;\n@@ -24,6 +24,11 @@ public final class OperatorBoundedPriorityQueue<T> implements Operator<T, T> {\n         return new Subscriber<T>(child) {\n \n             @Override\n+            public void onStart() {\n+                request(Long.MAX_VALUE);\n+            }\n+\n+            @Override\n             public void onCompleted() {\n                 while (true) {\n                     T t = q.poll();\n", "test_patch": "diff --git a/src/test/java/com/github/davidmoten/rx/operators/OperatorBoundedPriorityQueueTest.java b/src/test/java/com/github/davidmoten/rx/operators/OperatorBoundedPriorityQueueTest.java\nindex 394526d..bbfd24d 100644\n--- a/src/test/java/com/github/davidmoten/rx/operators/OperatorBoundedPriorityQueueTest.java\n+++ b/src/test/java/com/github/davidmoten/rx/operators/OperatorBoundedPriorityQueueTest.java\n@@ -11,6 +11,10 @@ import java.util.concurrent.atomic.AtomicBoolean;\n \n import org.junit.Test;\n \n+import com.github.davidmoten.rtree.RTree;\n+import com.github.davidmoten.rtree.geometry.Geometries;\n+import com.github.davidmoten.rtree.geometry.Line;\n+\n import rx.Observable;\n import rx.Observable.OnSubscribe;\n import rx.Subscriber;\n@@ -37,7 +41,7 @@ public class OperatorBoundedPriorityQueueTest {\n     public void testUnsubscribeAfterFirst() {\n         final AtomicBoolean completed = new AtomicBoolean(false);\n         Observable.range(1, 5)\n-        // go through priority queue\n+                // go through priority queue\n                 .lift(new OperatorBoundedPriorityQueue<Integer>(2, integerComparator))\n                 // subscribe\n                 .subscribe(new Subscriber<Integer>() {\n@@ -63,7 +67,7 @@ public class OperatorBoundedPriorityQueueTest {\n     public void testUnsubscribeAfterLastButBeforeCompletedCalled() {\n         final AtomicBoolean completed = new AtomicBoolean(false);\n         Observable.range(1, 5)\n-        // go through priority queue\n+                // go through priority queue\n                 .lift(new OperatorBoundedPriorityQueue<Integer>(2, integerComparator))\n                 // subscribe\n                 .subscribe(new Subscriber<Integer>() {\n@@ -94,7 +98,7 @@ public class OperatorBoundedPriorityQueueTest {\n         final AtomicBoolean completed = new AtomicBoolean(false);\n         final AtomicBoolean error = new AtomicBoolean(false);\n         Observable.<Integer> error(new RuntimeException())\n-        // go through priority queue\n+                // go through priority queue\n                 .lift(new OperatorBoundedPriorityQueue<Integer>(2, integerComparator))\n                 // subscribe\n                 .subscribe(new Subscriber<Integer>() {\n@@ -145,7 +149,7 @@ public class OperatorBoundedPriorityQueueTest {\n                 sub.onError(new RuntimeException());\n             }\n         })\n-        // go through priority queue\n+                // go through priority queue\n                 .lift(new OperatorBoundedPriorityQueue<Integer>(1, integerComparator))\n                 // subscribe\n                 .subscribe(subscriber);\n@@ -182,7 +186,7 @@ public class OperatorBoundedPriorityQueueTest {\n                 sub.onCompleted();\n             }\n         })\n-        // go through priority queue\n+                // go through priority queue\n                 .lift(new OperatorBoundedPriorityQueue<Integer>(1, integerComparator))\n                 // subscribe\n                 .subscribe(subscriber);\n@@ -190,4 +194,13 @@ public class OperatorBoundedPriorityQueueTest {\n         assertFalse(next.get());\n     }\n \n+    @Test(timeout = 3000)\n+    public void testOperatorShouldRequestMaxFromUpstream() {\n+        RTree<String, Line> tree = RTree.star().create();\n+        for (int i = 0; i < 5; ++i) {\n+            tree = tree.add(String.format(\"Hello %d\", i), Geometries.line(-i, -i, 5 + i, i));\n+        }\n+        tree.nearest(Geometries.point(2, 0.4), Double.MAX_VALUE, 1).toBlocking().single();\n+    }\n+\n }\n"}
{"repository": "davidmoten/rtree", "clone_url": "https://github.com/davidmoten/rtree.git", "timestamp": "2023-05-30T22:40:19.398211Z", "commit_hash": "bb3b0b3b773630a286a9e16797aad2861ebf0765", "commit_message": "fix Util.mbr() for negative values, fixes #34\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/com/github/davidmoten/rtree/Util.java b/src/main/java/com/github/davidmoten/rtree/Util.java\nindex 982fcc8..fca7893 100644\n--- a/src/main/java/com/github/davidmoten/rtree/Util.java\n+++ b/src/main/java/com/github/davidmoten/rtree/Util.java\n@@ -43,8 +43,8 @@ public final class Util {\n         Preconditions.checkArgument(!items.isEmpty());\n         float minX1 = Float.MAX_VALUE;\n         float minY1 = Float.MAX_VALUE;\n-        float maxX2 = Float.MIN_VALUE;\n-        float maxY2 = Float.MIN_VALUE;\n+        float maxX2 = -Float.MAX_VALUE;\n+        float maxY2 = -Float.MAX_VALUE;\n         for (final HasGeometry item : items) {\n             Rectangle r = item.geometry().mbr();\n             if (r.x1() < minX1)\n@@ -80,4 +80,5 @@ public final class Util {\n         list2.addAll(replacements);\n         return list2;\n     }\n+    \n }\n", "test_patch": "diff --git a/src/test/java/com/github/davidmoten/rtree/UtilTest.java b/src/test/java/com/github/davidmoten/rtree/UtilTest.java\nindex baa3781..a1d0649 100644\n--- a/src/test/java/com/github/davidmoten/rtree/UtilTest.java\n+++ b/src/test/java/com/github/davidmoten/rtree/UtilTest.java\n@@ -1,8 +1,14 @@\n package com.github.davidmoten.rtree;\n \n+import static org.junit.Assert.assertEquals;\n+\n+import java.util.Collections;\n+\n import org.junit.Test;\n \n import com.github.davidmoten.junit.Asserts;\n+import com.github.davidmoten.rtree.geometry.Geometries;\n+import com.github.davidmoten.rtree.geometry.Rectangle;\n \n public class UtilTest {\n \n@@ -10,5 +16,13 @@ public class UtilTest {\n     public void coverPrivateConstructor() {\n         Asserts.assertIsUtilityClass(Util.class);\n     }\n+    \n+    @Test\n+    public void testMbrWithNegativeValues() {\n+        Rectangle r = Geometries.rectangle(-2,-2,-1,-1);\n+        Rectangle mbr = Util.mbr(Collections.singleton(r));\n+        assertEquals(r,mbr);\n+        System.out.println(r);\n+    }\n \n }\n"}
{"repository": "davidmoten/rtree", "clone_url": "https://github.com/davidmoten/rtree.git", "timestamp": "2023-05-30T22:52:07.579074Z", "commit_hash": "e925ff583e757bd41ceb1109f6287ac4dd5b835b", "commit_message": "add line tests and fix intersects and increase coverage to 100% (of ImageSaver)\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/com/github/davidmoten/rtree/ImageSaver.java b/src/main/java/com/github/davidmoten/rtree/ImageSaver.java\nindex add4ef0..3676401 100644\n--- a/src/main/java/com/github/davidmoten/rtree/ImageSaver.java\n+++ b/src/main/java/com/github/davidmoten/rtree/ImageSaver.java\n@@ -2,16 +2,35 @@ package com.github.davidmoten.rtree;\n \n import java.awt.image.BufferedImage;\n import java.io.File;\n-import java.io.IOException;\n+import java.util.concurrent.Callable;\n \n import javax.imageio.ImageIO;\n \n final class ImageSaver {\n-    \n-    static void save(BufferedImage image, File file, String imageFormat) {\n+\n+    private ImageSaver() {\n+        // prevent instantiation\n+    }\n+\n+    static void save(final BufferedImage image, final File file, final String imageFormat) {\n+        // this is an ugly workaround to achieve 100% coverage (the pesky\n+        // IOException catch)\n+        // The performance hit of making this allocation should be negligible\n+        // compared to the cost of IO\n+        Callable<Void> callable = new Callable<Void>() {\n+            @Override\n+            public Void call() throws Exception {\n+                ImageIO.write(image, imageFormat, file);\n+                return null;\n+            }\n+        };\n+        run(callable);\n+    }\n+\n+    static void run(Callable<Void> callable) {\n         try {\n-            ImageIO.write(image, imageFormat, file);\n-        } catch (final IOException e) {\n+            callable.call();\n+        } catch (Exception e) {\n             throw new RuntimeException(e);\n         }\n     }\ndiff --git a/src/main/java/com/github/davidmoten/rtree/geometry/Circle.java b/src/main/java/com/github/davidmoten/rtree/geometry/Circle.java\nindex d07b391..9f45ac9 100644\n--- a/src/main/java/com/github/davidmoten/rtree/geometry/Circle.java\n+++ b/src/main/java/com/github/davidmoten/rtree/geometry/Circle.java\n@@ -32,10 +32,6 @@ public final class Circle implements Geometry {\n         return radius;\n     }\n \n-    public float diameter() {\n-        return 2 * radius;\n-    }\n-\n     @Override\n     public Rectangle mbr() {\n         return mbr;\ndiff --git a/src/main/java/com/github/davidmoten/rtree/geometry/Line.java b/src/main/java/com/github/davidmoten/rtree/geometry/Line.java\nindex 078f994..eddaab3 100644\n--- a/src/main/java/com/github/davidmoten/rtree/geometry/Line.java\n+++ b/src/main/java/com/github/davidmoten/rtree/geometry/Line.java\n@@ -31,7 +31,11 @@ public final class Line implements Geometry {\n             return 0;\n         } else {\n             double d1 = distance(r.x1(), r.y1(), r.x1(), r.y2());\n+            if (d1 == 0)\n+                return 0;\n             double d2 = distance(r.x1(), r.y2(), r.x2(), r.y2());\n+            if (d2 == 0)\n+                return 0;\n             double d3 = distance(r.x2(), r.y2(), r.x2(), r.y1());\n             double d4 = distance(r.x2(), r.y1(), r.x1(), r.y1());\n             return Math.min(d1, Math.min(d2, Math.min(d3, d4)));\n@@ -41,13 +45,17 @@ public final class Line implements Geometry {\n     private double distance(float x1, float y1, float x2, float y2) {\n         Float line = new Line2D.Float(x1, y1, x2, y2);\n         double d1 = line.ptSegDist(this.x1, this.y1);\n-        if (d1 == 0)\n-            return 0;\n         double d2 = line.ptSegDist(this.x2, this.y2);\n-        if (d1 < d2)\n-            return d1;\n+        Float line2 = new Line2D.Float(this.x1, this.y1, this.x2, this.y2);\n+        double d3 = line2.ptSegDist(x1, y1);\n+        if (d3 == 0)\n+            return 0;\n+        double d4 = line2.ptSegDist(x2, y2);\n+        if (d4 == 0)\n+            return 0;\n         else\n-            return d2;\n+            return Math.min(d1, Math.min(d2, Math.min(d3, d4)));\n+\n     }\n \n     @Override\n@@ -108,7 +116,7 @@ public final class Line implements Geometry {\n         }\n     }\n \n-    private static class Vector {\n+    private static final class Vector {\n         final float x;\n         final float y;\n \n@@ -141,11 +149,6 @@ public final class Line implements Geometry {\n             return x * x + y * y;\n         }\n \n-        @Override\n-        public String toString() {\n-            return \"Vector [x=\" + x + \", y=\" + y + \"]\";\n-        }\n-\n     }\n \n }\n", "test_patch": "diff --git a/src/test/java/com/github/davidmoten/rtree/geometry/LineTest.java b/src/test/java/com/github/davidmoten/rtree/geometry/LineTest.java\nindex 5ab9207..2943848 100644\n--- a/src/test/java/com/github/davidmoten/rtree/geometry/LineTest.java\n+++ b/src/test/java/com/github/davidmoten/rtree/geometry/LineTest.java\n@@ -14,91 +14,91 @@ public final class LineTest {\n     public void testDoesIntersectOtherLine() {\n         Line a = Geometries.line(-1, 0, 1, 0);\n         Line b = Geometries.line(0, -1, 0, 1);\n-        assertTrue(a.intersects(b));\n+        assertTrue(Intersects.lineIntersectsLine.call(a, b));\n     }\n \n     @Test\n     public void testDoesNotIntersectLine() {\n         Line a = Geometries.line(-1, 0, 1, 0);\n         Line b = Geometries.line(1.1, -1, 1.1, 1);\n-        assertFalse(a.intersects(b));\n+        assertFalse(Intersects.lineIntersectsLine.call(a, b));\n     }\n \n     @Test\n     public void testDoesIntersectRectangle() {\n         Line a = Geometries.line(-1, 0, 1, 0);\n         Rectangle b = Geometries.rectangle(0.2, -0.5, 0.8, 0.5);\n-        assertTrue(a.intersects(b));\n+        assertTrue(Intersects.lineIntersectsRectangle.call(a, b));\n     }\n \n     @Test\n     public void testDoesNotIntersectRectangle() {\n         Line a = Geometries.line(-1, 0, 1, 0);\n         Rectangle b = Geometries.rectangle(1.2, -0.5, 1.8, 0.5);\n-        assertFalse(a.intersects(b));\n+        assertFalse(Intersects.lineIntersectsRectangle.call(a, b));\n     }\n \n     @Test\n     public void testLineIntersectsCircle() {\n         Line a = Geometries.line(-1, 0, 1, 0);\n         Circle c = Geometries.circle(0, 0.5, 1);\n-        assertTrue(a.intersects(c));\n+        assertTrue(Intersects.lineIntersectsCircle.call(a, c));\n     }\n \n     @Test\n     public void testLineDoesNotIntersectCircle() {\n         Line a = Geometries.line(-1, 0, 1, 0);\n         Circle c = Geometries.circle(0, 0.5, 0.4);\n-        assertFalse(a.intersects(c));\n+        assertFalse(Intersects.lineIntersectsCircle.call(a, c));\n     }\n \n     @Test\n     public void testLineDoesNotIntersectCircleEast() {\n         Line a = Geometries.line(-1, 0, 1, 0);\n         Circle c = Geometries.circle(1.5, 0, 0.4);\n-        assertFalse(a.intersects(c));\n+        assertFalse(Intersects.lineIntersectsCircle.call(a, c));\n     }\n \n     @Test\n     public void testLineDoesIntersectCircleEast() {\n         Line a = Geometries.line(-1, 0, 1, 0);\n         Circle c = Geometries.circle(1.5, 0, 0.6);\n-        assertTrue(a.intersects(c));\n+        assertTrue(Intersects.lineIntersectsCircle.call(a, c));\n     }\n \n     @Test\n     public void testLineDoesNotIntersectCircleWest() {\n         Line a = Geometries.line(-1, 0, 1, 0);\n         Circle c = Geometries.circle(-1.5, 0, 0.4);\n-        assertFalse(a.intersects(c));\n+        assertFalse(Intersects.lineIntersectsCircle.call(a, c));\n     }\n \n     @Test\n     public void testLineDoesIntersectCircleWest() {\n         Line a = Geometries.line(-1, 0, 1, 0);\n         Circle c = Geometries.circle(-1.5, 0, 0.6);\n-        assertTrue(a.intersects(c));\n+        assertTrue(Intersects.lineIntersectsCircle.call(a, c));\n     }\n \n     @Test\n     public void testLineDoesNotIntersectCircleNorth() {\n         Line a = Geometries.line(-1, 0, 1, 0);\n         Circle c = Geometries.circle(0, 1.5, 0.4);\n-        assertFalse(a.intersects(c));\n+        assertFalse(Intersects.lineIntersectsCircle.call(a, c));\n     }\n \n     @Test\n     public void testLineDoesNotIntersectCircleSouth() {\n         Line a = Geometries.line(-1, 0, 1, 0);\n         Circle c = Geometries.circle(0, 1.5, 0.4);\n-        assertFalse(a.intersects(c));\n+        assertFalse(Intersects.lineIntersectsCircle.call(a, c));\n     }\n \n     @Test\n     public void testLineDoesIntersectCircleSouth() {\n         Line a = Geometries.line(-1, 0, 1, 0);\n         Circle c = Geometries.circle(0, 1.5, 0.6);\n-        assertFalse(a.intersects(c));\n+        assertFalse(Intersects.lineIntersectsCircle.call(a, c));\n     }\n \n     @Test\n@@ -115,21 +115,21 @@ public final class LineTest {\n     public void testLineSameXWithinCircle() {\n         Line a = Geometries.line(1, 2, 1, 4);\n         Circle c = Geometries.circle(1, 3, 2);\n-        assertTrue(a.intersects(c));\n+        assertTrue(Intersects.lineIntersectsCircle.call(a, c));\n     }\n \n     @Test\n     public void testLineIsPointWithinCircle() {\n         Line a = Geometries.line(1, 2, 1, 2);\n         Circle c = Geometries.circle(1, 3, 2);\n-        assertTrue(a.intersects(c));\n+        assertTrue(Intersects.lineIntersectsCircle.call(a, c));\n     }\n \n     @Test\n     public void testLineIsPointOutsideCircle() {\n         Line a = Geometries.line(1, 10, 1, 10);\n         Circle c = Geometries.circle(1, 3, 2);\n-        assertFalse(a.intersects(c));\n+        assertFalse(Intersects.lineIntersectsCircle.call(a, c));\n     }\n \n     @Test\n@@ -139,4 +139,46 @@ public final class LineTest {\n         assertEquals(Math.sqrt(5), a.distance(r), PRECISION);\n     }\n \n+    @Test\n+    public void testLineDistanceToRectangleIsZeroWhenOneEndIsInside() {\n+        Line a = Geometries.line(1, 2, 4, 4);\n+        Rectangle r = Geometries.rectangle(3, 3, 7, 7);\n+        assertEquals(0, a.distance(r), PRECISION);\n+    }\n+\n+    @Test\n+    public void testLineDistanceToRectangleIsZeroWhenOtherEndIsInside() {\n+        Line a = Geometries.line(4, 4, 1, 2);\n+        Rectangle r = Geometries.rectangle(3, 3, 7, 7);\n+        assertEquals(0, a.distance(r), PRECISION);\n+    }\n+\n+    @Test\n+    public void testLineDistanceToRectangleIsZeroWhenContainsWestEdge() {\n+        Line a = Geometries.line(3, 1, 3, 10);\n+        Rectangle r = Geometries.rectangle(3, 3, 7, 7);\n+        assertEquals(0, a.distance(r), PRECISION);\n+    }\n+\n+    @Test\n+    public void testLineDistanceToRectangleIsZeroWhenContainsNorthEdge() {\n+        Line a = Geometries.line(2, 7, 10, 7);\n+        Rectangle r = Geometries.rectangle(3, 3, 7, 7);\n+        assertEquals(0, a.distance(r), PRECISION);\n+    }\n+\n+    @Test\n+    public void testLineDistanceToRectangleIsZeroWhenContainsSouthEdge() {\n+        Line a = Geometries.line(2, 3, 10, 3);\n+        Rectangle r = Geometries.rectangle(3, 3, 7, 7);\n+        assertEquals(0, a.distance(r), PRECISION);\n+    }\n+\n+    @Test\n+    public void testLineDistanceToRectangleIsZeroWhenContainsEastEdge() {\n+        Line a = Geometries.line(7, 1, 7, 10);\n+        Rectangle r = Geometries.rectangle(3, 3, 7, 7);\n+        assertEquals(0, a.distance(r), PRECISION);\n+    }\n+\n }\n"}
{"repository": "davidmoten/rtree", "clone_url": "https://github.com/davidmoten/rtree.git", "timestamp": "2023-05-30T22:57:19.872127Z", "commit_hash": "adc99ad31b7a1b4debe74e84121c054c733cc829", "commit_message": "fix issue #28, Geometries.normalizeLongitude(-180) should return 180\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/com/github/davidmoten/rtree/geometry/Geometries.java b/src/main/java/com/github/davidmoten/rtree/geometry/Geometries.java\nindex e93c9f1..fcb0102 100644\n--- a/src/main/java/com/github/davidmoten/rtree/geometry/Geometries.java\n+++ b/src/main/java/com/github/davidmoten/rtree/geometry/Geometries.java\n@@ -20,7 +20,8 @@ public final class Geometries {\n         return Circle.create(x, y, radius);\n     }\n \n-    public static Rectangle rectangleGeographic(double lon1, double lat1, double lon2, double lat2) {\n+    public static Rectangle rectangleGeographic(double lon1, double lat1, double lon2,\n+            double lat2) {\n         double x1 = normalizeLongitude(lon1);\n         double x2 = normalizeLongitude(lon2);\n         if (x2 < x1) {\n@@ -35,11 +36,15 @@ public final class Geometries {\n \n     @VisibleForTesting\n     static double normalizeLongitude(double d) {\n-        double sign = Math.signum(d);\n-        double x = Math.abs(d) / 360;\n-        double x2 = (x - Math.floor(x)) * 360;\n-        if (x2 >= 180)\n-            x2 -= 360;\n-        return x2 * sign;\n+        if (d == -180.0)\n+            return -180.0;\n+        else {\n+            double sign = Math.signum(d);\n+            double x = Math.abs(d) / 360;\n+            double x2 = (x - Math.floor(x)) * 360;\n+            if (x2 >= 180)\n+                x2 -= 360;\n+            return x2 * sign;\n+        }\n     }\n }\n", "test_patch": "diff --git a/src/test/java/com/github/davidmoten/rtree/geometry/GeometriesTest.java b/src/test/java/com/github/davidmoten/rtree/geometry/GeometriesTest.java\nindex c4e0f6b..4c65d2d 100644\n--- a/src/test/java/com/github/davidmoten/rtree/geometry/GeometriesTest.java\n+++ b/src/test/java/com/github/davidmoten/rtree/geometry/GeometriesTest.java\n@@ -36,6 +36,21 @@ public class GeometriesTest {\n     }\n \n     @Test\n+    public void testNormalizeLongitude3_2() {\n+        assertEquals(-180, Geometries.normalizeLongitude(-180), PRECISION);\n+    }\n+\n+    @Test\n+    public void testNormalizeLongitude3_3() {\n+        assertEquals(-179, Geometries.normalizeLongitude(-179), PRECISION);\n+    }\n+\n+    @Test\n+    public void testNormalizeLongitude3_4() {\n+        assertEquals(179, Geometries.normalizeLongitude(-181), PRECISION);\n+    }\n+\n+    @Test\n     public void testNormalizeLongitude4() {\n         assertEquals(-179, Geometries.normalizeLongitude(181), PRECISION);\n     }\n"}
{"repository": "davidmoten/rtree", "clone_url": "https://github.com/davidmoten/rtree.git", "timestamp": "2023-05-30T23:03:31.546410Z", "commit_hash": "0249be077360b830560ed165a07e7aa25c12148e", "commit_message": "move RectangleTest into geometry package and fix rectangleLatLon\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/com/github/davidmoten/rtree/geometry/Geometries.java b/src/main/java/com/github/davidmoten/rtree/geometry/Geometries.java\nindex 9f88672..1d96d8b 100644\n--- a/src/main/java/com/github/davidmoten/rtree/geometry/Geometries.java\n+++ b/src/main/java/com/github/davidmoten/rtree/geometry/Geometries.java\n@@ -26,7 +26,7 @@ public final class Geometries {\n         if (x2 < x1) {\n             x2 += 360;\n         }\n-        return rectangle(x1, lat1, x2, lon2);\n+        return rectangle(x1, lat1, x2, lat2);\n     }\n \n     public static Point pointLatLong(double lon, double lat) {\ndiff --git a/src/test/java/com/github/davidmoten/rtree/geometry/RectangleTest.java b/src/test/java/com/github/davidmoten/rtree/geometry/RectangleTest.java\nnew file mode 100644\nindex 0000000..b2e7302\n--- /dev/null\n+++ b/src/test/java/com/github/davidmoten/rtree/geometry/RectangleTest.java\n@@ -0,0 +1,171 @@\n+package com.github.davidmoten.rtree.geometry;\n+\n+import static com.github.davidmoten.rtree.geometry.Geometries.rectangle;\n+import static org.junit.Assert.*;\n+\n+import org.junit.Test;\n+\n+import com.github.davidmoten.rtree.geometry.Rectangle;\n+\n+public class RectangleTest {\n+\n+    private static final double PRECISION = 0.00001;\n+\n+    @Test\n+    public void testDistanceToSelfIsZero() {\n+        Rectangle r = rectangle(0, 0, 1, 1);\n+        assertEquals(0, r.distance(r), PRECISION);\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testXParametersWrongOrderThrowsException() {\n+        rectangle(2, 0, 1, 1);\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testYParametersWrongOrderThrowsException() {\n+        rectangle(0, 2, 1, 1);\n+    }\n+\n+    @Test\n+    public void testDistanceToOverlapIsZero() {\n+        Rectangle r = rectangle(0, 0, 2, 2);\n+        Rectangle r2 = rectangle(1, 1, 3, 3);\n+\n+        assertEquals(0, r.distance(r2), PRECISION);\n+        assertEquals(0, r2.distance(r), PRECISION);\n+    }\n+\n+    @Test\n+    public void testDistanceWhenSeparatedByXOnly() {\n+        Rectangle r = rectangle(0, 0, 2, 2);\n+        Rectangle r2 = rectangle(3, 0, 4, 2);\n+\n+        assertEquals(1, r.distance(r2), PRECISION);\n+        assertEquals(1, r2.distance(r), PRECISION);\n+    }\n+\n+    @Test\n+    public void testDistanceWhenSeparatedByXOnlyAndOverlapOnY() {\n+        Rectangle r = rectangle(0, 0, 2, 2);\n+        Rectangle r2 = rectangle(3, 1.5f, 4, 3.5f);\n+\n+        assertEquals(1, r.distance(r2), PRECISION);\n+        assertEquals(1, r2.distance(r), PRECISION);\n+    }\n+\n+    @Test\n+    public void testDistanceWhenSeparatedByDiagonally() {\n+        Rectangle r = rectangle(0, 0, 2, 1);\n+        Rectangle r2 = rectangle(3, 6, 10, 8);\n+\n+        assertEquals(Math.sqrt(26), r.distance(r2), PRECISION);\n+        assertEquals(Math.sqrt(26), r2.distance(r), PRECISION);\n+    }\n+\n+    @Test\n+    public void testInequalityWithNull() {\n+        assertFalse(rectangle(0, 0, 1, 1).equals(null));\n+    }\n+\n+    @Test\n+    public void testSimpleEquality() {\n+        Rectangle r = rectangle(0, 0, 2, 1);\n+        Rectangle r2 = rectangle(0, 0, 2, 1);\n+\n+        assertTrue(r.equals(r2));\n+    }\n+\n+    @Test\n+    public void testSimpleInEquality1() {\n+        Rectangle r = rectangle(0, 0, 2, 1);\n+        Rectangle r2 = rectangle(0, 0, 2, 2);\n+\n+        assertFalse(r.equals(r2));\n+    }\n+\n+    @Test\n+    public void testSimpleInEquality2() {\n+        Rectangle r = rectangle(0, 0, 2, 1);\n+        Rectangle r2 = rectangle(1, 0, 2, 1);\n+\n+        assertFalse(r.equals(r2));\n+    }\n+\n+    @Test\n+    public void testSimpleInEquality3() {\n+        Rectangle r = rectangle(0, 0, 2, 1);\n+        Rectangle r2 = rectangle(0, 1, 2, 1);\n+\n+        assertFalse(r.equals(r2));\n+    }\n+\n+    @Test\n+    public void testSimpleInEquality4() {\n+        Rectangle r = rectangle(0, 0, 2, 2);\n+        Rectangle r2 = rectangle(0, 0, 1, 2);\n+\n+        assertFalse(r.equals(r2));\n+    }\n+\n+    @Test\n+    public void testGeometry() {\n+        Rectangle r = rectangle(0, 0, 2, 1);\n+        assertTrue(r.equals(r.geometry()));\n+    }\n+\n+    @Test\n+    public void testIntersects() {\n+        Rectangle a = rectangle(14, 14, 86, 37);\n+        Rectangle b = rectangle(13, 23, 50, 80);\n+        assertTrue(a.intersects(b));\n+        assertTrue(b.intersects(a));\n+    }\n+\n+    @Test\n+    public void testIntersectsNoRectangleContainsCornerOfAnother() {\n+        Rectangle a = rectangle(10, 10, 50, 50);\n+        Rectangle b = rectangle(28.0, 4.0, 34.0, 85.0);\n+        assertTrue(a.intersects(b));\n+        assertTrue(b.intersects(a));\n+    }\n+\n+    @Test\n+    public void testIntersectsOneRectangleContainsTheOther() {\n+        Rectangle a = rectangle(10, 10, 50, 50);\n+        Rectangle b = rectangle(20, 20, 40, 40);\n+        assertTrue(a.intersects(b));\n+        assertTrue(b.intersects(a));\n+    }\n+    \n+    @Test\n+    public void testContains() {\n+        Rectangle r = rectangle(10,20,30,40);\n+        assertTrue(r.contains(20,30));\n+    }\n+    \n+    @Test\n+    public void testContainsReturnsFalseWhenLessThanMinY() {\n+        Rectangle r = rectangle(10,20,30,40);\n+        assertFalse(r.contains(20,19));\n+    }\n+    \n+    @Test\n+    public void testContainsReturnsFalseWhenGreaterThanMaxY() {\n+        Rectangle r = rectangle(10,20,30,40);\n+        assertFalse(r.contains(20,41));\n+    }\n+    \n+    @Test\n+    public void testContainsReturnsFalseWhenGreaterThanMaxX() {\n+        Rectangle r = rectangle(10,20,30,40);\n+        assertFalse(r.contains(31,30));\n+    }\n+    \n+    @Test\n+    public void testContainsReturnsFalseWhenLessThanMinX() {\n+        Rectangle r = rectangle(10,20,30,40);\n+        assertFalse(r.contains(9,30));\n+    }\n+\n+}\n\\ No newline at end of file\n", "test_patch": "diff --git a/src/test/java/com/github/davidmoten/rtree/RectangleTest.java b/src/test/java/com/github/davidmoten/rtree/RectangleTest.java\ndeleted file mode 100644\nindex 06a3684..0000000\n--- a/src/test/java/com/github/davidmoten/rtree/RectangleTest.java\n+++ /dev/null\n@@ -1,171 +0,0 @@\n-package com.github.davidmoten.rtree;\n-\n-import static com.github.davidmoten.rtree.geometry.Geometries.rectangle;\n-import static org.junit.Assert.*;\n-\n-import org.junit.Test;\n-\n-import com.github.davidmoten.rtree.geometry.Rectangle;\n-\n-public class RectangleTest {\n-\n-    private static final double PRECISION = 0.00001;\n-\n-    @Test\n-    public void testDistanceToSelfIsZero() {\n-        Rectangle r = rectangle(0, 0, 1, 1);\n-        assertEquals(0, r.distance(r), PRECISION);\n-    }\n-\n-    @Test(expected = IllegalArgumentException.class)\n-    public void testXParametersWrongOrderThrowsException() {\n-        rectangle(2, 0, 1, 1);\n-    }\n-\n-    @Test(expected = IllegalArgumentException.class)\n-    public void testYParametersWrongOrderThrowsException() {\n-        rectangle(0, 2, 1, 1);\n-    }\n-\n-    @Test\n-    public void testDistanceToOverlapIsZero() {\n-        Rectangle r = rectangle(0, 0, 2, 2);\n-        Rectangle r2 = rectangle(1, 1, 3, 3);\n-\n-        assertEquals(0, r.distance(r2), PRECISION);\n-        assertEquals(0, r2.distance(r), PRECISION);\n-    }\n-\n-    @Test\n-    public void testDistanceWhenSeparatedByXOnly() {\n-        Rectangle r = rectangle(0, 0, 2, 2);\n-        Rectangle r2 = rectangle(3, 0, 4, 2);\n-\n-        assertEquals(1, r.distance(r2), PRECISION);\n-        assertEquals(1, r2.distance(r), PRECISION);\n-    }\n-\n-    @Test\n-    public void testDistanceWhenSeparatedByXOnlyAndOverlapOnY() {\n-        Rectangle r = rectangle(0, 0, 2, 2);\n-        Rectangle r2 = rectangle(3, 1.5f, 4, 3.5f);\n-\n-        assertEquals(1, r.distance(r2), PRECISION);\n-        assertEquals(1, r2.distance(r), PRECISION);\n-    }\n-\n-    @Test\n-    public void testDistanceWhenSeparatedByDiagonally() {\n-        Rectangle r = rectangle(0, 0, 2, 1);\n-        Rectangle r2 = rectangle(3, 6, 10, 8);\n-\n-        assertEquals(Math.sqrt(26), r.distance(r2), PRECISION);\n-        assertEquals(Math.sqrt(26), r2.distance(r), PRECISION);\n-    }\n-\n-    @Test\n-    public void testInequalityWithNull() {\n-        assertFalse(rectangle(0, 0, 1, 1).equals(null));\n-    }\n-\n-    @Test\n-    public void testSimpleEquality() {\n-        Rectangle r = rectangle(0, 0, 2, 1);\n-        Rectangle r2 = rectangle(0, 0, 2, 1);\n-\n-        assertTrue(r.equals(r2));\n-    }\n-\n-    @Test\n-    public void testSimpleInEquality1() {\n-        Rectangle r = rectangle(0, 0, 2, 1);\n-        Rectangle r2 = rectangle(0, 0, 2, 2);\n-\n-        assertFalse(r.equals(r2));\n-    }\n-\n-    @Test\n-    public void testSimpleInEquality2() {\n-        Rectangle r = rectangle(0, 0, 2, 1);\n-        Rectangle r2 = rectangle(1, 0, 2, 1);\n-\n-        assertFalse(r.equals(r2));\n-    }\n-\n-    @Test\n-    public void testSimpleInEquality3() {\n-        Rectangle r = rectangle(0, 0, 2, 1);\n-        Rectangle r2 = rectangle(0, 1, 2, 1);\n-\n-        assertFalse(r.equals(r2));\n-    }\n-\n-    @Test\n-    public void testSimpleInEquality4() {\n-        Rectangle r = rectangle(0, 0, 2, 2);\n-        Rectangle r2 = rectangle(0, 0, 1, 2);\n-\n-        assertFalse(r.equals(r2));\n-    }\n-\n-    @Test\n-    public void testGeometry() {\n-        Rectangle r = rectangle(0, 0, 2, 1);\n-        assertTrue(r.equals(r.geometry()));\n-    }\n-\n-    @Test\n-    public void testIntersects() {\n-        Rectangle a = rectangle(14, 14, 86, 37);\n-        Rectangle b = rectangle(13, 23, 50, 80);\n-        assertTrue(a.intersects(b));\n-        assertTrue(b.intersects(a));\n-    }\n-\n-    @Test\n-    public void testIntersectsNoRectangleContainsCornerOfAnother() {\n-        Rectangle a = rectangle(10, 10, 50, 50);\n-        Rectangle b = rectangle(28.0, 4.0, 34.0, 85.0);\n-        assertTrue(a.intersects(b));\n-        assertTrue(b.intersects(a));\n-    }\n-\n-    @Test\n-    public void testIntersectsOneRectangleContainsTheOther() {\n-        Rectangle a = rectangle(10, 10, 50, 50);\n-        Rectangle b = rectangle(20, 20, 40, 40);\n-        assertTrue(a.intersects(b));\n-        assertTrue(b.intersects(a));\n-    }\n-    \n-    @Test\n-    public void testContains() {\n-        Rectangle r = rectangle(10,20,30,40);\n-        assertTrue(r.contains(20,30));\n-    }\n-    \n-    @Test\n-    public void testContainsReturnsFalseWhenLessThanMinY() {\n-        Rectangle r = rectangle(10,20,30,40);\n-        assertFalse(r.contains(20,19));\n-    }\n-    \n-    @Test\n-    public void testContainsReturnsFalseWhenGreaterThanMaxY() {\n-        Rectangle r = rectangle(10,20,30,40);\n-        assertFalse(r.contains(20,41));\n-    }\n-    \n-    @Test\n-    public void testContainsReturnsFalseWhenGreaterThanMaxX() {\n-        Rectangle r = rectangle(10,20,30,40);\n-        assertFalse(r.contains(31,30));\n-    }\n-    \n-    @Test\n-    public void testContainsReturnsFalseWhenLessThanMinX() {\n-        Rectangle r = rectangle(10,20,30,40);\n-        assertFalse(r.contains(9,30));\n-    }\n-\n-}\n\\ No newline at end of file\ndiff --git a/src/test/java/com/github/davidmoten/rtree/geometry/GeometriesTest.java b/src/test/java/com/github/davidmoten/rtree/geometry/GeometriesTest.java\nindex 0459943..00052b9 100644\n--- a/src/test/java/com/github/davidmoten/rtree/geometry/GeometriesTest.java\n+++ b/src/test/java/com/github/davidmoten/rtree/geometry/GeometriesTest.java\n@@ -70,6 +70,8 @@ public class GeometriesTest {\n         Rectangle r = Geometries.rectangleLatLong(10, -10, 5, 10);\n         assertEquals(10, r.x1(), PRECISION);\n         assertEquals(365, r.x2(), PRECISION);\n+        assertEquals(-10, r.y1(), PRECISION);\n+        assertEquals(10, r.y2(), PRECISION);\n     }\n \n     @Test\n"}
{"repository": "davidmoten/rtree", "clone_url": "https://github.com/davidmoten/rtree.git", "timestamp": "2023-05-30T23:13:51.970925Z", "commit_hash": "98bac668a8b3856d18ca6037886c4e7361d25d33", "commit_message": "fixes #21, poll in a loop rather than use iteratorand add tests to cover\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/com/github/davidmoten/rx/operators/OperatorBoundedPriorityQueue.java b/src/main/java/com/github/davidmoten/rx/operators/OperatorBoundedPriorityQueue.java\nindex 5112f80..245c24d 100644\n--- a/src/main/java/com/github/davidmoten/rx/operators/OperatorBoundedPriorityQueue.java\n+++ b/src/main/java/com/github/davidmoten/rx/operators/OperatorBoundedPriorityQueue.java\n@@ -25,10 +25,14 @@ public final class OperatorBoundedPriorityQueue<T> implements Operator<T, T> {\n \n             @Override\n             public void onCompleted() {\n-                for (T t : q) {\n-                    if (isUnsubscribed())\n+                while (true) {\n+                    T t = q.poll();\n+                    if (t == null)\n+                        break;\n+                    else if (!isUnsubscribed())\n+                        child.onNext(t);\n+                    else\n                         return;\n-                    child.onNext(t);\n                 }\n                 if (isUnsubscribed())\n                     return;\n", "test_patch": "diff --git a/src/test/java/com/github/davidmoten/rtree/RTreeTest.java b/src/test/java/com/github/davidmoten/rtree/RTreeTest.java\nindex 7c1eb57..0fd9de7 100644\n--- a/src/test/java/com/github/davidmoten/rtree/RTreeTest.java\n+++ b/src/test/java/com/github/davidmoten/rtree/RTreeTest.java\n@@ -468,6 +468,46 @@ public class RTreeTest {\n     }\n \n     @Test\n+    public void testNearestReturnsInOrder() {\n+        Object value = new Object();\n+        RTree<Object, Geometry> tree = RTree.create().add(value, point(1, 1))\n+                .add(value, point(2, 2)).add(value, point(3, 3)).add(value, point(4, 4));\n+        List<Entry<Object, Geometry>> list = tree.nearest(point(0, 0), 10, 10).toList()\n+                .toBlocking().single();\n+        System.out.println(list);\n+        assertEquals(4, list.size());\n+        assertEquals(point(1, 1), list.get(0).geometry());\n+        assertEquals(point(2, 2), list.get(1).geometry());\n+        assertEquals(point(3, 3), list.get(2).geometry());\n+        assertEquals(point(4, 4), list.get(3).geometry());\n+    }\n+\n+    @Test\n+    public void testNearestHonoursUnsubscribeJustBeforeCompletion() {\n+        Object value = new Object();\n+        RTree<Object, Geometry> tree = RTree.create().add(value, point(1, 1));\n+        final AtomicBoolean completeCalled = new AtomicBoolean(false);\n+        tree.nearest(point(0, 0), 10, 10).subscribe(new Subscriber<Object>() {\n+\n+            @Override\n+            public void onCompleted() {\n+                completeCalled.set(true);\n+            }\n+\n+            @Override\n+            public void onError(Throwable e) {\n+\n+            }\n+\n+            @Override\n+            public void onNext(Object t) {\n+                unsubscribe();\n+            }\n+        });\n+        assertFalse(completeCalled.get());\n+    }\n+\n+    @Test\n     public void testVisualizer() {\n         List<Entry<Object, Geometry>> entries = createRandomEntries(1000);\n         int maxChildren = 8;\n"}
{"repository": "davidmoten/rtree", "clone_url": "https://github.com/davidmoten/rtree.git", "timestamp": "2023-05-30T23:42:15.153608Z", "commit_hash": "670a5d92ea1a90b1026938fd54b73902ad61aa00", "commit_message": "implement delete all and fix bugs identified by new unit tests\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/com/github/davidmoten/rtree/Leaf.java b/src/main/java/com/github/davidmoten/rtree/Leaf.java\nindex eba70bf..5f64189 100644\n--- a/src/main/java/com/github/davidmoten/rtree/Leaf.java\n+++ b/src/main/java/com/github/davidmoten/rtree/Leaf.java\n@@ -74,16 +74,23 @@ final class Leaf<T> implements Node<T> {\n     }\n \n     @Override\n-    public NodeAndEntries<T> delete(Entry<T> entry) {\n+    public NodeAndEntries<T> delete(Entry<T> entry, boolean all) {\n         if (!entries.contains(entry)) {\n-            return new NodeAndEntries<T>(Optional.of(this), Collections.<Entry<T>> emptyList());\n+            return new NodeAndEntries<T>(Optional.of(this), Collections.<Entry<T>> emptyList(), 0);\n         } else {\n-            final List<Entry<T>> entries2 = Util.remove(entries, entry);\n+            final List<Entry<T>> entries2 = new ArrayList<Entry<T>>(entries);\n+            entries2.remove(entry);\n+            int numDeleted = 1;\n+            // keep deleting if all specified\n+            while (all && entries2.remove(entry))\n+                numDeleted += 1;\n+\n             if (entries2.size() >= context.minChildren()) {\n                 Leaf<T> node = new Leaf<T>(entries2, context);\n-                return new NodeAndEntries<T>(of(node), Collections.<Entry<T>> emptyList());\n+                return new NodeAndEntries<T>(of(node), Collections.<Entry<T>> emptyList(),\n+                        numDeleted);\n             } else {\n-                return new NodeAndEntries<T>(Optional.<Node<T>> absent(), entries2);\n+                return new NodeAndEntries<T>(Optional.<Node<T>> absent(), entries2, numDeleted);\n             }\n         }\n     }\ndiff --git a/src/main/java/com/github/davidmoten/rtree/Node.java b/src/main/java/com/github/davidmoten/rtree/Node.java\nindex 3c9519d..decfb9c 100644\n--- a/src/main/java/com/github/davidmoten/rtree/Node.java\n+++ b/src/main/java/com/github/davidmoten/rtree/Node.java\n@@ -12,7 +12,7 @@ interface Node<T> extends HasGeometry {\n \n     List<Node<T>> add(Entry<T> entry);\n \n-    NodeAndEntries<T> delete(Entry<T> entry);\n+    NodeAndEntries<T> delete(Entry<T> entry, boolean all);\n \n     void search(Func1<? super Geometry, Boolean> condition, Subscriber<? super Entry<T>> subscriber);\n \ndiff --git a/src/main/java/com/github/davidmoten/rtree/NodeAndEntries.java b/src/main/java/com/github/davidmoten/rtree/NodeAndEntries.java\nindex cfc5eb4..675bb69 100644\n--- a/src/main/java/com/github/davidmoten/rtree/NodeAndEntries.java\n+++ b/src/main/java/com/github/davidmoten/rtree/NodeAndEntries.java\n@@ -8,18 +8,24 @@ public class NodeAndEntries<T> {\n \n     private final Optional<? extends Node<T>> node;\n     private final List<Entry<T>> entries;\n+    private final int count;\n \n-    public NodeAndEntries(Optional<? extends Node<T>> node, List<Entry<T>> entries) {\n+    public NodeAndEntries(Optional<? extends Node<T>> node, List<Entry<T>> entries, int countDeleted) {\n         this.node = node;\n         this.entries = entries;\n+        this.count = countDeleted;\n     }\n \n     public Optional<? extends Node<T>> node() {\n         return node;\n     }\n \n-    public List<Entry<T>> entries() {\n+    public List<Entry<T>> entriesToAdd() {\n         return entries;\n     }\n \n+    public int countDeleted() {\n+        return count;\n+    }\n+\n }\ndiff --git a/src/main/java/com/github/davidmoten/rtree/NonLeaf.java b/src/main/java/com/github/davidmoten/rtree/NonLeaf.java\nindex 83e92ef..406b19f 100644\n--- a/src/main/java/com/github/davidmoten/rtree/NonLeaf.java\n+++ b/src/main/java/com/github/davidmoten/rtree/NonLeaf.java\n@@ -79,29 +79,42 @@ final class NonLeaf<T> implements Node<T> {\n     }\n \n     @Override\n-    public NodeAndEntries<T> delete(Entry<T> entry) {\n+    public NodeAndEntries<T> delete(Entry<T> entry, boolean all) {\n         List<Entry<T>> addTheseEntries = new ArrayList<Entry<T>>();\n         List<Node<T>> removeTheseNodes = new ArrayList<Node<T>>();\n         List<Node<T>> addTheseNodes = new ArrayList<Node<T>>();\n+        int countDeleted = 0;\n+\n         for (final Node<T> child : children) {\n             if (entry.geometry().intersects(child.geometry().mbr())) {\n-                final NodeAndEntries<T> result = child.delete(entry);\n-                if (result.node().isPresent())\n-                    addTheseNodes.add(result.node().get());\n-                removeTheseNodes.add(child);\n-                addTheseEntries.addAll(result.entries());\n+                final NodeAndEntries<T> result = child.delete(entry, all);\n+                if (result.node().isPresent()) {\n+                    if (result.node().get() != child) {\n+                        addTheseNodes.add(result.node().get());\n+                        removeTheseNodes.add(child);\n+                        addTheseEntries.addAll(result.entriesToAdd());\n+                        countDeleted += result.countDeleted();\n+                        if (!all)\n+                            break;\n+                    }\n+                } else {\n+                    removeTheseNodes.add(child);\n+                    addTheseEntries.addAll(result.entriesToAdd());\n+                    countDeleted += result.countDeleted();\n+                }\n             }\n         }\n         if (removeTheseNodes.isEmpty())\n-            return new NodeAndEntries<T>(of(this), Collections.<Entry<T>> emptyList());\n+            return new NodeAndEntries<T>(of(this), Collections.<Entry<T>> emptyList(), 0);\n         else {\n             List<Node<T>> nodes = Util.remove(children, removeTheseNodes);\n             nodes.addAll(addTheseNodes);\n             if (nodes.size() == 0)\n-                return new NodeAndEntries<T>(Optional.<Node<T>> absent(), addTheseEntries);\n+                return new NodeAndEntries<T>(Optional.<Node<T>> absent(), addTheseEntries,\n+                        countDeleted);\n             else {\n                 NonLeaf<T> node = new NonLeaf<T>(nodes, context);\n-                return new NodeAndEntries<T>(of(node), addTheseEntries);\n+                return new NodeAndEntries<T>(of(node), addTheseEntries, countDeleted);\n             }\n         }\n     }\ndiff --git a/src/main/java/com/github/davidmoten/rtree/RTree.java b/src/main/java/com/github/davidmoten/rtree/RTree.java\nindex 57d57fc..f7dfac1 100644\n--- a/src/main/java/com/github/davidmoten/rtree/RTree.java\n+++ b/src/main/java/com/github/davidmoten/rtree/RTree.java\n@@ -350,12 +350,12 @@ public final class RTree<R> {\n      *            the entries to add\n      * @return a sequence of trees\n      */\n-    public Observable<RTree<R>> delete(Observable<Entry<R>> entries) {\n+    public Observable<RTree<R>> delete(Observable<Entry<R>> entries, final boolean all) {\n         return entries.scan(this, new Func2<RTree<R>, Entry<R>, RTree<R>>() {\n \n             @Override\n             public RTree<R> call(RTree<R> tree, Entry<R> entry) {\n-                return tree.delete(entry);\n+                return tree.delete(entry, all);\n             }\n         });\n     }\n@@ -367,10 +367,10 @@ public final class RTree<R> {\n      *            entries to delete\n      * @return R-tree with entries deleted\n      */\n-    public RTree<R> delete(Iterable<Entry<R>> entries) {\n+    public RTree<R> delete(Iterable<Entry<R>> entries, boolean all) {\n         RTree<R> tree = this;\n         for (Entry<R> entry : entries)\n-            tree = tree.delete(entry);\n+            tree = tree.delete(entry, all);\n         return tree;\n     }\n \n@@ -386,8 +386,12 @@ public final class RTree<R> {\n      * @return a new immutable R-tree without one instance of the specified\n      *         entry\n      */\n+    public RTree<R> delete(R value, Geometry geometry, boolean all) {\n+        return delete(Entry.entry(value, geometry), all);\n+    }\n+\n     public RTree<R> delete(R value, Geometry geometry) {\n-        return delete(Entry.entry(value, geometry));\n+        return delete(Entry.entry(value, geometry), false);\n     }\n \n     /**\n@@ -400,18 +404,23 @@ public final class RTree<R> {\n      * @return a new immutable R-tree without one instance of the specified\n      *         entry\n      */\n-    public RTree<R> delete(Entry<R> entry) {\n+    public RTree<R> delete(Entry<R> entry, boolean all) {\n         if (root.isPresent()) {\n-            NodeAndEntries<R> nodeAndEntries = root.get().delete(entry);\n+            NodeAndEntries<R> nodeAndEntries = root.get().delete(entry, all);\n             if (nodeAndEntries.node().isPresent() && nodeAndEntries.node().get() == root.get())\n                 return this;\n             else\n-                return new RTree<R>(nodeAndEntries.node(), size - 1\n-                        - nodeAndEntries.entries().size(), context).add(nodeAndEntries.entries());\n+                return new RTree<R>(nodeAndEntries.node(), size - nodeAndEntries.countDeleted()\n+                        - nodeAndEntries.entriesToAdd().size(), context).add(nodeAndEntries\n+                        .entriesToAdd());\n         } else\n             return this;\n     }\n \n+    public RTree<R> delete(Entry<R> entry) {\n+        return delete(entry, false);\n+    }\n+\n     /**\n      * <p>\n      * Returns an Observable sequence of {@link Entry} that satisfy the given\ndiff --git a/src/main/java/com/github/davidmoten/rtree/SplitterQuadratic.java b/src/main/java/com/github/davidmoten/rtree/SplitterQuadratic.java\nindex 75a560b..fff12ef 100644\n--- a/src/main/java/com/github/davidmoten/rtree/SplitterQuadratic.java\n+++ b/src/main/java/com/github/davidmoten/rtree/SplitterQuadratic.java\n@@ -103,6 +103,10 @@ public final class SplitterQuadratic implements Splitter {\n                 }\n             }\n         }\n-        return new Pair<T>(e1.get(), e2.get());\n+        if (e1.isPresent())\n+            return new Pair<T>(e1.get(), e2.get());\n+        else\n+            // all items are the same item\n+            return new Pair<T>(items.get(0), items.get(1));\n     }\n }\ndiff --git a/src/main/java/com/github/davidmoten/rtree/Util.java b/src/main/java/com/github/davidmoten/rtree/Util.java\nindex 9b7920f..216a71b 100644\n--- a/src/main/java/com/github/davidmoten/rtree/Util.java\n+++ b/src/main/java/com/github/davidmoten/rtree/Util.java\n@@ -68,9 +68,11 @@ public final class Util {\n         return result;\n     }\n \n-    static <T> List<T> remove(List<T> list, T element) {\n+    static <T> List<T> remove(List<T> list, T element, boolean all) {\n         final ArrayList<T> result = new ArrayList<T>(list);\n         result.remove(element);\n+        while (all && result.remove(element))\n+            ;\n         return result;\n     }\n \n", "test_patch": "diff --git a/src/test/java/com/github/davidmoten/rtree/RTreeTest.java b/src/test/java/com/github/davidmoten/rtree/RTreeTest.java\nindex 27892eb..e26744e 100644\n--- a/src/test/java/com/github/davidmoten/rtree/RTreeTest.java\n+++ b/src/test/java/com/github/davidmoten/rtree/RTreeTest.java\n@@ -292,7 +292,7 @@ public class RTreeTest {\n     }\n \n     @Test\n-    public void testDeleteOneFromLargeTree() {\n+    public void testDeleteOneFromLargeTreeThenDeleteAllAndEnsureEmpty() {\n         int n = 10000;\n         RTree<Object> tree = createRandomRTree(n).add(e(1)).add(e(2)).delete(e(1));\n         assertEquals(n + 1, (int) tree.entries().count().toBlocking().single());\n@@ -306,6 +306,14 @@ public class RTreeTest {\n     }\n \n     @Test\n+    public void testDeleteOnlyDeleteOneIfThereAreMoreThanMaxChildren() {\n+        Entry<Object> e1 = e(1);\n+        int count = RTree.maxChildren(4).create().add(e1).add(e1).add(e1).add(e1).add(e1)\n+                .delete(e1).search(e1.geometry().mbr()).count().toBlocking().single();\n+        assertEquals(4, count);\n+    }\n+\n+    @Test\n     public void testDeleteItemThatIsNotPresentDoesNothing() {\n         Entry<Object> e1 = e(1);\n         Entry<Object> e2 = e(2);\n@@ -320,7 +328,7 @@ public class RTreeTest {\n                 .add(entry(\"MARY\", point(97, 125)));\n     }\n \n-    @Test(timeout=2000)\n+    @Test(timeout = 2000)\n     public void testUnsubscribe() {\n         RTree<Object> tree = createRandomRTree(1000);\n         assertEquals(0, (int) tree.entries().take(0).count().toBlocking().single());\n"}
