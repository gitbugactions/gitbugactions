{"repository": "cowtowncoder/java-uuid-generator", "clone_url": "https://github.com/cowtowncoder/java-uuid-generator.git", "timestamp": "2023-05-31T19:57:05.043151Z", "commit_hash": "10b6c09bbea1bdde3d6a095530013a59459f9481", "commit_message": "Fixed the bit-shuffling wrt #41 implementation (see #45)\n", "related_issues": "", "bug_patch": "diff --git a/release-notes/CREDITS b/release-notes/CREDITS\nindex 7a3dde1..975b715 100644\n--- a/release-notes/CREDITS\n+++ b/release-notes/CREDITS\n@@ -114,3 +114,7 @@ Andre Brait (andrebrait@github)\n Pascal Schumacher (PascalSchumacher@github)\n   * Reported #37: Problematic OSGI version range for slf4j dependency\n   [4.0.1]\n+\n+Hal Hildebrand (Hellblazer@github)\n+  * Contributed #41: Add support for Proposed type v6 (reordered timestamp)\n+  [4.1.0]\ndiff --git a/release-notes/VERSION b/release-notes/VERSION\nindex cad3816..8697111 100644\n--- a/release-notes/VERSION\n+++ b/release-notes/VERSION\n@@ -6,6 +6,8 @@ Releases\n \n 4.1.0 (not yet released)\n \n+#41: Add support for Proposed type v6 (reordered timestamp)\n+ (contributed by Hal H)\n - Fix a minor issue with argument validation for `Jug` tool class\n - Update junit dependency (via oss-parent:41)\n \ndiff --git a/src/main/java/com/fasterxml/uuid/UUIDTimer.java b/src/main/java/com/fasterxml/uuid/UUIDTimer.java\nindex e332c2f..4aa33a2 100644\n--- a/src/main/java/com/fasterxml/uuid/UUIDTimer.java\n+++ b/src/main/java/com/fasterxml/uuid/UUIDTimer.java\n@@ -247,7 +247,7 @@ public class UUIDTimer\n          * independent of whether we can use it:\n          */\n         if (systime < _lastSystemTimestamp) {\n-            logger.warn(\"System time going backwards! (got value {}, last {}\", systime, _lastSystemTimestamp);\n+            logger.warn(\"System time going backwards! (got value {}, last {})\", systime, _lastSystemTimestamp);\n             // Let's write it down, still\n             _lastSystemTimestamp = systime;\n         }\ndiff --git a/src/main/java/com/fasterxml/uuid/impl/TimeBasedReorderedGenerator.java b/src/main/java/com/fasterxml/uuid/impl/TimeBasedReorderedGenerator.java\nindex ec3e66f..75b5f2f 100644\n--- a/src/main/java/com/fasterxml/uuid/impl/TimeBasedReorderedGenerator.java\n+++ b/src/main/java/com/fasterxml/uuid/impl/TimeBasedReorderedGenerator.java\n@@ -99,20 +99,23 @@ public class TimeBasedReorderedGenerator extends NoArgGenerator\n     @Override\n     public UUID generate()\n     {\n+        // Ok, get 60-bit timestamp (4 MSB are ignored)\n         final long rawTimestamp = _timer.getTimestamp();\n-        // Time field components are kind of shuffled, need to slice:\n-        int clockHi = (int) (rawTimestamp >>> 32);\n-        int clockLo = (int) rawTimestamp;\n-        // and dice\n-        int midhi = (clockHi << 16) | (clockHi >>> 16);\n-        // need to squeeze in type (4 MSBs in byte 6, clock hi)\n-        midhi &= ~0xF000; // remove high nibble of 6th byte\n-        midhi |= 0x6000; // type 6\n-        long midhiL = (long) midhi;\n-        midhiL = ((midhiL << 32) >>> 32); // to get rid of sign extension\n+\n+        // First: discard 4 MSB, next 32 bits (top of 60-bit timestamp) form the\n+        // highest 32-bit segments\n+        final long timestampHigh = (rawTimestamp >>> 28) << 32;\n+        // and then bottom 28 bits split into mid (16 bits), low (12 bits)\n+        final int timestampLow = (int) rawTimestamp;\n+        // and then low part gets mixed with variant identifier\n+        final int timeBottom = (((timestampLow >> 12) & 0xFFFF) << 16)\n+                // and final 12 bits mixed with variant identifier\n+                | 0x6000 | (timestampLow & 0xFFF);\n+        long timeBottomL = (long) timeBottom;\n+        timeBottomL = ((timeBottomL << 32) >>> 32); // to get rid of sign extension\n+\n         // and reconstruct\n-        long l1 = (((long) clockLo) << 32) | midhiL;\n-        // last detail: must force 2 MSB to be '10'\n+        long l1 = timestampHigh | timeBottomL;\n         return new UUID(l1, _uuidL2);\n     }\n }\n", "test_patch": "diff --git a/src/test/java/com/fasterxml/uuid/UUIDGeneratorTest.java b/src/test/java/com/fasterxml/uuid/UUIDGeneratorTest.java\nindex f190bd2..c6904af 100644\n--- a/src/test/java/com/fasterxml/uuid/UUIDGeneratorTest.java\n+++ b/src/test/java/com/fasterxml/uuid/UUIDGeneratorTest.java\n@@ -438,7 +438,7 @@ public class UUIDGeneratorTest extends TestCase\n         checkUUIDArrayForUniqueness(uuid_array);\n         \n         // check that all uuids have timestamps between the start and end time\n-        checkUUIDArrayForCorrectCreationTime(uuid_array, start_time, end_time);\n+        checkUUIDArrayForCorrectCreationTimeReorder(uuid_array, start_time, end_time);\n     }\n     \n     /**\n@@ -487,7 +487,7 @@ public class UUIDGeneratorTest extends TestCase\n         checkUUIDArrayForUniqueness(uuid_array);\n         \n         // check that all uuids have timestamps between the start and end time\n-        checkUUIDArrayForCorrectCreationTime(uuid_array, start_time, end_time);\n+        checkUUIDArrayForCorrectCreationTimeReorder(uuid_array, start_time, end_time);\n         \n         // check that all UUIDs have the correct ethernet address in the UUID\n         checkUUIDArrayForCorrectEthernetAddress(uuid_array, ethernet_address);\n@@ -565,7 +565,7 @@ public class UUIDGeneratorTest extends TestCase\n     }\n     \n     private void checkUUIDArrayForCorrectVariantAndVersion(UUID[] uuidArray,\n-                                                           UUIDType expectedType)\n+            UUIDType expectedType)\n     {\n         // let's check that all the UUIDs are valid type-X UUIDs with the\n         // correct variant according to the specification.\n@@ -606,15 +606,16 @@ public class UUIDGeneratorTest extends TestCase\n         //     System.currenTimeMillis()...\n         assertTrue(\"Start time: \" + startTime +\" was after the end time: \" + endTime,\n             startTime <= endTime);\n-        \n+\n         // let's check that all uuids in the array have a timestamp which lands\n         // between the start and end time\n         for (int i = 0; i < uuidArray.length; i++){\n             byte[] temp_uuid = UUIDUtil.asByteArray(uuidArray[i]);\n-            \n+\n             // first we'll collect the UUID time stamp which is\n             // the number of 100-nanosecond intervals since\n             // 00:00:00.00 15 October 1582\n+\n             long uuid_time = 0L;\n             uuid_time |= ((temp_uuid[3] & 0xF0L) <<  0);\n             uuid_time |= ((temp_uuid[2] & 0xFFL) <<  8);\n@@ -643,6 +644,60 @@ public class UUIDGeneratorTest extends TestCase\n         }\n     }\n \n+    // Modified version for Variant 6 (reordered timestamps)\n+    private void checkUUIDArrayForCorrectCreationTimeReorder(UUID[] uuidArray,\n+            long startTime, long endTime)\n+    {\n+        // we need to convert from 100-nanosecond units (as used in UUIDs)\n+        // to millisecond units as used in UTC based time\n+        final long MILLI_CONVERSION_FACTOR = 10000L;\n+        // Since System.currentTimeMillis() returns time epoc time\n+        // (from 1-Jan-1970), and UUIDs use time from the beginning of\n+        // Gregorian calendar (15-Oct-1582) we have a offset for correction\n+        final long GREGORIAN_CALENDAR_START_TO_UTC_START_OFFSET =\n+            122192928000000000L;\n+\n+        // 21-Feb-2020, tatu: Not sure why this would be checked, as timestamps come from\n+        //     System.currenTimeMillis()...\n+        assertTrue(\"Start time: \" + startTime +\" was after the end time: \" + endTime,\n+            startTime <= endTime);\n+\n+        // let's check that all uuids in the array have a timestamp which lands\n+        // between the start and end time\n+        for (int i = 0; i < uuidArray.length; i++){\n+            byte[] temp_uuid = UUIDUtil.asByteArray(uuidArray[i]);\n+\n+            // first we'll collect the UUID time stamp which is\n+            // the number of 100-nanosecond intervals since\n+            // 00:00:00.00 15 October 1582\n+            long uuid_time = 0L;\n+            uuid_time |= ((temp_uuid[0] & 0xFFL) << 52);\n+            uuid_time |= ((temp_uuid[1] & 0xFFL) << 44);\n+            uuid_time |= ((temp_uuid[2] & 0xFFL) << 36);\n+            uuid_time |= ((temp_uuid[3] & 0xFFL) << 28);\n+            uuid_time |= ((temp_uuid[4] & 0xFFL) << 20);\n+            uuid_time |= ((temp_uuid[5] & 0xFFL) << 12);\n+            uuid_time |= ((temp_uuid[6] & 0x0FL) << 8);\n+            uuid_time |= ((temp_uuid[7] & 0xFFL));\n+\n+            // first we'll remove the gregorian offset\n+            uuid_time -= GREGORIAN_CALENDAR_START_TO_UTC_START_OFFSET;\n+\n+            // and convert to milliseconds as the system clock is in millis\n+            uuid_time /= MILLI_CONVERSION_FACTOR;\n+\n+            // now check that the times are correct\n+            assertTrue(\n+                \"Start time: \" + startTime +\n+                    \" was not before UUID timestamp: \" + uuid_time,\n+                startTime  <= uuid_time);\n+            assertTrue(\n+                \"UUID timestamp: \" + uuid_time +\n+                    \" was not before the end time: \" + endTime,\n+                uuid_time <= endTime);\n+        }\n+    }\n+\n     private void checkUUIDArrayForCorrectEthernetAddress(UUID[] uuidArray,\n         EthernetAddress ethernetAddress)\n     {\n"}
