{"repository": "cloudsimplus/cloudsimplus", "clone_url": "https://github.com/cloudsimplus/cloudsimplus.git", "timestamp": "2023-05-31T19:46:08.356792Z", "commit_hash": "32c926a47b6aad78f802dc85637a2785fe48965c", "commit_message": "Fix test failures\n\nSigned-off-by: Manoel Campos <manoelcampos@gmail.com>\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/cloudsimplus/core/CloudSimTag.java b/src/main/java/org/cloudsimplus/core/CloudSimTag.java\nindex a065e8f..3922faa 100755\n--- a/src/main/java/org/cloudsimplus/core/CloudSimTag.java\n+++ b/src/main/java/org/cloudsimplus/core/CloudSimTag.java\n@@ -68,27 +68,28 @@ public class CloudSimTag{\n     public static final int DC_LIST_REQUEST = BASE + 4;\n \n     /**\n-     * Denotes a request to register a {@link CloudInformationService} entity as a regional CIS.\n-     * When such a {@link SimEvent} is sent, the {@link SimEvent#getData()}\n-     * must be a {@link CloudInformationService} object.\n+     * This tag is used by an entity to send ping requests.\n      */\n-    public static final int REGISTER_REGIONAL_CIS = BASE + 13;\n+    public static final int ICMP_PKT_SUBMIT = NET_BASE + 5;\n \n     /**\n-     * Denotes a request to get a list of other regional CIS entities from the\n-     * system CIS entity.\n+     * This tag is used to return the ping request back to sender.\n      */\n-    public static final int REQUEST_REGIONAL_CIS = BASE + 14;\n+    public static final int ICMP_PKT_RETURN = NET_BASE + 6;\n \n     /**\n-     * This tag is used by an entity to send ping requests.\n+     * Denotes a request to register a {@link CloudInformationService} entity as a regional CIS.\n+     * When such a {@link SimEvent} is sent, the {@link SimEvent#getData()}\n+     * must be a {@link CloudInformationService} object.\n      */\n-    public static final int ICMP_PKT_SUBMIT = NET_BASE + 5;\n+    public static final int REGISTER_REGIONAL_CIS = BASE + 12;\n \n     /**\n-     * This tag is used to return the ping request back to sender.\n+     * Denotes a request to get a list of other regional CIS entities from the\n+     * system CIS entity.\n      */\n-    public static final int ICMP_PKT_RETURN = NET_BASE + 6;\n+    public static final int REQUEST_REGIONAL_CIS = BASE + 13;\n+\n \n     /**\n      * Denotes a broker request to schedule creation of waiting cloudlets.\n", "test_patch": "diff --git a/src/test/java/org/cloudsimplus/core/CloudSimTagTest.java b/src/test/java/org/cloudsimplus/core/CloudSimTagTest.java\nindex 0149c2a..77110ce 100755\n--- a/src/test/java/org/cloudsimplus/core/CloudSimTagTest.java\n+++ b/src/test/java/org/cloudsimplus/core/CloudSimTagTest.java\n@@ -46,7 +46,14 @@ public class CloudSimTagTest {\n     }\n \n     public static String msgFieldsWithDuplicatedValue(final Field field, final Field anotherField) {\n-        return \"The constant \" + field.getName() + \" has the same value of the constant \" + anotherField.getName();\n+        String value = \"\";\n+        try {\n+            value = \": \" + field.get(CloudSim.class).toString();\n+        } catch (IllegalAccessException e) {\n+        }\n+\n+        return \"The constant %s has the same value of the constant %s%s\"\n+            .formatted(field.getName(), anotherField.getName(), value);\n     }\n \n     /**\ndiff --git a/src/test/java/org/cloudsimplus/integrationtests/FinishedEntitiesPurgeTest.java b/src/test/java/org/cloudsimplus/integrationtests/FinishedEntitiesPurgeTest.java\ndeleted file mode 100755\nindex 5a81acf..0000000\n--- a/src/test/java/org/cloudsimplus/integrationtests/FinishedEntitiesPurgeTest.java\n+++ /dev/null\n@@ -1,284 +0,0 @@\n-/*\n- * CloudSim Plus: A modern, highly-extensible and easier-to-use Framework for\n- * Modeling and Simulation of Cloud Computing Infrastructures and Services.\n- * http://cloudsimplus.org\n- *\n- *     Copyright (C) 2015-2021 Universidade da Beira Interior (UBI, Portugal) and\n- *     the Instituto Federal de Educa\u00e7\u00e3o Ci\u00eancia e Tecnologia do Tocantins (IFTO, Brazil).\n- *\n- *     This file is part of CloudSim Plus.\n- *\n- *     CloudSim Plus is free software: you can redistribute it and/or modify\n- *     it under the terms of the GNU General Public License as published by\n- *     the Free Software Foundation, either version 3 of the License, or\n- *     (at your option) any later version.\n- *\n- *     CloudSim Plus is distributed in the hope that it will be useful,\n- *     but WITHOUT ANY WARRANTY; without even the implied warranty of\n- *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n- *     GNU General Public License for more details.\n- *\n- *     You should have received a copy of the GNU General Public License\n- *     along with CloudSim Plus. If not, see <http://www.gnu.org/licenses/>.\n- */\n-package org.cloudsimplus.integrationtests;\n-\n-import ch.qos.logback.classic.Level;\n-import org.cloudsimplus.brokers.DatacenterBroker;\n-import org.cloudsimplus.brokers.DatacenterBrokerSimple;\n-import org.cloudsimplus.cloudlets.Cloudlet;\n-import org.cloudsimplus.cloudlets.CloudletSimple;\n-import org.cloudsimplus.core.CloudSimPlus;\n-import org.cloudsimplus.datacenters.Datacenter;\n-import org.cloudsimplus.datacenters.DatacenterSimple;\n-import org.cloudsimplus.hosts.Host;\n-import org.cloudsimplus.hosts.HostSimple;\n-import org.cloudsimplus.listeners.EventInfo;\n-import org.cloudsimplus.resources.Pe;\n-import org.cloudsimplus.resources.PeSimple;\n-import org.cloudsimplus.util.Log;\n-import org.cloudsimplus.utilizationmodels.UtilizationModelFull;\n-import org.cloudsimplus.vms.Vm;\n-import org.cloudsimplus.vms.VmSimple;\n-import org.junit.jupiter.api.BeforeAll;\n-import org.junit.jupiter.api.DisplayName;\n-import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.api.TestInstance;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.stream.IntStream;\n-import java.util.stream.Stream;\n-\n-import static java.util.stream.Collectors.toCollection;\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-/**\n- * An integration test to assess the correctness of the simulation\n- * after purging finished entities.\n- * It creates a set of brokers, where each broker has the same number of VMs and cloudlets.\n- * However, the 1st broker receives the same number of previous cloudlets\n- * after their previous ones have finished.\n- * All Cloudlets for a given broker have the same length,\n- * however, cloudlets in different brokers have an arithmetically progressing length.\n- *\n- * @author Manoel Campos da Silva Filho\n- * @since CloudSim Plus 6.0.0\n- */\n-@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n-class FinishedEntitiesPurgeTest {\n-    private static final int HOST_PES = 8;\n-    private static final int VM_PES = 2;\n-\n-    private static final int CLOUDLET_PES = VM_PES;\n-    private static final long BASE_CLOUDLET_LENGTH = 1000;\n-\n-    private static final double SCHEDULING_INTERVAL_SECS = 1;\n-\n-    private static final int HOSTS_NUMBER = 1000;\n-    private static final int BROKERS_NUMBER = HOSTS_NUMBER/10;\n-    private static final int VMS_BY_BROKER = HOSTS_NUMBER / BROKERS_NUMBER * 4;\n-    private static final int CLOUDLETS_BY_BROKER = VMS_BY_BROKER;\n-    private static final int HOST_MIPS = 1000;\n-\n-    /**\n-     * Total number of cloudlets created statically across all brokers, before simulation start,\n-     * which are expected to finish.\n-     */\n-    private static final double STATIC_CLOUDLETS_TO_FINISH = CLOUDLETS_BY_BROKER * BROKERS_NUMBER;\n-\n-    /**\n-     * The maximum accepted difference in time results.\n-     */\n-    private static final double MAX_TIME_DELTA = 0.25;\n-\n-    private CloudSimPlus simulation;\n-    private List<DatacenterBroker> brokerList;\n-\n-    private long lastVmId;\n-    private long lastCloudletId;\n-    private boolean dynamicCloudletsSubmitted;\n-    private double previousEntitiesNumber;\n-\n-    @BeforeAll\n-    void setUp() {\n-        buildAndStartSimulation();\n-    }\n-\n-    @Test\n-    void cloudletExecTimeTime() {\n-        assertAll(getAllBrokersCloudletStream().map(cl -> () -> assertCloudletExecTime(cl)));\n-    }\n-\n-    /**\n-     *\n-     * Since the cloudlets for the first broker finish in 1 second and the length\n-     * is increased according to {@link #BASE_CLOUDLET_LENGTH},\n-     * the broker order defines the time when its cloudlets are expected to finish.\n-     * The exception is for the dynamic submitted cloudlets for the first broker,\n-     * that start when its previous cloudlets finish.\n-     * */\n-    private void assertCloudletExecTime(final Cloudlet cl) {\n-        final double expectedCloudletFinishTime = getBrokerOrder(cl);\n-        final var msg = \"%s on %s len %d start %.2f finish time\"\n-            .formatted(cl, cl.getBroker(), cl.getLength(), cl.getStartTime());\n-        assertEquals(expectedCloudletFinishTime, cl.getTotalExecutionTime(), 0.7, msg);\n-    }\n-\n-    /**\n-     * Gets the order of a broker inside its list (the broker at index 0 has order 1, and so on).\n-     * @param cloudlet the cloudlet to get its broker\n-     * @return\n-     */\n-    private long getBrokerOrder(final Cloudlet cloudlet) {\n-        return cloudlet.getBroker().getId() - 1;\n-    }\n-\n-    @Test\n-    void finishedCloudlets() {\n-        assertAll(brokerList.stream().map(broker -> () -> assertExpectedFinishedCloudletList(broker)));\n-    }\n-\n-    private void assertExpectedFinishedCloudletList(final DatacenterBroker broker) {\n-        final int expectedCloudletsByBroker = CLOUDLETS_BY_BROKER * (broker == brokerList.get(0) ? 2 : 1);\n-        final var msg = \"%s finished Cloudlets\".formatted(broker);\n-        assertEquals(expectedCloudletsByBroker, broker.getCloudletFinishedList().size(), msg);\n-    }\n-\n-    private Stream<Cloudlet> getAllBrokersCloudletStream() {\n-        return brokerList.stream().flatMap(broker -> broker.getCloudletFinishedList().stream());\n-    }\n-\n-    @Test()\n-    @DisplayName(\"Checks if brokers are being destroyed after becoming idle\")\n-    void brokerShutdownTime() {\n-        assertAll(brokerList.stream().map(broker -> () -> assertBrokerShutDownTime(broker)));\n-    }\n-\n-    /**\n-     * Checks if the broker shutdown time is the same as it's last finished VM.\n-     * The way the experiment is set, the time the broker shuts down\n-     * is it's id - 1. You can check that by just looking at the\n-     * the finish time of the broker's last cloudlet.\n-     * That rule doesn't apply only for the first broker,\n-     * that receives the double of cloudlets.\n-     * @param broker\n-     */\n-    private void assertBrokerShutDownTime(final DatacenterBroker broker) {\n-        final var msg = \"%s shutdown time\".formatted(broker);\n-        assertNotEquals(-1, broker.getShutdownTime(), 0.9, msg);\n-    }\n-\n-    private void buildAndStartSimulation() {\n-        Log.setLevel(Level.WARN);\n-        simulation = new CloudSimPlus();\n-        createDatacenter();\n-        createBrokers();\n-        simulation.addOnClockTickListener(this::onClockTickListener);\n-        simulation.start();\n-    }\n-\n-    private void onClockTickListener(final EventInfo evt) {\n-        //The statically submitted cloudlets for the first broker finish in 1 second\n-        final var broker0 = brokerList.get(0);\n-        if(evt.getTime() >= SCHEDULING_INTERVAL_SECS && !dynamicCloudletsSubmitted){\n-            dynamicCloudletsSubmitted = true;\n-            createCloudlets(broker0, BASE_CLOUDLET_LENGTH);\n-        } else if(evt.getTime() >= SCHEDULING_INTERVAL_SECS*2){\n-            /* After some time has passed since the static cloudlets submitted to the first broker\n-             * have finished, enable broker shutdown when it becomes idle. */\n-            broker0.setShutdownWhenIdle(true);\n-        }\n-\n-        final int entitiesNumber = simulation.getEntityList().size();\n-        if(entitiesNumber != previousEntitiesNumber){\n-            this.previousEntitiesNumber = entitiesNumber;\n-        }\n-    }\n-\n-    private void createBrokers() {\n-        this.brokerList = new ArrayList<>();\n-        for (int i = 0; i < BROKERS_NUMBER; i++) {\n-            final DatacenterBroker broker = createBroker();\n-            brokerList.add(broker);\n-            createVmsAndCloudlets(broker);\n-        }\n-\n-        /*The first broker is not destroyed automatically when it becomes idle.\n-        * Only after its dynamic cloudlets are created, this configuration is set.*/\n-        this.brokerList.get(0).setShutdownWhenIdle(false);\n-    }\n-\n-    /**\n-     * Creates a broker that destroys finished VMs immediately.\n-     * This way, the broker will shutdown as soon as all VMs have finished,\n-     * instead of waiting the end of the simulation.\n-     * @return\n-     */\n-    private DatacenterBroker createBroker() {\n-        return new DatacenterBrokerSimple(simulation).setVmDestructionDelay(0.2);\n-    }\n-\n-    private void createVmsAndCloudlets(final DatacenterBroker broker) {\n-        final var vmList = createVms(broker);\n-        final long length = BASE_CLOUDLET_LENGTH * brokerList.size();\n-        final List<Cloudlet> cloudlets = vmList.stream().map(vm -> createCloudlet(vm, length)).toList();\n-        broker.submitCloudletList(cloudlets);\n-    }\n-\n-    private Datacenter createDatacenter() {\n-        final var hostList = new ArrayList<Host>(HOSTS_NUMBER);\n-        for(int i = 0; i < HOSTS_NUMBER; i++) {\n-            final var host = createHost();\n-            hostList.add(host);\n-        }\n-\n-        return new DatacenterSimple(simulation, hostList).setSchedulingInterval(SCHEDULING_INTERVAL_SECS);\n-    }\n-\n-    private Host createHost() {\n-        final List<Pe> peList = IntStream.range(0, HOST_PES)\n-                                    .mapToObj(i -> new PeSimple(HOST_MIPS))\n-                                    .collect(toCollection(() -> new ArrayList<>(HOST_PES)));\n-\n-        final long ram = 2048; //in Megabytes\n-        final long bw = 10000; //in Megabits/s\n-        final long storage = 1000000; //in Megabytes\n-\n-        return new HostSimple(ram, bw, storage, peList);\n-    }\n-\n-    private List<Vm> createVms(final DatacenterBroker broker) {\n-        final var vmList = IntStream.range(0, VMS_BY_BROKER)\n-                                    .mapToObj(i -> createVm())\n-                                    .collect(toCollection(() -> new ArrayList<>(VMS_BY_BROKER)));\n-\n-        broker.submitVmList(vmList);\n-        return vmList;\n-    }\n-\n-    private Vm createVm() {\n-        final Vm vm = new VmSimple(lastVmId++, HOST_MIPS, VM_PES);\n-        vm.setRam(512).setBw(1000).setSize(10000);\n-        return vm;\n-    }\n-\n-    private void createCloudlets(final DatacenterBroker broker, final long length) {\n-        createCloudlets(broker, Vm.NULL, length);\n-    }\n-\n-    private void createCloudlets(final DatacenterBroker broker, final Vm vm, final long length) {\n-        final var cloudletList = IntStream.range(0, CLOUDLETS_BY_BROKER)\n-                                          .mapToObj(i -> createCloudlet(vm, length))\n-                                          .collect(toCollection(() -> new ArrayList<>(CLOUDLETS_BY_BROKER)));\n-\n-        broker.submitCloudletList(cloudletList);\n-    }\n-\n-    private Cloudlet createCloudlet(final Vm vm, final long length) {\n-        final var cloudlet = new CloudletSimple(lastCloudletId++, length, CLOUDLET_PES);\n-        cloudlet.setUtilizationModelCpu(new UtilizationModelFull());\n-        cloudlet.setSizes(1024).setVm(vm);\n-        return cloudlet;\n-    }\n-}\n"}
{"repository": "cloudsimplus/cloudsimplus", "clone_url": "https://github.com/cloudsimplus/cloudsimplus.git", "timestamp": "2023-05-31T20:02:27.001118Z", "commit_hash": "5f0e65f87b301bfc8e900b152b5d0769e4019b30", "commit_message": "Fix SwfWorkloadFileReaderTest\nafter making SwfWorkloadFileReader\nto read just the first file\ninside a zip package.\n\nSigned-off-by: Manoel Campos <manoelcampos@gmail.com>\n", "related_issues": "", "bug_patch": "diff --git a/src/test/resources/NASA-iPSC-1993-3.1-cln.swf.zip b/src/test/resources/NASA-iPSC-1993-3.1-cln.swf.zip\nnew file mode 100644\nindex 0000000..f4a4cd6\nBinary files /dev/null and b/src/test/resources/NASA-iPSC-1993-3.1-cln.swf.zip differ\n", "test_patch": "diff --git a/src/test/java/org/cloudsimplus/util/SwfWorkloadFileReaderTest.java b/src/test/java/org/cloudsimplus/util/SwfWorkloadFileReaderTest.java\nindex 2fe913b..40faa5c 100755\n--- a/src/test/java/org/cloudsimplus/util/SwfWorkloadFileReaderTest.java\n+++ b/src/test/java/org/cloudsimplus/util/SwfWorkloadFileReaderTest.java\n@@ -13,28 +13,28 @@ import static org.junit.jupiter.api.Assertions.assertTrue;\n \n public class SwfWorkloadFileReaderTest {\n     private static final Logger LOGGER = LoggerFactory.getLogger(SwfWorkloadFileReaderTest.class.getSimpleName());\n-    private static final int JOBS_AT_SWF_LCG_FILE = 188041;\n     private static final String SWF_FILE = \"LCG.swf\";\n-    private static final String ZIP_FILE = \"two-workload-files.zip\";\n+    private static final int    SWF_FILE_JOBS = 188041;\n+    private static final String ZIP_FILE = \"NASA-iPSC-1993-3.1-cln.swf.zip\";\n \n     /**\n      * Number of jobs of the NASA file inside the zip archive.\n      */\n-    private static final int JOBS_AT_SWF_NASA_FILE = 18239;\n+    private static final int ZIP_FILE_JOBS = 18239;\n \n     @Test\n     public void readGz() {\n-\t    assertTrue(assertCreatedCloudletsFromTrace(SWF_FILE+\".gz\", JOBS_AT_SWF_LCG_FILE));\n+\t    assertTrue(assertCreatedCloudletsFromTrace(SWF_FILE+\".gz\", SWF_FILE_JOBS));\n     }\n \n     @Test\n     public void readSwf() {\n-\t    assertTrue(assertCreatedCloudletsFromTrace(SWF_FILE, JOBS_AT_SWF_LCG_FILE));\n+\t    assertTrue(assertCreatedCloudletsFromTrace(SWF_FILE, SWF_FILE_JOBS));\n     }\n \n     @Test\n-    public void readZipWithTwoSwfFiles() {\n-\t    assertTrue(assertCreatedCloudletsFromTrace(ZIP_FILE, JOBS_AT_SWF_LCG_FILE + JOBS_AT_SWF_NASA_FILE));\n+    public void readZipSwfFiles() {\n+\t    assertTrue(assertCreatedCloudletsFromTrace(ZIP_FILE, ZIP_FILE_JOBS));\n     }\n \n     private boolean assertCreatedCloudletsFromTrace(final String fileNameWithoutPath, final int jobsNumber) {\ndiff --git a/src/test/resources/two-workload-files.zip b/src/test/resources/two-workload-files.zip\ndeleted file mode 100755\nindex 90060b9..0000000\nBinary files a/src/test/resources/two-workload-files.zip and /dev/null differ\n"}
