{"repository": "killme2008/aviatorscript", "clone_url": "https://github.com/killme2008/aviatorscript.git", "timestamp": "2023-05-31T18:52:32.456569Z", "commit_hash": "90bdb0c29f4eca0ce752011dca2018c13c29b394", "commit_message": "(fix) long type promption error, #162\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/com/googlecode/aviator/lexer/ExpressionLexer.java b/src/main/java/com/googlecode/aviator/lexer/ExpressionLexer.java\nindex c9af0dc..6d40241 100644\n--- a/src/main/java/com/googlecode/aviator/lexer/ExpressionLexer.java\n+++ b/src/main/java/com/googlecode/aviator/lexer/ExpressionLexer.java\n@@ -171,6 +171,7 @@ public class ExpressionLexer {\n       boolean isBigDecimal = false;\n       boolean scientificNotation = false;\n       boolean negExp = false;\n+      boolean isOverflow = false;\n       do {\n         sb.append(this.peek);\n         if (this.peek == '.') {\n@@ -239,6 +240,11 @@ public class ExpressionLexer {\n           }\n \n         }\n+\n+        if (lval < 0) {\n+          isOverflow = true;\n+        }\n+\n       } while (Character.isDigit(this.peek) || this.peek == '.' || this.peek == 'E'\n           || this.peek == 'e' || this.peek == 'M' || this.peek == 'N');\n       Number value;\n@@ -262,7 +268,7 @@ public class ExpressionLexer {\n         } else {\n           // if the long value is out of range,then it must be negative, so\n           // we make it as a big integer.\n-          if (lval < 0) {\n+          if (lval < 0 || isOverflow) {\n             value = new BigInteger(sb.toString());\n           } else {\n             value = lval;\n", "test_patch": "diff --git a/src/test/java/com/googlecode/aviator/test/function/GrammarUnitTest.java b/src/test/java/com/googlecode/aviator/test/function/GrammarUnitTest.java\nindex a0aad19..140da70 100644\n--- a/src/test/java/com/googlecode/aviator/test/function/GrammarUnitTest.java\n+++ b/src/test/java/com/googlecode/aviator/test/function/GrammarUnitTest.java\n@@ -20,6 +20,7 @@ import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertTrue;\n import static org.junit.Assert.fail;\n import java.math.BigDecimal;\n+import java.math.BigInteger;\n import java.util.ArrayList;\n import java.util.Date;\n import java.util.HashMap;\n@@ -51,6 +52,18 @@ public class GrammarUnitTest {\n     AviatorEvaluator.setOption(Options.ALWAYS_PARSE_FLOATING_POINT_NUMBER_INTO_DECIMAL, false);\n   }\n \n+\n+  @Test\n+  public void testIssue162() {\n+    Object val = AviatorEvaluator.execute(\"2017122615550747128008704\");\n+    assertTrue(val instanceof BigInteger);\n+    assertEquals(new BigInteger(\"2017122615550747128008704\"), val);\n+\n+    val = AviatorEvaluator.execute(\"-2017122615550747128008704\");\n+    assertTrue(val instanceof BigInteger);\n+    assertEquals(new BigInteger(\"-2017122615550747128008704\"), val);\n+  }\n+\n   @Test\n   public void testIssue87() {\n     AviatorEvaluator.setOption(Options.ALWAYS_PARSE_FLOATING_POINT_NUMBER_INTO_DECIMAL, true);\n"}
