{"repository": "ronmamo/reflections", "clone_url": "https://github.com/ronmamo/reflections.git", "timestamp": "2023-05-31T18:35:54.878718Z", "commit_hash": "5ff7a1d366e8656dfa0f2f476991b558b037e919", "commit_message": "ref-0.10.2 (#356)\n\n* fix npe on empty Resources store\r\n\r\n* ReflectionUtils.Methods to use getDeclaredMethods\r\n\r\n* add ReflectionUtils.Resources\r\n\r\n* add JdkTests\r\n\r\n* fragile/flaky\r\n\r\n* fix scanner index for deprecated scanners :(\r\n\r\n* deprecated scanners javadocs\r\n\r\n* JdkTests cleanup\r\n\r\n* Bump maven-javadoc-plugin from 3.1.1 to 3.3.1 (#352)\r\n\r\n* Detect annotations during expand super types step (#354)\r\n\r\n* Add subtypes to SubTypes store during expand super types step\r\n\r\n* Detect annotations during expandSuperType step\r\n\r\nCo-authored-by: Julian Rubin <julian.rubin@rtbhouse.com>\r\n\r\n* npe fix\r\n\r\n* ConfigurationBuilder.setParallel fluent\r\n\r\n* readme\r\n\r\n* arranged ReflectionsExpandSupertypesTest\r\n\r\n* Correct the wrong match (#334)\r\n\r\n* Correct the wrong matc\r\n\r\n* Fetch upstream\r\n\r\nCo-authored-by: ileler <ileler@qq.com>\r\n\r\n* arranged VfsTest\r\n\r\n* minors\r\n\r\nCo-authored-by: ronma <ronma@>\r\nCo-authored-by: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>\r\nCo-authored-by: Julian Rubin <rubin94@gmail.com>\r\nCo-authored-by: Julian Rubin <julian.rubin@rtbhouse.com>\r\nCo-authored-by: Kerwin Bryant <kerwin612@qq.com>\r\nCo-authored-by: ileler <ileler@qq.com>", "related_issues": "", "bug_patch": "diff --git a/README.md b/README.md\nindex 9aa03eb..6fd33bd 100644\n--- a/README.md\n+++ b/README.md\n@@ -40,50 +40,61 @@ Set<Class<?>> subTypes =\n   reflections.get(SubTypes.of(SomeType.class).asClass());\n \n Set<Class<?>> annotated = \n-  reflections.get(TypesAnnotated.with(SomeAnnotation.class).asClass());\n+  reflections.get(SubTypes.of(TypesAnnotated.with(SomeAnnotation.class)).asClass());\n ```\n \n-*Note that there are some breaking changes with Reflections 0.10+, along with performance improvements and more functional API. Migration is encouraged and should be easy though.*\n+Or using previous 0.9.x APIs, for example:\n+\n+```java\n+Set<Class<? extends SomeType>> subTypes =\n+  reflections.getSubTypesOf(SomeType.class);\n+\n+Set<Class<?>> annotated = \n+  reflections.getTypesAnnotatedWith(SomeAnnotation.class);\n+```\n+\n+*Note that there are some breaking changes with Reflections 0.10+, along with performance improvements and more functional API, see below.*\n \n ### Scan\n-Creating Reflections instance requires providing scanning configuration:\n+Creating Reflections instance requires [ConfigurationBuilder](https://ronmamo.github.io/reflections/org/reflections/util/ConfigurationBuilder.html), typically configured with packages and [Scanners](https://ronmamo.github.io/reflections/org/reflections/scanners/Scanners.html) to use: \n \n ```java\n-// scan for:\n-//   urls in classpath that contain 'com.my.project' package\n-//   filter types starting with 'com.my.project'\n-//   use the default scanners SubTypes and TypesAnnotated\n+// typical usage: scan package with the default scanners SubTypes, TypesAnnotated\n Reflections reflections = new Reflections(\n   new ConfigurationBuilder()\n     .forPackage(\"com.my.project\")\n     .filterInputsBy(new FilterBuilder().includePackage(\"com.my.project\")));\n \n-// or similarly\n+// or similarly using the convenient constructor\n Reflections reflections = new Reflections(\"com.my.project\");\n+```\n \n-// another example\n+Other examples:\n+```java\n+import static org.reflections.scanners.Scanners.*;\n+\n+// scan package with specific scanners\n Reflections reflections = new Reflections(\n   new ConfigurationBuilder()\n-    .addUrls(ClasspathHelper.forPackage(\"com.my.project\")) // same as forPackage\n-    .setScanners(Scanners.values())     // all standard scanners\n-    .filterInputsBy(new FilterBuilder() // optionally include/exclude packages \n-      .includePackage(\"com.my.project\")\n-      .excludePackage(\"com.my.project.exclude\")));\n-```\n+    .forPackage(\"com.my.project\")\n+    .filterInputsBy(new FilterBuilder().includePackage(\"com.my.project\").excludePackage(\"com.my.project.exclude\"))\n+    .setScanners(TypesAnnotated, MethodsAnnotated, MethodsReturn));\n \n-*See more in [ConfigurationBuilder](https://ronmamo.github.io/reflections/org/reflections/util/ConfigurationBuilder.html).*\n+// scan package with all standard scanners\n+Reflections reflections = new Reflections(\"com.my.project\", Scanners.values());\n+```\n \n Note that:\n-* **Scanners must be configured in order to be queried, otherwise an empty result is returned.**  \n-If not specified, default scanners are `SubTypes` and `TypesAnnotated`. For all standard [Scanners](https://ronmamo.github.io/reflections/org/reflections/scanners/Scanners.html) use `Scanners.values()` [(src)](src/main/java/org/reflections/scanners/Scanners.java).\n-* **All relevant URLs should be configured.**   \n+* **Scanner must be configured in order to be queried, otherwise an empty result is returned**  \n+If not specified, default scanners will be used SubTypes, TypesAnnotated.  \n+For all standard scanners use `Scanners.values()`. See more scanners in the source [package](https://ronmamo.github.io/reflections/org/reflections/scanners).\n+* **All relevant URLs should be configured**   \n+Consider `.filterInputsBy()` in case too many classes are scanned.  \n If required, Reflections will [expand super types](https://ronmamo.github.io/reflections/org/reflections/Reflections.html#expandSuperTypes(java.util.Map)) in order to get the transitive closure metadata without scanning large 3rd party urls.  \n-Consider adding inputs filter in case too many classes are scanned.  \n * Classloader can optionally be used for resolving runtime classes from names.\n \n ### Query\n Once Reflections was instantiated and scanning was successful, it can be used for querying the indexed metadata.  \n-Standard [Scanners](https://ronmamo.github.io/reflections/org/reflections/scanners/Scanners.html) are provided for query using `reflections.get()`, for example:  \n \n ```java\n import static org.reflections.scanners.Scanners.*;\n@@ -92,18 +103,14 @@ import static org.reflections.scanners.Scanners.*;\n Set<Class<?>> modules = \n   reflections.get(SubTypes.of(Module.class).asClass());\n \n-// TypesAnnotated\n+// TypesAnnotated (*1)\n Set<Class<?>> singletons = \n   reflections.get(TypesAnnotated.with(Singleton.class).asClass());\n \n-// MethodAnnotated\n+// MethodsAnnotated\n Set<Method> resources =\n   reflections.get(MethodsAnnotated.with(GetMapping.class).as(Method.class));\n \n-// ConstructorsAnnotated\n-Set<Constructor> injectables = \n-  reflections.get(ConstructorsAnnotated.with(Inject.class).as(Constructor.class));\n-\n // FieldsAnnotated\n Set<Field> ids = \n   reflections.get(FieldsAnnotated.with(Id.class).as(Field.class));\n@@ -113,7 +120,7 @@ Set<String> properties =\n   reflections.get(Resources.with(\".*\\\\.properties\"));\n ```\n \n-Member scanners:\n+More scanners:\n \n ```java\n // MethodsReturn\n@@ -128,51 +135,52 @@ Set<Method> someMethods =\n Set<Method> pathParam = \n   reflections.get(MethodsParameter.of(PathParam.class).as(Method.class));\n \n+// ConstructorsAnnotated\n+Set<Constructor> injectables =\n+  reflections.get(ConstructorsAnnotated.with(Inject.class).as(Constructor.class));\n+\n // ConstructorsSignature\n Set<Constructor> someConstructors = \n   reflections.get(ConstructorsSignature.of(String.class).as(Constructor.class));\n \n-// ConstructorsParameter\n-Set<Constructor> pathParam = \n-  reflections.get(ConstructorsParameter.of(PathParam.class).as(Constructor.class));\n+// MethodParameterNamesScanner\n+List<String> parameterNames =\n+  reflections.getMemberParameterNames(member);\n+\n+// MemberUsageScanner\n+Set<Member> usages =\n+  reflections.getMemberUsages(member)\n ```\n \n *See more examples in [ReflectionsQueryTest](src/test/java/org/reflections/ReflectionsQueryTest.java).*\n \n-Scanner queries return `Set<String>` by default, if not using `as() / asClass()` mappers:\n-```java\n-Set<String> moduleNames = \n-  reflections.get(SubTypes.of(Module.class));\n-\n-Set<String> singleNames = \n-  reflections.get(TypesAnnotated.with(Singleton.class));\n-```\n-Note that previous 0.9.x API is still supported, for example:\n-```java\n-Set<Class<?>> modules = \n-  reflections.getSubTypesOf(Module.class);\n+*Note that previous 0.9.x APIs are still supported*\n \n-Set<Class<?>> singletons = \n-  reflections.getTypesAnnotatedWith(Singleton.class);\n-```\n <details>\n-  <summary>Compare Scanners and previous 0.9.x API</summary>\n-\n-| Scanners | previous 0.9.x API |\n-| -------- | ------------------ |\n-| `get(SubType.of(T))` | getSubTypesOf(T) |\n-| `get(TypesAnnotated.with(A))` | getTypesAnnotatedWith(A) |\n-| `get(MethodsAnnotated.with(A))` | getMethodsAnnotatedWith(A) |\n-| `get(ConstructorsAnnotated.with(A))` | getConstructorsAnnotatedWith(A) |\n-| `get(FieldsAnnotated.with(A))` | getFieldsAnnotatedWith(A) |\n-| `get(Resources.with(regex))` | getResources(regex) |\n-| `get(MethodsParameter.with(P))` | getMethodsWithParameter(P) |\n-| `get(MethodsSignature.of(P, ...))` | getMethodsWithSignature(P, ...) |\n-| `get(MethodsReturn.of(T))` | getMethodsReturn(T) |\n-| `get(ConstructorsParameter.with(P))` | getConstructorsWithParameter(P) |\n-| `get(ConstructorsSignature.of(P, ...))` | getConstructorsWithSignature(P, ...) |\n+  <summary><i>Compare Scanners and previous 0.9.x API (*)</i></summary>\n+\n+| Scanners | previous 0.9.x API | previous Scanner |\n+| -------- | ------------------ | ------ |\n+| `get(SubType.of(T))` | getSubTypesOf(T) | ~~SubTypesScanner~~ |\n+| `get(SubTypes.of(`<br>&nbsp;&nbsp;&nbsp;&nbsp;`TypesAnnotated.with(A)))` | getTypesAnnotatedWith(A) *(1)*| ~~TypeAnnotationsScanner~~ | \n+| `get(MethodsAnnotated.with(A))` | getMethodsAnnotatedWith(A) | ~~MethodAnnotationsScanner~~ | \n+| `get(ConstructorsAnnotated.with(A))` | getConstructorsAnnotatedWith(A) *(2)*| ~~MethodAnnotationsScanner~~ | \n+| `get(FieldsAnnotated.with(A))` | getFieldsAnnotatedWith(A) | ~~FieldAnnotationsScanner~~ | \n+| `get(Resources.with(regex))` | getResources(regex) | ~~ResourcesScanner~~ | \n+| `get(MethodsParameter.with(P))` | getMethodsWithParameter(P) *(3)*<br>~~getMethodsWithAnyParamAnnotated(P)~~| ~~MethodParameterScanner~~<br>*obsolete* | \n+| `get(MethodsSignature.of(P, ...))` | getMethodsWithSignature(P, ...) *(3)<br>~~getMethodsMatchParams(P, ...)~~*| \" | \n+| `get(MethodsReturn.of(T))` | getMethodsReturn(T) *(3)*| \" | \n+| `get(ConstructorsParameter.with(P))` | getConstructorsWithParameter(P) *(3)<br>~~getConstructorsWithAnyParamAnnotated(P)~~*| \" | \n+| `get(ConstructorsSignature.of(P, ...))` | getConstructorsWithSignature(P, ...) *(3)<br>~~getConstructorsMatchParams(P, ...)~~*| \" | \n \n *Note: `asClass()` and `as()` mappings were omitted*\n+\n+*(1): The equivalent of `getTypesAnnotatedWith(A)` is `get(SubTypes.of(TypesAnnotated.with(A)))`, including SubTypes*  \n+\n+*(2): MethodsAnnotatedScanner does not include constructor annotation scanning, use instead Scanners.ConstructorsAnnotated*  \n+\n+*(3): MethodParameterScanner is obsolete, use instead as required:  \n+Scanners.MethodsParameter, Scanners.MethodsSignature, Scanners.MethodsReturn, Scanners.ConstructorsParameter, Scanners.ConstructorsSignature*\n </details>\n \n ## ReflectionUtils\n@@ -187,13 +195,15 @@ Set<Class<?>>    superTypes   = get(SuperTypes.of(T));\n Set<Field>       fields       = get(Fields.of(T));\n Set<Constructor> constructors = get(Constructors.of(T));\n Set<Methods>     methods      = get(Methods.of(T));\n+Set<URL>         resources    = get(Resources.with(T));\n+\n Set<Annotation>  annotations  = get(Annotations.of(T));\n-Set<Class<? extends Annotation>> annotationTypes = get(AnnotationTypess.of(T));\n+Set<Class<? extends Annotation>> annotationTypes = get(AnnotationTypes.of(T));\n ```\n \n *Previous ReflectionUtils 0.9.x API is still supported though marked for removal, more info in the javadocs.*\n \n-## QueryBuilder and QueryFunction\n+## Query API\n Each Scanner and ReflectionUtils function implements [QueryBuilder](https://ronmamo.github.io/reflections/org/reflections/util/QueryBuilder.html), and supports:\n * `get()` - function returns direct values \n * `with()` or `of()` - function returns all transitive values\n@@ -206,21 +216,19 @@ Next, each function implements [QueryFunction](https://ronmamo.github.io/reflect\n and provides fluent functional interface for composing `filter()`, `map()`, `flatMap()`, `as()` and more, such that:\n \n ```java\n+// filter, as/map\n QueryFunction<Store, Method> getters =\n   Methods.of(C1.class)\n     .filter(withModifier(Modifier.PUBLIC))\n     .filter(withPrefix(\"get\").and(withParametersCount(0)))\n     .as(Method.class);\n-```\n \n-Query functions can be composed, for example:\n-```java\n-// compose Scanner and ReflectionUtils functions \n+// compose Scanners and ReflectionUtils functions \n QueryFunction<Store, Method> methods = \n   SubTypes.of(type).asClass()  // <-- classpath scanned metadata\n     .flatMap(Methods::of);     // <-- java reflection api\n \n-// compose function of function\n+// function of function\n QueryFunction<Store, Class<? extends Annotation>> queryAnnotations = \n   Annotations.of(Methods.of(C4.class))\n     .map(Annotation::annotationType);\n@@ -256,11 +264,11 @@ Check the [tests](src/test/java/org/reflections) folder for more examples and AP\n \n ### What else?\n - **Integrating with build lifecycle**  \n-It is sometime useful to save the scanned metadata into xml/json as part of the build lifecycle for generating resources, \n+It is sometime useful to `Reflections.save()` the scanned metadata into xml/json as part of the build lifecycle for generating resources, \n and then collect it on bootstrap with `Reflections.collect()` and avoid scanning. *See [reflections-maven](https://github.com/ronmamo/reflections-maven/) for example*.\n - [JavaCodeSerializer](https://ronmamo.github.io/reflections/org/reflections/serializers/JavaCodeSerializer.html) - scanned metadata can be persisted into a generated Java source code. \n Although less common, it can be useful for accessing types and members in a strongly typed manner. *(see [example](src/test/java/org/reflections/MyTestModelStore.java))*\n-- [AnnotationMergeCollector](https://ronmamo.github.io/reflections/org/reflections/util/AnnotationMergeCollector.html) - can be used to merge similar annotations, for example for finding effective REST controller endpoints. *(see [test](src/test/java/org/reflections/ReflectionUtilsQueryTest.java#L216))*\n+- [AnnotationMergeCollector](https://ronmamo.github.io/reflections/org/reflections/util/AnnotationMergeCollector.html) - can be used to merge similar annotations. *(see [test](src/test/java/org/reflections/ReflectionUtilsQueryTest.java#L216))*\n - `MemberUsageScanner` - experimental scanner allow querying for member usages `getMemberUsages()` of packages/types/elements in the classpath.\n Can be used for finding usages between packages, layers, modules, types etc.  \n \ndiff --git a/pom.xml b/pom.xml\nindex 795050c..98931d6 100644\n--- a/pom.xml\n+++ b/pom.xml\n@@ -152,7 +152,7 @@\n                     <plugin>\n                         <groupId>org.apache.maven.plugins</groupId>\n                         <artifactId>maven-javadoc-plugin</artifactId>\n-                        <version>3.1.1</version>\n+                        <version>3.3.1</version>\n                         <executions>\n                             <execution>\n                                 <id>attach-javadocs</id>\ndiff --git a/src/main/java/org/reflections/Configuration.java b/src/main/java/org/reflections/Configuration.java\nindex 1a0b4d3..37bf66f 100644\n--- a/src/main/java/org/reflections/Configuration.java\n+++ b/src/main/java/org/reflections/Configuration.java\n@@ -28,6 +28,6 @@ public interface Configuration {\n     ClassLoader[] getClassLoaders();\n \n     /** if true (default), expand super types after scanning, for super types that were not scanned.\n-     * <p>see {@link org.reflections.Reflections#expandSuperTypes(Map)}*/\n+     * <p>see {@link Reflections#expandSuperTypes(Map, Map)}*/\n     boolean shouldExpandSuperTypes();\n }\ndiff --git a/src/main/java/org/reflections/ReflectionUtils.java b/src/main/java/org/reflections/ReflectionUtils.java\nindex 418c639..64102d0 100644\n--- a/src/main/java/org/reflections/ReflectionUtils.java\n+++ b/src/main/java/org/reflections/ReflectionUtils.java\n@@ -1,5 +1,6 @@\n package org.reflections;\n \n+import org.reflections.util.ClasspathHelper;\n import org.reflections.util.QueryFunction;\n import org.reflections.util.ReflectionUtilsPredicates;\n import org.reflections.util.UtilQueryBuilder;\n@@ -10,8 +11,10 @@ import java.lang.reflect.Constructor;\n import java.lang.reflect.Field;\n import java.lang.reflect.Method;\n import java.lang.reflect.Proxy;\n+import java.net.URL;\n import java.util.Arrays;\n import java.util.Collections;\n+import java.util.HashSet;\n import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n@@ -137,7 +140,7 @@ public abstract class ReflectionUtils extends ReflectionUtilsPredicates {\n \n     /** query methods <pre>{@code get(Methods.of(type)) -> Set<Method>}</pre> */\n     public static final UtilQueryBuilder<Class<?>, Method> Methods =\n-        element -> ctx -> Arrays.stream(element.getMethods()).filter(notObjectMethod).collect(Collectors.toCollection(LinkedHashSet::new));\n+        element -> ctx -> Arrays.stream(element.getDeclaredMethods()).filter(notObjectMethod).collect(Collectors.toCollection(LinkedHashSet::new));\n \n     /** query constructors <pre>{@code get(Constructors.of(type)) -> Set<Constructor> }</pre> */\n     public static final UtilQueryBuilder<Class<?>, Constructor> Constructors =\n@@ -147,6 +150,10 @@ public abstract class ReflectionUtils extends ReflectionUtilsPredicates {\n     public static final UtilQueryBuilder<Class<?>, Field> Fields =\n         element -> ctx -> Arrays.stream(element.getDeclaredFields()).collect(Collectors.toCollection(LinkedHashSet::new));\n \n+    /** query url resources using {@link ClassLoader#getResources(java.lang.String)} <pre>{@code get(Resources.with(name)) -> Set<URL> }</pre> */\n+    public static final UtilQueryBuilder<String, URL> Resources =\n+        element -> ctx -> new HashSet<>(ClasspathHelper.forResource(element));\n+\n     public static <T extends AnnotatedElement> UtilQueryBuilder<AnnotatedElement, T> extendType() {\n         return element -> {\n             if (element instanceof Class && !((Class<?>) element).isAnnotation()) {\ndiff --git a/src/main/java/org/reflections/Reflections.java b/src/main/java/org/reflections/Reflections.java\nindex 71d39d0..6454497 100644\n--- a/src/main/java/org/reflections/Reflections.java\n+++ b/src/main/java/org/reflections/Reflections.java\n@@ -81,7 +81,7 @@ import static org.reflections.scanners.Scanners.*;\n  * }</pre>\n  *\n  * <p>All relevant URLs should be configured.\n- * <br>If required, Reflections will {@link #expandSuperTypes(Map)} in order to get the transitive closure metadata without scanning large 3rd party urls.\n+ * <br>If required, Reflections will {@link #expandSuperTypes(Map, Map)} in order to get the transitive closure metadata without scanning large 3rd party urls.\n  * <p>{@link Scanners} must be configured in order to be queried, otherwise an empty result is returned.\n  * <br>Default scanners are {@code SubTypes} and {@code TypesAnnotated}.\n  * For all standard scanners use {@code Scanners.values()}.\n@@ -125,7 +125,7 @@ public class Reflections implements NameHelper {\n         this.configuration = configuration;\n         Map<String, Map<String, Set<String>>> storeMap = scan();\n         if (configuration.shouldExpandSuperTypes()) {\n-            expandSuperTypes(storeMap.get(SubTypes.index()));\n+            expandSuperTypes(storeMap.get(SubTypes.index()), storeMap.get(TypesAnnotated.index()));\n         }\n         store = new Store(storeMap);\n     }\n@@ -309,7 +309,7 @@ public class Reflections implements NameHelper {\n \n     /**\n      * expand super types after scanning, for super types that were not scanned.\n-     * <br>this is helpful in finding the transitive closure without scanning all 3rd party dependencies.\n+     * <br>this is helpful for finding the transitive closure without scanning all 3rd party dependencies.\n      * <p></p>\n      * for example, for classes A,B,C where A supertype of B, B supertype of C (A -> B -> C):\n      * <ul>\n@@ -317,25 +317,36 @@ public class Reflections implements NameHelper {\n      *     <li>if expanding supertypes, B will be expanded with A (A->B in store) - then getSubTypes(A) will return C</li>\n      * </ul>\n      */\n-    public void expandSuperTypes(Map<String, Set<String>> map) {\n-        if (map == null || map.isEmpty()) return;\n-        Set<String> keys = new LinkedHashSet<>(map.keySet());\n-        keys.removeAll(map.values().stream().flatMap(Collection::stream).collect(Collectors.toSet()));\n+    public void expandSuperTypes(Map<String, Set<String>> subTypesStore, Map<String, Set<String>> typesAnnotatedStore) {\n+        if (subTypesStore == null || subTypesStore.isEmpty()) return;\n+        Set<String> keys = new LinkedHashSet<>(subTypesStore.keySet());\n+        keys.removeAll(subTypesStore.values().stream().flatMap(Collection::stream).collect(Collectors.toSet()));\n         keys.remove(\"java.lang.Object\");\n         for (String key : keys) {\n             Class<?> type = forClass(key, loaders());\n             if (type != null) {\n-                expandSupertypes(map, key, type);\n+                expandSupertypes(subTypesStore, typesAnnotatedStore, key, type);\n             }\n         }\n     }\n \n-    private void expandSupertypes(Map<String, Set<String>> map, String key, Class<?> type) {\n+    private void expandSupertypes(Map<String, Set<String>> subTypesStore,\n+              Map<String, Set<String>> typesAnnotatedStore, String key, Class<?> type) {\n+        Set<Annotation> typeAnnotations = ReflectionUtils.getAnnotations(type);\n+        if (typesAnnotatedStore != null && !typeAnnotations.isEmpty()) {\n+            String typeName = type.getName();\n+            for (Annotation typeAnnotation : typeAnnotations) {\n+                String annotationName = typeAnnotation.annotationType().getName();\n+                typesAnnotatedStore.computeIfAbsent(annotationName, s -> new HashSet<>()).add(typeName);\n+            }\n+        }\n         for (Class<?> supertype : ReflectionUtils.getSuperTypes(type)) {\n             String supertypeName = supertype.getName();\n-            if (!map.containsKey(supertypeName)) {\n-                map.computeIfAbsent(supertypeName, s -> new HashSet<>()).add(key);\n-                expandSupertypes(map, supertypeName, supertype);\n+            if (subTypesStore.containsKey(supertypeName)) {\n+                subTypesStore.get(supertypeName).add(key);\n+            } else {\n+                subTypesStore.computeIfAbsent(supertypeName, s -> new HashSet<>()).add(key);\n+                expandSupertypes(subTypesStore, typesAnnotatedStore, supertypeName, supertype);\n             }\n         }\n     }\ndiff --git a/src/main/java/org/reflections/scanners/AbstractScanner.java b/src/main/java/org/reflections/scanners/AbstractScanner.java\nindex f35b85a..53252c8 100644\n--- a/src/main/java/org/reflections/scanners/AbstractScanner.java\n+++ b/src/main/java/org/reflections/scanners/AbstractScanner.java\n@@ -6,14 +6,19 @@ import java.util.List;\n import java.util.Map;\n \n @Deprecated\n-public class AbstractScanner implements Scanner {\n+class AbstractScanner implements Scanner {\n \tprotected final Scanner scanner;\n \n-\tpublic AbstractScanner(Scanner scanner) {\n+\tAbstractScanner(Scanner scanner) {\n \t\tthis.scanner = scanner;\n \t}\n \n \t@Override\n+\tpublic String index() {\n+\t\treturn scanner.index();\n+\t}\n+\n+\t@Override\n \tpublic List<Map.Entry<String, String>> scan(final ClassFile cls) {\n \t\treturn scanner.scan(cls);\n \t}\ndiff --git a/src/main/java/org/reflections/scanners/FieldAnnotationsScanner.java b/src/main/java/org/reflections/scanners/FieldAnnotationsScanner.java\nindex 11c836a..2545db5 100644\n--- a/src/main/java/org/reflections/scanners/FieldAnnotationsScanner.java\n+++ b/src/main/java/org/reflections/scanners/FieldAnnotationsScanner.java\n@@ -1,11 +1,12 @@\n package org.reflections.scanners;\n \n /** scan field annotations.\n- * <i>{@code Deprecated}, use {@link Scanners#FieldsAnnotated} instead</i>\n- * */\n+ * <i>{@code Deprecated}, use {@link Scanners#FieldsAnnotated} instead</i> */\n @Deprecated\n public class FieldAnnotationsScanner extends AbstractScanner {\n \n+    /** <i>{@code Deprecated}, use {@link Scanners#FieldsAnnotated} instead</i> */\n+    @Deprecated\n     public FieldAnnotationsScanner() {\n         super(Scanners.FieldsAnnotated);\n     }\ndiff --git a/src/main/java/org/reflections/scanners/MethodAnnotationsScanner.java b/src/main/java/org/reflections/scanners/MethodAnnotationsScanner.java\nindex dddb932..7c15083 100644\n--- a/src/main/java/org/reflections/scanners/MethodAnnotationsScanner.java\n+++ b/src/main/java/org/reflections/scanners/MethodAnnotationsScanner.java\n@@ -1,11 +1,13 @@\n package org.reflections.scanners;\n \n /** scan method annotations.\n- * <i>{@code Deprecated}, use {@link Scanners#MethodsAnnotated} instead</i>\n- * */\n+ * <p></p><i>breaking change: does not include constructor annotations, use {@link Scanners#ConstructorsAnnotated} instead </i>\n+ * <p></p><i>{@code Deprecated}, use {@link Scanners#MethodsAnnotated} and {@link Scanners#ConstructorsAnnotated} instead</i> */\n @Deprecated\n public class MethodAnnotationsScanner extends AbstractScanner {\n \n+    /** <i>{@code Deprecated}, use {@link Scanners#MethodsAnnotated} and {@link Scanners#ConstructorsAnnotated} instead</i> */\n+    @Deprecated\n     public MethodAnnotationsScanner() {\n         super(Scanners.MethodsAnnotated);\n     }\ndiff --git a/src/main/java/org/reflections/scanners/MethodParameterScanner.java b/src/main/java/org/reflections/scanners/MethodParameterScanner.java\nindex b47579b..ae073f0 100644\n--- a/src/main/java/org/reflections/scanners/MethodParameterScanner.java\n+++ b/src/main/java/org/reflections/scanners/MethodParameterScanner.java\n@@ -1,11 +1,29 @@\n package org.reflections.scanners;\n \n-/** scan methods/constructors and indexes parameters, return type and parameter annotations.\n- * <i>{@code Deprecated}, use {@link Scanners#MethodsParameter} instead</i>\n+/** Not supported since 0.10, will be removed.\n+ * <p></p><i>{@code Deprecated}, use instead:\n+ * <ul>\n+ *  <li>{@link Scanners#MethodsParameter}</li>\n+ *  <li>{@link Scanners#MethodsSignature}</li>\n+ *  <li>{@link Scanners#MethodsReturn}</li>\n+ *  <li>{@link Scanners#ConstructorsParameter}</li>\n+ *  <li>{@link Scanners#ConstructorsSignature}</li>\n+ * </ul>\n  * */\n @Deprecated\n public class MethodParameterScanner extends AbstractScanner {\n \n+    /** Not supported since 0.10, will be removed.\n+     * <p></p><i>{@code Deprecated}, use instead:\n+     * <ul>\n+     *  <li>{@link Scanners#MethodsParameter}</li>\n+     *  <li>{@link Scanners#MethodsSignature}</li>\n+     *  <li>{@link Scanners#MethodsReturn}</li>\n+     *  <li>{@link Scanners#ConstructorsParameter}</li>\n+     *  <li>{@link Scanners#ConstructorsSignature}</li>\n+     * </ul>\n+     */\n+    @Deprecated\n     public MethodParameterScanner() {\n         super(Scanners.MethodsParameter);\n     }\ndiff --git a/src/main/java/org/reflections/scanners/ResourcesScanner.java b/src/main/java/org/reflections/scanners/ResourcesScanner.java\nindex 8e20c30..1c8eb46 100644\n--- a/src/main/java/org/reflections/scanners/ResourcesScanner.java\n+++ b/src/main/java/org/reflections/scanners/ResourcesScanner.java\n@@ -2,11 +2,12 @@ package org.reflections.scanners;\n \n /** collects all resources that are not classes in a collection\n  * <p>key: value - {web.xml: WEB-INF/web.xml}</p>\n- * <i>{@code Deprecated}, use {@link Scanners#Resources} instead</i>\n- * */\n+ * <i>{@code Deprecated}, use {@link Scanners#Resources} instead</i> */\n @Deprecated\n public class ResourcesScanner extends AbstractScanner {\n \n+    /** <i>{@code Deprecated}, use {@link Scanners#Resources} instead</i> */\n+    @Deprecated\n     public ResourcesScanner() {\n         super(Scanners.Resources);\n     }\ndiff --git a/src/main/java/org/reflections/scanners/Scanners.java b/src/main/java/org/reflections/scanners/Scanners.java\nindex 37b0eb9..8e2e02f 100644\n--- a/src/main/java/org/reflections/scanners/Scanners.java\n+++ b/src/main/java/org/reflections/scanners/Scanners.java\n@@ -115,7 +115,8 @@ public enum Scanners implements Scanner, QueryBuilder, NameHelper {\n \n         @Override\n         public QueryFunction<Store, String> with(String pattern) {\n-            return store -> store.get(index()).entrySet().stream().filter(entry -> entry.getKey().matches(pattern))\n+            return store -> store.getOrDefault(index(), Collections.emptyMap())\n+                .entrySet().stream().filter(entry -> entry.getKey().matches(pattern))\n                 .flatMap(entry -> entry.getValue().stream()).collect(Collectors.toCollection(LinkedHashSet::new));\n         }\n     },\ndiff --git a/src/main/java/org/reflections/scanners/SubTypesScanner.java b/src/main/java/org/reflections/scanners/SubTypesScanner.java\nindex 4dcb4c4..35b93cb 100644\n--- a/src/main/java/org/reflections/scanners/SubTypesScanner.java\n+++ b/src/main/java/org/reflections/scanners/SubTypesScanner.java\n@@ -6,17 +6,20 @@ import java.util.List;\n import java.util.Map;\n \n /** scan superclass and interfaces of a class, allowing a reverse lookup for subtypes.\n- * <i>{@code Deprecated}, use {@link Scanners#SubTypes} instead</i>\n- * */\n+ * <i>{@code Deprecated}, use {@link Scanners#SubTypes} instead</i> */\n @Deprecated\n public class SubTypesScanner extends AbstractScanner {\n \n-    /** create new SubTypesScanner. will exclude direct Object subtypes */\n+    /** create new SubTypesScanner. will exclude direct Object subtypes\n+     * <i>{@code Deprecated}, use {@link Scanners#SubTypes} instead</i> */\n+    @Deprecated\n     public SubTypesScanner() {\n         super(Scanners.SubTypes);\n     }\n \n-    /** create new SubTypesScanner. include direct {@link Object} subtypes in results.  */\n+    /** create new SubTypesScanner. include direct {@link Object} subtypes in results.\n+     * <i>{@code Deprecated}, use {@link Scanners#SubTypes} instead</i> */\n+    @Deprecated\n     public SubTypesScanner(boolean excludeObjectClass) {\n         super(excludeObjectClass ? Scanners.SubTypes : Scanners.SubTypes.filterResultsBy(s -> true));\n     }\ndiff --git a/src/main/java/org/reflections/scanners/TypeAnnotationsScanner.java b/src/main/java/org/reflections/scanners/TypeAnnotationsScanner.java\nindex 7777c87..37bc1ca 100644\n--- a/src/main/java/org/reflections/scanners/TypeAnnotationsScanner.java\n+++ b/src/main/java/org/reflections/scanners/TypeAnnotationsScanner.java\n@@ -1,11 +1,12 @@\n package org.reflections.scanners;\n \n /** scan class annotations, where @Retention(RetentionPolicy.RUNTIME).\n- * <i>{@code Deprecated}, use {@link Scanners#TypesAnnotated} instead</i>\n- **/\n+ * <i>{@code Deprecated}, use {@link Scanners#TypesAnnotated} instead</i> */\n @Deprecated\n public class TypeAnnotationsScanner extends AbstractScanner {\n \n+    /** <i>{@code Deprecated}, use {@link Scanners#TypesAnnotated} instead</i> */\n+    @Deprecated\n      public TypeAnnotationsScanner() {\n         super(Scanners.TypesAnnotated);\n     }\ndiff --git a/src/main/java/org/reflections/util/ConfigurationBuilder.java b/src/main/java/org/reflections/util/ConfigurationBuilder.java\nindex aff76c4..2b455a2 100644\n--- a/src/main/java/org/reflections/util/ConfigurationBuilder.java\n+++ b/src/main/java/org/reflections/util/ConfigurationBuilder.java\n@@ -199,8 +199,9 @@ public class ConfigurationBuilder implements Configuration {\n     }\n \n     /** if true, scan urls in parallel. */\n-    public void setParallel(boolean parallel) {\n+    public ConfigurationBuilder setParallel(boolean parallel) {\n         isParallel = parallel;\n+        return this;\n     }\n \n     @Override\n@@ -230,7 +231,7 @@ public class ConfigurationBuilder implements Configuration {\n     }\n \n     /** if set to true, Reflections will expand super types after scanning.\n-     * <p>see {@link org.reflections.Reflections#expandSuperTypes(Map)} */\n+     * <p>see {@link org.reflections.Reflections#expandSuperTypes(Map, Map)} */\n     public ConfigurationBuilder setExpandSuperTypes(boolean expandSuperTypes) {\n         this.expandSuperTypes = expandSuperTypes;\n         return this;\ndiff --git a/src/main/java/org/reflections/util/UtilQueryBuilder.java b/src/main/java/org/reflections/util/UtilQueryBuilder.java\nindex 91d974e..7befd73 100644\n--- a/src/main/java/org/reflections/util/UtilQueryBuilder.java\n+++ b/src/main/java/org/reflections/util/UtilQueryBuilder.java\n@@ -13,7 +13,7 @@ import java.util.stream.Collectors;\n  * <pre>{@code UtilQueryBuilder<Annotation> builder =\n  *   element -> store -> element.getDeclaredAnnotations()} </pre>\n  */\n-public interface UtilQueryBuilder<F, E> extends NameHelper {\n+public interface UtilQueryBuilder<F, E> {\n \t/** get direct values of given element */\n \tQueryFunction<Store, E> get(F element);\n \ndiff --git a/src/main/java/org/reflections/vfs/Vfs.java b/src/main/java/org/reflections/vfs/Vfs.java\nindex a64732a..a153ec1 100644\n--- a/src/main/java/org/reflections/vfs/Vfs.java\n+++ b/src/main/java/org/reflections/vfs/Vfs.java\n@@ -186,20 +186,24 @@ public abstract class Vfs {\n \n         return null;\n     }\n-    \n+\n     private static boolean hasJarFileInPath(URL url) {\n-\t\treturn url.toExternalForm().matches(\".*\\\\.jar(!.*|$)\");\n-\t}\n+        return url.toExternalForm().matches(\".*\\\\.jar(!.*|$)\");\n+    }\n+\n+    private static boolean hasInnerJarFileInPath(URL url) {\n+        return url.toExternalForm().matches(\".+\\\\.jar!/.+\");\n+    }\n \n     /** default url types used by {@link org.reflections.vfs.Vfs#fromURL(java.net.URL)}\n      * <p>\n      * <p>jarFile - creates a {@link org.reflections.vfs.ZipDir} over jar file\n-     * <p>jarUrl - creates a {@link org.reflections.vfs.ZipDir} over a jar url (contains \".jar!/\" in it's name), using Java's {@link JarURLConnection}\n+     * <p>jarUrl - creates a {@link org.reflections.vfs.ZipDir} over a jar url, using Java's {@link JarURLConnection}\n      * <p>directory - creates a {@link org.reflections.vfs.SystemDir} over a file system directory\n      * <p>jboss vfs - for protocols vfs, using jboss vfs (should be provided in classpath)\n      * <p>jboss vfsfile - creates a {@link UrlTypeVFS} for protocols vfszip and vfsfile.\n      * <p>bundle - for bundle protocol, using eclipse FileLocator (should be provided in classpath)\n-     * <p>jarInputStream - creates a {@link JarInputDir} over jar files, using Java's JarInputStream\n+     * <p>jarInputStream - creates a {@link JarInputDir} over jar files (contains \".jar!/\" in it's name), using Java's JarInputStream\n      * */\n     public enum DefaultUrlTypes implements UrlType {\n         jarFile {\n@@ -214,7 +218,7 @@ public abstract class Vfs {\n \n         jarUrl {\n             public boolean matches(URL url) {\n-                return \"jar\".equals(url.getProtocol()) || \"zip\".equals(url.getProtocol()) || \"wsjar\".equals(url.getProtocol());\n+                return (\"jar\".equals(url.getProtocol()) || \"zip\".equals(url.getProtocol()) || \"wsjar\".equals(url.getProtocol())) && !hasInnerJarFileInPath(url);\n             }\n \n             public Dir createDir(URL url) throws Exception {\n@@ -252,7 +256,7 @@ public abstract class Vfs {\n             }\n \n             public Vfs.Dir createDir(URL url) throws Exception {\n-\t\treturn JbossDir.createDir(url);\n+                return JbossDir.createDir(url);\n             }\n         },\n \ndiff --git a/src/test/java/org/reflections/JdkTests.java b/src/test/java/org/reflections/JdkTests.java\nnew file mode 100644\nindex 0000000..630c536\n--- /dev/null\n+++ b/src/test/java/org/reflections/JdkTests.java\n@@ -0,0 +1,258 @@\n+package org.reflections;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.reflections.scanners.Scanner;\n+import org.reflections.scanners.Scanners;\n+import org.reflections.util.ClasspathHelper;\n+import org.reflections.util.ConfigurationBuilder;\n+import org.reflections.util.UtilQueryBuilder;\n+import org.reflections.vfs.Vfs;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.reflections.ReflectionUtils.get;\n+\n+/**\n+ * test reflection symmetry between jrt scanned metadata (Scanners) and java reflection accessibility (ReflectionUtils functions).\n+ * <p>except for known differences per jdk version, these pairs should access similar metadata:\n+ * SubTypes/SuperTypes, TypesAnnotated/AnnotatedTypes, MethodsAnnotated/AnnotatedTypes, Resources etc...\n+ * <p></p>tested with AdoptOpenJDK\n+ */\n+@SuppressWarnings({\"ArraysAsListWithZeroOrOneArgument\"})\n+public class JdkTests {\n+\n+\tprivate static Reflections reflections;\n+\n+\t@BeforeAll\n+\tstatic void init() {\n+\t\tif (!Vfs.getDefaultUrlTypes().get(0).getClass().equals(JrtUrlType.class)) {\n+\t\t\tVfs.addDefaultURLTypes(new JrtUrlType());\n+\t\t}\n+\t\tURL urls = ClasspathHelper.forClass(Object.class);\n+\t\tmeasure(\"before\");\n+\n+\t\treflections = new Reflections(\n+\t\t\tnew ConfigurationBuilder()\n+\t\t\t\t.addUrls(urls)\n+\t\t\t\t.setScanners(Scanners.values()));\n+\n+\t\tmeasure(\"scan\");\n+\t}\n+\n+\t@AfterAll\n+\tstatic void cleanup() {\n+\t\tif (Vfs.getDefaultUrlTypes().get(0).getClass().equals(JrtUrlType.class)) {\n+\t\t\tVfs.getDefaultUrlTypes().remove(0);\n+\t\t}\n+\t\treflections.getStore().clear();\n+\t\tmeasure(\"cleanup\");\n+\t}\n+\n+\t@Test\n+\tpublic void checkSubTypes() {\n+\t\tMap<String, Set<String>> diff = reflect(\n+\t\t\tScanners.SubTypes,\n+\t\t\tReflectionUtils.SuperTypes,\n+\t\t\tClass.class);\n+\n+\t\tassertEquals(diff, Collections.emptyMap());\n+\t}\n+\n+\t@Test\n+\tpublic void checkTypesAnnotated() {\n+\t\tMap<String, Set<String>> diff = reflect(\n+\t\t\tScanners.TypesAnnotated,\n+\t\t\tReflectionUtils.AnnotationTypes,\n+\t\t\tClass.class);\n+\n+\t\tArrays.asList(\"jdk.internal.PreviewFeature\", // jdk 15\n+\t\t\t\t\"jdk.internal.javac.PreviewFeature\") // jdk 17\n+\t\t\t.forEach(diff::remove);\n+\t\tassertEquals(diff, Collections.emptyMap());\n+\t}\n+\n+\t@Test\n+\tpublic void checkMethodsAnnotated() {\n+\t\tMap<String, Set<String>> diff = reflect(\n+\t\t\tScanners.MethodsAnnotated,\n+\t\t\tReflectionUtils.AnnotationTypes,\n+\t\t\tMethod.class);\n+\n+\t\t// todo fix differences @A2 such as - @A1 public @A2 result method(...)\n+\t\tArrays.asList(\"com.sun.istack.internal.NotNull\", // jdk 8\n+\t\t\t\t\"com.sun.istack.internal.Nullable\",\n+\t\t\t\t\"sun.reflect.CallerSensitive\",\n+\t\t\t\t\"java.lang.invoke.LambdaForm$Hidden\",\n+\t\t\t\t\"jdk.internal.reflect.CallerSensitive\",  // jdk 11, 13, 15\n+\t\t\t\t\"jdk.internal.PreviewFeature\")           // jdk 15\n+\t\t\t.forEach(diff::remove);\n+\t\tassertEquals(diff, Collections.emptyMap());\n+\t}\n+\n+\t@Test\n+\tpublic void checkConstructorsAnnotated() {\n+\t\tMap<String, Set<String>> diff = reflect(\n+\t\t\tScanners.ConstructorsAnnotated,\n+\t\t\tReflectionUtils.AnnotationTypes,\n+\t\t\tConstructor.class);\n+\n+\t\tassertEquals(diff, Collections.emptyMap());\n+\t}\n+\n+\t@Test\n+\tpublic void checkFieldsAnnotated() {\n+\t\tMap<String, Set<String>> diff = reflect(\n+\t\t\tScanners.FieldsAnnotated,\n+\t\t\tReflectionUtils.AnnotationTypes,\n+\t\t\tField.class);\n+\n+\t\tArrays.asList(\"com.sun.istack.internal.NotNull\", // jdk 8\n+\t\t\t\t\"com.sun.istack.internal.Nullable\",\n+\t\t\t\t\"jdk.internal.PreviewFeature\",           // jdk 15\n+\t\t\t\t\"jdk.internal.vm.annotation.Stable\")     // jdk 17\n+\t\t\t.forEach(diff::remove);\n+\t\tassertEquals(diff, Collections.emptyMap());\n+\t}\n+\n+\t@Test\n+\tpublic void checkResources() {\n+\t\tSet<String> diff = new HashSet<>();\n+\t\tMap<String, Set<String>> mmap = reflections.getStore().get(Scanners.Resources.index());\n+\t\tmmap.values().forEach(resources ->\n+\t\t\tresources.forEach(resource -> {\n+\t\t\t\tSet<URL> urls = get(ReflectionUtils.Resources.get(resource));\n+//\t\t\t\tif (urls == null || urls.isEmpty()) diff.add(resource);\n+\t\t\t\tfor (URL url : urls) {\n+\t\t\t\t\ttry { if (!Files.exists(JrtUrlType.getJrtRealPath(url))) diff.add(resource); }\n+\t\t\t\t\tcatch (Exception e) { diff.add(resource); }\n+\t\t\t\t}\n+\t\t\t}));\n+\t\tSystem.out.println(Scanners.Resources.index() + \": \" + mmap.values().stream().mapToInt(Set::size).sum() + \", missing: \" + diff.size());\n+\n+\t\tArrays.asList(\"META-INF/MANIFEST.MF\") // jdk 8\n+\t\t\t.forEach(diff::remove);\n+\t\tassertEquals(diff, Collections.emptySet());\n+\t}\n+\n+\t@Test\n+\tpublic void checkMethodsSignature() {\n+//        Map<String, Set<String>> diffMethodSignature =\n+//            findDiff(reflections, Scanners.MethodsSignature, ReflectionUtils.MethodSignature, Field.class);\n+//        assertEquals(diffMethodSignature, Collections.emptyMap());    }\n+\t}\n+\n+\tprivate <F extends AnnotatedElement, E extends AnnotatedElement> Map<String, Set<String>> reflect(\n+\t\tScanner scanner, UtilQueryBuilder<F, E> utilQueryBuilder, Class<? extends AnnotatedElement> resultType) {\n+\t\tMap<String, Set<String>> mmap = reflections.getStore().get(scanner.index());\n+\t\tMap<String, Set<String>> missing = new HashMap<>();\n+\t\tmmap.forEach((key, strings) ->\n+\t\t\tstrings.forEach(string -> {\n+\t\t\t\t//noinspection unchecked\n+\t\t\t\tF element = (F) reflections.forName(string, resultType);\n+\t\t\t\tif (element == null || !reflections.toNames(get(utilQueryBuilder.get(element))).contains(key)) {\n+\t\t\t\t\tmissing.computeIfAbsent(key, k -> new HashSet<>()).add(string);\n+\t\t\t\t}\n+\t\t\t}));\n+\t\tSystem.out.println(scanner.index() + \": \" + mmap.values().stream().mapToInt(Set::size).sum() + \", missing: \" + missing.values().stream().mapToInt(Set::size).sum());\n+\t\treturn missing;\n+\t}\n+\n+\tprivate static void measure(String s) {\n+\t\tSystem.out.printf(\"-> %s %s \", s, mb(mem()));\n+\t\tgc();\n+\t\tSystem.out.printf(\"(gc -> %s)%n\", mb(mem()));\n+\t}\n+\n+\tprivate static void gc() {\n+\t\tfor (int i = 0; i < 3; i++) {\n+\t\t\tRuntime.getRuntime().gc();\n+\t\t\tSystem.runFinalization();\n+\t\t\ttry {\n+\t\t\t\tThread.sleep(100);\n+\t\t\t} catch (InterruptedException e) { /*java sucks*/ }\n+\t\t}\n+\t}\n+\n+\tprivate static long mem() {\n+\t\treturn Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();\n+\t}\n+\n+\tprivate static String mb(long mem2) {\n+\t\treturn (mem2 / 1024 / 1024) + \"mb\";\n+\t}\n+\n+\tpublic static class JrtUrlType implements Vfs.UrlType {\n+\t\t@Override\n+\t\tpublic boolean matches(URL url) throws Exception {\n+\t\t\treturn url.getProtocol().equals(\"jrt\");\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Vfs.Dir createDir(URL url) throws Exception {\n+\t\t\tfinal Path realPath = getJrtRealPath(url);\n+\t\t\treturn new Vfs.Dir() {\n+\t\t\t\t@Override\n+\t\t\t\tpublic String getPath() {\n+\t\t\t\t\treturn url.getPath();\n+\t\t\t\t}\n+\n+\t\t\t\t@Override\n+\t\t\t\tpublic Iterable<Vfs.File> getFiles() {\n+\t\t\t\t\treturn () -> {\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\treturn Files.walk(realPath)\n+\t\t\t\t\t\t\t\t.filter(Files::isRegularFile)\n+\t\t\t\t\t\t\t\t.map(p -> (Vfs.File) new Vfs.File() {\n+\t\t\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\t\t\tpublic String getName() {\n+\t\t\t\t\t\t\t\t\t\treturn p.toString();\n+\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\t\t\tpublic String getRelativePath() {\n+\t\t\t\t\t\t\t\t\t\treturn p.startsWith(realPath) ? p.toString().substring(realPath.toString().length()) : p.toString();\n+\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\t\t\tpublic InputStream openInputStream() throws IOException {\n+\t\t\t\t\t\t\t\t\t\treturn Files.newInputStream(p);\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t})\n+\t\t\t\t\t\t\t\t.iterator();\n+\t\t\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\t\t\tthrow new ReflectionsException(e);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t};\n+\t\t\t\t}\n+\t\t\t};\n+\t\t}\n+\n+\t\t/**\n+\t\t * jdk 11 workaround for {@code Paths.get().toRealPath()}\n+\t\t */\n+\t\tpublic static Path getJrtRealPath(URL url) throws IOException {\n+\t\t\t// jdk 11 workaround\n+\t\t\treturn FileSystems.getFileSystem(URI.create(\"jrt:/\")).getPath(\"modules\", url.getPath())\n+\t\t\t\t.toRealPath();\n+\t\t}\n+\t}\n+}\ndiff --git a/src/test/resources/jarWithBootLibJar.jar b/src/test/resources/jarWithBootLibJar.jar\nnew file mode 100644\nindex 0000000..456c6da\nBinary files /dev/null and b/src/test/resources/jarWithBootLibJar.jar differ\n", "test_patch": "diff --git a/src/test/java/org/reflections/MoreTests.java b/src/test/java/org/reflections/MoreTests.java\nindex 16dbbf7..733fcd4 100644\n--- a/src/test/java/org/reflections/MoreTests.java\n+++ b/src/test/java/org/reflections/MoreTests.java\n@@ -21,7 +21,8 @@ import static org.reflections.MoreTestsModel.*;\n import static org.reflections.ReflectionUtils.Annotations;\n import static org.reflections.ReflectionUtils.SuperTypes;\n import static org.reflections.ReflectionUtilsTest.toStringSorted;\n-import static org.reflections.ReflectionsTest.are;\n+import static org.reflections.ReflectionsTest.equalTo;\n+import static org.reflections.scanners.Scanners.Resources;\n import static org.reflections.scanners.Scanners.SubTypes;\n \n public class MoreTests {\n@@ -30,7 +31,7 @@ public class MoreTests {\n     public void test_cyclic_annotation() {\n         Reflections reflections = new Reflections(MoreTestsModel.class);\n         assertThat(reflections.getTypesAnnotatedWith(CyclicAnnotation.class),\n-                are(CyclicAnnotation.class));\n+                equalTo(CyclicAnnotation.class));\n     }\n \n     @Test\n@@ -38,11 +39,12 @@ public class MoreTests {\n         Reflections reflections = new Reflections(\n             new ConfigurationBuilder()\n                 .setUrls(ClasspathHelper.forClass(TestModel.class))\n-                .setScanners(Scanners.Resources));\n+                .setScanners());\n \n         assertNull(reflections.getStore().get(SubTypes.index()));\n         assertTrue(reflections.getSubTypesOf(TestModel.C1.class).isEmpty());\n         assertTrue(reflections.get(SubTypes.of(TestModel.C1.class)).isEmpty());\n+        assertTrue(reflections.get(Resources.with(\".*\")).isEmpty());\n     }\n \n     @Test\ndiff --git a/src/test/java/org/reflections/ReflectionUtilsQueryTest.java b/src/test/java/org/reflections/ReflectionUtilsQueryTest.java\nindex 7c8708d..0a9ef35 100644\n--- a/src/test/java/org/reflections/ReflectionUtilsQueryTest.java\n+++ b/src/test/java/org/reflections/ReflectionUtilsQueryTest.java\n@@ -185,8 +185,7 @@ public class ReflectionUtilsQueryTest {\n \t\t\tequalTo(\n \t\t\t\tCombinedTestModel.Post.class.getDeclaredMethod(\"value\"),\n \t\t\t\tCombinedTestModel.Requests.class.getDeclaredMethod(\"value\"),\n-\t\t\t\tCombinedTestModel.Get.class.getDeclaredMethod(\"value\"),\n-\t\t\t\tAnnotation.class.getDeclaredMethod(\"annotationType\")));\n+\t\t\t\tCombinedTestModel.Get.class.getDeclaredMethod(\"value\")));\n \n \t\tassertEquals(query, query1);\n \t}\n@@ -203,11 +202,11 @@ public class ReflectionUtilsQueryTest {\n \t\tSet<String> collect = valueMaps.stream().map(Object::toString).sorted().collect(Collectors.toCollection(LinkedHashSet::new));\n \t\tassertThat(collect,\n \t\t\tequalTo(\n-\t\t\t\t\"{annotationType=interface org.reflections.CombinedTestModel$Get, value=/get}\",\n-\t\t\t\t\"{annotationType=interface org.reflections.CombinedTestModel$Post, value=/post}\",\n-\t\t\t\t\"{annotationType=interface org.reflections.CombinedTestModel$Requests, value=[\" +\n-\t\t\t\t\t\"{method=PUT, annotationType=interface org.reflections.CombinedTestModel$Request, value=/another}, \" +\n-\t\t\t\t\t\"{method=PATCH, annotationType=interface org.reflections.CombinedTestModel$Request, value=/another}]}\"\n+\t\t\t\t\"{value=/get}\",\n+\t\t\t\t\"{value=/post}\",\n+\t\t\t\t\"{value=[\" +\n+\t\t\t\t\t\"{method=PUT, value=/another}, \" +\n+\t\t\t\t\t\"{method=PATCH, value=/another}]}\"\n \t\t\t));\n \t}\n \ndiff --git a/src/test/java/org/reflections/ReflectionUtilsTest.java b/src/test/java/org/reflections/ReflectionUtilsTest.java\nindex ab964dd..1470a2d 100644\n--- a/src/test/java/org/reflections/ReflectionUtilsTest.java\n+++ b/src/test/java/org/reflections/ReflectionUtilsTest.java\n@@ -18,14 +18,12 @@ import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.HashSet;\n-import java.util.List;\n import java.util.Set;\n import java.util.stream.Collectors;\n \n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.junit.jupiter.api.Assertions.*;\n import static org.reflections.ReflectionUtils.*;\n-import static org.reflections.ReflectionsTest.are;\n import static org.reflections.ReflectionsTest.equalTo;\n \n @SuppressWarnings(\"unchecked\")\n@@ -33,7 +31,8 @@ public class ReflectionUtilsTest {\n \n     @Test\n     public void getAllTest() {\n-        assertThat(getAllSuperTypes(TestModel.C3.class, withAnnotation(TestModel.AI1.class)), are(TestModel.I1.class));\n+        assertThat(getAllSuperTypes(TestModel.C3.class, withAnnotation(TestModel.AI1.class)),\n+            equalTo(TestModel.I1.class));\n \n         Set<Method> allMethods = getAllMethods(TestModel.C4.class, withModifier(Modifier.PUBLIC), withReturnType(void.class));\n         Set<Method> allMethods1 = getAllMethods(TestModel.C4.class, withPattern(\"public.*.void .*\"));\ndiff --git a/src/test/java/org/reflections/ReflectionsExpandSupertypesTest.java b/src/test/java/org/reflections/ReflectionsExpandSupertypesTest.java\nindex 3123ac6..a59d275 100644\n--- a/src/test/java/org/reflections/ReflectionsExpandSupertypesTest.java\n+++ b/src/test/java/org/reflections/ReflectionsExpandSupertypesTest.java\n@@ -1,51 +1,97 @@\n package org.reflections;\n \n import org.junit.jupiter.api.Test;\n-import org.reflections.util.ClasspathHelper;\n import org.reflections.util.ConfigurationBuilder;\n import org.reflections.util.FilterBuilder;\n \n-import java.util.Collection;\n+import java.lang.annotation.Inherited;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n \n-import static org.junit.jupiter.api.Assertions.assertFalse;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.reflections.ReflectionsExpandSupertypesTest.ExpandTestModel.NotScanned;\n+import static org.reflections.ReflectionsExpandSupertypesTest.ExpandTestModel.Scanned;\n+import static org.reflections.ReflectionsQueryTest.equalTo;\n+import static org.reflections.scanners.Scanners.SubTypes;\n \n public class ReflectionsExpandSupertypesTest {\n \n     private final FilterBuilder inputsFilter = new FilterBuilder()\n-        .includePattern(\"org\\\\.reflections\\\\.ReflectionsExpandSupertypesTest\\\\$TestModel\\\\$ScannedScope\\\\$.*\");\n+        .includePattern(\"org\\\\.reflections\\\\.ReflectionsExpandSupertypesTest\\\\$ExpandTestModel\\\\$Scanned\\\\$.*\");\n \n     @SuppressWarnings(\"unused\")\n-    public interface TestModel {\n-        interface A { } // outside of scanned scope\n-        interface B extends A { } // outside of scanned scope, but immediate supertype\n+    public interface ExpandTestModel {\n+        interface NotScanned {\n+            @Retention(RetentionPolicy.RUNTIME)\n+            @interface MetaAnnotation { } // outside of scanned scope\n \n-        interface ScannedScope {\n-            interface C extends B { }\n-            interface D extends B { }\n+            @Retention(RetentionPolicy.RUNTIME)\n+            @Inherited\n+            @MetaAnnotation\n+            @interface TestAnnotation { } // outside of scanned scope, but immediate annotation\n+\n+            interface BaseInterface { } // outside of scanned scope\n+\n+            @TestAnnotation\n+            class BaseClass implements BaseInterface { } // outside of scanned scope, but immediate supertype\n+        }\n+\n+        interface Scanned {\n+            class ChildrenClass extends NotScanned.BaseClass { }\n         }\n     }\n \n     @Test\n     public void testExpandSupertypes() {\n-        Reflections refExpand = new Reflections(new ConfigurationBuilder().\n-                setUrls(ClasspathHelper.forClass(TestModel.ScannedScope.C.class)).\n-                filterInputsBy(inputsFilter));\n-        assertTrue(refExpand.getConfiguration().shouldExpandSuperTypes());\n-        Collection<Class<? extends TestModel.A>> subTypesOf = refExpand.getSubTypesOf(TestModel.A.class);\n-        assertTrue(subTypesOf.contains(TestModel.B.class), \"expanded\");\n-        assertTrue(subTypesOf.containsAll(refExpand.getSubTypesOf(TestModel.B.class)), \"transitivity\");\n+        ConfigurationBuilder configuration = new ConfigurationBuilder()\n+            .forPackage(\"org.reflections\")\n+            .filterInputsBy(inputsFilter);\n+\n+        Reflections reflections = new Reflections(configuration);\n+        assertThat(reflections.get(SubTypes.of(NotScanned.BaseInterface.class).asClass()),\n+            equalTo(\n+                NotScanned.BaseClass.class,\n+                Scanned.ChildrenClass.class));\n+\n+        Reflections refNoExpand = new Reflections(configuration.setExpandSuperTypes(false));\n+        assertThat(refNoExpand.get(SubTypes.of(NotScanned.BaseInterface.class).asClass()),\n+            equalTo());\n     }\n \n     @Test\n-    public void testNotExpandSupertypes() {\n-        Reflections refDontExpand = new Reflections(\n-            new ConfigurationBuilder()\n-                .forPackage(\"org.reflections\")\n-                .filterInputsBy(inputsFilter).\n-                setExpandSuperTypes(false));\n-        assertFalse(refDontExpand.getConfiguration().shouldExpandSuperTypes());\n-        Collection<Class<? extends TestModel.A>> subTypesOf1 = refDontExpand.getSubTypesOf(TestModel.A.class);\n-        assertFalse(subTypesOf1.contains(TestModel.B.class));\n+    void testDetectInheritedAnnotations() {\n+        ConfigurationBuilder configuration = new ConfigurationBuilder()\n+            .forPackage(\"org.reflections\")\n+            .filterInputsBy(inputsFilter);\n+\n+        Reflections reflections = new Reflections(configuration);\n+        assertThat(reflections.getTypesAnnotatedWith(NotScanned.TestAnnotation.class),\n+            equalTo(\n+                NotScanned.BaseClass.class,\n+                Scanned.ChildrenClass.class));\n+\n+        Reflections refNoExpand = new Reflections(configuration.setExpandSuperTypes(false));\n+        assertThat(refNoExpand.getTypesAnnotatedWith(NotScanned.TestAnnotation.class),\n+            equalTo());\n+    }\n+\n+    @Test\n+    void testExpandMetaAnnotations() {\n+        ConfigurationBuilder configuration = new ConfigurationBuilder()\n+            .forPackage(\"org.reflections\")\n+            .filterInputsBy(inputsFilter);\n+\n+        Reflections reflections = new Reflections(configuration);\n+        assertThat(reflections.getTypesAnnotatedWith(NotScanned.MetaAnnotation.class),\n+            equalTo());\n+//         todo fix, support expansion of meta annotations outside of scanned scope\n+//            equalTo(\n+//                NotScanned.TestAnnotation.class,\n+//                NotScanned.BaseClass.class,\n+//                Scanned.ChildrenClass.class));\n+\n+        Reflections refNoExpand = new Reflections(configuration.setExpandSuperTypes(false));\n+        assertThat(refNoExpand.getTypesAnnotatedWith(NotScanned.MetaAnnotation.class),\n+            equalTo());\n     }\n }\ndiff --git a/src/test/java/org/reflections/ReflectionsTest.java b/src/test/java/org/reflections/ReflectionsTest.java\nindex f497cd4..dbfb3db 100644\n--- a/src/test/java/org/reflections/ReflectionsTest.java\n+++ b/src/test/java/org/reflections/ReflectionsTest.java\n@@ -6,9 +6,14 @@ import org.hamcrest.Matcher;\n import org.hamcrest.core.IsEqual;\n import org.junit.jupiter.api.BeforeAll;\n import org.junit.jupiter.api.Test;\n+import org.reflections.scanners.FieldAnnotationsScanner;\n import org.reflections.scanners.MemberUsageScanner;\n+import org.reflections.scanners.MethodAnnotationsScanner;\n import org.reflections.scanners.MethodParameterNamesScanner;\n+import org.reflections.scanners.ResourcesScanner;\n import org.reflections.scanners.Scanners;\n+import org.reflections.scanners.SubTypesScanner;\n+import org.reflections.scanners.TypeAnnotationsScanner;\n import org.reflections.util.ClasspathHelper;\n import org.reflections.util.ConfigurationBuilder;\n import org.reflections.util.FilterBuilder;\n@@ -16,16 +21,15 @@ import org.reflections.util.NameHelper;\n \n import java.io.File;\n import java.lang.annotation.Annotation;\n-import java.lang.reflect.AnnotatedElement;\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.HashSet;\n import java.util.List;\n-import java.util.Objects;\n import java.util.function.Predicate;\n import java.util.regex.Pattern;\n import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.junit.jupiter.api.Assertions.*;\n@@ -41,13 +45,24 @@ public class ReflectionsTest implements NameHelper {\n \n     @BeforeAll\n     public static void init() {\n+        //noinspection deprecation\n         reflections = new Reflections(new ConfigurationBuilder()\n                 .setUrls(Collections.singletonList(ClasspathHelper.forClass(TestModel.class)))\n                 .filterInputsBy(TestModelFilter)\n                 .setScanners(\n+                    new SubTypesScanner(),\n+                    new TypeAnnotationsScanner(),\n+                    new MethodAnnotationsScanner(),\n+                    new FieldAnnotationsScanner(),\n+                    Scanners.ConstructorsAnnotated,\n+                    Scanners.MethodsParameter,\n+                    Scanners.MethodsSignature,\n+                    Scanners.MethodsReturn,\n+                    Scanners.ConstructorsParameter,\n+                    Scanners.ConstructorsSignature,\n+                    new ResourcesScanner(),\n                     new MethodParameterNamesScanner(),\n-                    new MemberUsageScanner())\n-                .addScanners(Scanners.values()));\n+                    new MemberUsageScanner()));\n     }\n \n     @Test\n@@ -234,8 +249,26 @@ public class ReflectionsTest implements NameHelper {\n     }\n \n     @Test\n-    public void testScannerNotConfigured() {\n-        assertTrue(new Reflections(TestModel.class, TestModelFilter).getMethodsAnnotatedWith(AC1.class).isEmpty());\n+    public void testScannerNotConfigured() throws NoSuchMethodException {\n+        Reflections reflections = new Reflections(new ConfigurationBuilder()\n+            .setUrls(Collections.singletonList(ClasspathHelper.forClass(TestModel.class)))\n+            .filterInputsBy(TestModelFilter.includePackage(\"org\\\\.reflections\\\\.UsageTestModel\\\\$.*\"))\n+            .setScanners());\n+\n+        assertTrue(reflections.getSubTypesOf(C1.class).isEmpty());\n+        assertTrue(reflections.getTypesAnnotatedWith(AC1.class).isEmpty());\n+        assertTrue(reflections.getMethodsAnnotatedWith(AC1.class).isEmpty());\n+        assertTrue(reflections.getMethodsWithSignature().isEmpty());\n+        assertTrue(reflections.getMethodsWithParameter(String.class).isEmpty());\n+        assertTrue(reflections.getMethodsReturn(String.class).isEmpty());\n+        assertTrue(reflections.getConstructorsAnnotatedWith(AM1.class).isEmpty());\n+        assertTrue(reflections.getConstructorsWithSignature().isEmpty());\n+        assertTrue(reflections.getConstructorsWithParameter(String.class).isEmpty());\n+        assertTrue(reflections.getFieldsAnnotatedWith(AF1.class).isEmpty());\n+        assertTrue(reflections.getResources(\".*\").isEmpty());\n+        assertTrue(reflections.getMemberParameterNames(C4.class.getDeclaredMethod(\"m4\", String.class)).isEmpty());\n+        assertTrue(reflections.getMemberUsage(UsageTestModel.C1.class.getDeclaredConstructor()).isEmpty());\n+        assertTrue(reflections.getAllTypes().isEmpty());\n     }\n \n     //\n@@ -282,23 +315,15 @@ public class ReflectionsTest implements NameHelper {\n         return IsEqual.equalTo(new HashSet<>(Arrays.asList(operand)));\n     }\n \n-    @SafeVarargs\n-    public final <T extends AnnotatedElement> Matcher<Collection<String>> equalToNames(T... operand) {\n-        return IsEqual.equalTo(new HashSet<>(toNames(operand)));\n-    }\n-\n     private Matcher<Collection<Class<?>>> annotatedWith(final Class<? extends Annotation> annotation) {\n         return new Match<Collection<Class<?>>>() {\n             public boolean matches(Object o) {\n                 for (Class<?> c : (Iterable<Class<?>>) o) {\n-                    if (!annotationTypes(Arrays.asList(c.getAnnotations())).contains(annotation)) return false;\n+                    List<Class<? extends Annotation>> annotationTypes = Stream.of(c.getAnnotations()).map(Annotation::annotationType).collect(Collectors.toList());\n+                    if (!annotationTypes.contains(annotation)) return false;\n                 }\n                 return true;\n             }\n         };\n     }\n-\n-    private List<Class<? extends Annotation>> annotationTypes(Collection<Annotation> annotations) {\n-        return annotations.stream().filter(Objects::nonNull).map(Annotation::annotationType).collect(Collectors.toList());\n-    }\n }\ndiff --git a/src/test/java/org/reflections/VfsTest.java b/src/test/java/org/reflections/VfsTest.java\nindex 817ac82..82c026a 100644\n--- a/src/test/java/org/reflections/VfsTest.java\n+++ b/src/test/java/org/reflections/VfsTest.java\n@@ -1,17 +1,22 @@\n package org.reflections;\n \n+import javassist.bytecode.ClassFile;\n import org.junit.jupiter.api.Test;\n import org.reflections.util.ClasspathHelper;\n import org.reflections.vfs.SystemDir;\n import org.reflections.vfs.Vfs;\n import org.slf4j.Logger;\n \n+import java.io.BufferedInputStream;\n+import java.io.DataInputStream;\n import java.io.File;\n import java.net.MalformedURLException;\n import java.net.URL;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n \n import static java.text.MessageFormat.format;\n import static org.junit.jupiter.api.Assertions.*;\n@@ -114,6 +119,35 @@ public class VfsTest {\n         }\n     }\n \n+    @Test\n+    public void vfsFromDirWithJarInJar() throws Exception {\n+        URL resource = ClasspathHelper.contextClassLoader().getResource(\"jarWithBootLibJar.jar\");\n+        URL innerJarUrl = new URL(\"jar:\" + resource.toExternalForm() + \"!/BOOT-INF/lib/jarWithManifest.jar\");\n+\n+        assertFalse(Vfs.DefaultUrlTypes.jarUrl.matches(innerJarUrl));\n+        Vfs.Dir jarUrlDir = Vfs.DefaultUrlTypes.jarUrl.createDir(innerJarUrl);\n+        assertNotEquals(innerJarUrl.getPath(), jarUrlDir.getPath());\n+\n+        assertTrue(Vfs.DefaultUrlTypes.jarInputStream.matches(innerJarUrl));\n+        Vfs.Dir jarInputStreamDir = Vfs.DefaultUrlTypes.jarInputStream.createDir(innerJarUrl);\n+        assertEquals(innerJarUrl.getPath(), jarInputStreamDir.getPath());\n+\n+        List<Vfs.File> files = StreamSupport.stream(jarInputStreamDir.getFiles().spliterator(), false).collect(Collectors.toList());\n+        assertEquals(1, files.size());\n+        Vfs.File file1 = files.get(0);\n+        assertEquals(\"empty.class\", file1.getName());\n+        assertEquals(\"pack/empty.class\", file1.getRelativePath());\n+\n+        for (Vfs.File file : jarInputStreamDir.getFiles()) {\n+            try (DataInputStream dis = new DataInputStream(new BufferedInputStream(file.openInputStream()))) {\n+                ClassFile classFile = new ClassFile(dis);\n+                assertEquals(\"org.reflections.empty\", classFile.getName());\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n     private void testVfsDir(Vfs.Dir dir) {\n         List<Vfs.File> files = new ArrayList<>();\n         for (Vfs.File file : dir.getFiles()) {\n"}
{"repository": "ronmamo/reflections", "clone_url": "https://github.com/ronmamo/reflections.git", "timestamp": "2023-05-31T19:14:48.486152Z", "commit_hash": "bbc3b722cb15185aae9d9e43d9be5d00a5709328", "commit_message": "Merge pull request #124 from jameskennedy/master\n\nTry 2: Fix url discovery to allow \".jar\" substrings in directory paths", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/reflections/vfs/Vfs.java b/src/main/java/org/reflections/vfs/Vfs.java\nindex f2050c7..a83e495 100644\n--- a/src/main/java/org/reflections/vfs/Vfs.java\n+++ b/src/main/java/org/reflections/vfs/Vfs.java\n@@ -190,6 +190,10 @@ public abstract class Vfs {\n \n         return null;\n     }\n+    \n+    private static boolean hasJarFileInPath(URL url) {\n+\t\treturn url.toExternalForm().matches(\".*\\\\.jar(\\\\!.*|$)\");\n+\t}\n \n     /** default url types used by {@link org.reflections.vfs.Vfs#fromURL(java.net.URL)}\n      * <p>\n@@ -204,7 +208,7 @@ public abstract class Vfs {\n     public static enum DefaultUrlTypes implements UrlType {\n         jarFile {\n             public boolean matches(URL url) {\n-                return url.getProtocol().equals(\"file\") && url.toExternalForm().contains(\".jar\");\n+                return url.getProtocol().equals(\"file\") && hasJarFileInPath(url);\n             }\n \n             public Dir createDir(final URL url) throws Exception {\n@@ -234,7 +238,7 @@ public abstract class Vfs {\n \n         directory {\n             public boolean matches(URL url) {\n-                return url.getProtocol().equals(\"file\") && !url.toExternalForm().contains(\".jar\") &&\n+                return url.getProtocol().equals(\"file\") && !hasJarFileInPath(url) &&\n                         getFile(url).isDirectory();\n             }\n \n", "test_patch": "diff --git a/src/test/java/org/reflections/VfsTest.java b/src/test/java/org/reflections/VfsTest.java\nindex 44b5d18..defdc8b 100644\n--- a/src/test/java/org/reflections/VfsTest.java\n+++ b/src/test/java/org/reflections/VfsTest.java\n@@ -1,15 +1,10 @@\n package org.reflections;\n \n-import com.google.common.base.Predicates;\n-import com.google.common.collect.Iterables;\n-import javassist.bytecode.ClassFile;\n-import org.junit.Ignore;\n-import org.junit.Test;\n-import org.reflections.adapters.JavassistAdapter;\n-import org.reflections.util.ClasspathHelper;\n-import org.reflections.vfs.JarInputDir;\n-import org.reflections.vfs.Vfs;\n-import org.reflections.vfs.ZipDir;\n+import static java.text.MessageFormat.format;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n \n import java.io.DataInputStream;\n import java.io.File;\n@@ -21,7 +16,19 @@ import java.net.URL;\n import java.util.Collection;\n import java.util.jar.JarFile;\n \n-import static org.junit.Assert.*;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.reflections.adapters.JavassistAdapter;\n+import org.reflections.util.ClasspathHelper;\n+import org.reflections.vfs.JarInputDir;\n+import org.reflections.vfs.SystemDir;\n+import org.reflections.vfs.Vfs;\n+import org.reflections.vfs.ZipDir;\n+\n+import com.google.common.base.Predicates;\n+import com.google.common.collect.Iterables;\n+\n+import javassist.bytecode.ClassFile;\n \n /** */\n public class VfsTest {\n@@ -121,6 +128,41 @@ public class VfsTest {\n     public void vfsFromDir() {\n         testVfsDir(getSomeDirectory());\n     }\n+    \n+    @Test\n+    public void vfsFromDirWithJarInName() throws MalformedURLException {\n+        String tmpFolder = System.getProperty(\"java.io.tmpdir\");\n+\t\ttmpFolder = tmpFolder.endsWith(File.separator) ? tmpFolder : tmpFolder + File.separator;\n+        String dirWithJarInName = tmpFolder + \"tony.jarvis\";\n+        File newDir = new File(dirWithJarInName);\n+        newDir.mkdir();\n+\n+        try {\n+            Vfs.Dir dir = Vfs.fromURL(new URL(format(\"file:{0}\", dirWithJarInName)));\n+\n+            assertEquals(dirWithJarInName, dir.getPath());\n+            assertEquals(SystemDir.class, dir.getClass());\n+        } finally {\n+            newDir.delete();\n+        }\n+    }\n+    \n+    @Test\n+    public void vfsFromDirWithinAJarUrl() throws MalformedURLException {\n+    \tURL directoryInJarUrl = ClasspathHelper.forClass(String.class);\n+        assertTrue(directoryInJarUrl.toString().startsWith(\"jar:file:\"));\n+        assertTrue(directoryInJarUrl.toString().contains(\".jar!\"));\n+        \n+        String directoryInJarPath = directoryInJarUrl.toExternalForm().replaceFirst(\"jar:\", \"\");\n+        int start = directoryInJarPath.indexOf(\":\") + 1;\n+\t\tint end = directoryInJarPath.indexOf(\".jar!\") + 4;\n+\t\tString expectedJarFile = directoryInJarPath.substring(start, end);\n+        \n+        Vfs.Dir dir = Vfs.fromURL(new URL(directoryInJarPath));\n+\n+        assertEquals(ZipDir.class, dir.getClass());\n+        assertEquals(expectedJarFile, dir.getPath());\n+    }\n \n     @Test\n     public void vfsFromJarFileUrl() throws MalformedURLException {\n@@ -227,7 +269,7 @@ public class VfsTest {\n     private URL getSomeJar() {\n         Collection<URL> urls = ClasspathHelper.forClassLoader();\n         for (URL url : urls) {\n-            if (!url.toExternalForm().contains(\"surefire\")) return url; //damn\n+            if (!url.toExternalForm().contains(\"surefire\") && url.toExternalForm().endsWith(\".jar\")) return url; //damn\n         }\n         throw new RuntimeException();\n     }\n"}
{"repository": "ronmamo/reflections", "clone_url": "https://github.com/ronmamo/reflections.git", "timestamp": "2023-05-31T19:30:50.291326Z", "commit_hash": "ff797ce4eaeb5d467c9c62e9aaac8c04f42b0df7", "commit_message": "Merge pull request #59 from kaxelson/master\n\nFixed premature return in FilterBuilder.includePackage(String...)", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/reflections/util/FilterBuilder.java b/src/main/java/org/reflections/util/FilterBuilder.java\nindex 767a7ed..d7e41a6 100644\n--- a/src/main/java/org/reflections/util/FilterBuilder.java\n+++ b/src/main/java/org/reflections/util/FilterBuilder.java\n@@ -42,7 +42,7 @@ public class FilterBuilder implements Predicate<String> {\n     /** include packages of given prefixes */\n     public FilterBuilder includePackage(final String... prefixes) {\n         for (String prefix : prefixes) {\n-            return add(new Include(prefix(prefix)));\n+            add(new Include(prefix(prefix)));\n         }\n         return this;\n     }\n", "test_patch": "diff --git a/src/test/java/org/reflections/FilterBuilderTest.java b/src/test/java/org/reflections/FilterBuilderTest.java\nindex 32295dd..94ecd27 100644\n--- a/src/test/java/org/reflections/FilterBuilderTest.java\n+++ b/src/test/java/org/reflections/FilterBuilderTest.java\n@@ -28,6 +28,16 @@ public class FilterBuilderTest {\n     }\n \n     @Test\n+    public void test_includePackageMultiple() {\n+        FilterBuilder filter = new FilterBuilder().includePackage(\"org.reflections\", \"org.foo\");\n+        assertTrue(filter.apply(\"org.reflections.Reflections\"));\n+        assertTrue(filter.apply(\"org.reflections.foo.Reflections\"));\n+        assertTrue(filter.apply(\"org.foo.Reflections\"));\n+        assertTrue(filter.apply(\"org.foo.bar.Reflections\"));\n+        assertFalse(filter.apply(\"org.bar.Reflections\"));\n+    }\n+\n+    @Test\n     public void test_includePackagebyClass() {\n         FilterBuilder filter = new FilterBuilder().includePackage(Reflections.class);\n         assertTrue(filter.apply(\"org.reflections.Reflections\"));\n"}
{"repository": "ronmamo/reflections", "clone_url": "https://github.com/ronmamo/reflections.git", "timestamp": "2023-05-31T19:38:26.940496Z", "commit_hash": "1cc59b3b281700abbcd657e04a819a89964a772c", "commit_message": "Fixed premature return in FilterBuilder.includePackage(String...)\n\nFilterBuilder.includePackage(String...) was returning after adding the first package\npassed in.  As a result, if the method was called with more than one package, only\nthe first would be added.  All others would be ignored.  This fix removes the errant\nreturn statment in the for loop to ensure that all passed in packages will be added.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/reflections/util/FilterBuilder.java b/src/main/java/org/reflections/util/FilterBuilder.java\nindex 767a7ed..d7e41a6 100644\n--- a/src/main/java/org/reflections/util/FilterBuilder.java\n+++ b/src/main/java/org/reflections/util/FilterBuilder.java\n@@ -42,7 +42,7 @@ public class FilterBuilder implements Predicate<String> {\n     /** include packages of given prefixes */\n     public FilterBuilder includePackage(final String... prefixes) {\n         for (String prefix : prefixes) {\n-            return add(new Include(prefix(prefix)));\n+            add(new Include(prefix(prefix)));\n         }\n         return this;\n     }\n", "test_patch": "diff --git a/src/test/java/org/reflections/FilterBuilderTest.java b/src/test/java/org/reflections/FilterBuilderTest.java\nindex 32295dd..94ecd27 100644\n--- a/src/test/java/org/reflections/FilterBuilderTest.java\n+++ b/src/test/java/org/reflections/FilterBuilderTest.java\n@@ -28,6 +28,16 @@ public class FilterBuilderTest {\n     }\n \n     @Test\n+    public void test_includePackageMultiple() {\n+        FilterBuilder filter = new FilterBuilder().includePackage(\"org.reflections\", \"org.foo\");\n+        assertTrue(filter.apply(\"org.reflections.Reflections\"));\n+        assertTrue(filter.apply(\"org.reflections.foo.Reflections\"));\n+        assertTrue(filter.apply(\"org.foo.Reflections\"));\n+        assertTrue(filter.apply(\"org.foo.bar.Reflections\"));\n+        assertFalse(filter.apply(\"org.bar.Reflections\"));\n+    }\n+\n+    @Test\n     public void test_includePackagebyClass() {\n         FilterBuilder filter = new FilterBuilder().includePackage(Reflections.class);\n         assertTrue(filter.apply(\"org.reflections.Reflections\"));\n"}
