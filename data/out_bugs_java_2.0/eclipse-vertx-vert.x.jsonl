{"repository": "eclipse-vertx/vert.x", "clone_url": "https://github.com/eclipse-vertx/vert.x.git", "timestamp": "2023-05-31T21:05:21.171081Z", "commit_hash": "d461719c56f82a4d3c6fd2c6261c650203037ed9", "commit_message": "The JsonParser class does not progress as much as it could when the processing faulty input.\n\nWhen the JsonParser process malformed input, it does halt the parsing and handle the error leaving unprocessed tokens in the underlying Jackson parser. These tokens will be processed when the JsonParser handle another input. When the Jackson parser fails we handle the error and then give up and reported behavior is a consequence.\n\nThe JsonParser has been modified to continue when a malformed input is reported instead of stopping after the error has been processed. Errors are collected and delivered after we all tokens have been processed.\n\nfixes #4338\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/io/vertx/core/parsetools/impl/JsonParserImpl.java b/src/main/java/io/vertx/core/parsetools/impl/JsonParserImpl.java\nindex 674c674..b347b67 100644\n--- a/src/main/java/io/vertx/core/parsetools/impl/JsonParserImpl.java\n+++ b/src/main/java/io/vertx/core/parsetools/impl/JsonParserImpl.java\n@@ -12,6 +12,7 @@\n package io.vertx.core.parsetools.impl;\n \n import com.fasterxml.jackson.core.JsonFactory;\n+import com.fasterxml.jackson.core.JsonLocation;\n import com.fasterxml.jackson.core.JsonToken;\n import com.fasterxml.jackson.core.ObjectCodec;\n import com.fasterxml.jackson.core.base.ParserBase;\n@@ -31,10 +32,7 @@ import io.vertx.core.parsetools.JsonParser;\n import io.vertx.core.streams.ReadStream;\n \n import java.io.IOException;\n-import java.util.ArrayDeque;\n-import java.util.Deque;\n-import java.util.List;\n-import java.util.Map;\n+import java.util.*;\n \n /**\n  * @author <a href=\"mailto:julien@julienviet.com\">Julien Viet</a>\n@@ -54,6 +52,7 @@ public class JsonParserImpl implements JsonParser {\n   private final ReadStream<Buffer> stream;\n   private boolean emitting;\n   private final Deque<JsonEventImpl> pending = new ArrayDeque<>();\n+  private List<IOException> collectedExceptions;\n \n   public JsonParserImpl(ReadStream<Buffer> stream) {\n     this.stream = stream;\n@@ -143,21 +142,24 @@ public class JsonParserImpl implements JsonParser {\n     }\n   }\n \n+  private void handle(IOException ioe) {\n+    if (collectedExceptions == null) {\n+      collectedExceptions = new ArrayList<>();\n+    }\n+    collectedExceptions.add(ioe);\n+  }\n+\n   @Override\n   public void handle(Buffer data) {\n     byte[] bytes = data.getBytes();\n     try {\n       parser.feedInput(bytes, 0, bytes.length);\n-      checkTokens();\n     } catch (IOException e) {\n-      if (exceptionHandler != null) {\n-        exceptionHandler.handle(e);\n-        return;\n-      } else {\n-        throw new DecodeException(e.getMessage(), e);\n-      }\n+      handle(e);\n     }\n+    checkTokens();\n     checkPending();\n+    checkExceptions();\n   }\n \n   @Override\n@@ -167,25 +169,33 @@ public class JsonParserImpl implements JsonParser {\n     }\n     ended = true;\n     parser.endOfInput();\n-    try {\n-      checkTokens();\n-    } catch (IOException e) {\n-      if (exceptionHandler != null) {\n-        exceptionHandler.handle(e);\n-        return;\n-      } else {\n-        throw new DecodeException(e.getMessage(), e);\n-      }\n-    }\n+    checkTokens();\n     checkPending();\n+    checkExceptions();\n   }\n \n-  private void checkTokens() throws IOException {\n+  private void checkTokens() {\n+    JsonLocation prevLocation = null;\n     while (true) {\n-      JsonToken token = parser.nextToken();\n+      JsonToken token;\n+      try {\n+        token = parser.nextToken();\n+      } catch (IOException e) {\n+        JsonLocation location = parser.currentLocation();\n+        if (prevLocation != null) {\n+          if (location.equals(prevLocation)) {\n+            // If we haven't done any progress, give up\n+            return;\n+          }\n+        }\n+        prevLocation = location;\n+        handle(e);\n+        continue;\n+      }\n       if (token == null || token == JsonToken.NOT_AVAILABLE) {\n         break;\n       }\n+      prevLocation = null;\n       String field = currentField;\n       currentField = null;\n       JsonEventImpl event;\n@@ -199,11 +209,20 @@ public class JsonParserImpl implements JsonParser {\n           break;\n         }\n         case FIELD_NAME: {\n-          currentField = parser.getCurrentName();\n+          try {\n+            currentField = parser.getCurrentName();\n+          } catch (IOException e) {\n+            handle(e);\n+          }\n           continue;\n         }\n         case VALUE_STRING: {\n-          event = new JsonEventImpl(token, JsonEventType.VALUE, field, parser.getText());\n+          try {\n+            event = new JsonEventImpl(token, JsonEventType.VALUE, field, parser.getText());\n+          } catch (IOException e) {\n+            handle(e);\n+            continue;\n+          }\n           break;\n         }\n         case VALUE_TRUE: {\n@@ -219,11 +238,21 @@ public class JsonParserImpl implements JsonParser {\n           break;\n         }\n         case VALUE_NUMBER_INT: {\n-          event = new JsonEventImpl(token, JsonEventType.VALUE, field, parser.getLongValue());\n+          try {\n+            event = new JsonEventImpl(token, JsonEventType.VALUE, field, parser.getLongValue());\n+          } catch (IOException e) {\n+            handle(e);\n+            continue;\n+          }\n           break;\n         }\n         case VALUE_NUMBER_FLOAT: {\n-          event = new JsonEventImpl(token, JsonEventType.VALUE, field, parser.getDoubleValue());\n+          try {\n+            event = new JsonEventImpl(token, JsonEventType.VALUE, field, parser.getDoubleValue());\n+          } catch (IOException e) {\n+            handle(e);\n+            continue;\n+          }\n           break;\n         }\n         case END_OBJECT: {\n@@ -288,6 +317,21 @@ public class JsonParserImpl implements JsonParser {\n     }\n   }\n \n+  private void checkExceptions() {\n+    List<IOException> exceptions = collectedExceptions;\n+    collectedExceptions = null;\n+    if (exceptions != null && exceptions.size() > 0) {\n+      if (exceptionHandler != null) {\n+        for (IOException ioe : exceptions) {\n+          exceptionHandler.handle(ioe);\n+        }\n+      } else {\n+        IOException ioe = exceptions.get(0);\n+        throw new DecodeException(ioe.getMessage(), ioe);\n+      }\n+    }\n+  }\n+\n   @Override\n   public JsonParser objectEventMode() {\n     objectValueMode = false;\n", "test_patch": "diff --git a/src/test/java/io/vertx/core/parsetools/JsonParserTest.java b/src/test/java/io/vertx/core/parsetools/JsonParserTest.java\nindex cc400ae..2c51506 100644\n--- a/src/test/java/io/vertx/core/parsetools/JsonParserTest.java\n+++ b/src/test/java/io/vertx/core/parsetools/JsonParserTest.java\n@@ -114,6 +114,35 @@ public class JsonParserTest {\n   }\n \n   @Test\n+  public void testParseWithErrors() {\n+    Buffer data = Buffer.buffer(\"{\\\"foo\\\":\\\"foo_value\\\"},{\\\"bar\\\":\\\"bar_value\\\"},{\\\"juu\\\":\\\"juu_value\\\"}\");\n+    JsonParser parser = JsonParser.newParser();\n+    List<JsonObject> objects = new ArrayList<>();\n+    List<Throwable> errors = new ArrayList<>();\n+    AtomicInteger endCount = new AtomicInteger();\n+    parser.objectValueMode()\n+      .handler(event -> objects.add(event.objectValue()))\n+      .exceptionHandler(errors::add)\n+      .endHandler(v -> endCount.incrementAndGet());\n+    parser.write(data);\n+    assertEquals(3, objects.size());\n+    List<JsonObject> expected = Arrays.asList(\n+      new JsonObject().put(\"foo\", \"foo_value\"),\n+      new JsonObject().put(\"bar\", \"bar_value\"),\n+      new JsonObject().put(\"juu\", \"juu_value\")\n+    );\n+    assertEquals(expected, objects);\n+    assertEquals(2, errors.size());\n+    assertEquals(0, endCount.get());\n+    objects.clear();\n+    errors.clear();\n+    parser.end();\n+    assertEquals(Collections.emptyList(), objects);\n+    assertEquals(Collections.emptyList(), errors);\n+    assertEquals(1, endCount.get());\n+  }\n+\n+  @Test\n   public void parseNumberFormatException() {\n     Buffer data = Buffer.buffer(Long.MAX_VALUE + \"0\");\n     try {\n"}
{"repository": "eclipse-vertx/vert.x", "clone_url": "https://github.com/eclipse-vertx/vert.x.git", "timestamp": "2023-05-31T22:07:24.763769Z", "commit_hash": "3174f1923e1fa12ff98932a4afddbf633c50871d", "commit_message": "Disable TLS 1.0 and 1.1 protocols by default - fixes #4560\n", "related_issues": "", "bug_patch": "diff --git a/src/main/asciidoc/net.adoc b/src/main/asciidoc/net.adoc\nindex fecdb2e..1de80db 100644\n--- a/src/main/asciidoc/net.adoc\n+++ b/src/main/asciidoc/net.adoc\n@@ -685,17 +685,24 @@ Cipher suite can be specified on the {@link io.vertx.core.net.NetServerOptions} \n \n ==== Configuring TLS protocol versions\n \n-By default, the TLS configuration will use the following protocol versions: TLSv1, TLSv1.1, TLSv1.2 and TLSv1.3. Protocol versions can be\n-configured by explicitly adding enabled protocols:\n+By default, the default TLS configuration enables the following protocols: TLSv1.2 and TLSv1.3. Protocol versions can be\n+enabled by explicitly adding them:\n \n [source,$lang]\n ----\n-{@link examples.NetExamples#example45}\n+{@link examples.NetExamples#addEnabledTLSPrococol}\n+----\n+\n+They can also be removed:\n+\n+[source,$lang]\n+----\n+{@link examples.NetExamples#removeEnabledTLSPrococol}\n ----\n \n Protocol versions can be specified on the {@link io.vertx.core.net.NetServerOptions} or {@link io.vertx.core.net.NetClientOptions} configuration.\n \n-NOTE: TLS 1.0 (TLSv1) and TLS 1.1 (TLSv1.1) are widely deprecated and will disabled by default in future Vert.x versions.\n+NOTE: TLS 1.0 (TLSv1) and TLS 1.1 (TLSv1.1) are widely deprecated and have been disabled by default since Vert.x 4.4.0.\n \n ==== SSL engine\n \ndiff --git a/src/main/java/examples/NetExamples.java b/src/main/java/examples/NetExamples.java\nindex fa1506c..8ef1cdf 100755\n--- a/src/main/java/examples/NetExamples.java\n+++ b/src/main/java/examples/NetExamples.java\n@@ -529,14 +529,19 @@ public class NetExamples {\n     NetServer server = vertx.createNetServer(options);\n   }\n \n-  /**\n-   * The default protocols are defined in {@link io.vertx.core.net.TCPSSLOptions#DEFAULT_ENABLED_SECURE_TRANSPORT_PROTOCOLS}, but you can change them.\n-   */\n-  public void example45(Vertx vertx, JksOptions keyStoreOptions) {\n+  public void addEnabledTLSPrococol(Vertx vertx, JksOptions keyStoreOptions) {\n     NetServerOptions options = new NetServerOptions().\n       setSsl(true).\n       setKeyStoreOptions(keyStoreOptions).\n-      removeEnabledSecureTransportProtocol(\"TLSv1\");\n+      addEnabledSecureTransportProtocol(\"TLSv1.1\");\n+    NetServer server = vertx.createNetServer(options);\n+  }\n+\n+  public void removeEnabledTLSPrococol(Vertx vertx, JksOptions keyStoreOptions) {\n+    NetServerOptions options = new NetServerOptions().\n+      setSsl(true).\n+      setKeyStoreOptions(keyStoreOptions).\n+      removeEnabledSecureTransportProtocol(\"TLSv1.2\");\n     NetServer server = vertx.createNetServer(options);\n   }\n \ndiff --git a/src/main/java/io/vertx/core/net/TCPSSLOptions.java b/src/main/java/io/vertx/core/net/TCPSSLOptions.java\nindex 09d7d90..d08330a 100755\n--- a/src/main/java/io/vertx/core/net/TCPSSLOptions.java\n+++ b/src/main/java/io/vertx/core/net/TCPSSLOptions.java\n@@ -85,7 +85,7 @@ public abstract class TCPSSLOptions extends NetworkOptions {\n    * <p/>\n    * \"SSLv2Hello\" is NOT enabled since it's disabled by default since JDK7\n    */\n-  public static final List<String> DEFAULT_ENABLED_SECURE_TRANSPORT_PROTOCOLS = Collections.unmodifiableList(Arrays.asList(\"TLSv1\", \"TLSv1.1\", \"TLSv1.2\", \"TLSv1.3\"));\n+  public static final List<String> DEFAULT_ENABLED_SECURE_TRANSPORT_PROTOCOLS = Collections.unmodifiableList(Arrays.asList(\"TLSv1.2\", \"TLSv1.3\"));\n \n   /**\n    * The default TCP_FASTOPEN value = false\n", "test_patch": "diff --git a/src/test/java/io/vertx/core/net/SSLHelperTest.java b/src/test/java/io/vertx/core/net/SSLHelperTest.java\nindex 81b273c..b635310 100755\n--- a/src/test/java/io/vertx/core/net/SSLHelperTest.java\n+++ b/src/test/java/io/vertx/core/net/SSLHelperTest.java\n@@ -150,9 +150,7 @@ public class SSLHelperTest extends VertxTestBase {\n   public void testDefaultVersions() {\n     testTLSVersions(new HttpServerOptions(), engine -> {\n       List<String> protocols = Arrays.asList(engine.getEnabledProtocols());\n-      assertEquals(4, protocols.size());\n-      assertTrue(protocols.contains(\"TLSv1\"));\n-      assertTrue(protocols.contains(\"TLSv1.1\"));\n+      assertEquals(2, protocols.size());\n       assertTrue(protocols.contains(\"TLSv1.2\"));\n       assertTrue(protocols.contains(\"TLSv1.3\"));\n     });\n"}
{"repository": "eclipse-vertx/vert.x", "clone_url": "https://github.com/eclipse-vertx/vert.x.git", "timestamp": "2023-05-31T22:28:12.232838Z", "commit_hash": "7ff8ecd5a41a598b1ce78d84b330555ec373a289", "commit_message": "Enable TLS 1.3 by default and update the documentation.\n\nfixes #4557\n", "related_issues": "", "bug_patch": "diff --git a/src/main/asciidoc/net.adoc b/src/main/asciidoc/net.adoc\nindex a04838f..fecdb2e 100644\n--- a/src/main/asciidoc/net.adoc\n+++ b/src/main/asciidoc/net.adoc\n@@ -685,7 +685,7 @@ Cipher suite can be specified on the {@link io.vertx.core.net.NetServerOptions} \n \n ==== Configuring TLS protocol versions\n \n-By default, the TLS configuration will use the following protocol versions: SSLv2Hello, TLSv1, TLSv1.1 and TLSv1.2. Protocol versions can be\n+By default, the TLS configuration will use the following protocol versions: TLSv1, TLSv1.1, TLSv1.2 and TLSv1.3. Protocol versions can be\n configured by explicitly adding enabled protocols:\n \n [source,$lang]\n@@ -695,6 +695,8 @@ configured by explicitly adding enabled protocols:\n \n Protocol versions can be specified on the {@link io.vertx.core.net.NetServerOptions} or {@link io.vertx.core.net.NetClientOptions} configuration.\n \n+NOTE: TLS 1.0 (TLSv1) and TLS 1.1 (TLSv1.1) are widely deprecated and will disabled by default in future Vert.x versions.\n+\n ==== SSL engine\n \n The engine implementation can be configured to use https://www.openssl.org[OpenSSL] instead of the JDK implementation.\ndiff --git a/src/main/java/examples/NetExamples.java b/src/main/java/examples/NetExamples.java\nindex f1e64f2..fa1506c 100755\n--- a/src/main/java/examples/NetExamples.java\n+++ b/src/main/java/examples/NetExamples.java\n@@ -536,8 +536,7 @@ public class NetExamples {\n     NetServerOptions options = new NetServerOptions().\n       setSsl(true).\n       setKeyStoreOptions(keyStoreOptions).\n-      removeEnabledSecureTransportProtocol(\"TLSv1\").\n-      addEnabledSecureTransportProtocol(\"TLSv1.3\");\n+      removeEnabledSecureTransportProtocol(\"TLSv1\");\n     NetServer server = vertx.createNetServer(options);\n   }\n \ndiff --git a/src/main/java/io/vertx/core/net/TCPSSLOptions.java b/src/main/java/io/vertx/core/net/TCPSSLOptions.java\nindex 7902c27..09d7d90 100755\n--- a/src/main/java/io/vertx/core/net/TCPSSLOptions.java\n+++ b/src/main/java/io/vertx/core/net/TCPSSLOptions.java\n@@ -79,13 +79,13 @@ public abstract class TCPSSLOptions extends NetworkOptions {\n   public static final SSLEngineOptions DEFAULT_SSL_ENGINE = null;\n \n   /**\n-   * The default ENABLED_SECURE_TRANSPORT_PROTOCOLS value = { \"TLSv1\", \"TLSv1.1\", \"TLSv1.2\" }\n+   * The default ENABLED_SECURE_TRANSPORT_PROTOCOLS value = { \"TLSv1\", \"TLSv1.1\", \"TLSv1.2\", \"TLSv1.3\" }\n    * <p/>\n    * SSLv3 is NOT enabled due to POODLE vulnerability http://en.wikipedia.org/wiki/POODLE\n    * <p/>\n    * \"SSLv2Hello\" is NOT enabled since it's disabled by default since JDK7\n    */\n-  public static final List<String> DEFAULT_ENABLED_SECURE_TRANSPORT_PROTOCOLS = Collections.unmodifiableList(Arrays.asList(\"TLSv1\", \"TLSv1.1\", \"TLSv1.2\"));\n+  public static final List<String> DEFAULT_ENABLED_SECURE_TRANSPORT_PROTOCOLS = Collections.unmodifiableList(Arrays.asList(\"TLSv1\", \"TLSv1.1\", \"TLSv1.2\", \"TLSv1.3\"));\n \n   /**\n    * The default TCP_FASTOPEN value = false\n", "test_patch": "diff --git a/src/test/java/io/vertx/core/http/Http1xTLSTest.java b/src/test/java/io/vertx/core/http/Http1xTLSTest.java\nindex 2b0c149..fd2656d 100644\n--- a/src/test/java/io/vertx/core/http/Http1xTLSTest.java\n+++ b/src/test/java/io/vertx/core/http/Http1xTLSTest.java\n@@ -13,16 +13,14 @@ package io.vertx.core.http;\n \n import io.netty.buffer.ByteBufUtil;\n import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.CompositeFuture;\n import io.vertx.core.DeploymentOptions;\n+import io.vertx.core.Future;\n import io.vertx.core.Promise;\n import io.vertx.core.VertxOptions;\n-import io.vertx.core.buffer.Buffer;\n-import io.vertx.core.net.NetServer;\n-import io.vertx.core.net.NetServerOptions;\n import io.vertx.test.tls.Cert;\n import io.vertx.test.tls.Trust;\n import org.junit.Assume;\n-import org.junit.Ignore;\n import org.junit.Test;\n \n import java.util.ArrayList;\n@@ -30,8 +28,8 @@ import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashSet;\n import java.util.List;\n-import java.util.Set;\n import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.stream.Collectors;\n \n@@ -203,7 +201,13 @@ public class Http1xTLSTest extends HttpTLSTest {\n     int num = VertxOptions.DEFAULT_EVENT_LOOP_POOL_SIZE;\n     Assume.assumeTrue(num > 1);\n     List<String> expected = Arrays.asList(\"chunk-1\", \"chunk-2\", \"chunk-3\");\n-    client = vertx.createHttpClient(new HttpClientOptions().setMaxPoolSize(num).setSsl(true).setTrustAll(true));\n+    HttpClientOptions options = new HttpClientOptions()\n+      .setEnabledSecureTransportProtocols(Collections.singleton(\"TLSv1.2\"))\n+      .setMaxPoolSize(num)\n+      .setSsl(true)\n+      .setTrustAll(true);\n+    client.close();\n+    client = vertx.createHttpClient(options);\n     AtomicInteger connCount = new AtomicInteger();\n     List<String> sessionIds = Collections.synchronizedList(new ArrayList<>());\n     client.connectionHandler(conn -> {\ndiff --git a/src/test/java/io/vertx/core/http/HttpTLSTest.java b/src/test/java/io/vertx/core/http/HttpTLSTest.java\nindex a32bf02..7ab5fd0 100755\n--- a/src/test/java/io/vertx/core/http/HttpTLSTest.java\n+++ b/src/test/java/io/vertx/core/http/HttpTLSTest.java\n@@ -1279,47 +1279,40 @@ public abstract class HttpTLSTest extends HttpTestBase {\n         } else {\n           httpHost = DEFAULT_HTTP_HOST;\n         }\n-        requestProvider.apply(client).onComplete(ar_ -> {\n-          if (ar_.succeeded()) {\n-            HttpClientRequest req = ar_.result();\n-            req.setFollowRedirects(followRedirects);\n-            req.send(\"foo\", ar2 -> {\n-              if (ar2.succeeded()) {\n-                HttpClientResponse response = ar2.result();\n-                HttpConnection conn = response.request().connection();\n-                if (conn.isSsl()) {\n-                  try {\n-                    clientPeerCert = conn.peerCertificates().get(0);\n-                  } catch (SSLPeerUnverifiedException ignore) {\n-                  }\n-                }\n-                if (shouldPass) {\n-                  response.version();\n-                  HttpMethod method = response.request().getMethod();\n-                  if (method == HttpMethod.GET || method == HttpMethod.HEAD) {\n-                    complete();\n-                  } else {\n-                    response.bodyHandler(data -> {\n-                      assertEquals(\"bar\", data.toString());\n-                      complete();\n-                    });\n-                  }\n-                } else {\n-                  HttpTLSTest.this.fail(\"Should not get a response\");\n-                }\n-              } else {\n-                System.out.println(\"HANDLE ME\");\n+        Future<Void> fut = requestProvider.apply(client).compose(req -> {\n+          req.setFollowRedirects(followRedirects);\n+          return req.send(\"foo\").compose(resp -> {\n+            HttpConnection conn = resp.request().connection();\n+            if (conn.isSsl()) {\n+              try {\n+                clientPeerCert = conn.peerCertificates().get(0);\n+              } catch (SSLPeerUnverifiedException ignore) {\n               }\n-            });\n-          } else {\n-            Throwable t = ar_.cause();\n+            }\n             if (shouldPass) {\n-              t.printStackTrace();\n-              HttpTLSTest.this.fail(\"Should not throw exception\");\n+              resp.version();\n+              HttpMethod method = resp.request().getMethod();\n+              if (method == HttpMethod.GET || method == HttpMethod.HEAD) {\n+                return resp.end();\n+              } else {\n+                return resp.body().map(body -> {\n+                  assertEquals(\"bar\", body.toString());\n+                  return null;\n+                });\n+              }\n             } else {\n-              complete();\n+              HttpTLSTest.this.fail(\"Should not get a response\");\n+              return null;\n             }\n-          }\n+          });\n+        });\n+        fut.onSuccess(v -> {\n+          assertTrue(shouldPass);\n+          complete();\n+        });\n+        fut.onFailure(err -> {\n+          assertFalse(\"Should not fail \" + err.getMessage(), shouldPass);\n+          complete();\n         });\n       });\n       await();\ndiff --git a/src/test/java/io/vertx/core/net/NetTest.java b/src/test/java/io/vertx/core/net/NetTest.java\nindex 38725bc..2681232 100755\n--- a/src/test/java/io/vertx/core/net/NetTest.java\n+++ b/src/test/java/io/vertx/core/net/NetTest.java\n@@ -28,6 +28,7 @@ import io.netty.handler.ssl.SslContext;\n import io.netty.handler.timeout.IdleStateEvent;\n import io.netty.util.internal.PlatformDependent;\n import io.vertx.core.*;\n+import io.vertx.core.Future;\n import io.vertx.core.buffer.Buffer;\n import io.vertx.core.eventbus.Message;\n import io.vertx.core.eventbus.MessageConsumer;\n@@ -1866,81 +1867,76 @@ public class NetTest extends VertxTestBase {\n           clientOptions.addEnabledSecureTransportProtocol(protocol);\n         }\n         client = vertx.createNetClient(clientOptions);\n-        client.connect(connectAddress, serverName, ar2 -> {\n-          if (ar2.succeeded()) {\n-            if (!startTLS && !shouldPass) {\n-              fail(\"Should not connect\");\n-              return;\n-            }\n-            final int numChunks = 100;\n-            final int chunkSize = 100;\n-            final List<Buffer> toSend = new ArrayList<>();\n-            final Buffer expected = Buffer.buffer();\n-            for (int i = 0; i< numChunks;i++) {\n-              Buffer chunk = TestUtils.randomBuffer(chunkSize);\n-              toSend.add(chunk);\n-              expected.appendBuffer(chunk);\n-            }\n-            final Buffer received = Buffer.buffer();\n-            final NetSocket socket = ar2.result();\n+        Future<Void> f = client.connect(connectAddress, serverName).compose(socket -> {\n+          Promise<Void> result = Promise.promise();\n+          final int numChunks = 100;\n+          final int chunkSize = 100;\n+          final List<Buffer> toSend = new ArrayList<>();\n+          final Buffer expected = Buffer.buffer();\n+          for (int i = 0; i< numChunks;i++) {\n+            Buffer chunk = TestUtils.randomBuffer(chunkSize);\n+            toSend.add(chunk);\n+            expected.appendBuffer(chunk);\n+          }\n+          final Buffer received = Buffer.buffer();\n \n-            if (socket.isSsl()) {\n-              try {\n-                clientPeerCert = socket.peerCertificates().get(0);\n-              } catch (SSLPeerUnverifiedException ignore) {\n-              }\n+          if (socket.isSsl()) {\n+            try {\n+              clientPeerCert = socket.peerCertificates().get(0);\n+            } catch (SSLPeerUnverifiedException ignore) {\n             }\n+          }\n \n-            final AtomicBoolean upgradedClient = new AtomicBoolean();\n-            socket.handler(buffer -> {\n-              received.appendBuffer(buffer);\n-              if (received.length() == expected.length()) {\n-                assertEquals(expected, received);\n-                complete();\n-              }\n-              if (startTLS && !upgradedClient.get()) {\n-                upgradedClient.set(true);\n-                assertFalse(socket.isSsl());\n-                Handler<AsyncResult<Void>> handler;\n-                if (shouldPass) {\n-                  handler = onSuccess(v -> {\n-                    assertTrue(socket.isSsl());\n-                    try {\n-                      clientPeerCert = socket.peerCertificates().get(0);\n-                    } catch (SSLPeerUnverifiedException ignore) {\n-                    }\n-                    // Now send the rest\n-                    for (int i = 1; i < numChunks; i++) {\n-                      socket.write(toSend.get(i));\n-                    }\n-                  });\n-                } else {\n-                  handler = onFailure(err -> complete());\n-                }\n-                if (serverName != null) {\n-                  socket.upgradeToSsl(serverName, handler);\n-                } else {\n-                  socket.upgradeToSsl(handler);\n-                }\n+          final AtomicBoolean upgradedClient = new AtomicBoolean();\n+          socket.exceptionHandler(result::tryFail);\n+          socket.handler(buffer -> {\n+            received.appendBuffer(buffer);\n+            if (received.length() == expected.length()) {\n+              assertEquals(expected, received);\n+              complete();\n+            }\n+            if (startTLS && !upgradedClient.get()) {\n+              upgradedClient.set(true);\n+              assertFalse(socket.isSsl());\n+              Future<Void> fut;\n+              if (serverName != null) {\n+                fut = socket.upgradeToSsl(serverName);\n               } else {\n-                assertTrue(socket.isSsl());\n+                fut = socket.upgradeToSsl();\n               }\n-            });\n-\n-            //Now send some data\n-            int numToSend = startTLS ? 1 : numChunks;\n-            for (int i = 0; i < numToSend; i++) {\n-              socket.write(toSend.get(i));\n-            }\n-          } else {\n-            if (shouldPass) {\n-              ar2.cause().printStackTrace();\n-              fail(\"Should not fail to connect\");\n+              if (shouldPass) {\n+                fut.onSuccess(v -> {\n+                  assertTrue(socket.isSsl());\n+                  try {\n+                    clientPeerCert = socket.peerCertificates().get(0);\n+                  } catch (SSLPeerUnverifiedException ignore) {\n+                  }\n+                  // Now send the rest\n+                  for (int i = 1; i < numChunks; i++) {\n+                    socket.write(toSend.get(i));\n+                  }\n+                });\n+              }\n+              fut.onFailure(result::tryFail);\n             } else {\n-              complete();\n+              assertTrue(socket.isSsl());\n             }\n+          });\n+\n+          //Now send some data\n+          int numToSend = startTLS ? 1 : numChunks;\n+          for (int i = 0; i < numToSend; i++) {\n+            socket.write(toSend.get(i));\n           }\n+\n+          return result.future();\n         });\n+\n+        if (shouldPass) {\n+          f.onComplete(onSuccess(v -> complete()));\n+        } else {\n+          f.onComplete(onFailure(v -> complete()));\n+        }\n       }));\n     }\n   }\ndiff --git a/src/test/java/io/vertx/core/net/SSLHelperTest.java b/src/test/java/io/vertx/core/net/SSLHelperTest.java\nindex 4150371..81b273c 100755\n--- a/src/test/java/io/vertx/core/net/SSLHelperTest.java\n+++ b/src/test/java/io/vertx/core/net/SSLHelperTest.java\n@@ -30,6 +30,7 @@ import javax.net.ssl.SSLContext;\n import javax.net.ssl.SSLEngine;\n import javax.net.ssl.SSLSessionContext;\n import java.util.*;\n+import java.util.function.Consumer;\n \n /**\n  * @author <a href=\"mailto:julien@julienviet.com\">Julien Viet</a>\n@@ -144,4 +145,47 @@ public class SSLHelperTest extends VertxTestBase {\n     JsonObject json = options.toJson();\n     assertEquals(new ArrayList<>(new HttpServerOptions(json).getEnabledSecureTransportProtocols()), expectedProtocols);\n   }\n+\n+  @Test\n+  public void testDefaultVersions() {\n+    testTLSVersions(new HttpServerOptions(), engine -> {\n+      List<String> protocols = Arrays.asList(engine.getEnabledProtocols());\n+      assertEquals(4, protocols.size());\n+      assertTrue(protocols.contains(\"TLSv1\"));\n+      assertTrue(protocols.contains(\"TLSv1.1\"));\n+      assertTrue(protocols.contains(\"TLSv1.2\"));\n+      assertTrue(protocols.contains(\"TLSv1.3\"));\n+    });\n+  }\n+\n+  @Test\n+  public void testSetVersion() {\n+    testTLSVersions(new HttpServerOptions().setEnabledSecureTransportProtocols(new HashSet<>(Arrays.asList(\"TLSv1.3\"))), engine -> {\n+      List<String> protocols = Arrays.asList(engine.getEnabledProtocols());\n+      assertEquals(1, protocols.size());\n+      assertTrue(protocols.contains(\"TLSv1.3\"));\n+    });\n+  }\n+\n+  @Test\n+  public void testSetVersions() {\n+    testTLSVersions(new HttpServerOptions().setEnabledSecureTransportProtocols(new HashSet<>(Arrays.asList(\"TLSv1\", \"TLSv1.3\"))), engine -> {\n+      List<String> protocols = Arrays.asList(engine.getEnabledProtocols());\n+      assertEquals(2, protocols.size());\n+      assertTrue(protocols.contains(\"TLSv1\"));\n+      assertTrue(protocols.contains(\"TLSv1.3\"));\n+    });\n+  }\n+\n+  private void testTLSVersions(HttpServerOptions options, Consumer<SSLEngine> check) {\n+    SSLHelper helper = new SSLHelper(options.setSsl(true).setKeyCertOptions(Cert.SERVER_JKS.get()), null);\n+    helper\n+      .init((ContextInternal) vertx.getOrCreateContext())\n+      .onComplete(onSuccess(v -> {\n+        SSLEngine engine = helper.createEngine((VertxInternal) vertx);\n+        check.accept(engine);\n+        testComplete();\n+      }));\n+    await();\n+  }\n }\n"}
{"repository": "eclipse-vertx/vert.x", "clone_url": "https://github.com/eclipse-vertx/vert.x.git", "timestamp": "2023-05-31T23:20:52.249650Z", "commit_hash": "670dfb2ce191f4934c5a5c5ba11479428b323aa6", "commit_message": "The thread factory SPI should be able to use the thread factory wrapper when it is created.\n\nThe wrapper of the vertx factory that is passed to the SPI relies on the vertx instance and it is not properly constructed when the thread factory SPI uses the wrapper when it is initialized.\n\nThe wrapper is now initialized with the resources it needs instead of retrieving them from the vertx instance.\n\nfixes #4471\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/io/vertx/core/impl/VertxImpl.java b/src/main/java/io/vertx/core/impl/VertxImpl.java\nindex f39083d..cf292be 100644\n--- a/src/main/java/io/vertx/core/impl/VertxImpl.java\n+++ b/src/main/java/io/vertx/core/impl/VertxImpl.java\n@@ -148,33 +148,41 @@ public class VertxImpl implements VertxInternal, MetricsProvider {\n     if (Vertx.currentContext() != null) {\n       log.warn(\"You're already on a Vert.x context, are you sure you want to create a new Vertx instance?\");\n     }\n+\n+    Boolean useDaemonThread = options.getUseDaemonThread();\n+    int workerPoolSize = options.getWorkerPoolSize();\n+    int internalBlockingPoolSize = options.getInternalBlockingPoolSize();\n+    BlockedThreadChecker checker = new BlockedThreadChecker(options.getBlockedThreadCheckInterval(), options.getBlockedThreadCheckIntervalUnit(), options.getWarningExceptionTime(), options.getWarningExceptionTimeUnit());\n+    long maxEventLoopExecuteTime = options.getMaxEventLoopExecuteTime();\n+    TimeUnit maxEventLoopExecuteTimeUnit = options.getMaxEventLoopExecuteTimeUnit();\n+    ThreadFactory acceptorEventLoopThreadFactory = createThreadFactory(threadFactory, checker, useDaemonThread, maxEventLoopExecuteTime, maxEventLoopExecuteTimeUnit, \"vert.x-acceptor-thread-\", false);\n+    TimeUnit maxWorkerExecuteTimeUnit = options.getMaxWorkerExecuteTimeUnit();\n+    long maxWorkerExecuteTime = options.getMaxWorkerExecuteTime();\n+\n+    ThreadFactory workerThreadFactory = createThreadFactory(threadFactory, checker, useDaemonThread, maxWorkerExecuteTime, maxWorkerExecuteTimeUnit, \"vert.x-worker-thread-\", true);\n+    ExecutorService workerExec = executorServiceFactory.createExecutor(workerThreadFactory, workerPoolSize, workerPoolSize);\n+    PoolMetrics workerPoolMetrics = metrics != null ? metrics.createPoolMetrics(\"worker\", \"vert.x-worker-thread\", options.getWorkerPoolSize()) : null;\n+    ThreadFactory internalWorkerThreadFactory = createThreadFactory(threadFactory, checker, useDaemonThread, maxWorkerExecuteTime, maxWorkerExecuteTimeUnit, \"vert.x-internal-blocking-\", true);\n+    ExecutorService internalWorkerExec = executorServiceFactory.createExecutor(internalWorkerThreadFactory, internalBlockingPoolSize, internalBlockingPoolSize);\n+    PoolMetrics internalBlockingPoolMetrics = metrics != null ? metrics.createPoolMetrics(\"worker\", \"vert.x-internal-blocking\", internalBlockingPoolSize) : null;\n+\n     closeFuture = new CloseFuture(log);\n-    maxEventLoopExecTime = options.getMaxEventLoopExecuteTime();\n-    maxEventLoopExecTimeUnit = options.getMaxEventLoopExecuteTimeUnit();\n-    checker = new BlockedThreadChecker(options.getBlockedThreadCheckInterval(), options.getBlockedThreadCheckIntervalUnit(), options.getWarningExceptionTime(), options.getWarningExceptionTimeUnit());\n-    eventLoopThreadFactory = createThreadFactory(maxEventLoopExecTime, maxEventLoopExecTimeUnit, \"vert.x-eventloop-thread-\", false);\n+    maxEventLoopExecTime = maxEventLoopExecuteTime;\n+    maxEventLoopExecTimeUnit = maxEventLoopExecuteTimeUnit;\n+    eventLoopThreadFactory = createThreadFactory(threadFactory, checker, useDaemonThread, maxEventLoopExecTime, maxEventLoopExecTimeUnit, \"vert.x-eventloop-thread-\", false);\n     eventLoopGroup = transport.eventLoopGroup(Transport.IO_EVENT_LOOP_GROUP, options.getEventLoopPoolSize(), eventLoopThreadFactory, NETTY_IO_RATIO);\n-    ThreadFactory acceptorEventLoopThreadFactory = createThreadFactory(options.getMaxEventLoopExecuteTime(), options.getMaxEventLoopExecuteTimeUnit(), \"vert.x-acceptor-thread-\", false);\n     // The acceptor event loop thread needs to be from a different pool otherwise can get lags in accepted connections\n     // under a lot of load\n     acceptorEventLoopGroup = transport.eventLoopGroup(Transport.ACCEPTOR_EVENT_LOOP_GROUP, 1, acceptorEventLoopThreadFactory, 100);\n-\n-    int workerPoolSize = options.getWorkerPoolSize();\n-    ThreadFactory workerThreadFactory = createThreadFactory(options.getMaxWorkerExecuteTime(), options.getMaxWorkerExecuteTimeUnit(), \"vert.x-worker-thread-\", true);\n-    ExecutorService workerExec = executorServiceFactory.createExecutor(workerThreadFactory, workerPoolSize, workerPoolSize);\n-    PoolMetrics workerPoolMetrics = metrics != null ? metrics.createPoolMetrics(\"worker\", \"vert.x-worker-thread\", options.getWorkerPoolSize()) : null;\n-    ThreadFactory internalWorkerThreadFactory = createThreadFactory(options.getMaxWorkerExecuteTime(), options.getMaxWorkerExecuteTimeUnit(), \"vert.x-internal-blocking-\", true);\n-    ExecutorService internalWorkerExec = executorServiceFactory.createExecutor(internalWorkerThreadFactory, options.getInternalBlockingPoolSize(), options.getInternalBlockingPoolSize());\n-    PoolMetrics internalBlockingPoolMetrics = metrics != null ? metrics.createPoolMetrics(\"worker\", \"vert.x-internal-blocking\", options.getInternalBlockingPoolSize()) : null;\n     internalWorkerPool = new WorkerPool(internalWorkerExec, internalBlockingPoolMetrics);\n     namedWorkerPools = new HashMap<>();\n     workerPool = new WorkerPool(workerExec, workerPoolMetrics);\n     defaultWorkerPoolSize = options.getWorkerPoolSize();\n-    maxWorkerExecTime = options.getMaxWorkerExecuteTime();\n-    maxWorkerExecTimeUnit = options.getMaxWorkerExecuteTimeUnit();\n+    maxWorkerExecTime = maxWorkerExecuteTime;\n+    maxWorkerExecTimeUnit = maxWorkerExecuteTimeUnit;\n     disableTCCL = options.getDisableTCCL();\n-    useDaemonThread = options.getUseDaemonThread();\n-\n+    this.checker = checker;\n+    this.useDaemonThread = useDaemonThread;\n     this.executorServiceFactory = executorServiceFactory;\n     this.threadFactory = threadFactory;\n     this.metrics = metrics;\n@@ -1113,7 +1121,7 @@ public class VertxImpl implements VertxInternal, MetricsProvider {\n     }\n     SharedWorkerPool sharedWorkerPool = namedWorkerPools.get(name);\n     if (sharedWorkerPool == null) {\n-      ThreadFactory workerThreadFactory = createThreadFactory(maxExecuteTime, maxExecuteTimeUnit, name + \"-\", true);\n+      ThreadFactory workerThreadFactory = createThreadFactory(threadFactory, checker, useDaemonThread, maxExecuteTime, maxExecuteTimeUnit, name + \"-\", true);\n       ExecutorService workerExec = executorServiceFactory.createExecutor(workerThreadFactory, poolSize, poolSize);\n       PoolMetrics workerMetrics = metrics != null ? metrics.createPoolMetrics(\"worker\", name, poolSize) : null;\n       namedWorkerPools.put(name, sharedWorkerPool = new SharedWorkerPool(name, workerExec, workerMetrics));\n@@ -1123,7 +1131,7 @@ public class VertxImpl implements VertxInternal, MetricsProvider {\n     return sharedWorkerPool;\n   }\n \n-  private ThreadFactory createThreadFactory(long maxExecuteTime, TimeUnit maxExecuteTimeUnit, String prefix, boolean worker) {\n+  private static ThreadFactory createThreadFactory(VertxThreadFactory threadFactory, BlockedThreadChecker checker, Boolean useDaemonThread, long maxExecuteTime, TimeUnit maxExecuteTimeUnit, String prefix, boolean worker) {\n     AtomicInteger threadCount = new AtomicInteger(0);\n     return runnable -> {\n       VertxThread thread = threadFactory.newVertxThread(runnable, prefix + threadCount.getAndIncrement(), worker, maxExecuteTime, maxExecuteTimeUnit);\n", "test_patch": "diff --git a/src/test/java/io/vertx/core/impl/VertxFactoryTest.java b/src/test/java/io/vertx/core/impl/VertxFactoryTest.java\nindex 9e9a0e8..5d869be 100644\n--- a/src/test/java/io/vertx/core/impl/VertxFactoryTest.java\n+++ b/src/test/java/io/vertx/core/impl/VertxFactoryTest.java\n@@ -14,7 +14,9 @@ import io.vertx.core.Vertx;\n import io.vertx.core.VertxOptions;\n import io.vertx.core.metrics.MetricsOptions;\n import io.vertx.core.net.impl.transport.Transport;\n+import io.vertx.core.spi.ExecutorServiceFactory;\n import io.vertx.core.spi.VertxMetricsFactory;\n+import io.vertx.core.spi.VertxThreadFactory;\n import io.vertx.core.spi.VertxTracerFactory;\n import io.vertx.core.spi.cluster.ClusterManager;\n import io.vertx.core.spi.tracing.VertxTracer;\n@@ -34,6 +36,9 @@ import java.net.URL;\n import java.net.URLClassLoader;\n import java.nio.file.Files;\n import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ThreadFactory;\n import java.util.concurrent.TimeUnit;\n \n import static org.junit.Assert.*;\n@@ -154,6 +159,34 @@ public class VertxFactoryTest {\n     assertSame(override, ((VertxInternal)vertx).transport());\n   }\n \n+  @Test\n+  public void testThatThreadFactoryCanCreateThreadsDuringTheirInitialization() {\n+    VertxBuilder factory = new VertxBuilder();\n+    VertxThreadFactory tf = new VertxThreadFactory() {\n+      @Override\n+      public VertxThread newVertxThread(Runnable target, String name, boolean worker, long maxExecTime, TimeUnit maxExecTimeUnit) {\n+        return VertxThreadFactory.INSTANCE.newVertxThread(target, name, worker, maxExecTime, maxExecTimeUnit);\n+      }\n+    };\n+    factory\n+      .threadFactory(tf)\n+      .executorServiceFactory(new CustomExecutorServiceFactory())\n+      .init()\n+      .vertx()\n+      .close().toCompletionStage().toCompletableFuture().join();\n+  }\n+\n+  private class CustomExecutorServiceFactory implements ExecutorServiceFactory {\n+\n+    @Override\n+    public ExecutorService createExecutor(ThreadFactory threadFactory, Integer concurrency, Integer maxConcurrency) {\n+      // Simulate the behavior of the JBoss enhanced queue executor.\n+      // It uses the thread factory to create a thread used to as scheduler thread.\n+      threadFactory.newThread(() -> {});\n+      return Executors.newCachedThreadPool();\n+    }\n+  }\n+\n   private void runWithServiceFromMetaInf(Class<?> service, String implementationName, Runnable runnable) {\n     ClassLoader classLoader;\n     try {\n"}
{"repository": "eclipse-vertx/vert.x", "clone_url": "https://github.com/eclipse-vertx/vert.x.git", "timestamp": "2023-06-01T00:01:32.912151Z", "commit_hash": "bb5c9e7a660ca21a6ee7168ded8ffb8b27de6077", "commit_message": "Vertx sends ByteBuf duplicates when a Buffer is written to a pipeline. In some cases, such buffer can be appended to by the SslHandlerCoalescingBufferQueue because a duplicate of a slice will be a duplicate and not a slice itself, leading to buffer corruption.\n\nThis commit replace the duplicate operation by a slice operation, which is a similar operation but always provides a slice and prevents ByteBuf written by Vertx to be appended to.\n\nfixes #4517\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/io/vertx/core/buffer/impl/BufferImpl.java b/src/main/java/io/vertx/core/buffer/impl/BufferImpl.java\nindex 4c42ca6..38af5a8 100644\n--- a/src/main/java/io/vertx/core/buffer/impl/BufferImpl.java\n+++ b/src/main/java/io/vertx/core/buffer/impl/BufferImpl.java\n@@ -537,7 +537,7 @@ public class BufferImpl implements Buffer {\n   }\n \n   public ByteBuf getByteBuf() {\n-    ByteBuf duplicate = buffer.duplicate();\n+    ByteBuf duplicate = buffer.slice();\n     if (buffer.getClass() != VertxHeapByteBuf.class && buffer.getClass() != VertxUnsafeHeapByteBuf.class) {\n       duplicate = Unpooled.unreleasableBuffer(duplicate);\n     }\n", "test_patch": "diff --git a/src/test/java/io/vertx/core/buffer/BufferTest.java b/src/test/java/io/vertx/core/buffer/BufferTest.java\nindex 2361f3d..d18a775 100644\n--- a/src/test/java/io/vertx/core/buffer/BufferTest.java\n+++ b/src/test/java/io/vertx/core/buffer/BufferTest.java\n@@ -1026,6 +1026,17 @@ public class BufferTest {\n     assertEquals(rand, buff.getLong(0));\n     buff.appendString(TestUtils.randomUnicodeString(100));\n     assertEquals(100, sliced.length());\n+    ByteBuf duplicate = sliced.getByteBuf();\n+    assertEquals(0, duplicate.readerIndex());\n+    assertEquals(100, duplicate.readableBytes());\n+    for (int i = 0; i < 100; i++) {\n+      assertEquals(buff.getByte(i), duplicate.getByte(i));\n+    }\n+    try {\n+      duplicate.writeByte(0);\n+      fail();\n+    } catch (IndexOutOfBoundsException ignore) {\n+    }\n   }\n \n   @Test\n@@ -1040,6 +1051,17 @@ public class BufferTest {\n     assertEquals(rand, buff.getLong(10));\n     buff.appendString(TestUtils.randomUnicodeString(100));\n     assertEquals(10, sliced.length());\n+    ByteBuf duplicate = sliced.getByteBuf();\n+    assertEquals(0, duplicate.readerIndex());\n+    assertEquals(10, duplicate.readableBytes());\n+    for (int i = 0; i < 10; i++) {\n+      assertEquals(buff.getByte(10 + i), duplicate.getByte(i));\n+    }\n+    try {\n+      duplicate.writeByte(0);\n+      fail();\n+    } catch (IndexOutOfBoundsException ignore) {\n+    }\n   }\n \n   @Test\ndiff --git a/src/test/java/io/vertx/core/http/HttpTest.java b/src/test/java/io/vertx/core/http/HttpTest.java\nindex 7538d41..f21830d 100644\n--- a/src/test/java/io/vertx/core/http/HttpTest.java\n+++ b/src/test/java/io/vertx/core/http/HttpTest.java\n@@ -1360,7 +1360,6 @@ public abstract class HttpTest extends HttpTestBase {\n           int padding = 5;\n           for (int i = 0;i < times;i++) {\n             Buffer paddedChunk = TestUtils.leftPad(padding, chunk);\n-            assertEquals(paddedChunk.getByteBuf().readerIndex(), padding);\n             req.write(paddedChunk);\n           }\n           req.end();\n"}
{"repository": "eclipse-vertx/vert.x", "clone_url": "https://github.com/eclipse-vertx/vert.x.git", "timestamp": "2023-06-01T01:13:59.224397Z", "commit_hash": "6f71b5f2adfb440b554ec9979ff3fdfd7830e985", "commit_message": "Do not log before being LoggerFactory is fully initialized (#4459)\n\n* Do not log before being LoggerFactory is fully initialized\r\n\r\nFixes reactiverse/reactiverse-contextual-logging#52\r\n\r\nOtherwise, a logger extension might use Vert.x classes before they are fully initialized.\r\n\r\nSigned-off-by: Thomas Segismont <tsegismont@gmail.com>\r\n\r\n* Add integration test for io.vertx.core.logging.LoggerFactory init fix\r\n\r\nSigned-off-by: Thomas Segismont <tsegismont@gmail.com>\r\n\r\nSigned-off-by: Thomas Segismont <tsegismont@gmail.com>", "related_issues": "", "bug_patch": "diff --git a/src/main/java/io/vertx/core/logging/Log4j2LogDelegateFactory.java b/src/main/java/io/vertx/core/logging/Log4j2LogDelegateFactory.java\nindex fa4d8ce..68d525f 100644\n--- a/src/main/java/io/vertx/core/logging/Log4j2LogDelegateFactory.java\n+++ b/src/main/java/io/vertx/core/logging/Log4j2LogDelegateFactory.java\n@@ -13,25 +13,22 @@ package io.vertx.core.logging;\n \n import io.vertx.core.spi.logging.LogDelegate;\n import io.vertx.core.spi.logging.LogDelegateFactory;\n+import org.apache.logging.log4j.LogManager;\n \n /**\n  * A {@link LogDelegateFactory} which creates {@link Log4j2LogDelegate} instances.\n  *\n  * @author Clement Escoffier - clement@apache.org\n- *\n- *\n  */\n-public class Log4j2LogDelegateFactory implements LogDelegateFactory\n-{\n+public class Log4j2LogDelegateFactory implements LogDelegateFactory {\n \n   @Override\n   public boolean isAvailable() {\n-    return true;\n+    return LogManager.getLogger(Log4j2LogDelegateFactory.class) != null;\n   }\n \n-  public LogDelegate createDelegate(final String name)\n-   {\n-      return new Log4j2LogDelegate(name);\n-   }\n+  public LogDelegate createDelegate(final String name) {\n+    return new Log4j2LogDelegate(name);\n+  }\n \n }\ndiff --git a/src/main/java/io/vertx/core/logging/LoggerFactory.java b/src/main/java/io/vertx/core/logging/LoggerFactory.java\nindex edc5621..84869d4 100644\n--- a/src/main/java/io/vertx/core/logging/LoggerFactory.java\n+++ b/src/main/java/io/vertx/core/logging/LoggerFactory.java\n@@ -32,6 +32,9 @@ public class LoggerFactory {\n \n   static {\n     initialise();\n+    // Do not log before being fully initialized (a logger extension may use Vert.x classes)\n+    LogDelegate log = delegateFactory.createDelegate(LoggerFactory.class.getName());\n+    log.debug(\"Using \" + delegateFactory.getClass().getName());\n   }\n \n   public static synchronized void initialise() {\n@@ -56,14 +59,12 @@ public class LoggerFactory {\n   }\n \n   private static boolean configureWith(String name, boolean shortName, ClassLoader loader) {\n-    String loggerName = LoggerFactory.class.getName();\n     try {\n       Class<?> clazz = Class.forName(shortName ? \"io.vertx.core.logging.\" + name + \"LogDelegateFactory\" : name, true, loader);\n       LogDelegateFactory factory = (LogDelegateFactory) clazz.newInstance();\n       if (!factory.isAvailable()) {\n         return false;\n       }\n-      factory.createDelegate(loggerName).debug(\"Using \" + factory.getClass().getName());\n       delegateFactory = factory;\n       return true;\n     } catch (Throwable ignore) {\ndiff --git a/src/test/java/io/vertx/core/impl/logging/NoExceptionInInitializerErrorTest.java b/src/test/java/io/vertx/core/impl/logging/NoExceptionInInitializerErrorTest.java\nnew file mode 100644\nindex 0000000..20a18f0\n--- /dev/null\n+++ b/src/test/java/io/vertx/core/impl/logging/NoExceptionInInitializerErrorTest.java\n@@ -0,0 +1,66 @@\n+/*\n+ * Copyright (c) 2011-2019 Contributors to the Eclipse Foundation\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0, or the Apache License, Version 2.0\n+ * which is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n+ */\n+\n+package io.vertx.core.impl.logging;\n+\n+import io.vertx.core.Vertx;\n+import org.apache.logging.log4j.core.LogEvent;\n+import org.apache.logging.log4j.core.config.plugins.Plugin;\n+import org.apache.logging.log4j.core.pattern.ConverterKeys;\n+import org.apache.logging.log4j.core.pattern.LogEventPatternConverter;\n+import org.apache.logging.log4j.core.pattern.PatternConverter;\n+import org.junit.After;\n+import org.junit.Test;\n+\n+import static io.vertx.core.logging.LoggerFactory.LOGGER_DELEGATE_FACTORY_CLASS_NAME;\n+\n+\n+/**\n+ * Must be separated from {@link LoggingBackendSelectionTest}.\n+ * Otherwise, the Vert.x instance might be fully initialized before our test runs.\n+ *\n+ * @author Thomas Segismont\n+ */\n+public class NoExceptionInInitializerErrorTest {\n+\n+  @After\n+  public void tearDown() {\n+    System.clearProperty(LOGGER_DELEGATE_FACTORY_CLASS_NAME);\n+  }\n+\n+  @Test\n+  public void doTest() throws Exception {\n+    System.setProperty(LOGGER_DELEGATE_FACTORY_CLASS_NAME, \"io.vertx.core.logging.Log4j2LogDelegateFactory\");\n+    // Will fail if:\n+    //  - the logging impl uses Vertx static methods (e.g. currentContext in a converter)\n+    //  - io.vertx.core.logging.LoggerFactory logs something before being fully initialized\n+    Vertx.vertx();\n+  }\n+\n+  @Plugin(name = \"VertxContextConverter\", category = PatternConverter.CATEGORY)\n+  @ConverterKeys(\"vsc\")\n+  public static class VertxContextConverter extends LogEventPatternConverter {\n+\n+    private VertxContextConverter(String[] options) {\n+      super(\"vsc\", \"vsc\");\n+    }\n+\n+    @Override\n+    public void format(LogEvent event, StringBuilder toAppendTo) {\n+      // We simply want to make sure we can only get an initialized Vert.x instance\n+      toAppendTo.append(Vertx.currentContext());\n+    }\n+\n+    public static VertxContextConverter newInstance(final String[] options) {\n+      return new VertxContextConverter(options);\n+    }\n+  }\n+}\n", "test_patch": "diff --git a/src/test/resources/log4j2-test.properties b/src/test/resources/log4j2-test.properties\nindex 271e4b6..b282950 100644\n--- a/src/test/resources/log4j2-test.properties\n+++ b/src/test/resources/log4j2-test.properties\n@@ -21,7 +21,7 @@ appender.console.type = Console\n appender.console.name = STDOUT\n appender.console.follow = true\n appender.console.layout.type = PatternLayout\n-appender.console.layout.pattern = [%t] %p %c %C{1}.%M:%L - %m%n\n+appender.console.layout.pattern = [%t] %p %c %C{1}.%M:%L %vsc - %m%n\n appender.console.target = SYSTEM_ERR\n \n rootLogger.level = trace\n"}
{"repository": "eclipse-vertx/vert.x", "clone_url": "https://github.com/eclipse-vertx/vert.x.git", "timestamp": "2023-06-01T02:40:12.793127Z", "commit_hash": "cdeece481d052fee522a0280972570c1facb3f00", "commit_message": "EventBus removeInboundInterceptor should use the INBOUND_INTERCEPTORS_UPDATER (#4423)\n\nFixes #4422\r\n\r\nOtherwise, no inbound interceptor will ever be removed.\r\n\r\nSigned-off-by: Thomas Segismont <tsegismont@gmail.com>", "related_issues": "", "bug_patch": "diff --git a/src/main/java/io/vertx/core/eventbus/impl/EventBusImpl.java b/src/main/java/io/vertx/core/eventbus/impl/EventBusImpl.java\nindex 7c3d203..c889da2 100644\n--- a/src/main/java/io/vertx/core/eventbus/impl/EventBusImpl.java\n+++ b/src/main/java/io/vertx/core/eventbus/impl/EventBusImpl.java\n@@ -57,25 +57,25 @@ public class EventBusImpl implements EventBusInternal, MetricsProvider {\n \n   @Override\n   public <T> EventBus addOutboundInterceptor(Handler<DeliveryContext<T>> interceptor) {\n-    addInterceptor(OUTBOUND_INTERCEPTORS_UPDATER, interceptor);\n+    addInterceptor(OUTBOUND_INTERCEPTORS_UPDATER, Objects.requireNonNull(interceptor));\n     return this;\n   }\n \n   @Override\n   public <T> EventBus addInboundInterceptor(Handler<DeliveryContext<T>> interceptor) {\n-    addInterceptor(INBOUND_INTERCEPTORS_UPDATER, interceptor);\n+    addInterceptor(INBOUND_INTERCEPTORS_UPDATER, Objects.requireNonNull(interceptor));\n     return this;\n   }\n \n   @Override\n   public <T> EventBus removeOutboundInterceptor(Handler<DeliveryContext<T>> interceptor) {\n-    removeInterceptor(OUTBOUND_INTERCEPTORS_UPDATER, interceptor);\n+    removeInterceptor(OUTBOUND_INTERCEPTORS_UPDATER, Objects.requireNonNull(interceptor));\n     return this;\n   }\n \n   @Override\n   public <T> EventBus removeInboundInterceptor(Handler<DeliveryContext<T>> interceptor) {\n-    removeInterceptor(OUTBOUND_INTERCEPTORS_UPDATER, interceptor);\n+    removeInterceptor(INBOUND_INTERCEPTORS_UPDATER, Objects.requireNonNull(interceptor));\n     return this;\n   }\n \n@@ -455,7 +455,7 @@ public class EventBusImpl implements EventBusInternal, MetricsProvider {\n       Handler[] interceptors = updater.get(this);\n       int idx = -1;\n       for (int i = 0;i < interceptors.length;i++) {\n-        if (interceptors[i] == interceptor) {\n+        if (interceptors[i].equals(interceptor)) {\n           idx = i;\n           break;\n         }\n", "test_patch": "diff --git a/src/test/java/io/vertx/core/eventbus/EventBusInterceptorTest.java b/src/test/java/io/vertx/core/eventbus/EventBusInterceptorTest.java\nindex 95c044d..245cbab 100644\n--- a/src/test/java/io/vertx/core/eventbus/EventBusInterceptorTest.java\n+++ b/src/test/java/io/vertx/core/eventbus/EventBusInterceptorTest.java\n@@ -147,7 +147,7 @@ public class EventBusInterceptorTest extends VertxTestBase {\n   }\n \n   @Test\n-  public void testRemoveOutboundInterceptor() {\n+  public void testRemoveInterceptor() {\n \n     AtomicInteger cnt1 = new AtomicInteger();\n     AtomicInteger cnt2 = new AtomicInteger();\n@@ -168,25 +168,28 @@ public class EventBusInterceptorTest extends VertxTestBase {\n       sc.next();\n     };\n \n-    eb.addOutboundInterceptor(eb1).addOutboundInterceptor(eb2).addOutboundInterceptor(eb3);\n+    eb\n+      .addInboundInterceptor(eb1).addOutboundInterceptor(eb1)\n+      .addInboundInterceptor(eb2).addOutboundInterceptor(eb2)\n+      .addInboundInterceptor(eb3).addOutboundInterceptor(eb3);\n \n     eb.consumer(\"some-address\", msg -> {\n       if (msg.body().equals(\"armadillo\")) {\n-        assertEquals(1, cnt1.get());\n-        assertEquals(1, cnt2.get());\n-        assertEquals(1, cnt3.get());\n-        eb.removeOutboundInterceptor(eb2);\n-        eb.send(\"some-address\", \"aardvark\");\n-      } else if (msg.body().equals(\"aardvark\")) {\n         assertEquals(2, cnt1.get());\n-        assertEquals(1, cnt2.get());\n+        assertEquals(2, cnt2.get());\n         assertEquals(2, cnt3.get());\n-        eb.removeOutboundInterceptor(eb3);\n+        eb.removeInboundInterceptor(eb2).removeOutboundInterceptor(eb2);\n+        eb.send(\"some-address\", \"aardvark\");\n+      } else if (msg.body().equals(\"aardvark\")) {\n+        assertEquals(4, cnt1.get());\n+        assertEquals(2, cnt2.get());\n+        assertEquals(4, cnt3.get());\n+        eb.removeInboundInterceptor(eb3).removeOutboundInterceptor(eb3);\n         eb.send(\"some-address\", \"anteater\");\n       } else if (msg.body().equals(\"anteater\")) {\n-        assertEquals(3, cnt1.get());\n-        assertEquals(1, cnt2.get());\n-        assertEquals(2, cnt3.get());\n+        assertEquals(6, cnt1.get());\n+        assertEquals(2, cnt2.get());\n+        assertEquals(4, cnt3.get());\n         testComplete();\n       } else {\n         fail(\"wrong body\");\n"}
{"repository": "eclipse-vertx/vert.x", "clone_url": "https://github.com/eclipse-vertx/vert.x.git", "timestamp": "2023-06-01T03:00:21.165691Z", "commit_hash": "0193a35bbaa54d6f0332dc5f793e4d5fc2098ef0", "commit_message": "When an HTTP/2 client connects, the failure will not be reported when the server disconnects without sending the initial settings.\n\nThe VertxHttp2ConnectionHandler should fail the connect failure when it becomes inactive before the initial settings have been read instead of the current processing.\n\nfixes #4419\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/io/vertx/core/http/impl/VertxHttp2ConnectionHandler.java b/src/main/java/io/vertx/core/http/impl/VertxHttp2ConnectionHandler.java\nindex bc4da22..c6d701f 100644\n--- a/src/main/java/io/vertx/core/http/impl/VertxHttp2ConnectionHandler.java\n+++ b/src/main/java/io/vertx/core/http/impl/VertxHttp2ConnectionHandler.java\n@@ -26,6 +26,7 @@ import io.netty.util.concurrent.Promise;\n import io.vertx.core.Handler;\n import io.vertx.core.buffer.Buffer;\n import io.vertx.core.http.GoAway;\n+import io.vertx.core.net.impl.ConnectionBase;\n \n import java.util.function.Function;\n \n@@ -139,8 +140,12 @@ class VertxHttp2ConnectionHandler<C extends Http2ConnectionBase> extends Http2Co\n   @Override\n   public void channelInactive(ChannelHandlerContext chctx) throws Exception {\n     if (connection != null) {\n-      if (removeHandler != null) {\n-        removeHandler.handle(connection);\n+      if (settingsRead) {\n+        if (removeHandler != null) {\n+          removeHandler.handle(connection);\n+        }\n+      } else {\n+        connectFuture.tryFailure(ConnectionBase.CLOSED_EXCEPTION);\n       }\n       super.channelInactive(chctx);\n       connection.handleClosed();\n", "test_patch": "diff --git a/src/test/java/io/vertx/core/http/Http2ClientTest.java b/src/test/java/io/vertx/core/http/Http2ClientTest.java\nindex 02bb1c9..27cde9d 100644\n--- a/src/test/java/io/vertx/core/http/Http2ClientTest.java\n+++ b/src/test/java/io/vertx/core/http/Http2ClientTest.java\n@@ -37,8 +37,10 @@ import io.vertx.core.Vertx;\n import io.vertx.core.buffer.Buffer;\n import io.vertx.core.http.impl.HttpClientConnection;\n import io.vertx.core.impl.VertxInternal;\n+import io.vertx.core.net.NetServer;\n import io.vertx.core.net.NetSocket;\n import io.vertx.core.net.SocketAddress;\n+import io.vertx.core.net.impl.ConnectionBase;\n import io.vertx.core.net.impl.SSLHelper;\n import io.vertx.test.core.AsyncTestBase;\n import io.vertx.test.core.TestUtils;\n@@ -2229,4 +2231,23 @@ public class Http2ClientTest extends Http2TestBase {\n       s.channel().close().sync();\n     }\n   }\n+\n+  @Test\n+  public void testClearTestDirectServerCloseBeforeSettingsRead() {\n+    NetServer server = vertx.createNetServer();\n+    server.connectHandler(conn -> {\n+      conn.handler(buff -> {\n+        conn.close();\n+      });\n+    });\n+    server.listen(DEFAULT_HTTPS_PORT, DEFAULT_HTTPS_HOST, onSuccess(s -> {\n+      client.close();\n+      client = vertx.createHttpClient(new HttpClientOptions().setProtocolVersion(HttpVersion.HTTP_2).setHttp2ClearTextUpgrade(false));\n+      client.request(requestOptions).onComplete(onFailure(err -> {\n+        assertEquals(err, ConnectionBase.CLOSED_EXCEPTION);\n+        testComplete();\n+      }));\n+    }));\n+    await();\n+  }\n }\n"}
{"repository": "eclipse-vertx/vert.x", "clone_url": "https://github.com/eclipse-vertx/vert.x.git", "timestamp": "2023-06-01T03:35:00.316445Z", "commit_hash": "796fd7b98c97530b88eff398ff3f924f6f9c06ab", "commit_message": "The pool implementation does not correctly update the internal connection usage counter when a waiter is cancelled between the connection request and the connect success callback when extra waiters are enqueued and the connection can share connection between several waiters (multiplexing). This lead to a greater connection use count and this leads to a leak where connection are held by the pool but cannot be borrowed.\n\nfixes #4392\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/io/vertx/core/net/impl/pool/SimpleConnectionPool.java b/src/main/java/io/vertx/core/net/impl/pool/SimpleConnectionPool.java\nindex a032986..0c59989 100644\n--- a/src/main/java/io/vertx/core/net/impl/pool/SimpleConnectionPool.java\n+++ b/src/main/java/io/vertx/core/net/impl/pool/SimpleConnectionPool.java\n@@ -309,16 +309,18 @@ public class SimpleConnectionPool<C> implements ConnectionPool<C> {\n           return null;\n         }\n         LeaseImpl<C> lease;\n+        int c;\n         if (waiter.disposed) {\n           lease = null;\n+          c = 0;\n         } else {\n           lease = new LeaseImpl<>(slot, waiter.handler);\n+          c = 1;\n           waiter.disposed = true;\n           acquisitions--;\n         }\n         LeaseImpl<C>[] leases;\n         int m = (int)Math.min(acquisitions, pool.waiters.size());\n-        int c = 1;\n         if (m > 0) {\n           c += m;\n           leases = new LeaseImpl[m];\n", "test_patch": "diff --git a/src/test/java/io/vertx/core/net/impl/pool/ConnectionPoolTest.java b/src/test/java/io/vertx/core/net/impl/pool/ConnectionPoolTest.java\nindex 2052fed..4f3f4c7 100644\n--- a/src/test/java/io/vertx/core/net/impl/pool/ConnectionPoolTest.java\n+++ b/src/test/java/io/vertx/core/net/impl/pool/ConnectionPoolTest.java\n@@ -726,30 +726,52 @@ public class ConnectionPoolTest extends VertxTestBase {\n \n   @Test\n   public void testCancelWaiterBeforeConnectionSuccess() throws Exception {\n-    testCancelWaiterBeforeConnection(true);\n+    testCancelWaiterBeforeConnection(true, 0);\n+  }\n+\n+  @Test\n+  public void testCancelWaiterBeforeConnectionSuccessWithExtraWaiters() throws Exception {\n+    testCancelWaiterBeforeConnection(true, 2);\n   }\n \n   @Test\n   public void testCancelWaiterBeforeConnectionFailure() throws Exception {\n-    testCancelWaiterBeforeConnection(false);\n+    testCancelWaiterBeforeConnection(false, 0);\n   }\n \n-  public void testCancelWaiterBeforeConnection(boolean success) throws Exception {\n+  public void testCancelWaiterBeforeConnection(boolean success, int extra) throws Exception {\n+    if (!success && extra > 0) {\n+      throw new IllegalArgumentException();\n+    }\n     waitFor(1);\n     EventLoopContext context = vertx.createEventLoopContext();\n     ConnectionManager mgr = new ConnectionManager();\n-    ConnectionPool<Connection> pool = ConnectionPool.pool(mgr, new int[] { 1 }, 1);\n-    CompletableFuture<PoolWaiter<Connection>> w = new CompletableFuture<>();\n+    ConnectionPool<Connection> pool = ConnectionPool.pool(mgr, new int[] { 1 }, 1 + extra);\n+    CompletableFuture<PoolWaiter<Connection>> waiterLatch = new CompletableFuture<>();\n     pool.acquire(context, new PoolWaiter.Listener<Connection>() {\n       @Override\n       public void onConnect(PoolWaiter<Connection> waiter) {\n-        w.complete(waiter);\n+        waiterLatch.complete(waiter);\n       }\n     }, 0, ar -> fail());\n-    w.get(10, TimeUnit.SECONDS);\n+    waiterLatch.get(10, TimeUnit.SECONDS);\n+    CountDownLatch enqueuedLatch = new CountDownLatch(extra);\n+    CountDownLatch recycledLatch = new CountDownLatch(extra);\n+    for (int i = 0;i < extra;i++) {\n+      pool.acquire(context, new PoolWaiter.Listener<Connection>() {\n+        @Override\n+        public void onEnqueue(PoolWaiter<Connection> waiter) {\n+          enqueuedLatch.countDown();\n+        }\n+      }, 0, onSuccess(conn -> {\n+        conn.recycle();\n+        recycledLatch.countDown();\n+      }));\n+    }\n+    awaitLatch(enqueuedLatch);\n     ConnectionRequest request = mgr.assertRequest();\n     CountDownLatch latch = new CountDownLatch(1);\n-    pool.cancel(w.get(10, TimeUnit.SECONDS), onSuccess(removed -> {\n+    pool.cancel(waiterLatch.get(10, TimeUnit.SECONDS), onSuccess(removed -> {\n       assertTrue(removed);\n       latch.countDown();\n     }));\n@@ -759,6 +781,16 @@ public class ConnectionPoolTest extends VertxTestBase {\n     } else {\n       request.fail(new Throwable());\n     }\n+    awaitLatch(recycledLatch);\n+    // Check we can acquire the same connection again\n+    CountDownLatch doneLatch = new CountDownLatch(extra);\n+    for (int i = 0;i < extra;i++) {\n+      pool.acquire(context, 0, onSuccess(conn -> {\n+        doneLatch.countDown();\n+        conn.recycle();\n+      }));\n+    }\n+    awaitLatch(doneLatch);\n   }\n \n   @Test\n"}
{"repository": "eclipse-vertx/vert.x", "clone_url": "https://github.com/eclipse-vertx/vert.x.git", "timestamp": "2023-06-01T04:50:01.466759Z", "commit_hash": "17b8feec26a01970b492a52dcd6bb9667bde745d", "commit_message": "Shared data enhancements (#4333)\n\n* Allow more types as shared data keys and values\r\n\r\nFixes #4186\r\n\r\nThe following types can be allowed as any other Number type of the platform:\r\n\r\n- BigInteger\r\n- BigDecimal\r\n\r\nThe following types can be allowed as a convenience:\r\n\r\n- ClusterSerializable\r\n- Serializable\r\n\r\nIndeed, it is possible to make a copy of them using object streams or buffers, but the developer should consider implementing Shareable (if possible).\r\n\r\nSigned-off-by: Thomas Segismont <tsegismont@gmail.com>\r\n\r\n* AsyncMap keys, values not available through reactivex/core\r\n\r\nCloses #2733\r\n\r\nSigned-off-by: Thomas Segismont <tsegismont@gmail.com>", "related_issues": "", "bug_patch": "diff --git a/src/main/java/io/vertx/core/shareddata/AsyncMap.java b/src/main/java/io/vertx/core/shareddata/AsyncMap.java\nindex 2152479..9b26cad 100644\n--- a/src/main/java/io/vertx/core/shareddata/AsyncMap.java\n+++ b/src/main/java/io/vertx/core/shareddata/AsyncMap.java\n@@ -22,6 +22,8 @@ import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n+import static io.vertx.codegen.annotations.GenIgnore.PERMITTED_TYPE;\n+\n \n /**\n  * An asynchronous map.\n@@ -263,7 +265,7 @@ public interface AsyncMap<K, V> {\n    *\n    * @param resultHandler invoked when the operation completes\n    */\n-  @GenIgnore\n+  @GenIgnore(PERMITTED_TYPE)\n   default void keys(Handler<AsyncResult<Set<K>>> resultHandler) {\n     keys().onComplete(resultHandler);\n   }\n@@ -271,7 +273,7 @@ public interface AsyncMap<K, V> {\n   /**\n    * Same as {@link #keys(Handler)} but returns a {@code Future} of the asynchronous result\n    */\n-  @GenIgnore\n+  @GenIgnore(PERMITTED_TYPE)\n   Future<Set<K>> keys();\n \n   /**\n@@ -283,7 +285,7 @@ public interface AsyncMap<K, V> {\n    *\n    * @param resultHandler invoked when the operation completes\n    */\n-  @GenIgnore\n+  @GenIgnore(PERMITTED_TYPE)\n   default void values(Handler<AsyncResult<List<V>>> resultHandler) {\n     values().onComplete(resultHandler);\n   }\n@@ -291,7 +293,7 @@ public interface AsyncMap<K, V> {\n   /**\n    * Same as {@link #values(Handler)} but returns a {@code Future} of the asynchronous result\n    */\n-  @GenIgnore\n+  @GenIgnore(PERMITTED_TYPE)\n   Future<List<V>> values();\n \n   /**\ndiff --git a/src/main/java/io/vertx/core/shareddata/impl/Checker.java b/src/main/java/io/vertx/core/shareddata/impl/Checker.java\nindex 843827f..4ee9090 100644\n--- a/src/main/java/io/vertx/core/shareddata/impl/Checker.java\n+++ b/src/main/java/io/vertx/core/shareddata/impl/Checker.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright (c) 2011-2019 Contributors to the Eclipse Foundation\n+ * Copyright (c) 2011-2022 Contributors to the Eclipse Foundation\n  *\n  * This program and the accompanying materials are made available under the\n  * terms of the Eclipse Public License 2.0 which is available at\n@@ -12,44 +12,113 @@\n package io.vertx.core.shareddata.impl;\n \n import io.vertx.core.buffer.Buffer;\n-import io.vertx.core.json.JsonArray;\n-import io.vertx.core.json.JsonObject;\n+import io.vertx.core.impl.logging.Logger;\n+import io.vertx.core.impl.logging.LoggerFactory;\n import io.vertx.core.shareddata.Shareable;\n \n+import java.io.*;\n+import java.lang.reflect.InvocationTargetException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+\n+import static java.util.stream.Collectors.toSet;\n+\n /**\n  * @author <a href=\"http://tfox.org\">Tim Fox</a>\n  */\n-public class Checker {\n+class Checker {\n+\n+  private static final Logger log = LoggerFactory.getLogger(Checker.class);\n+\n+  private static final Set<Class<?>> IMMUTABLE_TYPES = Stream.<Class<?>>builder()\n+    .add(String.class)\n+    .add(Integer.class)\n+    .add(Long.class)\n+    .add(Boolean.class)\n+    .add(Double.class)\n+    .add(Float.class)\n+    .add(Short.class)\n+    .add(Byte.class)\n+    .add(Character.class)\n+    .add(BigInteger.class)\n+    .add(BigDecimal.class)\n+    .build()\n+    .collect(toSet());\n \n   static void checkType(Object obj) {\n-    if (obj instanceof String ||\n-        obj instanceof Integer ||\n-        obj instanceof Long ||\n-        obj instanceof Boolean ||\n-        obj instanceof Double ||\n-        obj instanceof Float ||\n-        obj instanceof Short ||\n-        obj instanceof Byte ||\n-        obj instanceof Character ||\n-        obj instanceof byte[] ||\n-        obj instanceof Shareable) {\n-    } else {\n+    Objects.requireNonNull(obj, \"null not allowed for shareddata data structure\");\n+    // All immutables and byte arrays are Serializable by the platform\n+    if (!(obj instanceof Serializable || obj instanceof Shareable || obj instanceof ClusterSerializable)) {\n       throw new IllegalArgumentException(\"Invalid type for shareddata data structure: \" + obj.getClass().getName());\n     }\n   }\n \n+  @SuppressWarnings(\"unchecked\")\n   static <T> T copyIfRequired(T obj) {\n-    if (obj instanceof byte[]) {\n-      //Copy it\n-      byte[] bytes = (byte[]) obj;\n-      byte[] copy = new byte[bytes.length];\n-      System.arraycopy(bytes, 0, copy, 0, bytes.length);\n-      return (T) copy;\n+    Object result;\n+    if (obj == null) {\n+      // Happens with putIfAbsent\n+      result = null;\n+    } else if (IMMUTABLE_TYPES.contains(obj.getClass())) {\n+      result = obj;\n+    } else if (obj instanceof byte[]) {\n+      result = copyByteArray((byte[]) obj);\n     } else if (obj instanceof Shareable) {\n-      return (T) ((Shareable) obj).copy();\n+      result = ((Shareable) obj).copy();\n+    } else if (obj instanceof ClusterSerializable) {\n+      result = copyClusterSerializable((ClusterSerializable) obj);\n+    } else if (obj instanceof Serializable) {\n+      result = copySerializable(obj);\n     } else {\n-      return obj;\n+      throw new IllegalStateException();\n+    }\n+    return (T) result;\n+  }\n+\n+  private static byte[] copyByteArray(byte[] bytes) {\n+    byte[] copy = new byte[bytes.length];\n+    System.arraycopy(bytes, 0, copy, 0, bytes.length);\n+    return copy;\n+  }\n+\n+  private static ClusterSerializable copyClusterSerializable(ClusterSerializable obj) {\n+    logDeveloperInfo(obj);\n+    Buffer buffer = Buffer.buffer();\n+    obj.writeToBuffer(buffer);\n+    try {\n+      ClusterSerializable copy = obj.getClass().getConstructor().newInstance();\n+      copy.readFromBuffer(0, buffer);\n+      return copy;\n+    } catch (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  private static void logDeveloperInfo(Object obj) {\n+    if (log.isDebugEnabled()) {\n+      log.debug(\"Copying \" + obj.getClass() + \" for shared data. Consider implementing \" + Shareable.class + \" for better performance.\");\n     }\n   }\n \n+  private static Object copySerializable(Object obj) {\n+    logDeveloperInfo(obj);\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    byte[] bytes;\n+    try (ObjectOutputStream oos = new ObjectOutputStream(baos)) {\n+      oos.writeObject(obj);\n+      oos.flush();\n+    } catch (IOException e) {\n+      throw new RuntimeException(e);\n+    }\n+    bytes = baos.toByteArray();\n+    ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+    try (ObjectInputStream ois = new ObjectInputStream(bais)) {\n+      return ois.readObject();\n+    } catch (IOException | ClassNotFoundException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n }\n", "test_patch": "diff --git a/src/test/java/io/vertx/core/shareddata/LocalSharedDataTest.java b/src/test/java/io/vertx/core/shareddata/LocalSharedDataTest.java\nindex 5d05a36..836f0b8 100644\n--- a/src/test/java/io/vertx/core/shareddata/LocalSharedDataTest.java\n+++ b/src/test/java/io/vertx/core/shareddata/LocalSharedDataTest.java\n@@ -1,5 +1,5 @@\n /*\n- * Copyright (c) 2011-2019 Contributors to the Eclipse Foundation\n+ * Copyright (c) 2011-2022 Contributors to the Eclipse Foundation\n  *\n  * This program and the accompanying materials are made available under the\n  * terms of the Eclipse Public License 2.0 which is available at\n@@ -14,18 +14,20 @@ package io.vertx.core.shareddata;\n import io.vertx.core.buffer.Buffer;\n import io.vertx.core.json.JsonArray;\n import io.vertx.core.json.JsonObject;\n-import io.vertx.core.shareddata.LocalMap;\n-import io.vertx.core.shareddata.Shareable;\n-import io.vertx.core.shareddata.SharedData;\n+import io.vertx.core.shareddata.AsyncMapTest.SomeClusterSerializableObject;\n+import io.vertx.core.shareddata.AsyncMapTest.SomeSerializableObject;\n import io.vertx.test.core.TestUtils;\n import io.vertx.test.core.VertxTestBase;\n import org.junit.Test;\n \n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n import java.util.*;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.function.BiFunction;\n \n-import static io.vertx.test.core.TestUtils.*;\n+import static io.vertx.test.core.TestUtils.assertIllegalArgumentException;\n+import static io.vertx.test.core.TestUtils.assertNullPointerException;\n \n /**\n  * @author <a href=\"http://tfox.org\">Tim Fox</a>\n@@ -171,10 +173,12 @@ public class LocalSharedDataTest extends VertxTestBase {\n   @Test\n   public void testMapTypes() throws Exception {\n \n-    LocalMap map = sharedData.getLocalMap(\"foo\");\n+    LocalMap<Object, Object> map = sharedData.getLocalMap(\"foo\");\n \n     String key = \"key\";\n \n+    assertNullPointerException(() -> map.put(key, null));\n+\n     double d = new Random().nextDouble();\n     map.put(key, d);\n     assertEquals(d, map.get(key));\n@@ -183,7 +187,7 @@ public class LocalSharedDataTest extends VertxTestBase {\n     map.put(key, f);\n     assertEquals(f, map.get(key));\n \n-    byte b = (byte)new Random().nextInt();\n+    byte b = (byte) new Random().nextInt();\n     map.put(key, b);\n     assertEquals(b, map.get(key));\n \n@@ -234,15 +238,37 @@ public class LocalSharedDataTest extends VertxTestBase {\n \n     JsonObject obj = new JsonObject().put(\"foo\", \"bar\");\n     map.put(\"obj\", obj);\n-    JsonObject other = (JsonObject)map.get(\"obj\");\n+    JsonObject other = (JsonObject) map.get(\"obj\");\n     assertEquals(obj, other);\n     assertNotSame(obj, other); // Should be copied\n \n     JsonArray arr = new JsonArray().add(\"foo\");\n     map.put(\"arr\", arr);\n-    JsonArray otherArr = (JsonArray)map.get(\"arr\");\n+    JsonArray otherArr = (JsonArray) map.get(\"arr\");\n     assertEquals(arr, otherArr);\n     assertNotSame(arr, otherArr); // Should be copied\n+\n+    BigInteger bi = BigInteger.valueOf(new Random().nextLong());\n+    map.put(key, bi);\n+    BigInteger otherBi = (BigInteger) map.get(key);\n+    assertSame(bi, otherBi);\n+\n+    BigDecimal bd = BigDecimal.valueOf(new Random().nextDouble());\n+    map.put(key, bd);\n+    BigDecimal otherBd = (BigDecimal) map.get(key);\n+    assertSame(bd, otherBd);\n+\n+    SomeSerializableObject so = new SomeSerializableObject(TestUtils.randomAlphaString(15));\n+    map.put(key, so);\n+    SomeSerializableObject otherSo = (SomeSerializableObject) map.get(key);\n+    assertEquals(so, otherSo);\n+    assertNotSame(so, otherSo);\n+\n+    SomeClusterSerializableObject cso = new SomeClusterSerializableObject(TestUtils.randomAlphaString(15));\n+    map.put(key, cso);\n+    SomeClusterSerializableObject otherCso = (SomeClusterSerializableObject) map.get(key);\n+    assertEquals(cso, otherCso);\n+    assertNotSame(cso, otherCso);\n   }\n \n   @Test\n"}
{"repository": "eclipse-vertx/vert.x", "clone_url": "https://github.com/eclipse-vertx/vert.x.git", "timestamp": "2023-06-01T05:10:07.681886Z", "commit_hash": "2f3ddd7a4d97dcbb99c02e2d64e8459bbd5e7283", "commit_message": "DNS over TCP - fixes #4309\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/io/vertx/core/impl/resolver/DnsResolverProvider.java b/src/main/java/io/vertx/core/impl/resolver/DnsResolverProvider.java\nindex 77164fa..37f5f2f 100644\n--- a/src/main/java/io/vertx/core/impl/resolver/DnsResolverProvider.java\n+++ b/src/main/java/io/vertx/core/impl/resolver/DnsResolverProvider.java\n@@ -14,6 +14,7 @@ package io.vertx.core.impl.resolver;\n import io.netty.channel.ChannelFactory;\n import io.netty.channel.EventLoop;\n import io.netty.channel.socket.DatagramChannel;\n+import io.netty.channel.socket.SocketChannel;\n import io.netty.resolver.*;\n import io.netty.resolver.dns.*;\n import io.netty.util.NetUtil;\n@@ -86,7 +87,9 @@ public class DnsResolverProvider implements ResolverProvider {\n       }\n     }\n     DnsServerAddresses nameServerAddresses = options.isRotateServers() ? DnsServerAddresses.rotational(serverList) : DnsServerAddresses.sequential(serverList);\n-    DnsServerAddressStreamProvider nameServerAddressProvider = hostname -> nameServerAddresses.stream();\n+    DnsServerAddressStreamProvider nameServerAddressProvider = hostname -> {\n+      return nameServerAddresses.stream();\n+    };\n \n     HostsFileEntries entries;\n     if (options.getHostsPath() != null) {\n@@ -116,76 +119,67 @@ public class DnsResolverProvider implements ResolverProvider {\n     DnsCache authoritativeDnsServerCache = new DefaultDnsCache(minTtl, maxTtl, negativeTtl);\n \n     this.vertx = vertx;\n-    this.resolverGroup = new AddressResolverGroup<InetSocketAddress>() {\n+\n+\n+    DnsNameResolverBuilder builder = new DnsNameResolverBuilder();\n+    builder.hostsFileEntriesResolver(new HostsFileEntriesResolver() {\n+      @Override\n+      public InetAddress address(String inetHost, ResolvedAddressTypes resolvedAddressTypes) {\n+        if (inetHost.endsWith(\".\")) {\n+          inetHost = inetHost.substring(0, inetHost.length() - 1);\n+        }\n+        InetAddress address = lookup(inetHost, resolvedAddressTypes);\n+        if (address == null) {\n+          address = lookup(inetHost.toLowerCase(Locale.ENGLISH), resolvedAddressTypes);\n+        }\n+        return address;\n+      }\n+      InetAddress lookup(String inetHost, ResolvedAddressTypes resolvedAddressTypes) {\n+        switch (resolvedAddressTypes) {\n+          case IPV4_ONLY:\n+            return entries.inet4Entries().get(inetHost);\n+          case IPV6_ONLY:\n+            return entries.inet6Entries().get(inetHost);\n+          case IPV4_PREFERRED:\n+            Inet4Address inet4Address = entries.inet4Entries().get(inetHost);\n+            return inet4Address != null? inet4Address : entries.inet6Entries().get(inetHost);\n+          case IPV6_PREFERRED:\n+            Inet6Address inet6Address = entries.inet6Entries().get(inetHost);\n+            return inet6Address != null? inet6Address : entries.inet4Entries().get(inetHost);\n+          default:\n+            throw new IllegalArgumentException(\"Unknown ResolvedAddressTypes \" + resolvedAddressTypes);\n+        }\n+      }\n+    });\n+    builder.channelFactory(() -> vertx.transport().datagramChannel());\n+    builder.socketChannelFactory(() -> (SocketChannel) vertx.transport().channelFactory(false).newChannel());\n+    builder.nameServerProvider(nameServerAddressProvider);\n+    builder.optResourceEnabled(options.isOptResourceEnabled());\n+    builder.resolveCache(resolveCache);\n+    builder.authoritativeDnsServerCache(authoritativeDnsServerCache);\n+    builder.queryTimeoutMillis(options.getQueryTimeout());\n+    builder.maxQueriesPerResolve(options.getMaxQueries());\n+    builder.recursionDesired(options.getRdFlag());\n+    if (options.getSearchDomains() != null) {\n+      builder.searchDomains(options.getSearchDomains());\n+      int ndots = options.getNdots();\n+      if (ndots == -1) {\n+        ndots = AddressResolver.DEFAULT_NDOTS_RESOLV_OPTION;\n+      }\n+      builder.ndots(ndots);\n+    }\n+\n+    this.resolverGroup = new DnsAddressResolverGroup(builder) {\n       @Override\n-      protected io.netty.resolver.AddressResolver<InetSocketAddress> newResolver(EventExecutor executor) throws Exception {\n-        ChannelFactory<DatagramChannel> channelFactory = () -> vertx.transport().datagramChannel();\n-        DnsAddressResolverGroup group = new DnsAddressResolverGroup(channelFactory, nameServerAddressProvider) {\n-          @Override\n-          protected final io.netty.resolver.AddressResolver<InetSocketAddress> newAddressResolver(EventLoop eventLoop, NameResolver<InetAddress> resolver) throws Exception {\n-            if (options.isRoundRobinInetAddress()) {\n-              return new RoundRobinInetAddressResolver(eventLoop, resolver).asAddressResolver();\n-            } else {\n-              return super.newAddressResolver(eventLoop, resolver);\n-            }\n-          }\n-\n-          @Override\n-          protected NameResolver<InetAddress> newNameResolver(EventLoop eventLoop, ChannelFactory<? extends DatagramChannel> channelFactory, DnsServerAddressStreamProvider nameServerProvider) throws Exception {\n-            DnsNameResolverBuilder builder = new DnsNameResolverBuilder((EventLoop) executor);\n-            builder.hostsFileEntriesResolver(new HostsFileEntriesResolver() {\n-              @Override\n-              public InetAddress address(String inetHost, ResolvedAddressTypes resolvedAddressTypes) {\n-                if (inetHost.endsWith(\".\")) {\n-                  inetHost = inetHost.substring(0, inetHost.length() - 1);\n-                }\n-                InetAddress address = lookup(inetHost, resolvedAddressTypes);\n-                if (address == null) {\n-                  address = lookup(inetHost.toLowerCase(Locale.ENGLISH), resolvedAddressTypes);\n-                }\n-                return address;\n-              }\n-              InetAddress lookup(String inetHost, ResolvedAddressTypes resolvedAddressTypes) {\n-                switch (resolvedAddressTypes) {\n-                  case IPV4_ONLY:\n-                    return entries.inet4Entries().get(inetHost);\n-                  case IPV6_ONLY:\n-                    return entries.inet6Entries().get(inetHost);\n-                  case IPV4_PREFERRED:\n-                    Inet4Address inet4Address = entries.inet4Entries().get(inetHost);\n-                    return inet4Address != null? inet4Address : entries.inet6Entries().get(inetHost);\n-                  case IPV6_PREFERRED:\n-                    Inet6Address inet6Address = entries.inet6Entries().get(inetHost);\n-                    return inet6Address != null? inet6Address : entries.inet4Entries().get(inetHost);\n-                  default:\n-                    throw new IllegalArgumentException(\"Unknown ResolvedAddressTypes \" + resolvedAddressTypes);\n-                }\n-              }\n-            });\n-            builder.channelFactory(channelFactory);\n-            builder.nameServerProvider(nameServerAddressProvider);\n-            builder.optResourceEnabled(options.isOptResourceEnabled());\n-            builder.resolveCache(resolveCache);\n-            builder.authoritativeDnsServerCache(authoritativeDnsServerCache);\n-            builder.queryTimeoutMillis(options.getQueryTimeout());\n-            builder.maxQueriesPerResolve(options.getMaxQueries());\n-            builder.recursionDesired(options.getRdFlag());\n-            if (options.getSearchDomains() != null) {\n-              builder.searchDomains(options.getSearchDomains());\n-              int ndots = options.getNdots();\n-              if (ndots == -1) {\n-                ndots = AddressResolver.DEFAULT_NDOTS_RESOLV_OPTION;\n-              }\n-              builder.ndots(ndots);\n-            }\n-            return builder.build();\n-          }\n-        };\n-\n-        io.netty.resolver.AddressResolver<InetSocketAddress> resolver = group.getResolver(executor);\n-        resolvers.add(new ResolverRegistration(resolver, (EventLoop) executor));\n-\n-        return resolver;\n+      protected io.netty.resolver.AddressResolver<InetSocketAddress> newAddressResolver(EventLoop eventLoop, NameResolver<InetAddress> resolver) throws Exception {\n+        io.netty.resolver.AddressResolver<InetSocketAddress> addressResolver;\n+        if (options.isRoundRobinInetAddress()) {\n+          addressResolver = new RoundRobinInetAddressResolver(eventLoop, resolver).asAddressResolver();\n+        } else {\n+          addressResolver = super.newAddressResolver(eventLoop, resolver);\n+        }\n+        resolvers.add(new ResolverRegistration(addressResolver, eventLoop));\n+        return addressResolver;\n       }\n     };\n   }\n", "test_patch": "diff --git a/src/test/java/io/vertx/core/dns/HostnameResolutionTest.java b/src/test/java/io/vertx/core/dns/HostnameResolutionTest.java\nindex d938bbd..1c395d8 100644\n--- a/src/test/java/io/vertx/core/dns/HostnameResolutionTest.java\n+++ b/src/test/java/io/vertx/core/dns/HostnameResolutionTest.java\n@@ -31,10 +31,13 @@ import io.vertx.core.net.NetServerOptions;\n import io.vertx.test.core.TestUtils;\n import io.vertx.test.core.VertxTestBase;\n import io.vertx.test.fakedns.FakeDNSServer;\n+import org.apache.directory.server.dns.DnsException;\n+import org.apache.directory.server.dns.messages.QuestionRecord;\n import org.apache.directory.server.dns.messages.RecordClass;\n import org.apache.directory.server.dns.messages.RecordType;\n import org.apache.directory.server.dns.messages.ResourceRecord;\n import org.apache.directory.server.dns.store.DnsAttribute;\n+import org.apache.directory.server.dns.store.RecordStore;\n import org.junit.Test;\n \n import java.io.File;\n@@ -90,6 +93,24 @@ public class HostnameResolutionTest extends VertxTestBase {\n   }\n \n   @Test\n+  public void testAsyncResolveTruncated() throws Exception {\n+\n+    dnsServer.store(new RecordStore() {\n+      @Override\n+      public Set<ResourceRecord> getRecords(QuestionRecord question) throws DnsException {\n+        return Collections.singleton(new FakeDNSServer.VertxResourceRecord(\"vertx.io\", \"127.0.0.1\").setTruncated(true));\n+      }\n+    });\n+\n+\n+    ((VertxImpl) vertx).resolveAddress(\"vertx.io\", onSuccess(resolved -> {\n+      assertEquals(\"127.0.0.1\", resolved.getHostAddress());\n+      testComplete();\n+    }));\n+    await();\n+  }\n+\n+  @Test\n   public void testAsyncResolveFail() throws Exception {\n     ((VertxImpl) vertx).resolveAddress(\"vertx.com\", onFailure(failure -> {\n       assertTrue(\"Was expecting \" + failure + \" to be an instanceof UnknownHostException\", failure instanceof UnknownHostException);\n@@ -864,32 +885,7 @@ public class HostnameResolutionTest extends VertxTestBase {\n   }\n \n   private void testAddressSelection(AddressResolverOptions options, int expected) throws Exception {\n-    Function<String, ResourceRecord> createRecord = ipAddress -> new ResourceRecord() {\n-      @Override\n-      public String getDomainName() {\n-        return \"vertx.io\";\n-      }\n-\n-      @Override\n-      public RecordType getRecordType() {\n-        return RecordType.A;\n-      }\n-\n-      @Override\n-      public RecordClass getRecordClass() {\n-        return RecordClass.IN;\n-      }\n-\n-      @Override\n-      public int getTimeToLive() {\n-        return 100;\n-      }\n-\n-      @Override\n-      public String get(String s) {\n-        return DnsAttribute.IP_ADDRESS.equals(s) ? ipAddress : null;\n-      }\n-    };\n+    Function<String, ResourceRecord> createRecord = ipAddress -> new FakeDNSServer.VertxResourceRecord(\"vertx.io\", ipAddress);\n \n     Set<ResourceRecord> records = new LinkedHashSet<>();\n     records.add(createRecord.apply(\"127.0.0.1\"));\ndiff --git a/src/test/java/io/vertx/core/net/ProxyErrorTest.java b/src/test/java/io/vertx/core/net/ProxyErrorTest.java\nindex 8e458bf..91ae912 100644\n--- a/src/test/java/io/vertx/core/net/ProxyErrorTest.java\n+++ b/src/test/java/io/vertx/core/net/ProxyErrorTest.java\n@@ -51,9 +51,7 @@ public class ProxyErrorTest extends VertxTestBase {\n \n   @Override\n   protected void tearDown() throws Exception {\n-    if (dnsServer.isStarted()) {\n-      dnsServer.stop();\n-    }\n+    dnsServer.stop();\n     if (proxy!=null) {\n       proxy.stop();\n     }\ndiff --git a/src/test/java/io/vertx/test/fakedns/FakeDNSServer.java b/src/test/java/io/vertx/test/fakedns/FakeDNSServer.java\nindex 7beb758..808ff1a 100644\n--- a/src/test/java/io/vertx/test/fakedns/FakeDNSServer.java\n+++ b/src/test/java/io/vertx/test/fakedns/FakeDNSServer.java\n@@ -16,25 +16,29 @@ import org.apache.directory.server.dns.DnsServer;\n import org.apache.directory.server.dns.io.encoder.DnsMessageEncoder;\n import org.apache.directory.server.dns.io.encoder.ResourceRecordEncoder;\n import org.apache.directory.server.dns.messages.DnsMessage;\n+import org.apache.directory.server.dns.messages.DnsMessageModifier;\n import org.apache.directory.server.dns.messages.QuestionRecord;\n import org.apache.directory.server.dns.messages.RecordClass;\n import org.apache.directory.server.dns.messages.RecordType;\n import org.apache.directory.server.dns.messages.ResourceRecord;\n import org.apache.directory.server.dns.messages.ResourceRecordModifier;\n import org.apache.directory.server.dns.protocol.DnsProtocolHandler;\n+import org.apache.directory.server.dns.protocol.DnsTcpDecoder;\n import org.apache.directory.server.dns.protocol.DnsUdpDecoder;\n import org.apache.directory.server.dns.protocol.DnsUdpEncoder;\n import org.apache.directory.server.dns.store.DnsAttribute;\n import org.apache.directory.server.dns.store.RecordStore;\n+import org.apache.directory.server.protocol.shared.transport.TcpTransport;\n+import org.apache.directory.server.protocol.shared.transport.Transport;\n import org.apache.directory.server.protocol.shared.transport.UdpTransport;\n import org.apache.mina.core.buffer.IoBuffer;\n+import org.apache.mina.core.service.IoAcceptor;\n import org.apache.mina.core.session.IoSession;\n import org.apache.mina.filter.codec.ProtocolCodecFactory;\n import org.apache.mina.filter.codec.ProtocolCodecFilter;\n import org.apache.mina.filter.codec.ProtocolDecoder;\n import org.apache.mina.filter.codec.ProtocolEncoder;\n import org.apache.mina.filter.codec.ProtocolEncoderOutput;\n-import org.apache.mina.transport.socket.DatagramAcceptor;\n import org.apache.mina.transport.socket.DatagramSessionConfig;\n \n import java.io.IOException;\n@@ -83,7 +87,7 @@ public final class FakeDNSServer extends DnsServer {\n   private String ipAddress = IP_ADDRESS;\n   private int port = PORT;\n   private volatile RecordStore store;\n-  private DatagramAcceptor acceptor;\n+  private List<IoAcceptor> acceptors;\n   private final Deque<DnsMessage> currentMessage = new ArrayDeque<>();\n \n   public FakeDNSServer() {\n@@ -127,7 +131,7 @@ public final class FakeDNSServer extends DnsServer {\n   public FakeDNSServer testResolveAAAA(final String ipAddress) {\n     return store(new RecordStore() {\n       @Override\n-      public Set<ResourceRecord> getRecords(QuestionRecord questionRecord) throws org.apache.directory.server.dns.DnsException {\n+      public Set<ResourceRecord> getRecords(QuestionRecord questionRecord) {\n         Set<ResourceRecord> set = new HashSet<>();\n \n         ResourceRecordModifier rm = new ResourceRecordModifier();\n@@ -146,7 +150,7 @@ public final class FakeDNSServer extends DnsServer {\n   public FakeDNSServer testResolveMX(final int prio, final String mxRecord) {\n     return store(new RecordStore() {\n       @Override\n-      public Set<ResourceRecord> getRecords(QuestionRecord questionRecord) throws org.apache.directory.server.dns.DnsException {\n+      public Set<ResourceRecord> getRecords(QuestionRecord questionRecord) {\n         Set<ResourceRecord> set = new HashSet<>();\n \n         ResourceRecordModifier rm = new ResourceRecordModifier();\n@@ -165,7 +169,7 @@ public final class FakeDNSServer extends DnsServer {\n   public FakeDNSServer testResolveTXT(final String txt) {\n     return store(new RecordStore() {\n       @Override\n-      public Set<ResourceRecord> getRecords(QuestionRecord questionRecord) throws org.apache.directory.server.dns.DnsException {\n+      public Set<ResourceRecord> getRecords(QuestionRecord questionRecord) {\n         Set<ResourceRecord> set = new HashSet<>();\n \n         ResourceRecordModifier rm = new ResourceRecordModifier();\n@@ -359,12 +363,8 @@ public final class FakeDNSServer extends DnsServer {\n \n   @Override\n   public void start() throws IOException {\n-    UdpTransport transport = new UdpTransport(ipAddress, port);\n-    setTransports( transport );\n \n-    acceptor = transport.getAcceptor();\n-\n-    acceptor.setHandler(new DnsProtocolHandler(this, new RecordStore() {\n+    DnsProtocolHandler handler = new DnsProtocolHandler(this, new RecordStore() {\n       @Override\n       public Set<ResourceRecord> getRecords(QuestionRecord question) throws DnsException {\n         RecordStore actual = store;\n@@ -378,41 +378,156 @@ public final class FakeDNSServer extends DnsServer {\n       @Override\n       public void sessionCreated(IoSession session) throws Exception {\n         // Use our own codec to support AAAA testing\n-        session.getFilterChain().addFirst(\"codec\",\n-          new ProtocolCodecFilter(new TestDnsProtocolUdpCodecFactory()));\n+        if (session.getTransportMetadata().isConnectionless()) {\n+          session.getFilterChain().addFirst( \"codec\", new ProtocolCodecFilter(new TestDnsProtocolUdpCodecFactory()));\n+        } else {\n+          session.getFilterChain().addFirst( \"codec\", new ProtocolCodecFilter(new TestDnsProtocolTcpCodecFactory()));\n+        }\n       }\n+\n       @Override\n       public void messageReceived(IoSession session, Object message) {\n         if (message instanceof DnsMessage) {\n           synchronized (FakeDNSServer.this) {\n-           currentMessage.add((DnsMessage) message);\n+            currentMessage.add((DnsMessage) message);\n           }\n         }\n         super.messageReceived(session, message);\n       }\n-    });\n+    };\n \n-    // Allow the port to be reused even if the socket is in TIME_WAIT state\n-    ((DatagramSessionConfig) acceptor.getSessionConfig()).setReuseAddress(true);\n+    UdpTransport udpTransport = new UdpTransport(ipAddress, port);\n+    ((DatagramSessionConfig)udpTransport.getAcceptor().getSessionConfig()).setReuseAddress(true);\n+    TcpTransport tcpTransport = new TcpTransport(ipAddress, port);\n+    tcpTransport.getAcceptor().getSessionConfig().setReuseAddress(true);\n \n-    // Start the listener\n-    acceptor.bind();\n-  }\n+    setTransports(udpTransport, tcpTransport);\n+\n+    for  (Transport transport : getTransports()) {\n+      IoAcceptor acceptor = transport.getAcceptor();\n+\n+      acceptor.setHandler(handler);\n \n+      // Start the listener\n+      acceptor.bind();\n+    }\n+  }\n \n   @Override\n   public void stop() {\n-    acceptor.dispose();\n+    for (Transport transport : getTransports()) {\n+      System.out.println(\"closing \" +transport);\n+      transport.getAcceptor().dispose();\n+    }\n   }\n \n+  public static class VertxResourceRecord implements ResourceRecord {\n+\n+    private final String ipAddress;\n+    private final String domainName;\n+    private boolean isTruncated;\n+\n+    public VertxResourceRecord(String domainName, String ipAddress) {\n+      this.domainName = domainName;\n+      this.ipAddress = ipAddress;\n+    }\n+\n+    public boolean isTruncated() {\n+      return isTruncated;\n+    }\n+\n+    public VertxResourceRecord setTruncated(boolean truncated) {\n+      isTruncated = truncated;\n+      return this;\n+    }\n+\n+    @Override\n+    public String getDomainName() {\n+      return domainName;\n+    }\n+\n+    @Override\n+    public RecordType getRecordType() {\n+      return RecordType.A;\n+    }\n+\n+    @Override\n+    public RecordClass getRecordClass() {\n+      return RecordClass.IN;\n+    }\n+\n+    @Override\n+    public int getTimeToLive() {\n+      return 100;\n+    }\n+\n+    @Override\n+    public String get(String id) {\n+      return DnsAttribute.IP_ADDRESS.equals(id) ? ipAddress : null;\n+    }\n+  }\n+\n+  private static final ResourceRecordEncoder TestAAAARecordEncoder = new ResourceRecordEncoder() {\n+    @Override\n+    protected void putResourceRecordData(IoBuffer ioBuffer, ResourceRecord resourceRecord) {\n+      if (!resourceRecord.get(DnsAttribute.IP_ADDRESS).equals(\"::1\")) {\n+        throw new IllegalStateException(\"Only supposed to be used with IPV6 address of ::1\");\n+      }\n+      // encode the ::1\n+      ioBuffer.put(new byte[]{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1});\n+    }\n+  };\n+\n+  private final DnsMessageEncoder encoder = new DnsMessageEncoder();\n+\n+  private void encode(DnsMessage dnsMessage, IoBuffer buf) {\n+\n+    // Hack\n+    if (dnsMessage.getAnswerRecords().size() == 1 && dnsMessage.getAnswerRecords().get(0) instanceof VertxResourceRecord) {\n+      VertxResourceRecord vrr = (VertxResourceRecord) dnsMessage.getAnswerRecords().get(0);\n+\n+      DnsMessageModifier modifier = new DnsMessageModifier();\n+      modifier.setTransactionId(dnsMessage.getTransactionId());\n+      modifier.setMessageType(dnsMessage.getMessageType());\n+      modifier.setOpCode(dnsMessage.getOpCode());\n+      modifier.setAuthoritativeAnswer(dnsMessage.isAuthoritativeAnswer());\n+      modifier.setTruncated(dnsMessage.isTruncated());\n+      modifier.setRecursionDesired(dnsMessage.isRecursionDesired());\n+      modifier.setRecursionAvailable(dnsMessage.isRecursionAvailable());\n+      modifier.setReserved(dnsMessage.isReserved());\n+      modifier.setAcceptNonAuthenticatedData(dnsMessage.isAcceptNonAuthenticatedData());\n+      modifier.setResponseCode(dnsMessage.getResponseCode());\n+      modifier.setQuestionRecords(dnsMessage.getQuestionRecords());\n+      modifier.setAnswerRecords(dnsMessage.getAnswerRecords());\n+      modifier.setAuthorityRecords(dnsMessage.getAuthorityRecords());\n+      modifier.setAdditionalRecords(dnsMessage.getAdditionalRecords());\n+\n+      modifier.setTruncated(vrr.isTruncated);\n+\n+      dnsMessage = modifier.getDnsMessage();\n+    }\n+\n+    encoder.encode(buf, dnsMessage);\n+\n+    for (ResourceRecord record: dnsMessage.getAnswerRecords()) {\n+      // This is a hack to allow to also test for AAAA resolution as DnsMessageEncoder does not support it and it\n+      // is hard to extend, because the interesting methods are private...\n+      // In case of RecordType.AAAA we need to encode the RecordType by ourself\n+      if (record.getRecordType() == RecordType.AAAA) {\n+        try {\n+          TestAAAARecordEncoder.put(buf, record);\n+        } catch (IOException e) {\n+          // Should never happen\n+          throw new IllegalStateException(e);\n+        }\n+      }\n+    }\n+  }\n \n   /**\n    * ProtocolCodecFactory which allows to test AAAA resolution\n    */\n   private final class TestDnsProtocolUdpCodecFactory implements ProtocolCodecFactory {\n-    private DnsMessageEncoder encoder = new DnsMessageEncoder();\n-    private TestAAAARecordEncoder recordEncoder = new TestAAAARecordEncoder();\n-\n     @Override\n     public ProtocolEncoder getEncoder(IoSession session) throws Exception {\n       return new DnsUdpEncoder() {\n@@ -420,23 +535,8 @@ public final class FakeDNSServer extends DnsServer {\n         @Override\n         public void encode(IoSession session, Object message, ProtocolEncoderOutput out) {\n           IoBuffer buf = IoBuffer.allocate( 1024 );\n-          DnsMessage dnsMessage = (DnsMessage) message;\n-          encoder.encode(buf, dnsMessage);\n-          for (ResourceRecord record: dnsMessage.getAnswerRecords()) {\n-            // This is a hack to allow to also test for AAAA resolution as DnsMessageEncoder does not support it and it\n-            // is hard to extend, because the interesting methods are private...\n-            // In case of RecordType.AAAA we need to encode the RecordType by ourself\n-            if (record.getRecordType() == RecordType.AAAA) {\n-              try {\n-                recordEncoder.put(buf, record);\n-              } catch (IOException e) {\n-                // Should never happen\n-                throw new IllegalStateException(e);\n-              }\n-            }\n-          }\n+          FakeDNSServer.this.encode((DnsMessage)message, buf);\n           buf.flip();\n-\n           out.write( buf );\n         }\n       };\n@@ -446,16 +546,36 @@ public final class FakeDNSServer extends DnsServer {\n     public ProtocolDecoder getDecoder(IoSession session) throws Exception {\n       return new DnsUdpDecoder();\n     }\n+  }\n \n-    private final class TestAAAARecordEncoder extends ResourceRecordEncoder {\n-      @Override\n-      protected void putResourceRecordData(IoBuffer ioBuffer, ResourceRecord resourceRecord) {\n-        if (!resourceRecord.get(DnsAttribute.IP_ADDRESS).equals(\"::1\")) {\n-          throw new IllegalStateException(\"Only supposed to be used with IPV6 address of ::1\");\n+  /**\n+   * ProtocolCodecFactory which allows to test AAAA resolution\n+   */\n+  private final class TestDnsProtocolTcpCodecFactory implements ProtocolCodecFactory {\n+    @Override\n+    public ProtocolEncoder getEncoder(IoSession session) throws Exception {\n+      return new DnsUdpEncoder() {\n+\n+        @Override\n+        public void encode(IoSession session, Object message, ProtocolEncoderOutput out) {\n+          IoBuffer buf = IoBuffer.allocate( 1024 );\n+          buf.putShort( ( short ) 0 );\n+          FakeDNSServer.this.encode((DnsMessage) message, buf);\n+          encoder.encode( buf, ( DnsMessage ) message );\n+          int end = buf.position();\n+          short recordLength = ( short ) ( end - 2 );\n+          buf.rewind();\n+          buf.putShort( recordLength );\n+          buf.position( end );\n+          buf.flip();\n+          out.write( buf );\n         }\n-        // encode the ::1\n-        ioBuffer.put(new byte[]{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1});\n-      }\n+      };\n+    }\n+\n+    @Override\n+    public ProtocolDecoder getDecoder(IoSession session) throws Exception {\n+      return new DnsTcpDecoder();\n     }\n   }\n }\n"}
{"repository": "eclipse-vertx/vert.x", "clone_url": "https://github.com/eclipse-vertx/vert.x.git", "timestamp": "2023-06-01T05:30:12.666505Z", "commit_hash": "37e3f1dafd7899b7401a2aa606e7b36740cb54da", "commit_message": "Fix issue 4255 - HTTP header values verifier is laxer than what's advised in the RFCs\n\nAccording to :\n- https://datatracker.ietf.org/doc/html/rfc7230#section-3.2\n- https://datatracker.ietf.org/doc/html/rfc5234#appendix-B.1\n- https://datatracker.ietf.org/doc/html/rfc7540#section-10.3\n\nFor both HTTP/1.1 and HTTP/2.0 versions, bytes allowed for header value are : CR (0x0D), LF (0x0A), SP (0x20), HTAB (0x09) and ranges 0x21 to 0x7E and 0x80 to 0xFF (although the last range is considered as obsolete)\n\nFor more information, see the related issue : https://github.com/eclipse-vertx/vert.x/issues/4255\n\nSigned-off-by: Nils Renaud <renaud.nils@gmail.com>\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/io/vertx/core/http/impl/HttpUtils.java b/src/main/java/io/vertx/core/http/impl/HttpUtils.java\nindex b820df4..5ab9051 100644\n--- a/src/main/java/io/vertx/core/http/impl/HttpUtils.java\n+++ b/src/main/java/io/vertx/core/http/impl/HttpUtils.java\n@@ -795,7 +795,7 @@ public final class HttpUtils {\n     }\n   }\n \n-  private static final int HIGHEST_INVALID_VALUE_CHAR_MASK = ~15;\n+  private static final int HIGHEST_INVALID_VALUE_CHAR_MASK = ~0x1F;\n \n   private static int validateValueChar(CharSequence seq, int state, char character) {\n     /*\n@@ -804,15 +804,15 @@ public final class HttpUtils {\n      * 1: The previous character was CR\n      * 2: The previous character was LF\n      */\n-    if ((character & HIGHEST_INVALID_VALUE_CHAR_MASK) == 0) {\n-      // Check the absolutely prohibited characters.\n+    if ((character & HIGHEST_INVALID_VALUE_CHAR_MASK) == 0 || character == 0x7F) { // 0x7F is \"DEL\".\n+      // The only characters allowed in the range 0x00-0x1F are : HTAB, LF and CR\n       switch (character) {\n-        case 0x0: // NULL\n-          throw new IllegalArgumentException(\"a header value contains a prohibited character '\\0': \" + seq);\n-        case 0x0b: // Vertical tab\n-          throw new IllegalArgumentException(\"a header value contains a prohibited character '\\\\v': \" + seq);\n-        case '\\f':\n-          throw new IllegalArgumentException(\"a header value contains a prohibited character '\\\\f': \" + seq);\n+        case 0x09: // Horizontal tab - HTAB\n+        case 0x0a: // Line feed - LF\n+        case 0x0d: // Carriage return - CR\n+          break;\n+        default:\n+          throw new IllegalArgumentException(\"a header value contains a prohibited character '\" + (int) character + \"': \" + seq);\n       }\n     }\n \n", "test_patch": "diff --git a/src/test/java/io/vertx/core/http/Http1xTest.java b/src/test/java/io/vertx/core/http/Http1xTest.java\nindex 6755ebb..73e5c94 100644\n--- a/src/test/java/io/vertx/core/http/Http1xTest.java\n+++ b/src/test/java/io/vertx/core/http/Http1xTest.java\n@@ -4713,7 +4713,14 @@ public class Http1xTest extends HttpTest {\n \n   @Test\n   public void testHeaderValueValidation() {\n-    List<String> invalid = Arrays.asList(\"\\f\", \"\\0\", \"\\u000b\", \"\\r\\n3\", \"\\r3\", \"\\n3\", \"\\n\\r\");\n+    List<String> invalid = Arrays.asList(\n+      \"\\u0000\", \"\\u0001\", \"\\u0002\", \"\\u0003\", \"\\u0004\", \"\\u0005\", \"\\u0006\", \"\\u0007\", \"\\u0008\", /* HTAB */ /* LF */\n+      \"\\u000b\", \"\\u000c\", /* CR  */ \"\\u000e\", \"\\u000f\", \"\\u0010\", \"\\u0011\", \"\\u0012\", \"\\u0013\", \"\\u0014\", \"\\u0015\",\n+      \"\\u0016\", \"\\u0017\", \"\\u0018\", \"\\u0019\", \"\\u001a\", \"\\u001b\", \"\\u001c\", \"\\u001d\", \"\\u001e\", \"\\u001f\", /* SP */\n+      /* u0021-u007e */\n+      \"\\u007F\",\n+      /* u0080-u00FF obsolete but still accepted */\n+      \"\\r\\n3\", \"\\r3\", \"\\n3\", \"\\n\\r\");\n     for (String test : invalid) {\n       try {\n         HttpUtils.validateHeaderValue(test);\n"}
{"repository": "eclipse-vertx/vert.x", "clone_url": "https://github.com/eclipse-vertx/vert.x.git", "timestamp": "2023-06-01T05:50:18.104684Z", "commit_hash": "9784d3a2e8cd9306fc24d0bc38167aa4d4a827d3", "commit_message": "bugfix: Http1xServerResponse endHandler not called when sending a file. fixes #4302\n\nSigned-off-by: Markus Spika <markus.spika@gmail.com>\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/io/vertx/core/http/impl/Http1xServerResponse.java b/src/main/java/io/vertx/core/http/impl/Http1xServerResponse.java\nindex c73183b..9ee3336 100644\n--- a/src/main/java/io/vertx/core/http/impl/Http1xServerResponse.java\n+++ b/src/main/java/io/vertx/core/http/impl/Http1xServerResponse.java\n@@ -604,13 +604,20 @@ public class Http1xServerResponse implements HttpServerResponse, HttpResponse {\n           handler = bodyEndHandler;\n         }\n         if (handler != null) {\n-          context.emit(v -> {\n-            handler.handle(null);\n-          });\n+          context.emit(handler);\n         }\n \n         // allow to write next response\n         conn.responseComplete();\n+\n+        // signal end handler\n+        Handler<Void> end;\n+        synchronized (conn) {\n+          end = !closed ? endHandler : null;\n+        }\n+        if (null != end) {\n+          context.emit(end);\n+        }\n       });\n     }\n   }\n", "test_patch": "diff --git a/src/test/java/io/vertx/core/http/HttpTest.java b/src/test/java/io/vertx/core/http/HttpTest.java\nindex 22b01ab..cd1a5ec 100644\n--- a/src/test/java/io/vertx/core/http/HttpTest.java\n+++ b/src/test/java/io/vertx/core/http/HttpTest.java\n@@ -658,7 +658,7 @@ public abstract class HttpTest extends HttpTestBase {\n \n   @Test\n   public void testResponseEndHandlersSendFile() throws Exception {\n-    waitFor(2);\n+    waitFor(4);\n     AtomicInteger cnt = new AtomicInteger();\n     String content = \"iqdioqwdqwiojqwijdwqd\";\n     File toSend = setupFile(\"somefile.txt\", content);\n@@ -667,12 +667,14 @@ public abstract class HttpTest extends HttpTestBase {\n         // Insert another header\n         req.response().putHeader(\"extraheader\", \"wibble\");\n         assertEquals(0, cnt.getAndIncrement());\n+        complete();\n       });\n       req.response().bodyEndHandler(v -> {\n         assertEquals(content.length(), req.response().bytesWritten());\n         assertEquals(1, cnt.getAndIncrement());\n         complete();\n       });\n+      req.response().endHandler(v -> complete());\n       req.response().sendFile(toSend.getAbsolutePath());\n     }).listen(testAddress, onSuccess(server -> {\n       client.request(requestOptions).onComplete(onSuccess(req -> {\ndiff --git a/src/test/java/io/vertx/core/http/HttpTestBase.java b/src/test/java/io/vertx/core/http/HttpTestBase.java\nindex ff8363b..7f1350b 100644\n--- a/src/test/java/io/vertx/core/http/HttpTestBase.java\n+++ b/src/test/java/io/vertx/core/http/HttpTestBase.java\n@@ -11,22 +11,19 @@\n \n package io.vertx.core.http;\n \n-import io.vertx.core.AsyncResult;\n import io.vertx.core.Context;\n import io.vertx.core.Future;\n import io.vertx.core.Handler;\n import io.vertx.core.net.ProxyType;\n import io.vertx.core.net.SocketAddress;\n+import io.vertx.test.core.VertxTestBase;\n import io.vertx.test.proxy.HttpProxy;\n import io.vertx.test.proxy.SocksProxy;\n import io.vertx.test.proxy.TestProxyBase;\n-import io.vertx.test.core.VertxTestBase;\n \n import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n \n /**\n  * @author <a href=\"http://tfox.org\">Tim Fox</a>\n"}
{"repository": "eclipse-vertx/vert.x", "clone_url": "https://github.com/eclipse-vertx/vert.x.git", "timestamp": "2023-06-01T06:10:23.423426Z", "commit_hash": "ec79d00b63884d9ef629cd10a2d94cd25cce164c", "commit_message": "The ConnectionBase discards incoming message when the connection has been marked as closed, we should always accept such messages otherwise we might lose messages when a connection is closed proactively when a message read is in progress.\n\nfixes #4285\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/io/vertx/core/net/impl/ConnectionBase.java b/src/main/java/io/vertx/core/net/impl/ConnectionBase.java\nindex 9fe8c88..295d501 100644\n--- a/src/main/java/io/vertx/core/net/impl/ConnectionBase.java\n+++ b/src/main/java/io/vertx/core/net/impl/ConnectionBase.java\n@@ -149,14 +149,10 @@ public abstract class ConnectionBase {\n    */\n   final void read(Object msg) {\n     read = true;\n-    if (!closed) {\n-      if (METRICS_ENABLED) {\n-        reportBytesRead(msg);\n-      }\n-      handleMessage(msg);\n-    } else {\n-      ReferenceCountUtil.release(msg);\n+    if (METRICS_ENABLED) {\n+      reportBytesRead(msg);\n     }\n+    handleMessage(msg);\n   }\n \n   /**\n", "test_patch": "diff --git a/src/test/java/io/vertx/core/http/HttpTest.java b/src/test/java/io/vertx/core/http/HttpTest.java\nindex 6d830d3..22b01ab 100644\n--- a/src/test/java/io/vertx/core/http/HttpTest.java\n+++ b/src/test/java/io/vertx/core/http/HttpTest.java\n@@ -3619,7 +3619,6 @@ public abstract class HttpTest extends HttpTestBase {\n       conn.closeHandler(v -> complete());\n     });\n     server.requestHandler(req -> {\n-      fail();\n     });\n     startServer(testAddress, serverCtx, server);\n     client.connectionHandler(conn -> {\ndiff --git a/src/test/java/io/vertx/core/net/NetTest.java b/src/test/java/io/vertx/core/net/NetTest.java\nindex 449bf8a..e453319 100755\n--- a/src/test/java/io/vertx/core/net/NetTest.java\n+++ b/src/test/java/io/vertx/core/net/NetTest.java\n@@ -15,6 +15,7 @@ import io.netty.buffer.ByteBuf;\n import io.netty.buffer.Unpooled;\n import io.netty.channel.ChannelHandlerAdapter;\n import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n import io.netty.channel.ChannelPipeline;\n import io.netty.channel.ConnectTimeoutException;\n import io.netty.handler.codec.http.HttpMethod;\n@@ -1071,6 +1072,29 @@ public class NetTest extends VertxTestBase {\n   }\n \n   @Test\n+  public void testReceiveMessageAfterExplicitClose() throws Exception {\n+    server.connectHandler(so -> {\n+      so.write(\"Hello World\");\n+    });\n+    startServer();\n+    client.connect(testAddress, onSuccess(so -> {\n+      NetSocketInternal soi = (NetSocketInternal) so;\n+      soi.channelHandlerContext().pipeline().addFirst(new ChannelInboundHandlerAdapter() {\n+        @Override\n+        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+          so.close();\n+          super.channelRead(ctx, msg);\n+        }\n+      });\n+      so.handler(buff -> {\n+        assertEquals(\"Hello World\", buff.toString());\n+        testComplete();\n+      });\n+    }));\n+    await();\n+  }\n+\n+  @Test\n   public void testClientDrainHandler() {\n     pausingServer((s) -> {\n       client.connect(testAddress, onSuccess(sock -> {\n"}
{"repository": "eclipse-vertx/vert.x", "clone_url": "https://github.com/eclipse-vertx/vert.x.git", "timestamp": "2023-06-01T06:30:28.576763Z", "commit_hash": "b31fe3ce008ff86946d7f07cec3bfb1cf25fea00", "commit_message": "The pool state machine implementation does not notify the connection slot promise on a connect failure after the pool is closed. It is required to resolve this promise so pool implementation using the state machine can progress.\n\nThe ConnectFailed post task has been updated to resolve the promise when the pool has already been closed.\n\nfixes #4284\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/io/vertx/core/net/impl/pool/SimpleConnectionPool.java b/src/main/java/io/vertx/core/net/impl/pool/SimpleConnectionPool.java\nindex 1c78347..a032986 100644\n--- a/src/main/java/io/vertx/core/net/impl/pool/SimpleConnectionPool.java\n+++ b/src/main/java/io/vertx/core/net/impl/pool/SimpleConnectionPool.java\n@@ -366,20 +366,20 @@ public class SimpleConnectionPool<C> implements ConnectionPool<C> {\n       } else {\n         waiter.disposed = true;\n       }\n-      if (pool.closed) {\n-        return new Task() {\n-          @Override\n-          public void run() {\n-            waiter.handler.handle(POOL_CLOSED);\n-          }\n-        };\n+      if (!pool.closed) {\n+        pool.remove(removed);\n       }\n-      pool.remove(removed);\n       return new Task() {\n         @Override\n         public void run() {\n           if (waiter != null) {\n-            removed.context.emit(Future.failedFuture(cause), waiter.handler);\n+            Future<Lease<C>> waiterFailure;\n+            if (pool.closed) {\n+              waiterFailure = POOL_CLOSED;\n+            } else {\n+              waiterFailure = Future.failedFuture(cause);\n+            }\n+            removed.context.emit(waiterFailure, waiter.handler);\n           }\n           removed.result.fail(cause);\n         }\n@@ -776,8 +776,10 @@ public class SimpleConnectionPool<C> implements ConnectionPool<C> {\n       for (int i = 0;i < pool.size;i++) {\n         Slot<C> slot = pool.slots[i];\n         pool.slots[i] = null;\n-        if (slot.initiator != null) {\n+        PoolWaiter<C> waiter = slot.initiator;\n+        if (waiter != null) {\n           waiters.add(slot.initiator);\n+          slot.initiator.disposed = true;\n           slot.initiator = null;\n         }\n         pool.capacity -= slot.capacity;\n", "test_patch": "diff --git a/src/test/java/io/vertx/core/net/impl/pool/ConnectionPoolTest.java b/src/test/java/io/vertx/core/net/impl/pool/ConnectionPoolTest.java\nindex ef9811e..2052fed 100644\n--- a/src/test/java/io/vertx/core/net/impl/pool/ConnectionPoolTest.java\n+++ b/src/test/java/io/vertx/core/net/impl/pool/ConnectionPoolTest.java\n@@ -654,6 +654,48 @@ public class ConnectionPoolTest extends VertxTestBase {\n   }\n \n   @Test\n+  public void testConnectSuccessAfterClose() {\n+    testConnectResultAfterClose(true);\n+  }\n+\n+  @Test\n+  public void testConnectFailureAfterClose() {\n+    testConnectResultAfterClose(false);\n+  }\n+\n+  private void testConnectResultAfterClose(boolean success) {\n+    ConnectionManager mgr = new ConnectionManager();\n+    ConnectionPool<Connection> pool = ConnectionPool.pool(mgr, new int[] { 1 });\n+    EventLoopContext ctx = vertx.createEventLoopContext();\n+    AtomicInteger acquired = new AtomicInteger();\n+    pool.acquire(ctx,0, ar -> {\n+      assertEquals(0, acquired.getAndIncrement());\n+    });\n+    assertEquals(1, pool.size());\n+    ConnectionRequest request = mgr.assertRequest();\n+    Promise<List<Future<Connection>>> closeResult = Promise.promise();\n+    pool.close(closeResult);\n+    Throwable cause = new Throwable();\n+    Connection expected = new Connection();\n+    if (success) {\n+      request.connect(expected, 0);\n+    } else {\n+      request.fail(cause);\n+    }\n+    assertTrue(closeResult.future().isComplete());\n+    List<Future<Connection>> connections = closeResult.future().result();\n+    assertEquals(1, connections.size());\n+    assertEquals(success, connections.get(0).succeeded());\n+    assertEquals(0, pool.size());\n+    if (success) {\n+      assertEquals(expected, connections.get(0).result());\n+    } else {\n+      assertEquals(cause, connections.get(0).cause());\n+    }\n+    waitUntil(() -> acquired.get() == 1);\n+  }\n+\n+  @Test\n   public void testCancelQueuedWaiters() throws Exception {\n     waitFor(1);\n     EventLoopContext context = vertx.createEventLoopContext();\n"}
{"repository": "eclipse-vertx/vert.x", "clone_url": "https://github.com/eclipse-vertx/vert.x.git", "timestamp": "2023-06-01T07:13:00.449037Z", "commit_hash": "118ebe7026c7a087a08bcfa923482cc6e61f6d09", "commit_message": "Merge pull request #4253 from eclipse-vertx/issues/potential-bugs\n\nFixing small potential bugs: NPE, Resource leak, invalid branch", "related_issues": "", "bug_patch": "diff --git a/src/main/java/io/vertx/core/http/impl/HttpClientPush.java b/src/main/java/io/vertx/core/http/impl/HttpClientPush.java\nindex 1e04b06..afc4483 100644\n--- a/src/main/java/io/vertx/core/http/impl/HttpClientPush.java\n+++ b/src/main/java/io/vertx/core/http/impl/HttpClientPush.java\n@@ -34,7 +34,7 @@ public class HttpClientPush implements HttpRequest {\n     String rawMethod = headers.method().toString();\n     String authority = headers.authority() != null ? headers.authority().toString() : null;\n     MultiMap headersMap = new Http2HeadersAdaptor(headers);\n-    int pos = authority.indexOf(':');\n+    int pos = authority == null ? -1 : authority.indexOf(':');\n     if (pos == -1) {\n       this.host = authority;\n       this.port = 80;\ndiff --git a/src/main/java/io/vertx/core/json/impl/JsonUtil.java b/src/main/java/io/vertx/core/json/impl/JsonUtil.java\nindex dbab910..8137e15 100644\n--- a/src/main/java/io/vertx/core/json/impl/JsonUtil.java\n+++ b/src/main/java/io/vertx/core/json/impl/JsonUtil.java\n@@ -106,14 +106,12 @@ public final class JsonUtil {\n       val = val.toString();\n     } else if (val instanceof Shareable) {\n       // Shareable objects know how to copy themselves, this covers:\n-      // JsonObject, JsonArray or any user defined type that can shared across the cluster\n+      // JsonObject, JsonArray, Buffer or any user defined type that can shared across the cluster\n       val = ((Shareable) val).copy();\n     } else if (val instanceof Map) {\n       val = (new JsonObject((Map) val)).copy(copier);\n     } else if (val instanceof List) {\n       val = (new JsonArray((List) val)).copy(copier);\n-    } else if (val instanceof Buffer) {\n-      val = ((Buffer) val).copy();\n     } else if (val instanceof byte[]) {\n       // OK\n     } else if (val instanceof Instant) {\ndiff --git a/src/main/java/io/vertx/core/json/jackson/JacksonCodec.java b/src/main/java/io/vertx/core/json/jackson/JacksonCodec.java\nindex 03e4fae..81fd977 100644\n--- a/src/main/java/io/vertx/core/json/jackson/JacksonCodec.java\n+++ b/src/main/java/io/vertx/core/json/jackson/JacksonCodec.java\n@@ -105,6 +105,9 @@ public class JacksonCodec implements JsonCodec {\n   @Override\n   public Buffer toBuffer(Object object, boolean pretty) throws EncodeException {\n     ByteBuf buf = Unpooled.buffer();\n+    // There is no need to use a try with resources here as jackson\n+    // is a well-behaved and always calls the closes all streams in the\n+    // \"finally\" block bellow.\n     ByteBufOutputStream out = new ByteBufOutputStream(buf);\n     JsonGenerator generator = createGenerator(out, pretty);\n     try {\n", "test_patch": "diff --git a/src/test/java/io/vertx/core/json/JacksonTest.java b/src/test/java/io/vertx/core/json/JacksonTest.java\nindex 54a690a..e10804b 100644\n--- a/src/test/java/io/vertx/core/json/JacksonTest.java\n+++ b/src/test/java/io/vertx/core/json/JacksonTest.java\n@@ -11,10 +11,14 @@\n \n package io.vertx.core.json;\n \n+import io.vertx.core.buffer.Buffer;\n import io.vertx.core.json.jackson.JacksonCodec;\n import io.vertx.test.core.VertxTestBase;\n import org.junit.Test;\n \n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n /**\n  * @author <a href=\"mailto:julien@julienviet.com\">Julien Viet</a>\n  */\n@@ -57,4 +61,12 @@ public class JacksonTest extends VertxTestBase {\n       assertTrue(e.getMessage().contains(MyPojo.class.getName()));\n     }\n   }\n+\n+  @Test(expected = EncodeException.class)\n+  public void encodeToBuffer() {\n+    // if other than EncodeException happens here, then\n+    // there is probably a leak closing the netty buffer output stream\n+    codec.toBuffer(new RuntimeException(\"Unsupported\"));\n+  }\n+\n }\n"}
{"repository": "eclipse-vertx/vert.x", "clone_url": "https://github.com/eclipse-vertx/vert.x.git", "timestamp": "2023-06-01T07:33:07.254940Z", "commit_hash": "53dacca6a15c4512d4fc8b2adc486cf4d64fdc59", "commit_message": "HttpClientMetrics is closed twice, the HttpClientImpl should avoid closing it, since NetClientImpl will close it.\n\nfixes #4248\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/io/vertx/core/http/impl/HttpClientImpl.java b/src/main/java/io/vertx/core/http/impl/HttpClientImpl.java\nindex 11b6b5d..1c67595 100644\n--- a/src/main/java/io/vertx/core/http/impl/HttpClientImpl.java\n+++ b/src/main/java/io/vertx/core/http/impl/HttpClientImpl.java\n@@ -486,9 +486,6 @@ public class HttpClientImpl implements HttpClient, MetricsProvider, Closeable {\n     }\n     webSocketCM.close();\n     httpCM.close();\n-    if (metrics != null) {\n-      metrics.close();\n-    }\n     completion.complete();\n   }\n \n", "test_patch": "diff --git a/src/test/java/io/vertx/test/fakemetrics/FakeMetricsBase.java b/src/test/java/io/vertx/test/fakemetrics/FakeMetricsBase.java\nindex 0b0ee30..d2ef882 100644\n--- a/src/test/java/io/vertx/test/fakemetrics/FakeMetricsBase.java\n+++ b/src/test/java/io/vertx/test/fakemetrics/FakeMetricsBase.java\n@@ -23,6 +23,8 @@ public class FakeMetricsBase implements Metrics {\n \n   private static volatile Throwable unexpectedError;\n \n+  private boolean closed;\n+\n   public static <M extends FakeMetricsBase> M getMetrics(Measured measured) {\n     return (M) ((MetricsProvider) measured).getMetrics();\n   }\n@@ -43,4 +45,12 @@ public class FakeMetricsBase implements Metrics {\n       throw afe;\n     }\n   }\n+\n+  @Override\n+  public synchronized void close() {\n+    if (closed) {\n+      registerFailure(new IllegalStateException(getClass().getSimpleName() + \" already closed\"));\n+    }\n+    closed = true;\n+  }\n }\n"}
{"repository": "eclipse-vertx/vert.x", "clone_url": "https://github.com/eclipse-vertx/vert.x.git", "timestamp": "2023-06-01T07:53:12.861045Z", "commit_hash": "dd92f2cb88e50fcb360b7af1299b1e355c93b1b2", "commit_message": "bugfix: future for empty http 2 response does not complete. fixes #4233\n\nSigned-off-by: Markus Spika <markus.spika@gmail.com>\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/io/vertx/core/http/impl/Http2ServerResponse.java b/src/main/java/io/vertx/core/http/impl/Http2ServerResponse.java\nindex cfc9b18..d22b0ee 100644\n--- a/src/main/java/io/vertx/core/http/impl/Http2ServerResponse.java\n+++ b/src/main/java/io/vertx/core/http/impl/Http2ServerResponse.java\n@@ -436,6 +436,7 @@ public class Http2ServerResponse implements HttpServerResponse, HttpResponse {\n   void write(ByteBuf chunk, boolean end, Handler<AsyncResult<Void>> handler) {\n     Handler<Void> bodyEndHandler;\n     Handler<Void> endHandler;\n+    boolean invokeHandler = false;\n     synchronized (conn) {\n       if (ended) {\n         throw new IllegalStateException(\"Response has already been written\");\n@@ -453,6 +454,8 @@ public class Http2ServerResponse implements HttpServerResponse, HttpResponse {\n       boolean sent = checkSendHeaders(end && !hasBody && trailers == null);\n       if (hasBody || (!sent && end)) {\n         stream.writeData(chunk, end && trailers == null, handler);\n+      } else {\n+        invokeHandler = true;\n       }\n       if (end && trailers != null) {\n         stream.writeHeaders(trailers, true, null);\n@@ -467,6 +470,9 @@ public class Http2ServerResponse implements HttpServerResponse, HttpResponse {\n       if (endHandler != null) {\n         endHandler.handle(null);\n       }\n+      if (invokeHandler) {\n+        handler.handle(Future.succeededFuture());\n+      }\n     }\n   }\n \n", "test_patch": "diff --git a/src/test/java/io/vertx/core/http/HttpTest.java b/src/test/java/io/vertx/core/http/HttpTest.java\nindex c57bbcc..6d830d3 100644\n--- a/src/test/java/io/vertx/core/http/HttpTest.java\n+++ b/src/test/java/io/vertx/core/http/HttpTest.java\n@@ -20,8 +20,6 @@ import io.vertx.core.Future;\n import io.vertx.core.*;\n import io.vertx.core.buffer.Buffer;\n import io.vertx.core.dns.AddressResolverOptions;\n-import io.vertx.core.file.AsyncFile;\n-import io.vertx.core.http.impl.CookieImpl;\n import io.vertx.core.http.impl.HttpServerRequestInternal;\n import io.vertx.core.http.impl.ServerCookie;\n import io.vertx.core.impl.Utils;\n@@ -36,14 +34,12 @@ import io.vertx.test.fakestream.FakeStream;\n import io.vertx.test.netty.TestLoggerFactory;\n import io.vertx.test.proxy.HAProxy;\n import org.junit.Assume;\n-import org.junit.Ignore;\n import org.junit.Rule;\n import org.junit.Test;\n import org.junit.rules.TemporaryFolder;\n \n import java.io.*;\n import java.net.ServerSocket;\n-import java.net.URLDecoder;\n import java.net.URLEncoder;\n import java.text.DateFormat;\n import java.text.SimpleDateFormat;\n@@ -6632,4 +6628,41 @@ public abstract class HttpTest extends HttpTestBase {\n       }));\n     await();\n   }\n+\n+  @Test\n+  public void testResponseEndFutureCompletes_WithoutBody() throws Exception {\n+      testResponseEndFutureCompletes(HttpServerResponse::end);\n+  }\n+\n+  @Test\n+  public void testResponseEndFutureCompletes_WithBody() throws Exception {\n+    testResponseEndFutureCompletes(httpServerResponse -> httpServerResponse.end(\"hello\"));\n+  }\n+\n+  @Test\n+  public void testResponseEndFutureCompletes_ChunkedWithoutBody() throws Exception {\n+    testResponseEndFutureCompletes(httpServerResponse -> httpServerResponse.setChunked(true).write(\"hello\")\n+      .compose(nothing -> httpServerResponse.end())\n+    );\n+  }\n+\n+  @Test\n+  public void testResponseEndFutureCompletes_ChunkedWithBody() throws Exception {\n+    testResponseEndFutureCompletes(httpServerResponse -> httpServerResponse.setChunked(true).write(\"hello\")\n+      .compose(nothing -> httpServerResponse.end(\"world\"))\n+    );\n+  }\n+\n+  private void testResponseEndFutureCompletes(final Function<HttpServerResponse, Future<Void>> function) throws Exception {\n+    waitFor(2);\n+    server.requestHandler(\n+      httpServerRequest -> function.apply(httpServerRequest.response()).onComplete(onSuccess(nothing -> complete()))\n+    );\n+    startServer(testAddress);\n+    client.request(requestOptions)\n+      .compose(HttpClientRequest::send)\n+      .compose(HttpClientResponse::end)\n+      .onComplete(onSuccess(nothing -> complete()));\n+    await();\n+  }\n }\n"}
{"repository": "eclipse-vertx/vert.x", "clone_url": "https://github.com/eclipse-vertx/vert.x.git", "timestamp": "2023-06-01T08:44:56.124650Z", "commit_hash": "78dce7861a708db77aff9d3de55db7230a3ae2ab", "commit_message": "The pool implementation does not correctly check a waiter is enqueued in the waiter list before removing it leading to an incorrect waiter list size computation. In addition the size is used before a poll and instead a poll operation could be used and then check the polled nullity.\n\nfixes #4224\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/io/vertx/core/net/impl/pool/PoolWaiter.java b/src/main/java/io/vertx/core/net/impl/pool/PoolWaiter.java\nindex 7739fd9..88bdaf7 100644\n--- a/src/main/java/io/vertx/core/net/impl/pool/PoolWaiter.java\n+++ b/src/main/java/io/vertx/core/net/impl/pool/PoolWaiter.java\n@@ -53,6 +53,7 @@ public class PoolWaiter<C> {\n   PoolWaiter<C> prev;\n   PoolWaiter<C> next;\n   boolean disposed;\n+  boolean queued;\n \n   PoolWaiter(PoolWaiter.Listener<C> listener, ContextInternal context, final int capacity, Handler<AsyncResult<Lease<C>>> handler) {\n     this.listener = listener;\ndiff --git a/src/main/java/io/vertx/core/net/impl/pool/SimpleConnectionPool.java b/src/main/java/io/vertx/core/net/impl/pool/SimpleConnectionPool.java\nindex 7230f2f..651757a 100644\n--- a/src/main/java/io/vertx/core/net/impl/pool/SimpleConnectionPool.java\n+++ b/src/main/java/io/vertx/core/net/impl/pool/SimpleConnectionPool.java\n@@ -654,8 +654,9 @@ public class SimpleConnectionPool<C> implements ConnectionPool<C> {\n           }\n         };\n       }\n-      if (pool.waiters.removeFirst(waiter)) {\n+      if (pool.waiters.remove(waiter)) {\n         cancelled = true;\n+        waiter.disposed = true;\n       } else if (!waiter.disposed) {\n         waiter.disposed = true;\n         cancelled = true;\n@@ -710,8 +711,8 @@ public class SimpleConnectionPool<C> implements ConnectionPool<C> {\n     @Override\n     public Task execute(SimpleConnectionPool<C> pool) {\n       if (!pool.closed && slot.connection != null) {\n-        if (pool.waiters.size() > 0) {\n-          PoolWaiter<C> waiter = pool.waiters.poll();\n+        PoolWaiter<C> waiter = pool.waiters.poll();\n+        if (waiter != null) {\n           LeaseImpl<C> lease = new LeaseImpl<>(slot, waiter.handler);\n           return new Task() {\n             @Override\n@@ -810,11 +811,15 @@ public class SimpleConnectionPool<C> implements ConnectionPool<C> {\n         return null;\n       }\n       PoolWaiter<C> node = head.next;\n-      removeFirst(node);\n+      remove(node);\n       return node;\n     }\n \n     void addLast(PoolWaiter<C> node) {\n+      if (node.queued) {\n+        throw new IllegalStateException();\n+      }\n+      node.queued = true;\n       node.prev = head.prev;\n       node.next = head;\n       head.prev.next = node;\n@@ -823,6 +828,10 @@ public class SimpleConnectionPool<C> implements ConnectionPool<C> {\n     }\n \n     void addFirst(PoolWaiter<C> node) {\n+      if (node.queued) {\n+        throw new IllegalStateException();\n+      }\n+      node.queued = true;\n       node.prev = head;\n       node.next = head.prev;\n       head.next.prev = node;\n@@ -830,12 +839,14 @@ public class SimpleConnectionPool<C> implements ConnectionPool<C> {\n       size++;\n     }\n \n-    boolean removeFirst(PoolWaiter<C> node) {\n-      if (node.next == null) {\n+    boolean remove(PoolWaiter<C> node) {\n+      if (!node.queued) {\n         return false;\n       }\n       node.next.prev = node.prev;\n       node.prev.next = node.next;\n+      node.next = node.prev = null;\n+      node.queued = false;\n       size--;\n       return true;\n     }\n", "test_patch": "diff --git a/src/test/java/io/vertx/core/net/impl/pool/ConnectionPoolTest.java b/src/test/java/io/vertx/core/net/impl/pool/ConnectionPoolTest.java\nindex 0f0d789..b8f13a0 100644\n--- a/src/test/java/io/vertx/core/net/impl/pool/ConnectionPoolTest.java\n+++ b/src/test/java/io/vertx/core/net/impl/pool/ConnectionPoolTest.java\n@@ -632,10 +632,15 @@ public class ConnectionPoolTest extends VertxTestBase {\n         w.complete(waiter);\n       }\n     }, 0, ar -> fail());\n-    w.get(10, TimeUnit.SECONDS);\n-    pool.cancel(w.get(10, TimeUnit.SECONDS), onSuccess(removed -> {\n-      assertTrue(removed);\n-      testComplete();\n+    PoolWaiter<Connection> waiter = w.get(10, TimeUnit.SECONDS);\n+    pool.cancel(waiter, onSuccess(removed1 -> {\n+      assertTrue(removed1);\n+      assertEquals(0, pool.waiters());\n+      pool.cancel(waiter, onSuccess(removed2 -> {\n+        assertFalse(removed2);\n+        assertEquals(0, pool.waiters());\n+        testComplete();\n+      }));\n     }));\n     await();\n   }\n"}
{"repository": "eclipse-vertx/vert.x", "clone_url": "https://github.com/eclipse-vertx/vert.x.git", "timestamp": "2023-06-01T09:05:01.105066Z", "commit_hash": "73c58bed36ee4a8892a397e789ddbd592bfc489f", "commit_message": "Pool can deliver lease with null connection.\n\nA race can happen in the pool when it delivers a lease. Leases are created as pool post actions and sometimes can read a connection from a slot that became null in the meantime the post action is executed.\n\nLeases must be created before in pool tasks so they read the connection and then they are delivered with a non null (but potentially closed) connection.\n\nfixes #4221\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/io/vertx/core/net/impl/pool/SimpleConnectionPool.java b/src/main/java/io/vertx/core/net/impl/pool/SimpleConnectionPool.java\nindex 49a77ec..7230f2f 100644\n--- a/src/main/java/io/vertx/core/net/impl/pool/SimpleConnectionPool.java\n+++ b/src/main/java/io/vertx/core/net/impl/pool/SimpleConnectionPool.java\n@@ -303,34 +303,36 @@ public class SimpleConnectionPool<C> implements ConnectionPool<C> {\n           return null;\n         }\n         int c = 1;\n-        LeaseImpl<C>[] extra;\n         int concurrency;\n+        LeaseImpl<C> lease;\n         if (waiter.disposed) {\n-          waiter = null;\n+          lease = null;\n           concurrency = slot.concurrency;\n         } else {\n+          lease = new LeaseImpl<>(slot, waiter.handler);\n           waiter.disposed = true;\n           concurrency = slot.concurrency - 1;\n         }\n+        LeaseImpl<C>[] leases;\n         int m = Math.min(concurrency, pool.waiters.size());\n         if (m > 0) {\n           c += m;\n-          extra = new LeaseImpl[m];\n+          leases = new LeaseImpl[m];\n           for (int i = 0;i < m;i++) {\n-            extra[i] = new LeaseImpl<>(slot, pool.waiters.poll().handler);\n+            leases[i] = new LeaseImpl<>(slot, pool.waiters.poll().handler);\n           }\n         } else {\n-          extra = null;\n+          leases = null;\n         }\n         slot.concurrency -= c;\n         return new Task() {\n           @Override\n           public void run() {\n-            if (waiter != null) {\n-              new LeaseImpl<>(slot, waiter.handler).emit();\n+            if (lease != null) {\n+              lease.emit();\n             }\n-            if (extra != null) {\n-              for (LeaseImpl<C> lease : extra) {\n+            if (leases != null) {\n+              for (LeaseImpl<C> lease : leases) {\n                 lease.emit();\n               }\n             }\n@@ -553,10 +555,11 @@ public class SimpleConnectionPool<C> implements ConnectionPool<C> {\n       Slot<C> slot1 = (Slot<C>) pool.selector.apply(this, pool.list);\n       if (slot1 != null) {\n         slot1.concurrency--;\n+        LeaseImpl<C> lease = new LeaseImpl<>(slot1, handler);\n         return new Task() {\n           @Override\n           public void run() {\n-            new LeaseImpl<>(slot1, handler).emit();\n+            lease.emit();\n           }\n         };\n       }\n@@ -583,10 +586,11 @@ public class SimpleConnectionPool<C> implements ConnectionPool<C> {\n       Slot<C> slot3 = (Slot<C>) pool.fallbackSelector.apply(this, pool.list);\n       if (slot3 != null) {\n         slot3.concurrency--;\n+        LeaseImpl<C> lease = new LeaseImpl<>(slot3, handler);\n         return new Task() {\n           @Override\n           public void run() {\n-            new LeaseImpl<>(slot3, handler).emit();\n+            lease.emit();\n           }\n         };\n       }\n@@ -691,7 +695,7 @@ public class SimpleConnectionPool<C> implements ConnectionPool<C> {\n     }\n \n     void emit() {\n-      slot.context.emit(Future.succeededFuture(new LeaseImpl<>(slot, handler)), handler);\n+      slot.context.emit(Future.succeededFuture(this), handler);\n     }\n   }\n \n@@ -708,10 +712,11 @@ public class SimpleConnectionPool<C> implements ConnectionPool<C> {\n       if (!pool.closed && slot.connection != null) {\n         if (pool.waiters.size() > 0) {\n           PoolWaiter<C> waiter = pool.waiters.poll();\n+          LeaseImpl<C> lease = new LeaseImpl<>(slot, waiter.handler);\n           return new Task() {\n             @Override\n             public void run() {\n-              new LeaseImpl<>(slot, waiter.handler).emit();\n+              lease.emit();\n             }\n           };\n         } else {\n", "test_patch": "diff --git a/src/test/java/io/vertx/core/net/impl/pool/ConnectionPoolTest.java b/src/test/java/io/vertx/core/net/impl/pool/ConnectionPoolTest.java\nindex e75d11f..0f0d789 100644\n--- a/src/test/java/io/vertx/core/net/impl/pool/ConnectionPoolTest.java\n+++ b/src/test/java/io/vertx/core/net/impl/pool/ConnectionPoolTest.java\n@@ -574,6 +574,49 @@ public class ConnectionPoolTest extends VertxTestBase {\n   }\n \n   @Test\n+  public void testAcquireClosedConnection() throws Exception {\n+    ConnectionManager mgr = new ConnectionManager();\n+    ConnectionPool<Connection> pool = ConnectionPool.pool(mgr, new int[] { 1 });\n+    EventLoopContext context = vertx.createEventLoopContext();\n+    pool.acquire(context, 0, onSuccess(lease -> {\n+      lease.recycle();\n+    }));\n+    Connection expected = new Connection();\n+    ConnectionRequest request = mgr.assertRequest();\n+    request.connect(expected, 0);\n+    CountDownLatch latch1 = new CountDownLatch(1);\n+    CountDownLatch latch2 = new CountDownLatch(1);\n+    context.runOnContext(v -> {\n+      pool.evict(conn -> {\n+        // Make sure that the event-loop thread is busy and pool lock are borrowed\n+        latch1.countDown();\n+        try {\n+          // Wait until the acquisition and removal tasks are enqueued\n+          latch2.await();\n+        } catch (InterruptedException e) {\n+          Thread.currentThread().interrupt();\n+        }\n+        // When we return, the tasks will be executed by this thread\n+        // but the acquisition callback is a pool post action executed after the removal task is executed\n+        return false;\n+      }, ar -> {\n+      });\n+    });\n+    awaitLatch(latch1);\n+    AtomicBoolean closed = new AtomicBoolean();\n+    pool.acquire(context, 0, onSuccess(lease -> {\n+      // Get not null closed connection\n+      assertNotNull(lease.get());\n+      assertTrue(closed.get());\n+      testComplete();\n+    }));\n+    request.listener.onRemove();\n+    closed.set(true);\n+    latch2.countDown();\n+    await();\n+  }\n+\n+  @Test\n   public void testCancelQueuedWaiters() throws Exception {\n     waitFor(1);\n     EventLoopContext context = vertx.createEventLoopContext();\n"}
{"repository": "eclipse-vertx/vert.x", "clone_url": "https://github.com/eclipse-vertx/vert.x.git", "timestamp": "2023-06-01T09:25:06.719764Z", "commit_hash": "ed9db7f095c18179c28d7aa1aa8f4eeff0b8f759", "commit_message": "The Http2Settings max header list size setting is ignored by the conversion to the actual Netty settings since we only send a setting when the new value is different from the initial value. The initial value is wrong and therefore leads to obtaining the incorrect value.\n\nfixes #4211\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/io/vertx/core/http/Http2Settings.java b/src/main/java/io/vertx/core/http/Http2Settings.java\nindex 5ce4a7e..da63248 100644\n--- a/src/main/java/io/vertx/core/http/Http2Settings.java\n+++ b/src/main/java/io/vertx/core/http/Http2Settings.java\n@@ -57,9 +57,9 @@ public class Http2Settings {\n   public static final int DEFAULT_MAX_FRAME_SIZE = 16384;\n \n   /**\n-   * Default HTTP/2 spec value for {@link #getMaxHeaderListSize} : {@code Integer.MAX_VALUE}\n+   * Default HTTP/2 spec value for {@link #getMaxHeaderListSize} : {@code 8192}\n    */\n-  public static final int DEFAULT_MAX_HEADER_LIST_SIZE = Integer.MAX_VALUE;\n+  public static final int DEFAULT_MAX_HEADER_LIST_SIZE = 8192;\n \n   /**\n    * Default HTTP/2 spec value for {@link #getExtraSettings} : {@code null}\n", "test_patch": "diff --git a/src/test/java/io/vertx/core/http/Http2Test.java b/src/test/java/io/vertx/core/http/Http2Test.java\nindex 7f783f9..9ddfbde 100644\n--- a/src/test/java/io/vertx/core/http/Http2Test.java\n+++ b/src/test/java/io/vertx/core/http/Http2Test.java\n@@ -504,6 +504,23 @@ public class Http2Test extends HttpTest {\n   }\n \n   @Test\n+  public void testMaxHaderListSize() throws Exception {\n+    server.close();\n+    server = vertx.createHttpServer(createBaseServerOptions().setInitialSettings(new Http2Settings().setMaxHeaderListSize(Integer.MAX_VALUE)));\n+    server.requestHandler(req -> {\n+      req.response().end();\n+    });\n+    startServer(testAddress);\n+    client.request(new RequestOptions(requestOptions).setTimeout(10000))\n+      .compose(HttpClientRequest::send)\n+      .onComplete(onSuccess(resp -> {\n+        assertEquals(Integer.MAX_VALUE, resp.request().connection().remoteSettings().getMaxHeaderListSize());\n+        testComplete();\n+      }));\n+    await();\n+  }\n+\n+  @Test\n   public void testFoo() throws Exception {\n     waitFor(2);\n     server.requestHandler(req -> {\n"}
{"repository": "eclipse-vertx/vert.x", "clone_url": "https://github.com/eclipse-vertx/vert.x.git", "timestamp": "2023-06-01T09:56:19.222272Z", "commit_hash": "85ddcc8c2559e295355ebc76bc542657615ab5a2", "commit_message": "Fix integration test for native that was missing exclusions to properly test the feature\n", "related_issues": "", "bug_patch": "diff --git a/pom.xml b/pom.xml\nindex eaf60cb..27a3c61 100644\n--- a/pom.xml\n+++ b/pom.xml\n@@ -475,7 +475,9 @@\n               </includes>\n               <classpathDependencyExcludes>\n                 <classpathDependencyExclude>io.netty:netty-transport-native-epoll</classpathDependencyExclude>\n+                <classpathDependencyExclude>io.netty:netty-transport-classes-epoll</classpathDependencyExclude>\n                 <classpathDependencyExclude>io.netty:netty-transport-native-kqueue</classpathDependencyExclude>\n+                <classpathDependencyExclude>io.netty:netty-transport-classes-kqueue</classpathDependencyExclude>\n               </classpathDependencyExcludes>\n             </configuration>\n           </execution>\n", "test_patch": "diff --git a/src/test/java/io/vertx/it/TransportTest.java b/src/test/java/io/vertx/it/TransportTest.java\nindex 3984f27..5754b27 100644\n--- a/src/test/java/io/vertx/it/TransportTest.java\n+++ b/src/test/java/io/vertx/it/TransportTest.java\n@@ -39,14 +39,14 @@ public class TransportTest extends AsyncTestBase {\n   public void testNoNative() {\n     ClassLoader classLoader = Vertx.class.getClassLoader();\n     try {\n-      classLoader.loadClass(\"io.netty.channel.epoll.Epoll\");\n-      fail(\"Was not expected to load Epoll class\");\n+      Class<?> clazz = classLoader.loadClass(\"io.netty.channel.epoll.Epoll\");\n+      fail(\"Was not expected to load Epoll class from \" + clazz.getProtectionDomain().getCodeSource().getLocation());\n     } catch (ClassNotFoundException ignore) {\n       // Expected\n     }\n     try {\n-      classLoader.loadClass(\"io.netty.channel.kqueue.KQueue\");\n-      fail(\"Was not expected to load KQueue class\");\n+      Class<?> clazz = classLoader.loadClass(\"io.netty.channel.kqueue.KQueue\");\n+      fail(\"Was not expected to load KQueue class from \" + clazz.getProtectionDomain().getCodeSource().getLocation());\n     } catch (ClassNotFoundException ignore) {\n       // Expected\n     }\n"}
{"repository": "eclipse-vertx/vert.x", "clone_url": "https://github.com/eclipse-vertx/vert.x.git", "timestamp": "2023-06-01T10:16:24.431224Z", "commit_hash": "d06b5b735f40b2564df96333b7672306a4252b99", "commit_message": "Fix shared client implementation that must retain a strong reference to the hook it creates otherwise this hook might be garbaged and in this situation the shared client will never be released due to the lack of reference decrement.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/io/vertx/core/impl/CloseFuture.java b/src/main/java/io/vertx/core/impl/CloseFuture.java\nindex 2aadb93..c5d161a 100644\n--- a/src/main/java/io/vertx/core/impl/CloseFuture.java\n+++ b/src/main/java/io/vertx/core/impl/CloseFuture.java\n@@ -42,7 +42,10 @@ public class CloseFuture implements Closeable {\n   }\n \n   /**\n-   * Add a close hook, notified when the {@link #close(Promise)} )} method is called.\n+   * Add a close {@code hook}, notified when the {@link #close(Promise)} )} method is called.\n+   *\n+   * The {@code hook} will be weakly referenced therefore, the caller needs to retain a reference to the hook\n+   * otherwise it might be reclaimed and therefore never be called.\n    *\n    * @param hook the hook to add\n    */\n@@ -51,7 +54,7 @@ public class CloseFuture implements Closeable {\n       throw new IllegalStateException();\n     }\n     if (hook instanceof CloseFuture) {\n-      // Close future might be closed independantly, so we optimize and remove the hooks when\n+      // Close future might be closed independently, so we optimize and remove the hooks when\n       // the close future completes\n       CloseFuture fut = (CloseFuture) hook;\n       fut.future().onComplete(ar -> remove(fut));\ndiff --git a/src/main/java/io/vertx/core/impl/SharedClientHolder.java b/src/main/java/io/vertx/core/impl/SharedClientHolder.java\nindex d76f00a..3cf4804 100644\n--- a/src/main/java/io/vertx/core/impl/SharedClientHolder.java\n+++ b/src/main/java/io/vertx/core/impl/SharedClientHolder.java\n@@ -11,17 +11,73 @@\n \n package io.vertx.core.impl;\n \n+import io.vertx.core.Closeable;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.shareddata.LocalMap;\n import io.vertx.core.shareddata.Shareable;\n \n+import java.util.function.Function;\n+\n class SharedClientHolder<C> implements Shareable {\n \n-  final CloseFuture closeFuture;\n+  static <C> C createSharedClient(Vertx vertx, String clientKey, String clientName, CloseFuture closeFuture, Function<CloseFuture, C> supplier) {\n+    LocalMap<String, SharedClientHolder<C>> localMap = vertx.sharedData().getLocalMap(clientKey);\n+    SharedClientHolder<C> v = localMap.compute(clientName, (key, value) -> {\n+      if (value == null) {\n+        Hook<C> hook = new Hook<>(vertx, clientKey, clientName);\n+        C client = supplier.apply(hook.closeFuture);\n+        return new SharedClientHolder<>(hook, 1, client);\n+      } else {\n+        return new SharedClientHolder<>(value.hook, value.count + 1, value.client);\n+      }\n+    });\n+    C client = v.client;\n+    closeFuture.add(v.hook);\n+    return client;\n+  }\n+\n+  final Hook<C> hook;\n   final int count;\n   final C client;\n \n-  SharedClientHolder(CloseFuture closeFuture, int count, C client) {\n-    this.closeFuture = closeFuture;\n+  SharedClientHolder(Hook<C> hook, int count, C client) {\n+    this.hook = hook;\n     this.count = count;\n     this.client = client;\n   }\n+\n+  private static class Hook<C> implements Closeable {\n+\n+    private final Vertx vertx;\n+    private final CloseFuture closeFuture;\n+    private final String clientKey;\n+    private final String clientName;\n+\n+    private Hook(Vertx vertx, String clientKey, String clientName) {\n+      this.vertx = vertx;\n+      this.closeFuture = new CloseFuture();\n+      this.clientKey = clientKey;\n+      this.clientName = clientName;\n+    }\n+\n+    @Override\n+    public void close(Promise<Void> completion) {\n+      LocalMap<String, SharedClientHolder<C>> localMap1 = vertx.sharedData().getLocalMap(clientKey);\n+      SharedClientHolder<C> res = localMap1.compute(clientName, (key, value) -> {\n+        if (value == null) {\n+          return null; // Should never happen unless bug\n+        } else if (value.count == 1) {\n+          return null;\n+        } else {\n+          return new SharedClientHolder<>(this, value.count - 1, value.client);\n+        }\n+      });\n+      if (res == null) {\n+        closeFuture.close(completion);\n+      } else {\n+        completion.complete();\n+      }\n+    }\n+  }\n }\ndiff --git a/src/main/java/io/vertx/core/impl/VertxInternal.java b/src/main/java/io/vertx/core/impl/VertxInternal.java\nindex d656858..b6d8b6e 100644\n--- a/src/main/java/io/vertx/core/impl/VertxInternal.java\n+++ b/src/main/java/io/vertx/core/impl/VertxInternal.java\n@@ -26,7 +26,6 @@ import io.vertx.core.net.impl.NetServerImpl;\n import io.vertx.core.net.impl.ServerID;\n import io.vertx.core.net.impl.TCPServerBase;\n import io.vertx.core.net.impl.transport.Transport;\n-import io.vertx.core.shareddata.LocalMap;\n import io.vertx.core.spi.cluster.ClusterManager;\n import io.vertx.core.spi.file.FileResolver;\n import io.vertx.core.spi.metrics.VertxMetrics;\n@@ -102,36 +101,7 @@ public interface VertxInternal extends Vertx {\n   HttpClient createHttpClient(HttpClientOptions options, CloseFuture closeFuture);\n \n   default <C> C createSharedClient(String clientKey, String clientName, CloseFuture closeFuture, Function<CloseFuture, C> supplier) {\n-    LocalMap<String, SharedClientHolder<C>> localMap = sharedData().getLocalMap(clientKey);\n-    SharedClientHolder<C> v = localMap.compute(clientName, (key, value) -> {\n-      if (value == null) {\n-        CloseFuture fut = new CloseFuture();\n-        C client = supplier.apply(fut);\n-        return new SharedClientHolder<>(fut, 1, client);\n-      } else {\n-        return new SharedClientHolder<>(value.closeFuture, value.count + 1, value.client);\n-      }\n-    });\n-    C client = v.client;\n-    CloseFuture close = v.closeFuture;\n-    closeFuture.add(completion -> {\n-      LocalMap<String, SharedClientHolder<C>> localMap1 = sharedData().getLocalMap(clientKey);\n-      SharedClientHolder<C> res = localMap1.compute(clientName, (key, value) -> {\n-        if (value == null) {\n-          return null; // Should never happen unless bug\n-        } else if (value.count == 1) {\n-          return null;\n-        } else {\n-          return new SharedClientHolder<>(value.closeFuture, value.count - 1, value.client);\n-        }\n-      });\n-      if (res == null) {\n-        close.close(completion);\n-      } else {\n-        completion.complete();\n-      }\n-    });\n-    return client;\n+    return SharedClientHolder.createSharedClient(this, clientKey, clientName, closeFuture, supplier);\n   }\n \n   /**\n", "test_patch": "diff --git a/src/test/java/io/vertx/core/http/SharedHttpClientTest.java b/src/test/java/io/vertx/core/http/SharedHttpClientTest.java\nindex 13176fe..640d4be 100644\n--- a/src/test/java/io/vertx/core/http/SharedHttpClientTest.java\n+++ b/src/test/java/io/vertx/core/http/SharedHttpClientTest.java\n@@ -191,7 +191,6 @@ public class SharedHttpClientTest extends VertxTestBase {\n   private static class ServerVerticle extends AbstractVerticle implements Handler<HttpServerRequest> {\n \n     volatile Promise<Void> replyLatch;\n-    volatile int port;\n     Set<HttpConnection> connections = Collections.synchronizedSet(new HashSet<>());\n     volatile int maxConnections;\n \n@@ -205,8 +204,7 @@ public class SharedHttpClientTest extends VertxTestBase {\n           maxConnections = Math.max(maxConnections, connections.size());\n         })\n         .requestHandler(this)\n-        .listen(0)\n-        .onSuccess(server -> port = server.actualPort())\n+        .listen(HttpTest.DEFAULT_HTTP_PORT)\n         .<Void>mapEmpty()\n         .onComplete(startPromise);\n     }\n@@ -219,7 +217,7 @@ public class SharedHttpClientTest extends VertxTestBase {\n \n   private static HttpClientOptions httpClientOptions(ServerVerticle serverVerticle, int sharedPoolSize) {\n     return new HttpClientOptions()\n-      .setDefaultPort(serverVerticle.port)\n+      .setDefaultPort(HttpTest.DEFAULT_HTTP_PORT)\n       .setMaxPoolSize(sharedPoolSize);\n   }\n \n"}
{"repository": "eclipse-vertx/vert.x", "clone_url": "https://github.com/eclipse-vertx/vert.x.git", "timestamp": "2023-06-01T10:36:29.643248Z", "commit_hash": "aeac1a735ab37f7911f1fac136ddf386d38b26c1", "commit_message": "NetClientOptions toJson method does not merge the specific NetClientOptions - fixes #4193\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/io/vertx/core/net/NetClientOptions.java b/src/main/java/io/vertx/core/net/NetClientOptions.java\nindex cbee89d..4a15379 100755\n--- a/src/main/java/io/vertx/core/net/NetClientOptions.java\n+++ b/src/main/java/io/vertx/core/net/NetClientOptions.java\n@@ -416,4 +416,11 @@ public class NetClientOptions extends ClientOptionsBase {\n   public NetClientOptions setSslHandshakeTimeoutUnit(TimeUnit sslHandshakeTimeoutUnit) {\n     return (NetClientOptions) super.setSslHandshakeTimeoutUnit(sslHandshakeTimeoutUnit);\n   }\n+\n+  @Override\n+  public JsonObject toJson() {\n+    JsonObject json = super.toJson();\n+    NetClientOptionsConverter.toJson(this, json);\n+    return json;\n+  }\n }\n", "test_patch": "diff --git a/src/test/java/io/vertx/core/net/NetTest.java b/src/test/java/io/vertx/core/net/NetTest.java\nindex 66c27d5..449bf8a 100755\n--- a/src/test/java/io/vertx/core/net/NetTest.java\n+++ b/src/test/java/io/vertx/core/net/NetTest.java\n@@ -465,8 +465,16 @@ public class NetTest extends VertxTestBase {\n     long reconnectInterval = TestUtils.randomPositiveInt();\n     boolean useAlpn = TestUtils.randomBoolean();\n     String hostnameVerificationAlgorithm = TestUtils.randomAlphaString(10);\n-    String sslEngine = TestUtils.randomBoolean() ? \"jdkSslEngineOptions\" : \"openSslEngineOptions\";\n-    boolean openSslSessionCacheEnabled = rand.nextBoolean();\n+    String sslEngine;\n+    JsonObject sslEngineOptions;\n+    if (TestUtils.randomBoolean()) {\n+      sslEngine = \"jdkSslEngineOptions\";\n+      sslEngineOptions = new JsonObject();\n+    } else {\n+      sslEngine = \"openSslEngineOptions\";\n+      boolean sessionCacheEnabled = rand.nextBoolean();\n+      sslEngineOptions = new JsonObject().put(\"sessionCacheEnabled\", sessionCacheEnabled);\n+    }\n     long sslHandshakeTimeout = TestUtils.randomPositiveLong();\n \n     JsonObject json = new JsonObject();\n@@ -488,11 +496,16 @@ public class NetTest extends VertxTestBase {\n         .put(\"reconnectAttempts\", reconnectAttempts)\n         .put(\"reconnectInterval\", reconnectInterval)\n         .put(\"useAlpn\", useAlpn)\n-        .put(sslEngine, new JsonObject())\n+        .put(sslEngine, sslEngineOptions)\n         .put(\"hostnameVerificationAlgorithm\", hostnameVerificationAlgorithm)\n-        .put(\"openSslSessionCacheEnabled\", openSslSessionCacheEnabled)\n         .put(\"sslHandshakeTimeout\", sslHandshakeTimeout);\n \n+\n+    JsonObject converted = new NetClientOptions(json).toJson();\n+    for (Map.Entry<String, Object> entry : json) {\n+      assertEquals(entry.getValue(), converted.getValue(entry.getKey()));\n+    }\n+\n     NetClientOptions options = new NetClientOptions(json);\n     assertEquals(sendBufferSize, options.getSendBufferSize());\n     assertEquals(receiverBufferSize, options.getReceiveBufferSize());\n"}
{"repository": "eclipse-vertx/vert.x", "clone_url": "https://github.com/eclipse-vertx/vert.x.git", "timestamp": "2023-06-01T11:16:40.454323Z", "commit_hash": "8e7a53925d479104d63f299e9cc07c9fe8809dee", "commit_message": "Fix the cookie comparator to consider user-agent cookies correctly\n\nSigned-off-by: Paulo Lopes <pmlopes@gmail.com>\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/io/vertx/core/http/impl/CookieImpl.java b/src/main/java/io/vertx/core/http/impl/CookieImpl.java\nindex 15f59d0..f7e46f6 100644\n--- a/src/main/java/io/vertx/core/http/impl/CookieImpl.java\n+++ b/src/main/java/io/vertx/core/http/impl/CookieImpl.java\n@@ -26,17 +26,26 @@ import io.vertx.core.http.CookieSameSite;\n public class CookieImpl implements ServerCookie {\n \n   private final io.netty.handler.codec.http.cookie.Cookie nettyCookie;\n+  // denotes if a cookie has been created from an HTTP request (true) or during the\n+  // application/response life cycle (false)\n+  private final boolean fromUserAgent;\n+\n   private boolean changed;\n-  private boolean fromUserAgent;\n-  // extension features\n+  // extension feature(s)\n   private CookieSameSite sameSite;\n \n   public CookieImpl(String name, String value) {\n     this.nettyCookie = new DefaultCookie(name, value);\n+    fromUserAgent = false;\n     this.changed = true;\n   }\n \n-  public CookieImpl(io.netty.handler.codec.http.cookie.Cookie nettyCookie) {\n+  /**\n+   * Internal constructor, only used by the CookieJar.\n+   *\n+   * @param nettyCookie the underlying cookie object\n+   */\n+  CookieImpl(io.netty.handler.codec.http.cookie.Cookie nettyCookie) {\n     this.nettyCookie = nettyCookie;\n     fromUserAgent = true;\n   }\ndiff --git a/src/main/java/io/vertx/core/http/impl/CookieJar.java b/src/main/java/io/vertx/core/http/impl/CookieJar.java\nindex d5d2e62..00983e1 100644\n--- a/src/main/java/io/vertx/core/http/impl/CookieJar.java\n+++ b/src/main/java/io/vertx/core/http/impl/CookieJar.java\n@@ -147,6 +147,11 @@ public class CookieJar extends AbstractSet<ServerCookie> {\n       return v;\n     }\n \n+    if (cookie.isFromUserAgent()) {\n+      // user-agent cookies never include a path or domain, so we must assume equality\n+      return 0;\n+    }\n+\n     if (cookie.getPath() == null) {\n       if (path != null) {\n         return -1;\n", "test_patch": "diff --git a/src/test/java/io/vertx/core/http/HttpTest.java b/src/test/java/io/vertx/core/http/HttpTest.java\nindex e03988c..c57bbcc 100644\n--- a/src/test/java/io/vertx/core/http/HttpTest.java\n+++ b/src/test/java/io/vertx/core/http/HttpTest.java\n@@ -23,6 +23,7 @@ import io.vertx.core.dns.AddressResolverOptions;\n import io.vertx.core.file.AsyncFile;\n import io.vertx.core.http.impl.CookieImpl;\n import io.vertx.core.http.impl.HttpServerRequestInternal;\n+import io.vertx.core.http.impl.ServerCookie;\n import io.vertx.core.impl.Utils;\n import io.vertx.core.net.*;\n import io.vertx.core.net.impl.HAProxyMessageCompletionHandler;\n@@ -6035,6 +6036,24 @@ public abstract class HttpTest extends HttpTestBase {\n     });\n   }\n \n+  @Test\n+  public void testReplaceCookie() throws Exception {\n+    testCookies(\"XSRF-TOKEN=c359b44aef83415\", req -> {\n+      assertEquals(1, req.cookieCount());\n+      req.response().addCookie(Cookie.cookie(\"XSRF-TOKEN\", \"88533580000c314\").setPath(\"/\"));\n+      Map<String, Cookie> deprecatedMap = req.cookieMap();\n+      assertFalse(((ServerCookie) deprecatedMap.get(\"XSRF-TOKEN\")).isFromUserAgent());\n+      assertEquals(\"/\", deprecatedMap.get(\"XSRF-TOKEN\").getPath());\n+      req.response().end();\n+    }, resp -> {\n+      List<String> cookies = resp.headers().getAll(\"set-cookie\");\n+      // the expired cookie must be sent back\n+      assertEquals(1, cookies.size());\n+      // ensure that the cookie jar was updated correctly\n+      assertEquals(\"XSRF-TOKEN=88533580000c314; Path=/\", cookies.get(0));\n+    });\n+  }\n+\n   private void testCookies(String cookieHeader, Consumer<HttpServerRequest> serverChecker, Consumer<HttpClientResponse> clientChecker) throws Exception {\n     server.requestHandler(serverChecker::accept);\n     startServer(testAddress);\n"}
{"repository": "eclipse-vertx/vert.x", "clone_url": "https://github.com/eclipse-vertx/vert.x.git", "timestamp": "2023-06-01T11:48:07.587499Z", "commit_hash": "a2e2b20843e01c9dd6951e88c3ee328ec004188e", "commit_message": "HTTP/1.1 client metric is reset for allocated but non sent requests - fixes #4158\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/io/vertx/core/http/impl/Http1xClientConnection.java b/src/main/java/io/vertx/core/http/impl/Http1xClientConnection.java\nindex a0229a2..e1bddfa 100644\n--- a/src/main/java/io/vertx/core/http/impl/Http1xClientConnection.java\n+++ b/src/main/java/io/vertx/core/http/impl/Http1xClientConnection.java\n@@ -1041,17 +1041,6 @@ public class Http1xClientConnection extends Http1xConnectionBase<WebSocketImpl> \n     context.execute(writable, handler);\n   }\n \n-  /**\n-   * @return a list of all pending streams\n-   */\n-  private Iterable<Stream> pendingStreams() {\n-    // There might be duplicate between the requets list and the responses list\n-    LinkedHashSet<Stream> list = new LinkedHashSet<>();\n-    list.addAll(requests);\n-    list.addAll(responses);\n-    return list;\n-  }\n-\n   protected void handleClosed() {\n     super.handleClosed();\n     long timerID = shutdownTimerID;\n@@ -1072,15 +1061,21 @@ public class Http1xClientConnection extends Http1xConnectionBase<WebSocketImpl> \n     }\n     WebSocketImpl ws;\n     VertxTracer tracer = context.tracer();\n-    Iterable<Stream> streams;\n+    List<Stream> allocatedStreams;\n+    List<Stream> sentStreams;\n     synchronized (this) {\n       ws = webSocket;\n-      streams = pendingStreams();\n+      sentStreams = new ArrayList<>(responses);\n+      allocatedStreams = new ArrayList<>(requests);\n+      allocatedStreams.removeAll(responses);\n     }\n     if (ws != null) {\n       ws.handleConnectionClosed();\n     }\n-    for (Stream stream : streams) {\n+    for (Stream stream : allocatedStreams) {\n+      stream.context.execute(null, v -> stream.handleClosed());\n+    }\n+    for (Stream stream : sentStreams) {\n       if (metrics != null) {\n         metrics.requestReset(stream.metric);\n       }\n@@ -1105,15 +1100,16 @@ public class Http1xClientConnection extends Http1xConnectionBase<WebSocketImpl> \n   protected void handleException(Throwable e) {\n     super.handleException(e);\n     WebSocketImpl ws;\n-    Iterable<Stream> streams;\n+    LinkedHashSet<Stream> allStreams = new LinkedHashSet<>();\n     synchronized (this) {\n       ws = webSocket;\n-      streams = pendingStreams();\n+      allStreams.addAll(requests);\n+      allStreams.addAll(responses);\n     }\n     if (ws != null) {\n       ws.handleException(e);\n     }\n-    for (Stream stream : streams) {\n+    for (Stream stream : allStreams) {\n       stream.handleException(e);\n     }\n   }\n", "test_patch": "diff --git a/src/test/java/io/vertx/core/http/Http1xMetricsTest.java b/src/test/java/io/vertx/core/http/Http1xMetricsTest.java\nindex 1000d1f..ccde658 100644\n--- a/src/test/java/io/vertx/core/http/Http1xMetricsTest.java\n+++ b/src/test/java/io/vertx/core/http/Http1xMetricsTest.java\n@@ -10,10 +10,31 @@\n  */\n package io.vertx.core.http;\n \n+import io.vertx.test.fakemetrics.FakeHttpClientMetrics;\n+import org.junit.Test;\n+\n+import java.util.concurrent.CountDownLatch;\n+\n public class Http1xMetricsTest extends HttpMetricsTestBase {\n \n   public Http1xMetricsTest() {\n     super(HttpVersion.HTTP_1_1);\n   }\n \n+  @Test\n+  public void testAllocatedStreamResetShouldNotCallMetricsLifecycle() throws Exception {\n+    server.requestHandler(req -> {\n+      fail();\n+    });\n+    startServer();\n+    CountDownLatch latch = new CountDownLatch(1);\n+    client = vertx.createHttpClient(createBaseClientOptions().setIdleTimeout(2));\n+    client.request(requestOptions).onComplete(onSuccess(req -> {\n+      req.exceptionHandler(err -> {\n+        latch.countDown();\n+      });\n+      req.connection().close();\n+    }));\n+    awaitLatch(latch);\n+  }\n }\ndiff --git a/src/test/java/io/vertx/test/fakemetrics/FakeHttpClientMetrics.java b/src/test/java/io/vertx/test/fakemetrics/FakeHttpClientMetrics.java\nindex 2a83e44..208d400 100644\n--- a/src/test/java/io/vertx/test/fakemetrics/FakeHttpClientMetrics.java\n+++ b/src/test/java/io/vertx/test/fakemetrics/FakeHttpClientMetrics.java\n@@ -155,6 +155,7 @@ public class FakeHttpClientMetrics extends FakeMetricsBase implements HttpClient\n     if (err != null) {\n       AssertionFailedError afe = new AssertionFailedError();\n       afe.initCause(err);\n+      unexpectedError = null;\n       throw afe;\n     }\n   }\n"}
{"repository": "eclipse-vertx/vert.x", "clone_url": "https://github.com/eclipse-vertx/vert.x.git", "timestamp": "2023-06-01T12:08:13.535996Z", "commit_hash": "366686696b8837318eb66ea7669b263ecbf4ae47", "commit_message": "Several fixes necessary to implement WebSocket upgrade support in a reverse proxy implemented with Vert.x\n\nWhen using the HTTP client connect API, the HTTP/1.1 implementation incorrectly case sensitively compares the connection header to the Upgrade value and therefore does not always remove the HTTP handlers on the pipeline to handle correctly the ByteBuf to the upgraded NetSocket.\n\nThe HTTP/1.1 server will only provide a NetSocket when the HTTP CONNECT method is used, it should also work when the client is requesting an HTTP upgrade. Therefore the HTTP server will return a valid NetSocket if and only if the request is a CONNECT or an HTTP connection upgrade, depending on the case a 200 or 101 response will be sent.\n\nfixes #4156\nfixes #4152\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/io/vertx/core/http/HttpServerRequest.java b/src/main/java/io/vertx/core/http/HttpServerRequest.java\nindex da19143..361a9f5 100644\n--- a/src/main/java/io/vertx/core/http/HttpServerRequest.java\n+++ b/src/main/java/io/vertx/core/http/HttpServerRequest.java\n@@ -314,11 +314,11 @@ public interface HttpServerRequest extends ReadStream<Buffer> {\n   /**\n    * Establish a TCP <a href=\"https://tools.ietf.org/html/rfc7231#section-4.3.6\">tunnel<a/> with the client.\n    *\n-   * <p> This must be called only for {@code CONNECT} HTTP method and before any response is sent.\n+   * <p> This must be called only for {@code CONNECT} HTTP method or for HTTP connection upgrade, before any response is sent.\n    *\n-   * <p> Calling this sends a {@code 200} response with no {@code content-length} header set and\n-   * then provides the {@code NetSocket} for handling the created tunnel. Any HTTP header set on the\n-   * response before calling this method will be sent.\n+   * <p> Calling this sends a {@code 200} response for a {@code CONNECT} or a {@code 101} for a connection upgrade wit\n+   * no {@code content-length} header set and then provides the {@code NetSocket} for handling the created tunnel.\n+   * Any HTTP header set on the response before calling this method will be sent.\n    *\n    * <pre>\n    * server.requestHandler(req -> {\ndiff --git a/src/main/java/io/vertx/core/http/impl/Http1xClientConnection.java b/src/main/java/io/vertx/core/http/impl/Http1xClientConnection.java\nindex f2fce9b..a0229a2 100644\n--- a/src/main/java/io/vertx/core/http/impl/Http1xClientConnection.java\n+++ b/src/main/java/io/vertx/core/http/impl/Http1xClientConnection.java\n@@ -758,7 +758,7 @@ public class Http1xClientConnection extends Http1xConnectionBase<WebSocketImpl> \n         if ((request.method == HttpMethod.CONNECT &&\n              response.statusCode == 200) || (\n              request.method == HttpMethod.GET &&\n-             request.headers != null && request.headers.contains(\"connection\", \"Upgrade\", false) &&\n+             request.headers != null && request.headers.contains(CONNECTION, UPGRADE, true) &&\n              response.statusCode == 101)) {\n           removeChannelHandlers();\n         } else {\ndiff --git a/src/main/java/io/vertx/core/http/impl/Http1xServerRequest.java b/src/main/java/io/vertx/core/http/impl/Http1xServerRequest.java\nindex bcd767c..21b11da 100644\n--- a/src/main/java/io/vertx/core/http/impl/Http1xServerRequest.java\n+++ b/src/main/java/io/vertx/core/http/impl/Http1xServerRequest.java\n@@ -25,7 +25,6 @@ import io.vertx.core.MultiMap;\n import io.vertx.core.buffer.Buffer;\n import io.vertx.core.http.*;\n import io.vertx.core.http.Cookie;\n-import io.vertx.core.http.HttpMethod;\n import io.vertx.core.http.HttpVersion;\n import io.vertx.core.http.impl.headers.HeadersAdaptor;\n import io.vertx.core.impl.ContextInternal;\n@@ -375,10 +374,7 @@ public class Http1xServerRequest implements HttpServerRequestInternal, io.vertx.\n \n   @Override\n   public Future<NetSocket> toNetSocket() {\n-    if (method() != HttpMethod.CONNECT) {\n-      return context.failedFuture(\"HTTP method must be CONNECT to upgrade the connection to a net socket\");\n-    }\n-    return response.netSocket();\n+    return response.netSocket(method(), headers());\n   }\n \n   @Override\ndiff --git a/src/main/java/io/vertx/core/http/impl/Http1xServerResponse.java b/src/main/java/io/vertx/core/http/impl/Http1xServerResponse.java\nindex 58a25cd..c73183b 100644\n--- a/src/main/java/io/vertx/core/http/impl/Http1xServerResponse.java\n+++ b/src/main/java/io/vertx/core/http/impl/Http1xServerResponse.java\n@@ -14,6 +14,9 @@ package io.vertx.core.http.impl;\n import io.netty.buffer.ByteBuf;\n import io.netty.buffer.Unpooled;\n import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPipeline;\n import io.netty.channel.ChannelPromise;\n import io.netty.handler.codec.http.DefaultHttpContent;\n import io.netty.handler.codec.http.EmptyHttpHeaders;\n@@ -48,7 +51,7 @@ import java.io.File;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n import java.io.RandomAccessFile;\n-import java.util.List;\n+import java.util.Map;\n import java.util.Set;\n \n import static io.vertx.core.http.HttpHeaders.SET_COOKIE;\n@@ -750,15 +753,19 @@ public class Http1xServerResponse implements HttpServerResponse, HttpResponse {\n     }\n   }\n \n-  Future<NetSocket> netSocket() {\n+  Future<NetSocket> netSocket(HttpMethod requestMethod, MultiMap requestHeaders) {\n     synchronized (conn) {\n       if (netSocket == null) {\n         if (headWritten) {\n-          return context.failedFuture(\"Response for CONNECT already sent\");\n+          return context.failedFuture(\"Response already sent\");\n         }\n-        status = HttpResponseStatus.OK;\n+        if (!HttpUtils.isConnectOrUpgrade(requestMethod, requestHeaders)) {\n+          return context.failedFuture(\"HTTP method must be CONNECT or an HTTP upgrade to upgrade the connection to a TCP socket\");\n+        }\n+        status = requestMethod == HttpMethod.CONNECT ? HttpResponseStatus.OK : HttpResponseStatus.SWITCHING_PROTOCOLS;\n         prepareHeaders(-1);\n-        conn.writeToChannel(new AssembledHttpResponse(head, version, status, headers));\n+        PromiseInternal<Void> upgradePromise = context.promise();\n+        conn.writeToChannel(new AssembledHttpResponse(head, version, status, headers), upgradePromise);\n         written = true;\n         Promise<NetSocket> promise = context.promise();\n         netSocket = promise.future();\ndiff --git a/src/main/java/io/vertx/core/http/impl/Http2ServerRequest.java b/src/main/java/io/vertx/core/http/impl/Http2ServerRequest.java\nindex 0073a94..24e5c58 100644\n--- a/src/main/java/io/vertx/core/http/impl/Http2ServerRequest.java\n+++ b/src/main/java/io/vertx/core/http/impl/Http2ServerRequest.java\n@@ -52,7 +52,6 @@ import javax.net.ssl.SSLPeerUnverifiedException;\n import javax.security.cert.X509Certificate;\n import java.net.URISyntaxException;\n import java.nio.channels.ClosedChannelException;\n-import java.util.List;\n import java.util.Set;\n \n /**\ndiff --git a/src/main/java/io/vertx/core/http/impl/HttpUtils.java b/src/main/java/io/vertx/core/http/impl/HttpUtils.java\nindex 70ae1eb..cec7438 100644\n--- a/src/main/java/io/vertx/core/http/impl/HttpUtils.java\n+++ b/src/main/java/io/vertx/core/http/impl/HttpUtils.java\n@@ -22,11 +22,9 @@ import io.netty.handler.codec.http2.Http2Settings;\n import io.netty.util.AsciiString;\n import io.netty.util.CharsetUtil;\n import io.vertx.core.AsyncResult;\n-import io.vertx.core.Context;\n import io.vertx.core.Future;\n import io.vertx.core.Handler;\n import io.vertx.core.MultiMap;\n-import io.vertx.core.Vertx;\n import io.vertx.core.buffer.Buffer;\n import io.vertx.core.file.AsyncFile;\n import io.vertx.core.file.FileSystem;\n@@ -35,9 +33,7 @@ import io.vertx.core.http.HttpServerRequest;\n import io.vertx.core.http.HttpServerResponse;\n import io.vertx.core.http.StreamPriority;\n import io.vertx.core.impl.VertxInternal;\n-import io.vertx.core.net.NetSocket;\n import io.vertx.core.spi.tracing.TagExtractor;\n-import io.vertx.core.streams.WriteStream;\n \n import java.io.File;\n import java.io.FileNotFoundException;\n@@ -909,4 +905,8 @@ public final class HttpUtils {\n       resultHandler.handle(Future.failedFuture(e));\n     }\n   }\n+\n+  static boolean isConnectOrUpgrade(io.vertx.core.http.HttpMethod method, MultiMap headers) {\n+    return method == io.vertx.core.http.HttpMethod.CONNECT || (method == io.vertx.core.http.HttpMethod.GET && headers.contains(io.vertx.core.http.HttpHeaders.CONNECTION, io.vertx.core.http.HttpHeaders.UPGRADE, true));\n+  }\n }\n", "test_patch": "diff --git a/src/test/java/io/vertx/core/http/Http1xTest.java b/src/test/java/io/vertx/core/http/Http1xTest.java\nindex 67d639d..034db10 100644\n--- a/src/test/java/io/vertx/core/http/Http1xTest.java\n+++ b/src/test/java/io/vertx/core/http/Http1xTest.java\n@@ -5110,6 +5110,11 @@ public class Http1xTest extends HttpTest {\n   }\n \n   @Test\n+  public void testHttpUpgrade() {\n+    testHttpConnect(new RequestOptions(requestOptions).setMethod(HttpMethod.GET).addHeader(HttpHeaders.CONNECTION, \"UpGrAdE\"), 101);\n+  }\n+\n+  @Test\n   public void testServerResponseReset() throws Exception {\n     waitFor(2);\n     server.requestHandler(req -> {\ndiff --git a/src/test/java/io/vertx/core/http/HttpTest.java b/src/test/java/io/vertx/core/http/HttpTest.java\nindex c8a7417..6d1c978 100644\n--- a/src/test/java/io/vertx/core/http/HttpTest.java\n+++ b/src/test/java/io/vertx/core/http/HttpTest.java\n@@ -5075,6 +5075,10 @@ public abstract class HttpTest extends HttpTestBase {\n \n   @Test\n   public void testHttpConnect() {\n+    testHttpConnect(new RequestOptions(requestOptions).setMethod(HttpMethod.CONNECT), 200);\n+  }\n+\n+  protected void testHttpConnect(RequestOptions options, int sc) {\n     Buffer buffer = TestUtils.randomBuffer(128);\n     Buffer received = Buffer.buffer();\n     CompletableFuture<Void> closeSocket = new CompletableFuture<>();\n@@ -5087,7 +5091,7 @@ public abstract class HttpTest extends HttpTestBase {\n       server.requestHandler(req -> {\n         vertx.createNetClient(new NetClientOptions()).connect(1235, \"localhost\", onSuccess(dst -> {\n \n-          req.response().setStatusCode(200);\n+          req.response().setStatusCode(sc);\n           req.response().setStatusMessage(\"Connection established\");\n \n           // Now create a NetSocket\n@@ -5104,10 +5108,10 @@ public abstract class HttpTest extends HttpTestBase {\n         }));\n       });\n       server.listen(testAddress, onSuccess(s -> {\n-        client.request(new RequestOptions(requestOptions).setMethod(HttpMethod.CONNECT)).onComplete(onSuccess(req -> {\n+        client.request(options).onComplete(onSuccess(req -> {\n           req\n             .connect(onSuccess(resp -> {\n-              assertEquals(200, resp.statusCode());\n+              assertEquals(sc, resp.statusCode());\n               NetSocket socket = resp.netSocket();\n               socket.handler(buff -> {\n                 received.appendBuffer(buff);\ndiff --git a/src/test/java/io/vertx/core/http/WebSocketTest.java b/src/test/java/io/vertx/core/http/WebSocketTest.java\nindex 66b5a03..28dbb8c 100644\n--- a/src/test/java/io/vertx/core/http/WebSocketTest.java\n+++ b/src/test/java/io/vertx/core/http/WebSocketTest.java\n@@ -656,13 +656,13 @@ public class WebSocketTest extends VertxTestBase {\n     String secHeader = req.headers().get(\"Sec-WebSocket-Key\");\n     String tmp = secHeader + \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n     String encoded = sha1(tmp);\n-    return ((Http1xServerConnection)req.connection()).netSocket().onSuccess(sock -> {\n-      sock.write(\"HTTP/1.1 101 Web Socket Protocol Handshake\\r\\n\" +\n-        \"Upgrade: WebSocket\\r\\n\" +\n-        \"Connection: upgrade\\r\\n\" +\n-        \"Sec-WebSocket-Accept: \" + encoded + \"\\r\\n\" +\n-        \"\\r\\n\");\n-    });\n+    HttpServerResponse resp = req.response();\n+    MultiMap headers = resp.headers();\n+    headers.set(HttpHeaders.CONNECTION, HttpHeaders.UPGRADE);\n+    headers.set(\"upgrade\", \"WebSocket\");\n+    headers.set(\"connection\", \"upgrade\");\n+    headers.set(\"sec-websocket-accept\", encoded);\n+    return req.toNetSocket();\n   }\n \n   private void testWSWriteStream(WebsocketVersion version) throws Exception {\n"}
{"repository": "eclipse-vertx/vert.x", "clone_url": "https://github.com/eclipse-vertx/vert.x.git", "timestamp": "2023-06-01T12:39:48.963309Z", "commit_hash": "8b58ec05f03001522898f24a128c8889312bc1da", "commit_message": "Our Buffer implementation can return this when the wrapped ByteBuf is read-only.\n\nfixes #4136\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/io/vertx/core/buffer/impl/BufferImpl.java b/src/main/java/io/vertx/core/buffer/impl/BufferImpl.java\nindex 02c5044..4c42ca6 100644\n--- a/src/main/java/io/vertx/core/buffer/impl/BufferImpl.java\n+++ b/src/main/java/io/vertx/core/buffer/impl/BufferImpl.java\n@@ -518,7 +518,7 @@ public class BufferImpl implements Buffer {\n   }\n \n   public Buffer copy() {\n-    return new BufferImpl(buffer.copy());\n+    return buffer.isReadOnly() ? this : new BufferImpl(buffer.copy());\n   }\n \n   public Buffer slice() {\n", "test_patch": "diff --git a/src/test/java/io/vertx/core/buffer/BufferTest.java b/src/test/java/io/vertx/core/buffer/BufferTest.java\nindex 01f3988..2361f3d 100644\n--- a/src/test/java/io/vertx/core/buffer/BufferTest.java\n+++ b/src/test/java/io/vertx/core/buffer/BufferTest.java\n@@ -1172,4 +1172,12 @@ public class BufferTest {\n     f.apply(buffer, 0);\n     assertIndexOutOfBoundsException(() -> f.apply(buffer, 1));\n   }\n+\n+  @Test\n+  public void testReadOnlyByteBuf() {\n+    String s = \"Hello World\";\n+    ByteBuf byteBuf = Unpooled.buffer(0, s.length() - 1);\n+    Buffer buff = Buffer.buffer(byteBuf.asReadOnly());\n+    assertSame(buff, buff.copy());\n+  }\n }\n"}
