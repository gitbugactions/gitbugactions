{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-05-31T18:40:03.273843Z", "commit_hash": "33405a17ae203d91c29e87da0e89c117f566d7ce", "commit_message": "fix type inference on arithmetic operation\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/math/MathProcessor.java b/src/main/java/org/mvel2/math/MathProcessor.java\nindex ae6fe73..83eb8fe 100644\n--- a/src/main/java/org/mvel2/math/MathProcessor.java\n+++ b/src/main/java/org/mvel2/math/MathProcessor.java\n@@ -60,27 +60,20 @@ public strictfp class MathProcessor {\n     if (type2 < 1)\n       type2 = val2 == null ? DataTypes.OBJECT : __resolveType(val2.getClass());\n \n-    switch (type1) {\n-      case BIG_DECIMAL:\n-\n-        switch (type2) {\n-          case BIG_DECIMAL:\n-            return doBigDecimalArithmetic((BigDecimal) val1, operation, (BigDecimal) val2, false, -1);\n-          default:\n-            if (type2 > 99) {\n-              return doBigDecimalArithmetic((BigDecimal) val1, operation, asBigDecimal(val2), false, -1);\n-            }\n-            else {\n-              return _doOperations(type1, val1, operation, type2, val2);\n-            }\n-        }\n-      default:\n+    if (type1 == BIG_DECIMAL) {\n+      if (type2 == BIG_DECIMAL) {\n+        return doBigDecimalArithmetic((BigDecimal) val1, operation, (BigDecimal) val2, false, -1);\n+      }\n+      if (type2 > 99) {\n+        return doBigDecimalArithmetic((BigDecimal) val1, operation, asBigDecimal(val2), false, -1);\n+      } else {\n         return _doOperations(type1, val1, operation, type2, val2);\n-\n+      }\n     }\n+    return _doOperations(type1, val1, operation, type2, val2);\n   }\n \n-  private static Object doPrimWrapperArithmetic(final Number val1, final int operation, final Number val2, boolean iNumber, int returnTarget) {\n+  private static Object doPrimWrapperArithmetic(final Number val1, final int operation, final Number val2, int returnTarget) {\n     switch (operation) {\n       case ADD:\n         return toType(val1.doubleValue() + val2.doubleValue(), returnTarget);\n@@ -188,13 +181,13 @@ public strictfp class MathProcessor {\n         }\n \n       case GTHAN:\n-        return val1 != null && val2 != null ? val1.compareTo(val2) > 0 : false;\n+        return val1 != null && val2 != null && val1.compareTo(val2) > 0;\n       case GETHAN:\n-        return val1 != null && val2 != null ? val1.compareTo(val2) >= 0 : false;\n+        return val1 != null && val2 != null && val1.compareTo(val2) >= 0;\n       case LTHAN:\n-        return val1 != null && val2 != null ? val1.compareTo(val2) < 0 : false;\n+        return val1 != null && val2 != null && val1.compareTo(val2) < 0;\n       case LETHAN:\n-        return val1 != null && val2 != null ? val1.compareTo(val2) <= 0 : false;\n+        return val1 != null && val2 != null && val1.compareTo(val2) <= 0;\n       case EQUAL:\n         return val1 == null ? val2 == null : val2 != null && val1.compareTo(val2) == 0;\n       case NEQUAL:\n@@ -210,9 +203,8 @@ public strictfp class MathProcessor {\n         return doOperationsSameType(type1, val1, operation, val2);\n       }\n       else if (val2 != null && isNumericOperation(type1, val1, operation, type2, val2)) {\n-        return doPrimWrapperArithmetic(getNumber(val1, type1),\n-            operation,\n-            getNumber(val2, type2), true, box(type2) > box(type1) ? box(type2) : box(type1));\n+        return doPrimWrapperArithmetic(getNumber(val1, type1), operation,\n+            getNumber(val2, type2), Math.max(box(type2), box(type1)));\n       }\n       else if (operation != ADD &&\n           (type1 == DataTypes.W_BOOLEAN || type2 == DataTypes.W_BOOLEAN) &&\n@@ -281,7 +273,6 @@ public strictfp class MathProcessor {\n \n       case GETHAN:\n         if (val1 instanceof Comparable) {\n-          //noinspection unchecked\n           try {\n             return val2 != null && ((Comparable) val1).compareTo(val2) >= 0;\n           }\n@@ -313,7 +304,6 @@ public strictfp class MathProcessor {\n \n       case LETHAN:\n         if (val1 instanceof Comparable) {\n-          //noinspection unchecked\n           try {\n             return val2 != null && ((Comparable) val1).compareTo(val2) <= 0;\n           }\n@@ -344,14 +334,14 @@ public strictfp class MathProcessor {\n     if (val1 != null) {\n       return val1.equals(val2);\n     }\n-    else return val2 == null || (val2.equals(val1));\n+    else return val2 == null;\n   }\n \n   private static Boolean safeNotEquals(final Object val1, final Object val2) {\n     if (val1 != null) {\n       return !val1.equals(val2);\n     }\n-    else return (val2 != null && !val2.equals(val1));\n+    else return val2 != null;\n   }\n \n   private static Object doOperationsSameType(int type1, Object val1, int operation, Object val2) {\n@@ -607,11 +597,11 @@ public strictfp class MathProcessor {\n           case MOD:\n             return ((BigInteger) val1).remainder(((BigInteger) val2));\n           case GTHAN:\n-            return ((BigInteger) val1).compareTo(((BigInteger) val2)) == 1;\n+            return ((BigInteger) val1).compareTo(((BigInteger) val2)) > 0;\n           case GETHAN:\n             return ((BigInteger) val1).compareTo(((BigInteger) val2)) >= 0;\n           case LTHAN:\n-            return ((BigInteger) val1).compareTo(((BigInteger) val2)) == -1;\n+            return ((BigInteger) val1).compareTo(((BigInteger) val2)) < 0;\n           case LETHAN:\n             return ((BigInteger) val1).compareTo(((BigInteger) val2)) <= 0;\n           case EQUAL:\n@@ -650,7 +640,7 @@ public strictfp class MathProcessor {\n   }\n \n   private static long toLong(Object val) {\n-    return val instanceof Long ? (Long) val : ((Long) val).longValue();\n+    return val instanceof Long ? (Long) val : ((Number) val).longValue();\n   }\n \n   private static double toDouble(Object val) {\n@@ -697,10 +687,9 @@ public strictfp class MathProcessor {\n       case DataTypes.W_FLOAT:\n       case DataTypes.SHORT:\n       case DataTypes.W_SHORT:\n-        return ((Number) in).doubleValue();\n       case DataTypes.DOUBLE:\n       case DataTypes.W_DOUBLE:\n-        return (Double) in;\n+        return ((Number) in).doubleValue();\n       case DataTypes.CHAR:\n       case DataTypes.W_CHAR:\n         return Double.parseDouble(String.valueOf(in));\ndiff --git a/src/main/java/org/mvel2/util/ASTBinaryTree.java b/src/main/java/org/mvel2/util/ASTBinaryTree.java\nindex 31ff6df..e2f40f6 100644\n--- a/src/main/java/org/mvel2/util/ASTBinaryTree.java\n+++ b/src/main/java/org/mvel2/util/ASTBinaryTree.java\n@@ -7,7 +7,7 @@ import org.mvel2.ast.OperatorNode;\n import static org.mvel2.Operator.*;\n \n public class ASTBinaryTree {\n-    private ASTNode root;\n+    private final ASTNode root;\n     private ASTBinaryTree left;\n     private ASTBinaryTree right;\n \n@@ -36,7 +36,7 @@ public class ASTBinaryTree {\n         if (left == null || right == null) throw new RuntimeException(\"Malformed expression\");\n         Class<?> leftType = left.getReturnType(strongTyping);\n         Class<?> rightType = right.getReturnType(strongTyping);\n-        switch (((OperatorNode)root).getOperator()) {\n+        switch (root.getOperator()) {\n             case CONTAINS:\n             case SOUNDEX:\n             case INSTANCEOF:\n@@ -50,7 +50,7 @@ public class ASTBinaryTree {\n             case DIV:\n                 if (strongTyping && !CompatibilityStrategy.areEqualityCompatible(leftType, rightType))\n                     throw new RuntimeException(\"Associative operation requires compatible types. Found \" + leftType + \" and \" + rightType);\n-                return Double.class;\n+                return leftType == rightType && (leftType.isPrimitive() || Number.class.isAssignableFrom(leftType)) ? leftType : Double.class;\n             case MOD:\n                 if (strongTyping && !CompatibilityStrategy.areEqualityCompatible(leftType, rightType))\n                     throw new RuntimeException(\"Associative operation requires compatible types. Found \" + leftType + \" and \" + rightType);\n@@ -93,7 +93,7 @@ public class ASTBinaryTree {\n     private int comparePrecedence(ASTNode node1, ASTNode node2) {\n         if (!(node1 instanceof OperatorNode) && !(node2 instanceof OperatorNode)) return 0;\n         if (node1 instanceof OperatorNode && node2 instanceof OperatorNode) {\n-            return PTABLE[((OperatorNode)node1).getOperator()] - PTABLE[((OperatorNode)node2).getOperator()];\n+            return PTABLE[node1.getOperator()] - PTABLE[node2.getOperator()];\n         }\n         return node1 instanceof OperatorNode ? -1 : 1;\n     }\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\nindex 1cd0cdd..7518dfe 100644\n--- a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n@@ -5009,4 +5009,13 @@ public class CoreConfidenceTests extends AbstractTest {\n       assertEquals(expected, result);\n     }\n   }\n+\n+  public void testAnalyzeMathAbs() {\n+    final ParserContext parserContext = new ParserContext();\n+    parserContext.setStrictTypeEnforcement(true);\n+    parserContext.setStrongTyping(true);\n+    parserContext.addInput(\"x\", Integer.class);\n+    parserContext.addInput(\"y\", Integer.class);\n+    assertEquals(int.class, MVEL.analyze( \"Math.abs(x - y);\", parserContext ));\n+  }\n }\n\\ No newline at end of file\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-05-31T18:46:49.744852Z", "commit_hash": "056e9c89229e49f6393fb732b4338d8894e74655", "commit_message": "Fix Issue #267 (#269)\n\nCo-authored-by: Mario Fusco <mario.fusco@gmail.com>", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/conversion/ArrayHandler.java b/src/main/java/org/mvel2/conversion/ArrayHandler.java\nindex 5580868..0d49666 100644\n--- a/src/main/java/org/mvel2/conversion/ArrayHandler.java\n+++ b/src/main/java/org/mvel2/conversion/ArrayHandler.java\n@@ -69,7 +69,7 @@ public class ArrayHandler implements ConversionHandler {\n     if (!input.getClass().isArray()) {\n       // if the input isn't an array converts it in an array with lenght = 1 having has its single item the input itself\n       Object target = newInstance(targType, 1);\n-      set(target, 0, input);\n+      set(target, 0, convert(input, targType));\n       return target;\n     }\n \n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\nindex 7fb9220..1cd0cdd 100644\n--- a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n@@ -4933,6 +4933,11 @@ public class CoreConfidenceTests extends AbstractTest {\n     Serializable compiledExpr = MVEL.compileExpression(expression, pctx);\n     assertEquals( \"test\", MVEL.executeExpression(compiledExpr, null, factory));\n   }\n+  \n+  public void testLooseTypeConversion() {\n+     int [] result = MVEL.eval(\"3.0\", int [].class);\n+     assertEquals(3, result[0]);\n+  }\n \n   public void testGetBestConstructorCandidateOfBigDecimal() {\n       Class<?>[] arguments = new Class<?>[]{BigDecimal.class}; // new BigDecimal(BigDecimal bd) doesn't exist. But want to get a constant candidate\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-05-31T18:53:30.806835Z", "commit_hash": "3fa407d764079ecf3615a99743783c32835d1d90", "commit_message": "[DROOLS-6729] Exception happens randomly in specific rule after Constraint Jitting (#279)\n\n- Fix isVarArgs logic and compare BigInteger", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/util/ParseTools.java b/src/main/java/org/mvel2/util/ParseTools.java\nindex fc79639..03ae14f 100644\n--- a/src/main/java/org/mvel2/util/ParseTools.java\n+++ b/src/main/java/org/mvel2/util/ParseTools.java\n@@ -329,10 +329,14 @@ public class ParseTools {\n     if (numeric1 == numeric2) {\n       return 0;\n     }\n-    if ((numeric1 == double.class) && (numeric2 == float.class || numeric2 == long.class || numeric2 == int.class || numeric2 == short.class)) {\n+    if (numeric1 == BigDecimal.class) {\n+        return 1;\n+    } else if ((numeric1 == double.class) && (numeric2 == float.class || numeric2 == long.class || numeric2 == int.class || numeric2 == short.class || numeric2 == BigInteger.class)) {\n+      return 1;\n+    } else if ((numeric1 == float.class) && (numeric2 == long.class || numeric2 == int.class || numeric2 == short.class || numeric2 == BigInteger.class)) {\n+      // float is preferred over long/BigInteger assuming users don't want to lose decimal part\n       return 1;\n-    } else if ((numeric1 == float.class) && (numeric2 == long.class || numeric2 == int.class || numeric2 == short.class)) {\n-      // float is preferred over long assuming users don't want to lose decimal part\n+    } else if ((numeric1 == BigInteger.class) && (numeric2 == long.class || numeric2 == int.class || numeric2 == short.class)) {\n       return 1;\n     } else if ((numeric1 == long.class) && (numeric2 == int.class || numeric2 == short.class)) {\n       return 1;\n@@ -497,6 +501,7 @@ public class ParseTools {\n     Class[] parmTypes;\n     Constructor bestCandidate = null;\n     int bestScore = 0;\n+    boolean bestCandidateIsVarArgs = false;\n \n     for (Constructor construct : getConstructors(cls)) {\n       boolean isVarArgs = construct.isVarArgs();\n@@ -509,13 +514,16 @@ public class ParseTools {\n       }\n \n       int score = getMethodScore(arguments, requireExact, parmTypes, isVarArgs);\n+\n       if (score != 0) {\n         if (score > bestScore) {\n           bestCandidate = construct;\n           bestScore = score;\n+          bestCandidateIsVarArgs = isVarArgs;\n         }\n-        else if (score == bestScore && (isMorePreciseForBigDecimal(construct, bestCandidate, arguments) || !isVarArgs)) {\n+        else if (score == bestScore && (isMorePreciseForBigDecimal(construct, bestCandidate, arguments) || (bestCandidateIsVarArgs && !isVarArgs))) {\n           bestCandidate = construct;\n+          bestCandidateIsVarArgs = isVarArgs;\n         }\n       }\n     }\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\nindex 4011bdf..de4a76b 100644\n--- a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n@@ -7,6 +7,7 @@ import java.io.IOException;\n import java.io.OutputStream;\n import java.io.PrintStream;\n import java.io.Serializable;\n+import java.lang.reflect.Constructor;\n import java.lang.reflect.Field;\n import java.lang.reflect.Method;\n import java.lang.reflect.Modifier;\n@@ -4932,4 +4933,26 @@ public class CoreConfidenceTests extends AbstractTest {\n     Serializable compiledExpr = MVEL.compileExpression(expression, pctx);\n     assertEquals( \"test\", MVEL.executeExpression(compiledExpr, null, factory));\n   }\n+\n+  public void testGetBestConstructorCandidateOfBigDecimal() {\n+      Class<?>[] arguments = new Class<?>[] {BigDecimal.class}; // new BigDecimal(BigDecimal bd) doesn't exist. But want to get a constant candidate\n+      Constructor constructor = ParseTools.getBestConstructorCandidate(arguments, BigDecimal.class, true);\n+      Assert.assertArrayEquals(new Class<?>[] {double.class}, constructor.getParameterTypes());\n+\n+      arguments = new Class<?>[] {BigInteger.class};\n+      constructor = ParseTools.getBestConstructorCandidate(arguments, BigDecimal.class, true);\n+      Assert.assertArrayEquals(new Class<?>[] {BigInteger.class}, constructor.getParameterTypes());\n+\n+      arguments = new Class<?>[] {int.class};\n+      constructor = ParseTools.getBestConstructorCandidate(arguments, BigDecimal.class, true);\n+      Assert.assertArrayEquals(new Class<?>[] {int.class}, constructor.getParameterTypes());\n+\n+      arguments = new Class<?>[] {double.class};\n+      constructor = ParseTools.getBestConstructorCandidate(arguments, BigDecimal.class, true);\n+      Assert.assertArrayEquals(new Class<?>[] {double.class}, constructor.getParameterTypes());\n+\n+      arguments = new Class<?>[] {String.class};\n+      constructor = ParseTools.getBestConstructorCandidate(arguments, BigDecimal.class, true);\n+      Assert.assertArrayEquals(new Class<?>[] {String.class}, constructor.getParameterTypes());\n+  }\n }\n\\ No newline at end of file\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-05-31T19:05:01.509172Z", "commit_hash": "45d44c9a115a478219a57b44434df4e9bcbe5143", "commit_message": "fix use of ClassImportResolverFactory in thread unsafe evaluation\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/integration/impl/BaseVariableResolverFactory.java b/src/main/java/org/mvel2/integration/impl/BaseVariableResolverFactory.java\nindex 1e76510..8fffacf 100644\n--- a/src/main/java/org/mvel2/integration/impl/BaseVariableResolverFactory.java\n+++ b/src/main/java/org/mvel2/integration/impl/BaseVariableResolverFactory.java\n@@ -46,7 +46,10 @@ public abstract class BaseVariableResolverFactory implements VariableResolverFac\n   }\n \n   public VariableResolverFactory setNextFactory(VariableResolverFactory resolverFactory) {\n-    return nextFactory = resolverFactory;\n+    if (resolverFactory != this) {\n+      nextFactory = resolverFactory;\n+    }\n+    return nextFactory;\n   }\n \n   public VariableResolver getVariableResolver(String name) {\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/ThreadUnsafeTest.java b/src/test/java/org/mvel2/tests/core/ThreadUnsafeTest.java\nindex 64271e9..37a14eb 100644\n--- a/src/test/java/org/mvel2/tests/core/ThreadUnsafeTest.java\n+++ b/src/test/java/org/mvel2/tests/core/ThreadUnsafeTest.java\n@@ -80,6 +80,30 @@ public class ThreadUnsafeTest extends AbstractTest {\n         }\n     }\n \n+    public void testClassImportResolver2() {\n+        MVEL.RUNTIME_OPT_THREAD_UNSAFE = true;\n+\n+        try {\n+            ParserContext pCtx = new ParserContext();\n+\n+            AlgoContext ctx = new AlgoContext();\n+            ExpressionContext expressionContext = new ExpressionContext();\n+            ctx.setExpressionContext(expressionContext);\n+            expressionContext.setContext(ctx);\n+\n+            Order order = new Order(1, 10,100.49);\n+            OrderHelper helper = new OrderHelper();\n+            helper.setOrder(order);\n+            expressionContext.setHelper(helper);\n+\n+            Object compiledExpression3 = MVEL.compileExpression( \"import java.util.List; LeavesUnreservedQty<10 ? 1 : (RemainingSeconds<30?2:0.66)\", pCtx );\n+            int remainingSeconds = (int) MVEL.executeExpression(compiledExpression3, expressionContext, expressionContext.getVariableMap());\n+            assertEquals(2, remainingSeconds);\n+        } finally {\n+            MVEL.RUNTIME_OPT_THREAD_UNSAFE = false;\n+        }\n+    }\n+\n     public static class AlgoContext {\n \n         ExpressionContext expressionContext;\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-05-31T19:11:54.258979Z", "commit_hash": "bbe0264543d950265f2e2857e5aadb7bc5646955", "commit_message": "fix use of StackResetResolverFactory in thread unsafe evaluation\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/integration/impl/StackResetResolverFactory.java b/src/main/java/org/mvel2/integration/impl/StackResetResolverFactory.java\nindex d2e96e4..97ff3ba 100644\n--- a/src/main/java/org/mvel2/integration/impl/StackResetResolverFactory.java\n+++ b/src/main/java/org/mvel2/integration/impl/StackResetResolverFactory.java\n@@ -87,6 +87,8 @@ public class StackResetResolverFactory implements VariableResolverFactory {\n   }\n \n   public void setDelegate(VariableResolverFactory delegate) {\n-    this.delegate = delegate;\n+    if (this != delegate) {\n+      this.delegate = delegate;\n+    }\n   }\n }\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/ThreadUnsafeTest.java b/src/test/java/org/mvel2/tests/core/ThreadUnsafeTest.java\nindex fcfd3b2..814ceb8 100644\n--- a/src/test/java/org/mvel2/tests/core/ThreadUnsafeTest.java\n+++ b/src/test/java/org/mvel2/tests/core/ThreadUnsafeTest.java\n@@ -9,7 +9,7 @@ import org.mvel2.ParserContext;\n \n public class ThreadUnsafeTest extends AbstractTest {\n \n-    public void test() {\n+    public void testClassImportResolver() {\n         MVEL.RUNTIME_OPT_THREAD_UNSAFE = true;\n \n         try {\n@@ -43,6 +43,39 @@ public class ThreadUnsafeTest extends AbstractTest {\n         }\n     }\n \n+    public void testStackResolver() {\n+        MVEL.RUNTIME_OPT_THREAD_UNSAFE = true;\n+\n+        try {\n+            ParserContext pCtx = new ParserContext();\n+\n+            AlgoContext ctx = new AlgoContext();\n+            ExpressionContext expressionContext = new ExpressionContext();\n+            ctx.setExpressionContext(expressionContext);\n+            expressionContext.setContext(ctx);\n+\n+            Order order = new Order(1, 10,100.49);\n+            OrderHelper helper = new OrderHelper();\n+            helper.setOrder(order);\n+            expressionContext.setHelper(helper);\n+\n+            Object compiledExpression = MVEL.compileExpression( \"total\" );\n+            double total = (Double) MVEL.executeExpression(compiledExpression, expressionContext, expressionContext.getVariableMap());\n+            System.out.println(total);\n+\n+            Object compiledExpression1 = MVEL.compileExpression( \"leavesQty <10 ? 1.0 : (RemainSecond <30? 2.0 : 0.66)\" );\n+            double remaining = (Double) MVEL.executeExpression(compiledExpression1, expressionContext, expressionContext.getVariableMap());\n+            System.out.println(remaining);\n+\n+            order = new Order(2, 20,101.49);\n+            helper.setOrder(order);\n+            total = MVEL.executeExpression(compiledExpression, expressionContext, expressionContext.getVariableMap(), Double.class);\n+            System.out.println(total);\n+        } finally {\n+            MVEL.RUNTIME_OPT_THREAD_UNSAFE = false;\n+        }\n+    }\n+\n     public static class AlgoContext {\n \n         ExpressionContext expressionContext;\n@@ -61,7 +94,7 @@ public class ThreadUnsafeTest extends AbstractTest {\n         }\n     }\n \n-    public static class ExpressionContext {\n+    public class ExpressionContext {\n         AlgoContext context;\n \n         OrderHelper helper;\n@@ -84,8 +117,7 @@ public class ThreadUnsafeTest extends AbstractTest {\n             this.helper = helper;\n         }\n \n-        public double getTotal()\n-        {\n+        public double getTotal() {\n             return helper.getQty() * helper.getPrice();\n         }\n \n@@ -93,8 +125,7 @@ public class ThreadUnsafeTest extends AbstractTest {\n             return variableMap;\n         }\n \n-        public double getFarTouchPrice()\n-        {\n+        public double getFarTouchPrice() {\n             return context.getFarTouchPrice();\n         }\n \n@@ -102,20 +133,25 @@ public class ThreadUnsafeTest extends AbstractTest {\n             this.variableMap = variableMap;\n         }\n \n-        public boolean HAS(String key)\n-        {\n+        public boolean HAS(String key) {\n             return variableMap.containsKey(key);\n         }\n \n-        public Object GET(String key)\n-        {\n+        public Object GET(String key) {\n             return variableMap.get(key);\n         }\n \n-        public void SET(String key, Object obj)\n-        {\n+        public void SET(String key, Object obj) {\n             variableMap.put(key, obj);\n         }\n+\n+        public double getleavesQty() {\n+            return helper.getQty();\n+        }\n+\n+        public int getRemainSecond() {\n+            return 30;\n+        }\n     }\n \n     public static class Order {\n@@ -126,8 +162,7 @@ public class ThreadUnsafeTest extends AbstractTest {\n \n         double price;\n \n-        public Order(long id, int qty, double price)\n-        {\n+        public Order(long id, int qty, double price) {\n             this.orderId = id;\n             this.qty = qty;\n             this.price = price;\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-05-31T19:20:49.601982Z", "commit_hash": "8904a96dcac4f9fb9157b3698caa603b59109be8", "commit_message": "Issue182 constructor vararg support (#245)\n\n* Fix issue 182 - Support for varargs constructor\r\n\r\n* Revert accidental inclusion of Eclipse .classpath in PR\r\n\r\nCo-authored-by: Mario Fusco <mario.fusco@gmail.com>", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java b/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java\nindex 497d7a9..c0dd204 100644\n--- a/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java\n+++ b/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java\n@@ -2104,17 +2104,6 @@ private Object optimizeFieldMethodProperty(Object ctx, String property, Class<?>\n           mv.visitTypeInsn(CHECKCAST, getInternalName(declaringClass));\n         }\n \n-          Class<?> aClass = m.getParameterTypes()[m.getParameterTypes().length - 1];\n-          if(m.isVarArgs()){\n-              if(es == null || es.length == (m.getParameterTypes().length - 1) ){\n-                  ExecutableStatement[] executableStatements = new ExecutableStatement[m.getParameterTypes().length];\n-                  if(es != null){\n-                      System.arraycopy(es,0,executableStatements,0,es.length);\n-                  }\n-                  executableStatements[executableStatements.length -1 ]= new ExecutableLiteral(Array.newInstance(aClass,0));\n-                  es = executableStatements;\n-              }\n-          }\n \n         for (int i = 0; es != null && i < es.length; i++) {\n           if (es[i] instanceof ExecutableLiteral) {\n@@ -2168,7 +2157,7 @@ private Object optimizeFieldMethodProperty(Object ctx, String property, Class<?>\n                 else {\n                   assert debug(\"LDC \" + lit + \" (\" + lit.getClass().getName() + \")\");\n \n-                  mv.visitLdcInsn(convert(lit, parameterTypes[i]));\n+                  mv.visitLdcInsn(c);\n \n                   if (isPrimitiveWrapper(parameterTypes[i])) {\n                     wrapPrimitive(lit.getClass());\n@@ -2241,6 +2230,10 @@ private Object optimizeFieldMethodProperty(Object ctx, String property, Class<?>\n           }\n         }\n \n+        if(m.isVarArgs() && (es == null || es.length == (parameterTypes.length - 1) )){\n+            // The last parameter is a vararg and there is no value, create an empty array array\n+            createArray(getBaseComponentType(parameterTypes[parameterTypes.length - 1]) ,0);\n+        }\n         if ((m.getModifiers() & STATIC) != 0) {\n           assert debug(\"INVOKESTATIC: \" + m.getName());\n           mv.visitMethodInsn(INVOKESTATIC, getInternalName(declaringClass), m.getName(), getMethodDescriptor(m));\n@@ -3238,9 +3231,9 @@ private Object optimizeFieldMethodProperty(Object ctx, String property, Class<?>\n         Class<?> paramType = null;\n         int vaStart = -1;\n         for (i = 0; i < constructorParms.size(); i++) {\n-          if (i < cns.getParameterTypes().length) {\n-            paramType = cns.getParameterTypes()[i];\n-            if (cns.isVarArgs() && i == cns.getParameterTypes().length - 1) {\n+          if (i < parameterTypes.length) {\n+            paramType = parameterTypes[i];\n+            if (cns.isVarArgs() && i == parameterTypes.length - 1) {\n               paramType = getBaseComponentType(paramType);\n               vaStart = i;\n               createArray(paramType, constructorParms.size() - vaStart);\n@@ -3298,6 +3291,10 @@ private Object optimizeFieldMethodProperty(Object ctx, String property, Class<?>\n           }\n \n         }\n+        if (i < parameterTypes.length && cns.isVarArgs()) {\n+            // The last parameter is a vararg and there is no value, create an empty array array\n+            createArray(getBaseComponentType(parameterTypes[i]) ,0);\n+        }\n \n         assert debug(\"INVOKESPECIAL \" + getInternalName(cls) + \".<init> : \" + getConstructorDescriptor(cns));\n         mv.visitMethodInsn(INVOKESPECIAL, getInternalName(cls), \"<init>\", getConstructorDescriptor(cns));\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\nindex 8bc5993..4011bdf 100644\n--- a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n@@ -4899,7 +4899,21 @@ public class CoreConfidenceTests extends AbstractTest {\n     assertEquals(double.class, method.getReturnType());\n     Assert.assertArrayEquals(new Class<?>[] {double.class, int.class}, method.getParameterTypes());\n   }\n-\n+  \n+  public void testEmptyVarargConstructor() {\n+      String clsName = MySet.class.getName();\n+      OptimizerFactory.setDefaultOptimizer(\"ASM\");\n+      Serializable s = MVEL.compileExpression(\"new \" + clsName + \"()\");\n+      assertNotNull(MVEL.executeExpression(s));\n+  }\n+  \n+  public void testEmptyVarargMethod() {\n+    OptimizerFactory.setDefaultOptimizer(\"ASM\");\n+    Serializable s = MVEL.compileExpression(\"m.add()\");\n+    Map<String, MySet> inputs = Collections.singletonMap(\"m\", new MySet());\n+    MVEL.executeExpression(s, inputs);\n+  }\n+  \n   public void testForLoopWithSpaces() {\n     VariableResolverFactory factory = new MapVariableResolverFactory(new HashMap<String, Object>());\n     factory.createVariable(\"strings\", Arrays.asList( \"test\" ));\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-05-31T19:28:36.168752Z", "commit_hash": "cdc86d2addbb90e2ed91c4e51ed2cc07370b1bfb", "commit_message": "Fix Issue #252 (#254)\n\n* Fix for Eclipse Photon\r\n\r\n* Revert classpath changes\r\n\r\n* Revert \"Revert classpath changes\"\r\n\r\nThis reverts commit 5d9f56d4b3b0c563e2d7be3e2fb4a9ab3bd160a8.\r\n\r\nRevert \"Fix for Eclipse Photon\"\r\n\r\nThis reverts commit f6f837d7d2e842a9cd5021d9365cf601ac5c8275.\r\n\r\n* Fixes #252", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/PropertyAccessor.java b/src/main/java/org/mvel2/PropertyAccessor.java\nindex 845bd2a..4fd492d 100644\n--- a/src/main/java/org/mvel2/PropertyAccessor.java\n+++ b/src/main/java/org/mvel2/PropertyAccessor.java\n@@ -900,7 +900,8 @@ public class PropertyAccessor {\n      * If the target object is an instance of java.lang.Class itself then do not\n      * adjust the Class scope target.\n      */\n-    Class cls = currType != null ? currType : ((ctx instanceof Class ? (Class) ctx : ctx.getClass()));\n+    boolean classTarget = ctx instanceof Class;\n+    Class cls = currType != null ? currType : ((classTarget ? (Class) ctx : ctx.getClass()));\n     currType = null;\n \n     if (cls == Proto.ProtoInstance.class) {\n@@ -936,7 +937,7 @@ public class PropertyAccessor {\n         parameterTypes = m.getParameterTypes();\n       }\n \n-      if (m == null) {\n+      if (m == null && classTarget) {\n         /**\n          * If we didn't find anything, maybe we're looking for the actual java.lang.Class methods.\n          */\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/PropertyAccessTests.java b/src/test/java/org/mvel2/tests/core/PropertyAccessTests.java\nindex d2c36d9..89491a3 100644\n--- a/src/test/java/org/mvel2/tests/core/PropertyAccessTests.java\n+++ b/src/test/java/org/mvel2/tests/core/PropertyAccessTests.java\n@@ -1,8 +1,10 @@\n package org.mvel2.tests.core;\n \n+import org.junit.Assert;\n import org.mvel2.CompileException;\n import org.mvel2.MVEL;\n import org.mvel2.ParserContext;\n+import org.mvel2.PropertyAccessException;\n import org.mvel2.integration.PropertyHandler;\n import org.mvel2.integration.PropertyHandlerFactory;\n import org.mvel2.integration.VariableResolverFactory;\n@@ -564,4 +566,34 @@ public class PropertyAccessTests extends AbstractTest {\n     }\n     assertEquals(COUNT, trueCount);\n   }\n+  public class Service {\n+      private void hello() {\n+        System.out.println(\"hello world\");\n+      }\n+    }\n+\n+    public void testPrivateMethod() {\n+      Map<String, Object> vars = new HashMap<>();\n+      vars.put(\"service\", new Service());\n+      try {\n+        MVEL.eval(\"service.hello()\", vars);\n+        fail(\"Should have thrown a PropertyAccessException\");\n+      }\n+      catch (PropertyAccessException pae) {\n+        Assert.assertTrue(pae.getMessage().contains(\"Error: unable to resolve method\"));\n+      }\n+    }\n+    \n+    public void testPrivateMethodCompiled() {\n+      Map<String, Object> vars = new HashMap<>();\n+      vars.put(\"service\", new Service());\n+      Serializable expr = MVEL.compileExpression(\"service.hello()\");\n+      try {\n+        MVEL.executeExpression(expr, vars);\n+        fail(\"Should have thrown a PropertyAccessException\");\n+      }\n+      catch (PropertyAccessException pae) {\n+        Assert.assertTrue(pae.getMessage().contains(\"Error: unable to resolve method\"));\n+      }\n+    }\n }\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-05-31T19:35:34.481954Z", "commit_hash": "ce037852c6d81aa566cb2d1a4499c41150db97df", "commit_message": "Merge pull request #250 from MalcolmOdd/Issue249\n\nFix Issue #249", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/util/CompilerTools.java b/src/main/java/org/mvel2/util/CompilerTools.java\nindex 8ba0291..8fe67c3 100644\n--- a/src/main/java/org/mvel2/util/CompilerTools.java\n+++ b/src/main/java/org/mvel2/util/CompilerTools.java\n@@ -150,8 +150,14 @@ public class CompilerTools {\n               && tkOp2.getFields() != -1 && (op2 = tkOp2.getOperator()) != -1 && op2 < 21) {\n \n             if (PTABLE[op2] > PTABLE[op]) {\n-              //       bo.setRightMost(new BinaryOperation(op2, bo.getRightMost(), astLinkedList.nextNode(), pCtx));\n-              bo.setRightMost(boOptimize(op2, bo.getRightMost(), astLinkedList.nextNode(), pCtx));\n+               BinaryOperation newRightBo = boOptimize(op2, bo.getRightMost(), astLinkedList.nextNode(), pCtx);\n+               if (isIntOptimizationviolation(bo, newRightBo)) {\n+                 // Oops! We optimized the node based on the assumed right node type but it gets replaced\n+                 bo = new BinaryOperation(bo.getOperation(), bo.getLeft(), newRightBo, pCtx);\n+               }\n+               else {\n+                 bo.setRightMost(newRightBo);\n+               }\n             }\n             else if (bo.getOperation() != op2 && PTABLE[op] == PTABLE[op2]) {\n               if (PTABLE[bo.getOperation()] == PTABLE[op2]) {\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/ArithmeticTests.java b/src/test/java/org/mvel2/tests/core/ArithmeticTests.java\nindex 56d2d7b..0796ef9 100644\n--- a/src/test/java/org/mvel2/tests/core/ArithmeticTests.java\n+++ b/src/test/java/org/mvel2/tests/core/ArithmeticTests.java\n@@ -1,5 +1,6 @@\n package org.mvel2.tests.core;\n \n+import org.junit.Assert;\n import org.mvel2.MVEL;\n import org.mvel2.ParserConfiguration;\n import org.mvel2.ParserContext;\n@@ -1071,4 +1072,17 @@ public class ArithmeticTests extends AbstractTest {\n     Object result = MVEL.executeExpression(expr, new HashMap<String, Object>());\n     assertEquals(new BigDecimal(2), result);\n   }\n+  \n+  public void testIssue249() {\n+    /* https://github.com/mvel/mvel/issues/249\n+     * The following caused a ClassCastException because the compiler optimized for integers\n+     */\n+    String rule = \"70 + 30 *  x1\";\n+    ParserContext parserContext = new ParserContext();\n+    Serializable compileExpression = MVEL.compileExpression(rule, parserContext);\n+    Map<String, Object> expressionVars = new HashMap<>();\n+    expressionVars.put(\"x1\", 128.33);\n+    Object result = MVEL.executeExpression(compileExpression, parserContext, expressionVars);\n+    Assert.assertEquals(3919.9, ((Number)result).doubleValue(), 0.01);\n+  }\n }\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-05-31T19:43:51.077626Z", "commit_hash": "f33227ec8f785b97cc69c7f58a097fd05d259fc4", "commit_message": "fix for loop parsing\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/ast/ForEachNode.java b/src/main/java/org/mvel2/ast/ForEachNode.java\nindex bdaab9f..2c0ac86 100644\n--- a/src/main/java/org/mvel2/ast/ForEachNode.java\n+++ b/src/main/java/org/mvel2/ast/ForEachNode.java\n@@ -17,6 +17,8 @@\n  */\n package org.mvel2.ast;\n \n+import java.lang.reflect.Array;\n+\n import org.mvel2.CompileException;\n import org.mvel2.DataConversion;\n import org.mvel2.MVEL;\n@@ -27,9 +29,9 @@ import org.mvel2.integration.impl.DefaultLocalVariableResolverFactory;\n import org.mvel2.integration.impl.ItemResolverFactory;\n import org.mvel2.util.ParseTools;\n \n-import java.lang.reflect.Array;\n-\n-import static org.mvel2.util.ParseTools.*;\n+import static org.mvel2.util.ParseTools.createStringTrimmed;\n+import static org.mvel2.util.ParseTools.getBaseComponentType;\n+import static org.mvel2.util.ParseTools.subCompileExpression;\n \n /**\n  * @author Christopher Brock\n@@ -178,11 +180,10 @@ public class ForEachNode extends BlockNode {\n \n     int x;\n     if ((x = (item = createStringTrimmed(condition, start, cursor - start)).indexOf(' ')) != -1) {\n-      String tk = new String(condition, start, x).trim();\n+      String tk = item.substring(0, x);\n       try {\n         itemType = ParseTools.findClass(null, tk, pCtx);\n-        item = new String(condition, start + x, (cursor - start) - x).trim();\n-\n+        item = item.substring( item.lastIndexOf( ' ' )+1, item.length() );\n       }\n       catch (ClassNotFoundException e) {\n         throw new CompileException(\"cannot resolve identifier: \" + tk, condition, start);\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\nindex e5c0c25..8bc5993 100644\n--- a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n@@ -4899,4 +4899,23 @@ public class CoreConfidenceTests extends AbstractTest {\n     assertEquals(double.class, method.getReturnType());\n     Assert.assertArrayEquals(new Class<?>[] {double.class, int.class}, method.getParameterTypes());\n   }\n+\n+  public void testForLoopWithSpaces() {\n+    VariableResolverFactory factory = new MapVariableResolverFactory(new HashMap<String, Object>());\n+    factory.createVariable(\"strings\", Arrays.asList( \"test\" ));\n+\n+    ParserConfiguration pconf = new ParserConfiguration();\n+    ParserContext pctx = new ParserContext(pconf);\n+    pctx.setStrictTypeEnforcement(true);\n+    pctx.setStrongTyping(true);\n+    pctx.addInput(\"strings\", List.class);\n+\n+    String expression =\n+            \"for (   String   s : strings ) {\\n\" +\n+            \"  return s;\\n\" +\n+            \"}\";\n+\n+    Serializable compiledExpr = MVEL.compileExpression(expression, pctx);\n+    assertEquals( \"test\", MVEL.executeExpression(compiledExpr, null, factory));\n+  }\n }\n\\ No newline at end of file\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-05-31T19:50:30.314844Z", "commit_hash": "4eee5573c01c4374f421356e1fa02e6ce91fadb3", "commit_message": "Fix Issue #249\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/util/CompilerTools.java b/src/main/java/org/mvel2/util/CompilerTools.java\nindex 8ba0291..8fe67c3 100644\n--- a/src/main/java/org/mvel2/util/CompilerTools.java\n+++ b/src/main/java/org/mvel2/util/CompilerTools.java\n@@ -150,8 +150,14 @@ public class CompilerTools {\n               && tkOp2.getFields() != -1 && (op2 = tkOp2.getOperator()) != -1 && op2 < 21) {\n \n             if (PTABLE[op2] > PTABLE[op]) {\n-              //       bo.setRightMost(new BinaryOperation(op2, bo.getRightMost(), astLinkedList.nextNode(), pCtx));\n-              bo.setRightMost(boOptimize(op2, bo.getRightMost(), astLinkedList.nextNode(), pCtx));\n+               BinaryOperation newRightBo = boOptimize(op2, bo.getRightMost(), astLinkedList.nextNode(), pCtx);\n+               if (isIntOptimizationviolation(bo, newRightBo)) {\n+                 // Oops! We optimized the node based on the assumed right node type but it gets replaced\n+                 bo = new BinaryOperation(bo.getOperation(), bo.getLeft(), newRightBo, pCtx);\n+               }\n+               else {\n+                 bo.setRightMost(newRightBo);\n+               }\n             }\n             else if (bo.getOperation() != op2 && PTABLE[op] == PTABLE[op2]) {\n               if (PTABLE[bo.getOperation()] == PTABLE[op2]) {\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/ArithmeticTests.java b/src/test/java/org/mvel2/tests/core/ArithmeticTests.java\nindex 56d2d7b..0796ef9 100644\n--- a/src/test/java/org/mvel2/tests/core/ArithmeticTests.java\n+++ b/src/test/java/org/mvel2/tests/core/ArithmeticTests.java\n@@ -1,5 +1,6 @@\n package org.mvel2.tests.core;\n \n+import org.junit.Assert;\n import org.mvel2.MVEL;\n import org.mvel2.ParserConfiguration;\n import org.mvel2.ParserContext;\n@@ -1071,4 +1072,17 @@ public class ArithmeticTests extends AbstractTest {\n     Object result = MVEL.executeExpression(expr, new HashMap<String, Object>());\n     assertEquals(new BigDecimal(2), result);\n   }\n+  \n+  public void testIssue249() {\n+    /* https://github.com/mvel/mvel/issues/249\n+     * The following caused a ClassCastException because the compiler optimized for integers\n+     */\n+    String rule = \"70 + 30 *  x1\";\n+    ParserContext parserContext = new ParserContext();\n+    Serializable compileExpression = MVEL.compileExpression(rule, parserContext);\n+    Map<String, Object> expressionVars = new HashMap<>();\n+    expressionVars.put(\"x1\", 128.33);\n+    Object result = MVEL.executeExpression(compileExpression, parserContext, expressionVars);\n+    Assert.assertEquals(3919.9, ((Number)result).doubleValue(), 0.01);\n+  }\n }\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-05-31T20:05:58.546281Z", "commit_hash": "cc736a2454758d153b01713c164171647c64a612", "commit_message": "Merge pull request #225 from MalcolmOdd/Issue224\n\nFix #224", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java b/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java\nindex f2d357b..0dd5ebd 100644\n--- a/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java\n+++ b/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java\n@@ -46,6 +46,7 @@ import org.mvel2.optimizers.impl.refl.nodes.Union;\n import org.mvel2.util.JITClassLoader;\n import org.mvel2.util.MVELClassLoader;\n import org.mvel2.util.MethodStub;\n+import org.mvel2.util.NullType;\n import org.mvel2.util.ParseTools;\n import org.mvel2.util.PropertyTools;\n import org.mvel2.util.StringAppender;\n@@ -1761,6 +1762,9 @@ private Object optimizeFieldMethodProperty(Object ctx, String property, Class<?>\n       if (pCtx.isStrictTypeEnforcement()) {\n         for (int i = 0; i < args.length; i++) {\n           argTypes[i] = es[i].getKnownEgressType();\n+          if (es[i] instanceof ExecutableLiteral && ((ExecutableLiteral)es[i]).getLiteral() == null) {\n+              argTypes[i] = NullType.class;\n+            }\n         }\n       }\n       else {\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\nindex 91d443d..0abfb3c 100644\n--- a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n@@ -4220,6 +4220,11 @@ public class CoreConfidenceTests extends AbstractTest {\n     assertEquals(null + \"abc\", MVEL.executeExpression(MVEL.compileExpression(str, pctx)));\n   }\n \n+  public void testStaticMethodsInvocationWithNullArgASM() {\n+      OptimizerFactory.setDefaultOptimizer(\"ASM\");\n+      testStaticMethodsInvocationWithNullArg();\n+    }\n+\n   public interface InterfaceA {\n     InterfaceB getB();\n   }\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-05-31T20:13:44.671431Z", "commit_hash": "47897d1d2c6bb6f25102220b93f4b5eea019f348", "commit_message": "Merge pull request #227 from MalcolmOdd/Issue226\n\nIssue226 Fix nested expression implementation", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java b/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java\nindex b4e1f59..f2d357b 100644\n--- a/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java\n+++ b/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java\n@@ -1555,7 +1555,7 @@ private Object optimizeFieldMethodProperty(Object ctx, String property, Class<?>\n     if (ctx == null) return null;\n \n     ExecutableStatement compiled = (ExecutableStatement) subCompileExpression(tk.toCharArray());\n-    Object item = compiled.getValue(ctx, variableFactory);\n+    Object item = compiled.getValue(this.ctx, variableFactory);\n \n     ++cursor;\n \ndiff --git a/src/main/java/org/mvel2/optimizers/impl/refl/ReflectiveAccessorOptimizer.java b/src/main/java/org/mvel2/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\nindex 273da22..2afdaad 100644\n--- a/src/main/java/org/mvel2/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\n+++ b/src/main/java/org/mvel2/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\n@@ -697,11 +697,6 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n         return getMethod(ctx, property);\n       }\n \n-      // if it is not already using this as context try to read the property value from this\n-      if (ctx != this.thisRef && this.thisRef != null) {\n-        addAccessorNode(new ThisValueAccessor());\n-        return getBeanProperty(this.thisRef, property);\n-      }\n \n       if (ctx == null) {\n         throw new PropertyAccessException(\"unresolvable property or identifier: \" + property, expr, start, pCtx);\n@@ -759,7 +754,7 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n     if (itemSubExpr) {\n       try {\n         idx = (itemStmt = (ExecutableStatement) subCompileExpression(item.toCharArray(), pCtx))\n-            .getValue(ctx, thisRef, variableFactory);\n+            .getValue(thisRef, thisRef, variableFactory);\n       }\n       catch (CompileException e) {\n         e.setExpr(this.expr);\n@@ -860,7 +855,7 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n     ExecutableStatement itemStmt = null;\n     if (itemSubExpr) {\n       idx = (itemStmt = (ExecutableStatement) subCompileExpression(item.toCharArray(), pCtx))\n-          .getValue(ctx, thisRef, variableFactory);\n+          .getValue(thisRef, thisRef, variableFactory);\n     }\n \n     ++cursor;\n@@ -1006,7 +1001,6 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n     return getMethod(ctx, name, args, argTypes, es);\n   }\n \n-  @SuppressWarnings({\"unchecked\"})\n   private Object getMethod(Object ctx, String name, Object[] args, Class[] argTypes, ExecutableStatement[] es) throws Exception {\n     if (first && variableFactory != null && variableFactory.isResolveable(name)) {\n       Object ptr = variableFactory.getVariableResolver(name).getValue();\n@@ -1083,12 +1077,6 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n         return getLength(ctx);\n       }\n \n-      // if it is not already using this as context try to access the method this\n-      if (ctx != this.thisRef && this.thisRef != null) {\n-        addAccessorNode(new ThisValueAccessor());\n-        return getMethod(this.thisRef, name, args, argTypes, es);\n-      }\n-\n       for (int i = 0; i < args.length; i++) {\n         errorBuild.append(args[i] != null ? args[i].getClass().getName() : null);\n         if (i < args.length - 1) errorBuild.append(\", \");\ndiff --git a/src/main/java/org/mvel2/optimizers/impl/refl/nodes/MapAccessorNest.java b/src/main/java/org/mvel2/optimizers/impl/refl/nodes/MapAccessorNest.java\nindex 7998585..23f25f1 100644\n--- a/src/main/java/org/mvel2/optimizers/impl/refl/nodes/MapAccessorNest.java\n+++ b/src/main/java/org/mvel2/optimizers/impl/refl/nodes/MapAccessorNest.java\n@@ -51,10 +51,10 @@ public class MapAccessorNest implements AccessorNode {\n \n   public Object getValue(Object ctx, Object elCtx, VariableResolverFactory vrf) {\n     if (nextNode != null) {\n-      return nextNode.getValue(((Map) ctx).get(property.getValue(ctx, elCtx, vrf)), elCtx, vrf);\n+      return nextNode.getValue(((Map) ctx).get(property.getValue(elCtx, elCtx, vrf)), elCtx, vrf);\n     }\n     else {\n-      return ((Map) ctx).get(property.getValue(ctx, elCtx, vrf));\n+      return ((Map) ctx).get(property.getValue(elCtx, elCtx, vrf));\n     }\n   }\n \n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\nindex 74dd64a..91d443d 100644\n--- a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n@@ -37,6 +37,7 @@ import org.mvel2.MVEL;\n import org.mvel2.Macro;\n import org.mvel2.ParserConfiguration;\n import org.mvel2.ParserContext;\n+import org.mvel2.PropertyAccessException;\n import org.mvel2.PropertyAccessor;\n import org.mvel2.ast.ASTNode;\n import org.mvel2.compiler.CompiledExpression;\n@@ -3455,6 +3456,79 @@ public class CoreConfidenceTests extends AbstractTest {\n     assertTrue(result);\n   }\n \n+  public void testMVEL226() {\n+      Map<String, String> foo = new HashMap();\n+      foo.put(\"bar\", \"baz\");\n+      OptimizerFactory.setDefaultOptimizer(\"reflective\");\n+      Serializable compiledExpression = MVEL.compileExpression(\"this.bar\");\n+      VariableResolverFactory factory = new MapVariableResolverFactory(new HashMap<String, Object>());\n+      assertEquals(\"baz\", MVEL.executeExpression(compiledExpression, foo, factory, String.class));\n+    }\n+\n+  public void testMapAccessWithNestedPropertyAO() {\n+      boolean allowCompilerOverride = MVEL.COMPILER_OPT_ALLOW_OVERRIDE_ALL_PROPHANDLING;\n+      MVEL.COMPILER_OPT_ALLOW_OVERRIDE_ALL_PROPHANDLING = true;\n+      try {\n+         String str = \"map[key] == \\\"one\\\"\";\n+         ParserConfiguration pconf = new ParserConfiguration();\n+         ParserContext pctx = new ParserContext(pconf);\n+         pctx.setStrongTyping(true);\n+         pctx.addInput(\"this\", POJO.class);\n+         ExecutableStatement stmt = (ExecutableStatement) MVEL.compileExpression(str, pctx);\n+\n+         POJO ctx = new POJO();\n+         ctx.getMap().put(\"1\", \"one\");\n+         Boolean result = (Boolean) MVEL.executeExpression(stmt, ctx);\n+         assertTrue(result);\n+         result = (Boolean) MVEL.executeExpression(stmt, ctx);\n+         assertTrue(result);\n+      } finally {\n+         MVEL.COMPILER_OPT_ALLOW_OVERRIDE_ALL_PROPHANDLING = allowCompilerOverride;\n+      }\n+    }\n+  \n+  public void testMapAccessWithNestedPropertyAO_ASM() {\n+      OptimizerFactory.setDefaultOptimizer(\"ASM\");\n+      boolean allowCompilerOverride = MVEL.COMPILER_OPT_ALLOW_OVERRIDE_ALL_PROPHANDLING;\n+      MVEL.COMPILER_OPT_ALLOW_OVERRIDE_ALL_PROPHANDLING = true;\n+      try {\n+         String str = \"map[key] == \\\"one\\\"\";\n+         ParserConfiguration pconf = new ParserConfiguration();\n+         ParserContext pctx = new ParserContext(pconf);\n+         pctx.setStrongTyping(true);\n+         pctx.addInput(\"this\", POJO.class);\n+         ExecutableStatement stmt = (ExecutableStatement) MVEL.compileExpression(str, pctx);\n+\n+         POJO ctx = new POJO();\n+         ctx.getMap().put(\"1\", \"one\");\n+         Boolean result = (Boolean) MVEL.executeExpression(stmt, ctx);\n+         assertTrue(result);\n+         result = (Boolean) MVEL.executeExpression(stmt, ctx);\n+         assertTrue(result);\n+      } finally {\n+         MVEL.COMPILER_OPT_ALLOW_OVERRIDE_ALL_PROPHANDLING = allowCompilerOverride;\n+      }\n+  }\n+  \n+  public void testMapAccessProperty() {\n+      String str = \"map.key\";\n+\n+      ParserConfiguration pconf = new ParserConfiguration();\n+      ParserContext pctx = new ParserContext(pconf);\n+      pctx.setStrongTyping(true);\n+      pctx.addInput(\"this\", POJO.class);\n+      ExecutableStatement stmt = (ExecutableStatement) MVEL.compileExpression(str, pctx);\n+\n+      POJO ctx = new POJO();\n+      try {\n+        MVEL.executeExpression(stmt, ctx);\n+        fail(\"Expected PropertyAccessException\");\n+      }\n+      catch (PropertyAccessException ex) {\n+\t  assertTrue(ex.getMessage().contains(\"could not access: key\"));\n+      }      \n+  }\n+  \n   public void testMapAccessWithNestedProperty() {\n     String str = \"map[key] == \\\"one\\\"\";\n \n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-05-31T20:21:47.436001Z", "commit_hash": "2779203a13941c940f06873365349ac1794d6a35", "commit_message": "Issue226 Fix nested expression implementation\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java b/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java\nindex b4e1f59..f2d357b 100644\n--- a/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java\n+++ b/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java\n@@ -1555,7 +1555,7 @@ private Object optimizeFieldMethodProperty(Object ctx, String property, Class<?>\n     if (ctx == null) return null;\n \n     ExecutableStatement compiled = (ExecutableStatement) subCompileExpression(tk.toCharArray());\n-    Object item = compiled.getValue(ctx, variableFactory);\n+    Object item = compiled.getValue(this.ctx, variableFactory);\n \n     ++cursor;\n \ndiff --git a/src/main/java/org/mvel2/optimizers/impl/refl/ReflectiveAccessorOptimizer.java b/src/main/java/org/mvel2/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\nindex 273da22..2afdaad 100644\n--- a/src/main/java/org/mvel2/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\n+++ b/src/main/java/org/mvel2/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\n@@ -697,11 +697,6 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n         return getMethod(ctx, property);\n       }\n \n-      // if it is not already using this as context try to read the property value from this\n-      if (ctx != this.thisRef && this.thisRef != null) {\n-        addAccessorNode(new ThisValueAccessor());\n-        return getBeanProperty(this.thisRef, property);\n-      }\n \n       if (ctx == null) {\n         throw new PropertyAccessException(\"unresolvable property or identifier: \" + property, expr, start, pCtx);\n@@ -759,7 +754,7 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n     if (itemSubExpr) {\n       try {\n         idx = (itemStmt = (ExecutableStatement) subCompileExpression(item.toCharArray(), pCtx))\n-            .getValue(ctx, thisRef, variableFactory);\n+            .getValue(thisRef, thisRef, variableFactory);\n       }\n       catch (CompileException e) {\n         e.setExpr(this.expr);\n@@ -860,7 +855,7 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n     ExecutableStatement itemStmt = null;\n     if (itemSubExpr) {\n       idx = (itemStmt = (ExecutableStatement) subCompileExpression(item.toCharArray(), pCtx))\n-          .getValue(ctx, thisRef, variableFactory);\n+          .getValue(thisRef, thisRef, variableFactory);\n     }\n \n     ++cursor;\n@@ -1006,7 +1001,6 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n     return getMethod(ctx, name, args, argTypes, es);\n   }\n \n-  @SuppressWarnings({\"unchecked\"})\n   private Object getMethod(Object ctx, String name, Object[] args, Class[] argTypes, ExecutableStatement[] es) throws Exception {\n     if (first && variableFactory != null && variableFactory.isResolveable(name)) {\n       Object ptr = variableFactory.getVariableResolver(name).getValue();\n@@ -1083,12 +1077,6 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n         return getLength(ctx);\n       }\n \n-      // if it is not already using this as context try to access the method this\n-      if (ctx != this.thisRef && this.thisRef != null) {\n-        addAccessorNode(new ThisValueAccessor());\n-        return getMethod(this.thisRef, name, args, argTypes, es);\n-      }\n-\n       for (int i = 0; i < args.length; i++) {\n         errorBuild.append(args[i] != null ? args[i].getClass().getName() : null);\n         if (i < args.length - 1) errorBuild.append(\", \");\ndiff --git a/src/main/java/org/mvel2/optimizers/impl/refl/nodes/MapAccessorNest.java b/src/main/java/org/mvel2/optimizers/impl/refl/nodes/MapAccessorNest.java\nindex 7998585..23f25f1 100644\n--- a/src/main/java/org/mvel2/optimizers/impl/refl/nodes/MapAccessorNest.java\n+++ b/src/main/java/org/mvel2/optimizers/impl/refl/nodes/MapAccessorNest.java\n@@ -51,10 +51,10 @@ public class MapAccessorNest implements AccessorNode {\n \n   public Object getValue(Object ctx, Object elCtx, VariableResolverFactory vrf) {\n     if (nextNode != null) {\n-      return nextNode.getValue(((Map) ctx).get(property.getValue(ctx, elCtx, vrf)), elCtx, vrf);\n+      return nextNode.getValue(((Map) ctx).get(property.getValue(elCtx, elCtx, vrf)), elCtx, vrf);\n     }\n     else {\n-      return ((Map) ctx).get(property.getValue(ctx, elCtx, vrf));\n+      return ((Map) ctx).get(property.getValue(elCtx, elCtx, vrf));\n     }\n   }\n \n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\nindex ded7219..61ffce8 100644\n--- a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n@@ -37,6 +37,7 @@ import org.mvel2.MVEL;\n import org.mvel2.Macro;\n import org.mvel2.ParserConfiguration;\n import org.mvel2.ParserContext;\n+import org.mvel2.PropertyAccessException;\n import org.mvel2.PropertyAccessor;\n import org.mvel2.ast.ASTNode;\n import org.mvel2.compiler.CompiledExpression;\n@@ -3455,6 +3456,79 @@ public class CoreConfidenceTests extends AbstractTest {\n     assertTrue(result);\n   }\n \n+  public void testMVEL226() {\n+      Map<String, String> foo = new HashMap();\n+      foo.put(\"bar\", \"baz\");\n+      OptimizerFactory.setDefaultOptimizer(\"reflective\");\n+      Serializable compiledExpression = MVEL.compileExpression(\"this.bar\");\n+      VariableResolverFactory factory = new MapVariableResolverFactory(new HashMap<String, Object>());\n+      assertEquals(\"baz\", MVEL.executeExpression(compiledExpression, foo, factory, String.class));\n+    }\n+\n+  public void testMapAccessWithNestedPropertyAO() {\n+      boolean allowCompilerOverride = MVEL.COMPILER_OPT_ALLOW_OVERRIDE_ALL_PROPHANDLING;\n+      MVEL.COMPILER_OPT_ALLOW_OVERRIDE_ALL_PROPHANDLING = true;\n+      try {\n+         String str = \"map[key] == \\\"one\\\"\";\n+         ParserConfiguration pconf = new ParserConfiguration();\n+         ParserContext pctx = new ParserContext(pconf);\n+         pctx.setStrongTyping(true);\n+         pctx.addInput(\"this\", POJO.class);\n+         ExecutableStatement stmt = (ExecutableStatement) MVEL.compileExpression(str, pctx);\n+\n+         POJO ctx = new POJO();\n+         ctx.getMap().put(\"1\", \"one\");\n+         Boolean result = (Boolean) MVEL.executeExpression(stmt, ctx);\n+         assertTrue(result);\n+         result = (Boolean) MVEL.executeExpression(stmt, ctx);\n+         assertTrue(result);\n+      } finally {\n+         MVEL.COMPILER_OPT_ALLOW_OVERRIDE_ALL_PROPHANDLING = allowCompilerOverride;\n+      }\n+    }\n+  \n+  public void testMapAccessWithNestedPropertyAO_ASM() {\n+      OptimizerFactory.setDefaultOptimizer(\"ASM\");\n+      boolean allowCompilerOverride = MVEL.COMPILER_OPT_ALLOW_OVERRIDE_ALL_PROPHANDLING;\n+      MVEL.COMPILER_OPT_ALLOW_OVERRIDE_ALL_PROPHANDLING = true;\n+      try {\n+         String str = \"map[key] == \\\"one\\\"\";\n+         ParserConfiguration pconf = new ParserConfiguration();\n+         ParserContext pctx = new ParserContext(pconf);\n+         pctx.setStrongTyping(true);\n+         pctx.addInput(\"this\", POJO.class);\n+         ExecutableStatement stmt = (ExecutableStatement) MVEL.compileExpression(str, pctx);\n+\n+         POJO ctx = new POJO();\n+         ctx.getMap().put(\"1\", \"one\");\n+         Boolean result = (Boolean) MVEL.executeExpression(stmt, ctx);\n+         assertTrue(result);\n+         result = (Boolean) MVEL.executeExpression(stmt, ctx);\n+         assertTrue(result);\n+      } finally {\n+         MVEL.COMPILER_OPT_ALLOW_OVERRIDE_ALL_PROPHANDLING = allowCompilerOverride;\n+      }\n+  }\n+  \n+  public void testMapAccessProperty() {\n+      String str = \"map.key\";\n+\n+      ParserConfiguration pconf = new ParserConfiguration();\n+      ParserContext pctx = new ParserContext(pconf);\n+      pctx.setStrongTyping(true);\n+      pctx.addInput(\"this\", POJO.class);\n+      ExecutableStatement stmt = (ExecutableStatement) MVEL.compileExpression(str, pctx);\n+\n+      POJO ctx = new POJO();\n+      try {\n+        MVEL.executeExpression(stmt, ctx);\n+        fail(\"Expected PropertyAccessException\");\n+      }\n+      catch (PropertyAccessException ex) {\n+\t  assertTrue(ex.getMessage().contains(\"could not access: key\"));\n+      }      \n+  }\n+  \n   public void testMapAccessWithNestedProperty() {\n     String str = \"map[key] == \\\"one\\\"\";\n \n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-05-31T20:28:48.622339Z", "commit_hash": "cdddff966b945d4d38f62b538b441794c7870840", "commit_message": "Fix #224\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java b/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java\nindex b4e1f59..e674eee 100644\n--- a/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java\n+++ b/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java\n@@ -46,6 +46,7 @@ import org.mvel2.optimizers.impl.refl.nodes.Union;\n import org.mvel2.util.JITClassLoader;\n import org.mvel2.util.MVELClassLoader;\n import org.mvel2.util.MethodStub;\n+import org.mvel2.util.NullType;\n import org.mvel2.util.ParseTools;\n import org.mvel2.util.PropertyTools;\n import org.mvel2.util.StringAppender;\n@@ -1761,6 +1762,9 @@ private Object optimizeFieldMethodProperty(Object ctx, String property, Class<?>\n       if (pCtx.isStrictTypeEnforcement()) {\n         for (int i = 0; i < args.length; i++) {\n           argTypes[i] = es[i].getKnownEgressType();\n+          if (es[i] instanceof ExecutableLiteral && ((ExecutableLiteral)es[i]).getLiteral() == null) {\n+              argTypes[i] = NullType.class;\n+            }\n         }\n       }\n       else {\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\nindex ded7219..042036f 100644\n--- a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n@@ -4142,6 +4142,11 @@ public class CoreConfidenceTests extends AbstractTest {\n     assertEquals(null + \"abc\", MVEL.executeExpression(MVEL.compileExpression(str, pctx)));\n   }\n \n+  public void testStaticMethodsInvocationWithNullArgASM() {\n+      OptimizerFactory.setDefaultOptimizer(\"ASM\");\n+      testStaticMethodsInvocationWithNullArg();\n+    }\n+\n   public interface InterfaceA {\n     InterfaceB getB();\n   }\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-05-31T20:36:06.819555Z", "commit_hash": "49669cf4ecb14c2c445eb9546d64bbadac8f0784", "commit_message": "Fix Issue220 (same PR since a lot of code overlaps)\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java b/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java\nindex 59d8f09..e03f4da 100644\n--- a/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java\n+++ b/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java\n@@ -2592,6 +2592,41 @@ private Object optimizeFieldMethodProperty(Object ctx, String property, Class<?>\n       wrapPrimitive(byte.class);\n     }\n   }\n+  \n+  /**\n+   * Gets the ASM instruction operand for the given primitive type.\n+   * Will throw IllegalStateException if the type is not primitive.\n+   * @param c The class representing the primitive type. \n+   * @return The operand\n+   */\n+  public static int toPrimitiveTypeOperand(Class<?> c) {\n+      if (c == int.class) return Opcodes.T_INT;\n+      if (c == long.class) return Opcodes.T_LONG;\n+      if (c == double.class) return Opcodes.T_DOUBLE;\n+      if (c == float.class) return Opcodes.T_FLOAT;\n+      if (c == short.class) return Opcodes.T_SHORT;\n+      if (c == byte.class) return Opcodes.T_BYTE;\n+      if (c == char.class) return Opcodes.T_CHAR;\n+      if (c == boolean.class) return Opcodes.T_BOOLEAN;\n+      throw new IllegalStateException(\"Non-primitive type passed to toPrimitiveTypeOperand: \" + c);\n+   }\n+\n+  /**\n+   * Create an array of any type (primitive or reference)\n+   * @param componentType The type of array elements\n+   * @param length The length of the array\n+   */\n+  private void createArray(Class componentType, int length) {\n+      intPush(length);\n+      if (componentType.isPrimitive()) {\n+         assert debug(\"NEWARRAY \" + getInternalName(componentType) + \" (\" + length + \")\");\n+         mv.visitIntInsn(NEWARRAY, toPrimitiveTypeOperand(componentType)); \n+      }\n+      else {\n+         assert debug(\"ANEWARRAY \" + getInternalName(componentType) + \" (\" + length + \")\");\n+         mv.visitTypeInsn(ANEWARRAY, getInternalName(componentType));\n+      }\n+    }\n \n   public void arrayStore(Class cls) {\n     if (cls.isPrimitive()) {\n@@ -2872,16 +2907,8 @@ private Object optimizeFieldMethodProperty(Object ctx, String property, Class<?>\n       }\n \n       try {\n-        intPush(((Object[]) o).length);\n         Class componentType = getSubComponentType(type);\n-        if (componentType.isPrimitive()) {\n-            assert debug(\"NEWARRAY \" + getInternalName(componentType) + \" (\" + ((Object[]) o).length + \")\");\n-            mv.visitIntInsn(NEWARRAY, toPrimitiveTypeOperand(componentType)); \n-        }\n-        else {\n-            assert debug(\"ANEWARRAY \" + getInternalName(componentType) + \" (\" + ((Object[]) o).length + \")\");\n-            mv.visitTypeInsn(ANEWARRAY, getInternalName(componentType));\n-        }\n+        createArray(componentType, ((Object[])o).length);\n         Class cls = dim > 1 ? findClass(null, repeatChar('[', dim - 1)\n             + \"L\" + getBaseComponentType(type).getName() + \";\", pCtx)\n             : toNonPrimitiveArray(type);\n@@ -3140,9 +3167,31 @@ private Object optimizeFieldMethodProperty(Object ctx, String property, Class<?>\n         }\n \n         this.returnType = cns.getDeclaringClass();\n+        Class[] parameterTypes = cns.getParameterTypes();\n \n         Class tg;\n+        Class<?> paramType = null;\n+        int vaStart = -1;\n         for (i = 0; i < constructorParms.size(); i++) {\n+          if (i < cns.getParameterTypes().length) {\n+            paramType = cns.getParameterTypes()[i];\n+            if (cns.isVarArgs() && i == cns.getParameterTypes().length - 1) {\n+              paramType = getBaseComponentType(paramType);\n+              vaStart = i;\n+              createArray(paramType, constructorParms.size() - vaStart);\n+            }\n+          }\n+          else {\n+            if (vaStart < 0 || paramType == null) {\n+              throw new IllegalStateException(\"Incorrect argument count \" + i);\n+            }\n+          }\n+          if (vaStart >= 0) {\n+              assert debug(\"DUP\");\n+              mv.visitInsn(DUP);\n+              intPush(i - vaStart);\n+          }\n+\n           assert debug(\"ALOAD 0\");\n           mv.visitVarInsn(ALOAD, 0);\n           assert debug(\"GETFIELD p\" + i);\n@@ -3156,18 +3205,18 @@ private Object optimizeFieldMethodProperty(Object ctx, String property, Class<?>\n               + \"compiler/ExecutableStatement\", \"getValue\", \"(Ljava/lang/Object;L\" + NAMESPACE\n               + \"integration/VariableResolverFactory;)Ljava/lang/Object;\");\n \n-          tg = cns.getParameterTypes()[i].isPrimitive()\n-              ? getWrapperClass(cns.getParameterTypes()[i]) : cns.getParameterTypes()[i];\n+          tg = paramType.isPrimitive()\n+              ? getWrapperClass(paramType) : paramType;\n \n-          if (parms[i] != null && !parms[i].getClass().isAssignableFrom(cns.getParameterTypes()[i])) {\n+          if (parms[i] != null && !parms[i].getClass().isAssignableFrom(paramType)) {\n             ldcClassConstant(tg);\n \n             assert debug(\"INVOKESTATIC \" + NAMESPACE + \"DataConversion.convert\");\n             mv.visitMethodInsn(INVOKESTATIC, \"\" + NAMESPACE + \"DataConversion\", \"convert\",\n                 \"(Ljava/lang/Object;Ljava/lang/Class;)Ljava/lang/Object;\");\n \n-            if (cns.getParameterTypes()[i].isPrimitive()) {\n-              unwrapPrimitive(cns.getParameterTypes()[i]);\n+            if (paramType.isPrimitive()) {\n+              unwrapPrimitive(paramType);\n             }\n             else {\n               assert debug(\"CHECKCAST \" + getInternalName(tg));\n@@ -3176,8 +3225,11 @@ private Object optimizeFieldMethodProperty(Object ctx, String property, Class<?>\n \n           }\n           else {\n-            assert debug(\"CHECKCAST \" + getInternalName(cns.getParameterTypes()[i]));\n-            mv.visitTypeInsn(CHECKCAST, getInternalName(cns.getParameterTypes()[i]));\n+            assert debug(\"CHECKCAST \" + getInternalName(paramType));\n+            mv.visitTypeInsn(CHECKCAST, getInternalName(paramType));\n+          }\n+          if (vaStart >= 0) {\n+              arrayStore(paramType);\n           }\n \n         }\n@@ -3329,15 +3381,4 @@ private Object optimizeFieldMethodProperty(Object ctx, String property, Class<?>\n   public boolean isLiteralOnly() {\n     return literal;\n   }\n-  public static int toPrimitiveTypeOperand(Class<?> c) {\n-      if (c == int.class) return Opcodes.T_INT;\n-      if (c == long.class) return Opcodes.T_LONG;\n-      if (c == double.class) return Opcodes.T_DOUBLE;\n-      if (c == float.class) return Opcodes.T_FLOAT;\n-      if (c == short.class) return Opcodes.T_SHORT;\n-      if (c == byte.class) return Opcodes.T_BYTE;\n-      if (c == char.class) return Opcodes.T_CHAR;\n-      if (c == boolean.class) return Opcodes.T_BOOLEAN;\n-      throw new IllegalStateException(\"Non-primitive type passed to toPrimitiveTypeOperand: \" + c);\n-   }\n }\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\nindex ded7219..ae85c78 100644\n--- a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n@@ -3849,6 +3849,16 @@ public class CoreConfidenceTests extends AbstractTest {\n     assertTrue(result.contains(\"s2\"));\n   }\n \n+  public void testTypedVarArgsConstructorASM() {\n+    OptimizerFactory.setDefaultOptimizer(\"ASM\");\n+    try {\n+\ttestTypedVarArgsConstructor();\n+    }\n+    finally {\n+\t OptimizerFactory.setDefaultOptimizer(OptimizerFactory.DYNAMIC);\n+    }\n+  }\n+\n   private <T> T compileAndExecuteWithStrongTyping(String expression) {\n     return (T) compileAndExecuteWithStrongTyping(expression, new HashMap());\n   }\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-05-31T20:43:59.006034Z", "commit_hash": "129baa96ee5a7452554688655a1c4f6ebee55877", "commit_message": "Merge pull request #212 from X1aoFang/master\n\nFix __resolveType process InternalNumber as Object", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/util/ParseTools.java b/src/main/java/org/mvel2/util/ParseTools.java\nindex e055ead..1bd2ee2 100644\n--- a/src/main/java/org/mvel2/util/ParseTools.java\n+++ b/src/main/java/org/mvel2/util/ParseTools.java\n@@ -1042,6 +1042,7 @@ public class ParseTools {\n \n     typeCodes.put(BigDecimal.class, DataTypes.BIG_DECIMAL);\n     typeCodes.put(BigInteger.class, DataTypes.BIG_INTEGER);\n+    typeCodes.put(InternalNumber.class, DataTypes.BIG_DECIMAL);\n \n     typeCodes.put(int.class, DataTypes.INTEGER);\n     typeCodes.put(double.class, DataTypes.DOUBLE);\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/ArithmeticTests.java b/src/test/java/org/mvel2/tests/core/ArithmeticTests.java\nindex 0ef5482..8dce6e7 100644\n--- a/src/test/java/org/mvel2/tests/core/ArithmeticTests.java\n+++ b/src/test/java/org/mvel2/tests/core/ArithmeticTests.java\n@@ -1064,4 +1064,11 @@ public class ArithmeticTests extends AbstractTest {\n     vars.put(\"x\", 4);\n     assertEquals(Math.ceil((double) 4 / 3), MVEL.executeExpression(stmt, vars));\n   }\n+  \n+  public void testBigDecimalAssignmentIncrement() {\n+    String str = \"s1=0B;s1+=1;s1+=1;s1\";\n+    Serializable expr = MVEL.compileExpression(str);\n+    Object result = MVEL.executeExpression(expr, new HashMap<String, Object>());\n+    assertEquals(new BigDecimal(2), result);\n+  }\n }\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-05-31T20:50:25.970467Z", "commit_hash": "56b8415627d078a62ebbce748f2ccc9f171f349f", "commit_message": "Merge pull request #201 from MalcolmOdd/Issue200\n\nFix IncompatibleClassChangeError for bean property accessor declared in interface", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java b/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java\nindex bc71f97..b4e1f59 100644\n--- a/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java\n+++ b/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java\n@@ -1117,9 +1117,16 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n \n         returnType = ((Method) member).getReturnType();\n \n-        assert debug(\"INVOKEVIRTUAL \" + member.getName() + \":\" + returnType);\n-        mv.visitMethodInsn(INVOKEVIRTUAL, getInternalName(member.getDeclaringClass()), member.getName(),\n+        if (member.getDeclaringClass().isInterface()) {\n+          assert debug(\"INVOKEINTERFACE \" + member.getName() + \":\" + returnType);\n+          mv.visitMethodInsn(INVOKEINTERFACE, getInternalName(member.getDeclaringClass()), member.getName(),\n+              getMethodDescriptor((Method) member));\n+        }\n+        else {\n+          assert debug(\"INVOKEVIRTUAL \" + member.getName() + \":\" + returnType);\n+          mv.visitMethodInsn(INVOKEVIRTUAL, getInternalName(member.getDeclaringClass()), member.getName(),\n             getMethodDescriptor((Method) member));\n+        }\n       }\n       catch (IllegalAccessException e) {\n         Method iFaceMeth = determineActualTargetMethod((Method) member);\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/PropertyAccessTests.java b/src/test/java/org/mvel2/tests/core/PropertyAccessTests.java\nindex 8d6e947..d2c36d9 100644\n--- a/src/test/java/org/mvel2/tests/core/PropertyAccessTests.java\n+++ b/src/test/java/org/mvel2/tests/core/PropertyAccessTests.java\n@@ -548,4 +548,20 @@ public class PropertyAccessTests extends AbstractTest {\n   public void testPublicStaticFieldMVEL314(){\n     assertEquals(Foo.STATIC_BAR, runSingleTest(\"org.mvel2.tests.core.res.Foo.STATIC_BAR\"));\n   }\n+  /*\n+   * Test fix for https://github.com/mvel/mvel/issues/200\n+   */\n+  public void testCollectionEmptyASM() {\n+    Serializable compiled = MVEL.compileExpression(\"validationIssues.empty\");\n+    Map<String, Object> properties = new HashMap<String, Object>();\n+    properties.put(\"validationIssues\", new ArrayList<Object>());\n+    int trueCount = 0;\n+    final int COUNT = 1000;\n+    for (int i = 0; i < COUNT; i++) {\n+        if (MVEL.executeExpression(compiled, properties, Boolean.class)) {\n+            trueCount++;\n+        }\n+    }\n+    assertEquals(COUNT, trueCount);\n+  }\n }\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-05-31T20:57:40.899107Z", "commit_hash": "f0b39f10dbba020f19450ef233546db26696f664", "commit_message": "Fix IncompatibleClassChangeError for bean property accessor declared in interface\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java b/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java\nindex 47aede9..060b188 100644\n--- a/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java\n+++ b/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java\n@@ -1117,9 +1117,16 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n \n         returnType = ((Method) member).getReturnType();\n \n-        assert debug(\"INVOKEVIRTUAL \" + member.getName() + \":\" + returnType);\n-        mv.visitMethodInsn(INVOKEVIRTUAL, getInternalName(member.getDeclaringClass()), member.getName(),\n+        if (member.getDeclaringClass().isInterface()) {\n+          assert debug(\"INVOKEINTERFACE \" + member.getName() + \":\" + returnType);\n+          mv.visitMethodInsn(INVOKEINTERFACE, getInternalName(member.getDeclaringClass()), member.getName(),\n+              getMethodDescriptor((Method) member));\n+        }\n+        else {\n+          assert debug(\"INVOKEVIRTUAL \" + member.getName() + \":\" + returnType);\n+          mv.visitMethodInsn(INVOKEVIRTUAL, getInternalName(member.getDeclaringClass()), member.getName(),\n             getMethodDescriptor((Method) member));\n+        }\n       }\n       catch (IllegalAccessException e) {\n         Method iFaceMeth = determineActualTargetMethod((Method) member);\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/PropertyAccessTests.java b/src/test/java/org/mvel2/tests/core/PropertyAccessTests.java\nindex 8d6e947..d2c36d9 100644\n--- a/src/test/java/org/mvel2/tests/core/PropertyAccessTests.java\n+++ b/src/test/java/org/mvel2/tests/core/PropertyAccessTests.java\n@@ -548,4 +548,20 @@ public class PropertyAccessTests extends AbstractTest {\n   public void testPublicStaticFieldMVEL314(){\n     assertEquals(Foo.STATIC_BAR, runSingleTest(\"org.mvel2.tests.core.res.Foo.STATIC_BAR\"));\n   }\n+  /*\n+   * Test fix for https://github.com/mvel/mvel/issues/200\n+   */\n+  public void testCollectionEmptyASM() {\n+    Serializable compiled = MVEL.compileExpression(\"validationIssues.empty\");\n+    Map<String, Object> properties = new HashMap<String, Object>();\n+    properties.put(\"validationIssues\", new ArrayList<Object>());\n+    int trueCount = 0;\n+    final int COUNT = 1000;\n+    for (int i = 0; i < COUNT; i++) {\n+        if (MVEL.executeExpression(compiled, properties, Boolean.class)) {\n+            trueCount++;\n+        }\n+    }\n+    assertEquals(COUNT, trueCount);\n+  }\n }\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-05-31T21:05:38.232433Z", "commit_hash": "a36860e24adefff01d6632e3cd8d71e6ebafa89a", "commit_message": "fix compilation and execution of expressions mixing literals and variables\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/compiler/AbstractParser.java b/src/main/java/org/mvel2/compiler/AbstractParser.java\nindex 65b961d..0e8c02d 100644\n--- a/src/main/java/org/mvel2/compiler/AbstractParser.java\n+++ b/src/main/java/org/mvel2/compiler/AbstractParser.java\n@@ -2430,7 +2430,7 @@ public class AbstractParser implements Parser, Serializable {\n              */\n             ASTNode nextToken = nextToken();\n             if (compileMode && !nextToken.isLiteral()) {\n-              splitAccumulator.push(previousToken, new OperatorNode(operator, expr, st, pCtx));\n+              splitAccumulator.push(nextToken, new OperatorNode(operator2, expr, st, pCtx));\n               return OP_OVERFLOW;\n             }\n             dStack.push(operator = operator2, nextToken.getReducedValue(ctx, ctx, variableFactory));\ndiff --git a/src/main/java/org/mvel2/compiler/ExpressionCompiler.java b/src/main/java/org/mvel2/compiler/ExpressionCompiler.java\nindex 24ea1b7..340fcc8 100644\n--- a/src/main/java/org/mvel2/compiler/ExpressionCompiler.java\n+++ b/src/main/java/org/mvel2/compiler/ExpressionCompiler.java\n@@ -123,7 +123,7 @@ public class ExpressionCompiler extends AbstractParser {\n \n       fields |= COMPILE_IMMEDIATE;\n \n-      while ((tk = nextToken()) != null) {\n+      main_loop: while ((tk = nextToken()) != null) {\n         /**\n          * If this is a debug symbol, just add it and continue.\n          */\n@@ -199,7 +199,7 @@ public class ExpressionCompiler extends AbstractParser {\n                     stk.push(tkLA2.getLiteralValue(), op = tkOp2.getOperator());\n \n                     if (isArithmeticOperator(op)) {\n-                      compileReduce(op, astBuild);\n+                      if (!compileReduce(op, astBuild)) continue main_loop;\n                     }\n                     else {\n                       reduce();\n@@ -353,7 +353,7 @@ public class ExpressionCompiler extends AbstractParser {\n         astBuild.addTokenNode(new LiteralNode(stk.pop(), pCtx), operator);\n         astBuild.addTokenNode(rightValue, (OperatorNode) splitAccumulator.pop());\n         astBuild.addTokenNode(verify(pCtx, (ASTNode) splitAccumulator.pop()));\n-        return true;\n+        return false;\n       case OP_NOT_LITERAL:\n         ASTNode tkLA2 = (ASTNode) stk.pop();\n         Integer tkOp2 = (Integer) stk.pop();\ndiff --git a/src/main/java/org/mvel2/util/CompilerTools.java b/src/main/java/org/mvel2/util/CompilerTools.java\nindex 8a9e649..c246573 100644\n--- a/src/main/java/org/mvel2/util/CompilerTools.java\n+++ b/src/main/java/org/mvel2/util/CompilerTools.java\n@@ -103,7 +103,7 @@ public class CompilerTools {\n             bo = null;\n \n             boolean inv = tkOp.isOperator(Operator.SUB);\n-            boolean reduc = isReductionOpportunity(tkOp, tk2);\n+            boolean reduc = tk.isLiteral() && isReductionOpportunity(tkOp, tk2);\n             boolean p_inv = false;\n \n             while (reduc) {\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\nindex 201b30b..9e3cd34 100644\n--- a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n@@ -4666,16 +4666,23 @@ public class CoreConfidenceTests extends AbstractTest {\n   }\n \n   public void testUseVariableFactoryWithArithmeticOperation() {\n-    checkOperation(\"3 + 4 * i.get()\", 11);\n-    checkOperation(\"2 * 3 + 4 * i.get()\", 14);\n-    checkOperation(\"1 + 2 * 3 + i.get()\", 9);\n-    checkOperation(\"1 + 2 * 3 + 4 * i.get()\", 15);\n-    checkOperation(\"1 + 2 * 3 + i.get() * 4\", 15);\n-    checkOperation(\"1 + 2 * 3 + i.get() + 4\", 13);\n+    checkOperation(\"3 + 4 * i.get()\", 43);\n+    checkOperation(\"2 * 3 + 4 * i.get()\", 46);\n+    checkOperation(\"1 + 2 * 3 + i.get()\", 17);\n+    checkOperation(\"2 * 3 + 4 * i.get()\", 46);\n+    checkOperation(\"1 + 2 * 3 + 4 * i.get()\", 47);\n+    checkOperation(\"1 + 2 * 3 + i.get() * 4\", 47);\n+    checkOperation(\"1 + 2 * 3 + i.get() + 4\", 21);\n+    checkOperation(\"4 * i.get() + 5\", 45);\n+    checkOperation(\"3 + 4 * i.get() + 5\", 48);\n+    checkOperation(\"2 * 3 + 4 * i.get() + 5\", 51);\n+    checkOperation(\"1 + 2 * 3 + 4 * i.get() + 5\", 52);\n+    checkOperation(\"1 + 2 * 3 + 4 * i.get() * 5\", 207);\n+    checkOperation(\"i.get() + 1 + 2 * 3 + 4 * i.get()\", 57);\n   }\n \n   private void checkOperation(String expression, int expectedResult) {\n-    AtomicInteger i = new AtomicInteger( 2 );\n+    AtomicInteger i = new AtomicInteger( 10 );\n     VariableResolverFactory factory = new MapVariableResolverFactory(new HashMap<String, Object>());\n     factory.createVariable(\"i\", i);\n \n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-05-31T21:11:01.356962Z", "commit_hash": "2f5eb2459797414d5d60f36b8a0905fb00382974", "commit_message": "fix compilation and execution of expressions mixing literals and variables\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/compiler/ExpressionCompiler.java b/src/main/java/org/mvel2/compiler/ExpressionCompiler.java\nindex 34d660a..24ea1b7 100644\n--- a/src/main/java/org/mvel2/compiler/ExpressionCompiler.java\n+++ b/src/main/java/org/mvel2/compiler/ExpressionCompiler.java\n@@ -359,7 +359,7 @@ public class ExpressionCompiler extends AbstractParser {\n         Integer tkOp2 = (Integer) stk.pop();\n         astBuild.addTokenNode(new LiteralNode(getStackValueResult(), pCtx));\n         astBuild.addTokenNode(new OperatorNode(tkOp2, expr, st, pCtx), verify(pCtx, tkLA2));\n-        return true;\n+        return false;\n     }\n     return true;\n   }\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\nindex 04f6a35..201b30b 100644\n--- a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n@@ -4670,6 +4670,8 @@ public class CoreConfidenceTests extends AbstractTest {\n     checkOperation(\"2 * 3 + 4 * i.get()\", 14);\n     checkOperation(\"1 + 2 * 3 + i.get()\", 9);\n     checkOperation(\"1 + 2 * 3 + 4 * i.get()\", 15);\n+    checkOperation(\"1 + 2 * 3 + i.get() * 4\", 15);\n+    checkOperation(\"1 + 2 * 3 + i.get() + 4\", 13);\n   }\n \n   private void checkOperation(String expression, int expectedResult) {\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-05-31T21:17:11.651768Z", "commit_hash": "d25ee225a8c601f49d31e1bef6322d3feb6911c0", "commit_message": "fix compilation and execution of expressions mixing literals and variables\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/compiler/AbstractParser.java b/src/main/java/org/mvel2/compiler/AbstractParser.java\nindex 9006c0b..65b961d 100644\n--- a/src/main/java/org/mvel2/compiler/AbstractParser.java\n+++ b/src/main/java/org/mvel2/compiler/AbstractParser.java\n@@ -2408,8 +2408,6 @@ public class AbstractParser implements Parser, Serializable {\n          * need to stop if this is not a literal.\n          */\n         if (compileMode && !tk.isLiteral()) {\n-\n-\n           splitAccumulator.push(tk, new OperatorNode(operator2, expr, st, pCtx));\n           return OP_OVERFLOW;\n         }\n@@ -2417,6 +2415,7 @@ public class AbstractParser implements Parser, Serializable {\n         dStack.push(operator = operator2, tk.getReducedValue(ctx, ctx, variableFactory));\n \n         while (true) {\n+          ASTNode previousToken = tk;\n           // look ahead again\n           if ((tk = nextToken()) != null && (operator2 = tk.getOperator()) != -1\n               && operator2 != END_OF_STMT && PTABLE[operator2] > PTABLE[operator]) {\n@@ -2429,7 +2428,12 @@ public class AbstractParser implements Parser, Serializable {\n             /**\n              * This operator is of higher precedence, or the same level precedence.  push to the RHS.\n              */\n-            dStack.push(operator = operator2, nextToken().getReducedValue(ctx, ctx, variableFactory));\n+            ASTNode nextToken = nextToken();\n+            if (compileMode && !nextToken.isLiteral()) {\n+              splitAccumulator.push(previousToken, new OperatorNode(operator, expr, st, pCtx));\n+              return OP_OVERFLOW;\n+            }\n+            dStack.push(operator = operator2, nextToken.getReducedValue(ctx, ctx, variableFactory));\n \n             continue;\n           }\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\nindex f47fdb9..04f6a35 100644\n--- a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n@@ -4666,6 +4666,13 @@ public class CoreConfidenceTests extends AbstractTest {\n   }\n \n   public void testUseVariableFactoryWithArithmeticOperation() {\n+    checkOperation(\"3 + 4 * i.get()\", 11);\n+    checkOperation(\"2 * 3 + 4 * i.get()\", 14);\n+    checkOperation(\"1 + 2 * 3 + i.get()\", 9);\n+    checkOperation(\"1 + 2 * 3 + 4 * i.get()\", 15);\n+  }\n+\n+  private void checkOperation(String expression, int expectedResult) {\n     AtomicInteger i = new AtomicInteger( 2 );\n     VariableResolverFactory factory = new MapVariableResolverFactory(new HashMap<String, Object>());\n     factory.createVariable(\"i\", i);\n@@ -4676,8 +4683,8 @@ public class CoreConfidenceTests extends AbstractTest {\n     pctx.setStrongTyping(true);\n     pctx.addInput(\"i\", AtomicInteger.class);\n \n-    Serializable compiledExpr = MVEL.compileExpression(\"1 + 2 * 3 + i.get()\", pctx);\n+    Serializable compiledExpr = MVEL.compileExpression(expression, pctx);\n     int result = (Integer)MVEL.executeExpression(compiledExpr, null, factory);\n-    assertEquals(9, result);\n+    assertEquals(expectedResult, result);\n   }\n }\n\\ No newline at end of file\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-05-31T21:42:34.796600Z", "commit_hash": "826d423596e53f59958eb1666a57dcde7416cf6e", "commit_message": "[issue-135] The optimization for the Collection.isEmpty() method is fixed\n\nThe reflective getter for collections' empty property is changed to Collection.isEmpty() method to prevent the IllegalAccessException when the context is changed from ArrayList to Collections.EmptyList or from HashSet to Collections.EmptySet and vice versa\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/util/PropertyTools.java b/src/main/java/org/mvel2/util/PropertyTools.java\nindex c97801e..0513308 100644\n--- a/src/main/java/org/mvel2/util/PropertyTools.java\n+++ b/src/main/java/org/mvel2/util/PropertyTools.java\n@@ -97,6 +97,13 @@ public class PropertyTools {\n     String getter = ReflectionUtil.getGetter(property);\n \n     Method candidate = null;\n+\n+    if (Collection.class.isAssignableFrom(clazz) && \"isEmpty\".equals(isGet)) {\n+      try {\n+        return Collection.class.getMethod(\"isEmpty\");\n+      } catch (NoSuchMethodException ignore) {}\n+    }\n+\n     for (Method meth : clazz.getMethods()) {\n       if ((meth.getModifiers() & PUBLIC) != 0 && (meth.getModifiers() & STATIC) == 0 && meth.getParameterTypes().length == 0\n           && (getter.equals(meth.getName()) || property.equals(meth.getName()) || ((isGet.equals(meth.getName()) || simpleIsGet.equals(meth.getName())) && meth.getReturnType() == boolean.class)\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/PropertyAccessTests.java b/src/test/java/org/mvel2/tests/core/PropertyAccessTests.java\nindex bc36679..8d6e947 100644\n--- a/src/test/java/org/mvel2/tests/core/PropertyAccessTests.java\n+++ b/src/test/java/org/mvel2/tests/core/PropertyAccessTests.java\n@@ -468,6 +468,41 @@ public class PropertyAccessTests extends AbstractTest {\n     }\n   }\n \n+  public final class Data {\n+\n+    private final Collection<Object> list;\n+\n+    Data(List<Object> list) {\n+      this.list = list;\n+    }\n+\n+    public Collection<Object> getList() {\n+      return list;\n+    }\n+  }\n+\n+  public void testStaleReflectiveCollectionIsEmptyAccessor() {\n+    try\n+    {\n+      OptimizerFactory.setDefaultOptimizer(OptimizerFactory.SAFE_REFLECTIVE);\n+      Serializable getFooExpression = MVEL.compileExpression(\"list.empty\");\n+      Map vars = new HashMap();\n+\n+      // ArrayList -> Colletions.EmptyList\n+      assertEquals(true, MVEL.executeExpression(getFooExpression, new Data(new ArrayList<Object>())));\n+      assertEquals(true, MVEL.executeExpression(getFooExpression, new Data(Collections.emptyList())));\n+\n+      // Colletions.EmptyList -> ArrayList\n+      assertEquals(true, MVEL.executeExpression(getFooExpression, new Data(Collections.emptyList())));\n+      assertEquals(true, MVEL.executeExpression(getFooExpression, new Data(new ArrayList<Object>())));\n+      OptimizerFactory.setDefaultOptimizer(OptimizerFactory.DYNAMIC);\n+    }\n+    finally\n+    {\n+      OptimizerFactory.setDefaultOptimizer(OptimizerFactory.DYNAMIC);\n+    }\n+  }\n+\n   public void testMVEL308() {\n     String expression = \"foreach(field: updates.entrySet()) { ctx._target[field.key] = field.value; }\";\n     Serializable compiled = MVEL.compileExpression(expression);\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-05-31T21:46:38.698308Z", "commit_hash": "1bcbe976b8e0fcac5cda277b0f604d769a3d2671", "commit_message": "fix generic type inference in composite expressions\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/ParserConfiguration.java b/src/main/java/org/mvel2/ParserConfiguration.java\nindex f8adfbd..41cc122 100644\n--- a/src/main/java/org/mvel2/ParserConfiguration.java\n+++ b/src/main/java/org/mvel2/ParserConfiguration.java\n@@ -42,7 +42,6 @@ import static org.mvel2.util.ParseTools.forNameWithInner;\n  * The resusable parser configuration object.\n  */\n public class ParserConfiguration implements Serializable {\n-  private static final int MAX_NEGATIVE_CACHE_SIZE;\n \n   protected final Map<String, Object> imports = new ConcurrentHashMap<String, Object>();\n   protected HashSet<String> packageImports;\n@@ -55,16 +54,6 @@ public class ParserConfiguration implements Serializable {\n \n   private boolean allowBootstrapBypass = true;\n \n-  static {\n-    String negCacheSize = System.getProperty(\"mvel2.compiler.max_neg_cache_size\");\n-    if (negCacheSize != null) {\n-      MAX_NEGATIVE_CACHE_SIZE = Integer.parseInt(negCacheSize);\n-    }\n-    else {\n-      MAX_NEGATIVE_CACHE_SIZE = 1000;\n-    }\n-  }\n-\n   public ParserConfiguration() {\n   }\n \ndiff --git a/src/main/java/org/mvel2/ParserContext.java b/src/main/java/org/mvel2/ParserContext.java\nindex 129f2d9..093e694 100644\n--- a/src/main/java/org/mvel2/ParserContext.java\n+++ b/src/main/java/org/mvel2/ParserContext.java\n@@ -844,18 +844,6 @@ public class ParserContext implements Serializable {\n     return globalFunctions != null && globalFunctions.size() != 0;\n   }\n \n-  public void addTypeParameters(String name, Class type) {\n-    if (typeParameters == null) typeParameters = new HashMap<String, Map<String, Type>>();\n-\n-    Map<String, Type> newPkg = new HashMap<String, Type>();\n-\n-    for (Type t : type.getTypeParameters()) {\n-      newPkg.put(t.toString(), Object.class);\n-    }\n-\n-    typeParameters.put(name, newPkg);\n-  }\n-\n   public void addTypeParameters(Map<String, Map<String, Type>> typeParameters) {\n     if (typeParameters == null) return;\n     if (this.typeParameters == null) typeParameters = new HashMap<String, Map<String, Type>>();\n@@ -1074,11 +1062,6 @@ public class ParserContext implements Serializable {\n     return this;\n   }\n \n-  public ParserContext withTypeParameter(String name, Class type) {\n-    addTypeParameters(name, type);\n-    return this;\n-  }\n-\n   public ParserContext withTypeParameters(Map<String, Map<String, Type>> typeParameters) {\n     addTypeParameters(typeParameters);\n     return this;\ndiff --git a/src/main/java/org/mvel2/compiler/PropertyVerifier.java b/src/main/java/org/mvel2/compiler/PropertyVerifier.java\nindex e999db8..5230deb 100644\n--- a/src/main/java/org/mvel2/compiler/PropertyVerifier.java\n+++ b/src/main/java/org/mvel2/compiler/PropertyVerifier.java\n@@ -153,9 +153,6 @@ public class PropertyVerifier extends AbstractOptimizer {\n \n   private void recordTypeParmsForProperty(String property) {\n     if (pCtx.isStrictTypeEnforcement()) {\n-      if ((paramTypes = pCtx.getTypeParameters(property)) == null) {\n-        pCtx.addTypeParameters(property, pCtx.getVarOrInputType(property));\n-      }\n       pCtx.setLastTypeParameters(pCtx.getTypeParametersAsArray(property));\n     }\n   }\n@@ -402,10 +399,10 @@ public class PropertyVerifier extends AbstractOptimizer {\n \n     if (pCtx.isStrictTypeEnforcement()) {\n       if (Map.class.isAssignableFrom(property.length() != 0 ? ctx = getBeanProperty(ctx, property) : ctx)) {\n-        ctx = type2Class(pCtx.getLastTypeParameters().length != 0 ? pCtx.getLastTypeParameters()[1] : Object.class);\n+        ctx = type2Class(pCtx.getLastTypeParameters() != null && pCtx.getLastTypeParameters().length != 0 ? pCtx.getLastTypeParameters()[1] : Object.class);\n       }\n       else if (Collection.class.isAssignableFrom(ctx)) {\n-        ctx = pCtx.getLastTypeParameters().length == 0 ? Object.class : type2Class(pCtx.getLastTypeParameters()[0]);\n+        ctx = pCtx.getLastTypeParameters() == null || pCtx.getLastTypeParameters().length == 0 ? Object.class : type2Class(pCtx.getLastTypeParameters()[0]);\n       }\n       else if (ctx.isArray()) {\n         ctx = ctx.getComponentType();\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\nindex 7396c44..2c2b3ab 100644\n--- a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n@@ -4571,4 +4571,23 @@ public class CoreConfidenceTests extends AbstractTest {\n     Thingy result = (Thingy) MVEL.executeExpression(MVEL.compileExpression(\"new Thingy(name)\", pctx), vars);\n     assertEquals( \"test\", result.getName() );\n   }\n+\n+  public void testGenericsWithOr() {\n+    final ParserContext parserContext = new ParserContext();\n+    parserContext.setStrictTypeEnforcement(true);\n+    parserContext.setStrongTyping(true);\n+    parserContext.addInput(\"o\", OrderLine.class);\n+    parserContext.addInput(\"p\", Product.class);\n+    Class<?> clazz = MVEL.analyze(\"p.id == o.product.id || p.category == o.product.category\", parserContext);\n+    assertEquals(Boolean.class, clazz);\n+  }\n+\n+  public interface OrderLine<T extends Product> {\n+    T getProduct();\n+  }\n+\n+  public interface Product {\n+    String getId();\n+    String getCategory();\n+  }\n }\n\\ No newline at end of file\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-05-31T21:51:13.048762Z", "commit_hash": "a63efbdc59f1caa30c4d9cca3dde77139e934f12", "commit_message": "fix varargs method resolution\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/util/ParseTools.java b/src/main/java/org/mvel2/util/ParseTools.java\nindex d462da7..d019c1a 100644\n--- a/src/main/java/org/mvel2/util/ParseTools.java\n+++ b/src/main/java/org/mvel2/util/ParseTools.java\n@@ -18,24 +18,6 @@\n \n package org.mvel2.util;\n \n-import org.mvel2.CompileException;\n-import org.mvel2.DataTypes;\n-import org.mvel2.MVEL;\n-import org.mvel2.Operator;\n-import org.mvel2.OptimizationFailure;\n-import org.mvel2.ParserContext;\n-import org.mvel2.ast.ASTNode;\n-import org.mvel2.compiler.AbstractParser;\n-import org.mvel2.compiler.BlankLiteral;\n-import org.mvel2.compiler.CompiledExpression;\n-import org.mvel2.compiler.ExecutableAccessor;\n-import org.mvel2.compiler.ExecutableAccessorSafe;\n-import org.mvel2.compiler.ExecutableLiteral;\n-import org.mvel2.compiler.ExpressionCompiler;\n-import org.mvel2.integration.VariableResolverFactory;\n-import org.mvel2.integration.impl.ClassImportResolverFactory;\n-import org.mvel2.math.MathProcessor;\n-\n import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n@@ -61,6 +43,24 @@ import java.util.List;\n import java.util.Map;\n import java.util.WeakHashMap;\n \n+import org.mvel2.CompileException;\n+import org.mvel2.DataTypes;\n+import org.mvel2.MVEL;\n+import org.mvel2.Operator;\n+import org.mvel2.OptimizationFailure;\n+import org.mvel2.ParserContext;\n+import org.mvel2.ast.ASTNode;\n+import org.mvel2.compiler.AbstractParser;\n+import org.mvel2.compiler.BlankLiteral;\n+import org.mvel2.compiler.CompiledExpression;\n+import org.mvel2.compiler.ExecutableAccessor;\n+import org.mvel2.compiler.ExecutableAccessorSafe;\n+import org.mvel2.compiler.ExecutableLiteral;\n+import org.mvel2.compiler.ExpressionCompiler;\n+import org.mvel2.integration.VariableResolverFactory;\n+import org.mvel2.integration.impl.ClassImportResolverFactory;\n+import org.mvel2.math.MathProcessor;\n+\n import static java.lang.Class.forName;\n import static java.lang.Double.parseDouble;\n import static java.lang.String.valueOf;\n@@ -254,7 +254,7 @@ public class ParseTools {\n           }\n \n           boolean isVarArgs = meth.isVarArgs();\n-          if (parmTypes.length != arguments.length && !isVarArgs) {\n+          if ( isArgsNumberNotCompatible( arguments, parmTypes, isVarArgs ) ) {\n             continue;\n           }\n \n@@ -300,6 +300,10 @@ public class ParseTools {\n     return bestCandidate;\n   }\n \n+  private static boolean isArgsNumberNotCompatible( Class[] arguments, Class<?>[] parmTypes, boolean isVarArgs ) {\n+    return ( isVarArgs && parmTypes.length-1 > arguments.length ) || ( !isVarArgs && parmTypes.length != arguments.length );\n+  }\n+\n   private static boolean isMoreSpecialized( Method newCandidate, Method oldCandidate ) {\n     return oldCandidate.getReturnType().isAssignableFrom( newCandidate.getReturnType()) &&\n            oldCandidate.getDeclaringClass().isAssignableFrom( newCandidate.getDeclaringClass());\n@@ -459,7 +463,8 @@ public class ParseTools {\n \n     for (Constructor construct : getConstructors(cls)) {\n       boolean isVarArgs = construct.isVarArgs();\n-      if ((parmTypes = getConstructors(construct)).length != arguments.length && !construct.isVarArgs()) {\n+      parmTypes = getConstructors(construct);\n+      if ( isArgsNumberNotCompatible( arguments, parmTypes, isVarArgs ) ) {\n         continue;\n       }\n       else if (arguments.length == 0 && parmTypes.length == 0) {\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\nindex e37243d..7396c44 100644\n--- a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n@@ -1,5 +1,33 @@\n package org.mvel2.tests.core;\n \n+import java.awt.*;\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.io.Serializable;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Calendar;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.Vector;\n+\n import junit.framework.TestCase;\n import org.mvel2.CompileException;\n import org.mvel2.DataConversion;\n@@ -53,34 +81,6 @@ import org.mvel2.tests.core.res.res2.PublicClass;\n import org.mvel2.util.ParseTools;\n import org.mvel2.util.ReflectionUtil;\n \n-import java.awt.*;\n-import java.io.BufferedReader;\n-import java.io.File;\n-import java.io.IOException;\n-import java.io.OutputStream;\n-import java.io.PrintStream;\n-import java.io.Serializable;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.math.BigDecimal;\n-import java.math.BigInteger;\n-import java.net.URL;\n-import java.net.URLClassLoader;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Calendar;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.LinkedHashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.Vector;\n-\n import static java.util.Collections.unmodifiableCollection;\n import static org.mvel2.MVEL.*;\n import static org.mvel2.util.ParseTools.loadFromFile;\n@@ -4533,4 +4533,42 @@ public class CoreConfidenceTests extends AbstractTest {\n     parserContext.addInput(\"conv\", Convention.class);\n     assertEquals(List.class, MVEL.analyze(\"conv.getComms().get(\\\"test\\\")\", parserContext));\n   }\n+\n+  public static class Thingy implements Serializable {\n+    private String name;\n+    private String version;\n+    private Object[] items;\n+\n+    public Thingy(String name, String version, Object... items) {\n+      this.name = name;\n+      this.version = version;\n+      this.items = items;\n+    }\n+\n+    public Thingy(String name) {\n+      this.name = name;\n+      this.version = null;\n+      this.items = null;\n+    }\n+\n+    public void print() {\n+      System.out.println(\"Printing rule \" + name);\n+    }\n+\n+    public String getName() {\n+      return name;\n+    }\n+  }\n+\n+  public void testInvokeVarargConstructor() {\n+    ParserConfiguration conf = new ParserConfiguration();\n+    conf.addImport( Thingy.class );\n+    ParserContext pctx = new ParserContext( conf );\n+    pctx.setStrictTypeEnforcement(true);\n+    pctx.setStrongTyping(true);\n+    pctx.addInput(\"name\", String.class);\n+    Map vars = new HashMap() {{ put(\"name\", \"test\"); }};\n+    Thingy result = (Thingy) MVEL.executeExpression(MVEL.compileExpression(\"new Thingy(name)\", pctx), vars);\n+    assertEquals( \"test\", result.getName() );\n+  }\n }\n\\ No newline at end of file\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-05-31T21:55:31.842880Z", "commit_hash": "5dc9fe365a26906bd73a6ab48cbe1b5b140eb5f8", "commit_message": "fix analisys of expression with generic types\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/compiler/PropertyVerifier.java b/src/main/java/org/mvel2/compiler/PropertyVerifier.java\nindex 307e925..c6a1bb0 100644\n--- a/src/main/java/org/mvel2/compiler/PropertyVerifier.java\n+++ b/src/main/java/org/mvel2/compiler/PropertyVerifier.java\n@@ -639,7 +639,8 @@ public class PropertyVerifier extends AbstractOptimizer {\n         /**\n          * If the paramTypes Map contains the known type, return that type.\n          */\n-        return (Class) paramTypes.get(returnTypeArg);\n+        Type type = paramTypes.get(returnTypeArg);\n+        return type instanceof Class ? (Class) type : (Class) ((ParameterizedType) type).getRawType();\n       }\n       else if (typeArgs.containsKey(returnTypeArg)) {\n         /**\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\nindex 9305037..e37243d 100644\n--- a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n@@ -4515,4 +4515,22 @@ public class CoreConfidenceTests extends AbstractTest {\n     Map vars = new HashMap() {{ put(\"a\", new O1()); }};\n     assertEquals(\"value\", MVEL.executeExpression(MVEL.compileExpression(\"a.getObj().getValue()\", parserContext), vars));\n   }\n+\n+  public class Convention {\n+    private final Map<String, List<String>> comms;\n+    public Convention( Map<String, List<String>> comms ) {\n+      this.comms = comms;\n+    }\n+    public Map<String, List<String>> getComms(){\n+      return comms;\n+    }\n+  }\n+\n+  public void testParseGenericMap() {\n+    final ParserContext parserContext = new ParserContext();\n+    parserContext.setStrictTypeEnforcement(true);\n+    parserContext.setStrongTyping(true);\n+    parserContext.addInput(\"conv\", Convention.class);\n+    assertEquals(List.class, MVEL.analyze(\"conv.getComms().get(\\\"test\\\")\", parserContext));\n+  }\n }\n\\ No newline at end of file\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-05-31T22:08:31.625630Z", "commit_hash": "6e568f1fa1e2025bc901d77caddec0d6e9cf930a", "commit_message": "fix import resolution with inner classes\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/ParserConfiguration.java b/src/main/java/org/mvel2/ParserConfiguration.java\nindex 7267d79..37797a6 100644\n--- a/src/main/java/org/mvel2/ParserConfiguration.java\n+++ b/src/main/java/org/mvel2/ParserConfiguration.java\n@@ -28,10 +28,16 @@ import java.io.Serializable;\n import java.lang.reflect.Field;\n import java.lang.reflect.Method;\n import java.lang.reflect.Modifier;\n-import java.util.*;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n \n-import static java.lang.Thread.currentThread;\n+import static org.mvel2.util.ParseTools.forNameWithInner;\n \n /**\n  * The resusable parser configuration object.\n@@ -118,7 +124,7 @@ public class ParserConfiguration implements Serializable {\n       }\n       else {\n         for (Field f : c.getDeclaredFields()) {\n-          if ((f.getModifiers() & (Modifier.STATIC | Modifier.PUBLIC)) != 0) {\n+          if ((f.getModifiers() & (Modifier.STATIC | Modifier.PUBLIC)) == (Modifier.STATIC | Modifier.PUBLIC)) {\n             imports.put(f.getName(), f.get(null));\n           }\n         }\n@@ -160,10 +166,10 @@ public class ParserConfiguration implements Serializable {\n     Class cls = null;\n     for (String pkg : packageImports) {\n       try {\n-        cls = Class.forName(pkg + \".\" + className, true, getClassLoader());\n+        cls = forNameWithInner( pkg + \".\" + className, getClassLoader() );\n         found++;\n       }\n-      catch (ClassNotFoundException e) {\n+      catch (ClassNotFoundException cnfe) {\n         // do nothing.\n       }\n       catch (NoClassDefFoundError e) {\ndiff --git a/src/main/java/org/mvel2/optimizers/AbstractOptimizer.java b/src/main/java/org/mvel2/optimizers/AbstractOptimizer.java\nindex 7e6a9d0..a7ec8b6 100644\n--- a/src/main/java/org/mvel2/optimizers/AbstractOptimizer.java\n+++ b/src/main/java/org/mvel2/optimizers/AbstractOptimizer.java\n@@ -68,20 +68,21 @@ public class AbstractOptimizer extends AbstractParser {\n           case '.':\n             if (!meth) {\n               ClassLoader classLoader = pCtx != null ? pCtx.getClassLoader() : currentThread().getContextClassLoader();\n+              String test = new String(expr, start, (cursor = last) - start);\n               try {\n-                String test = new String(expr, start, (cursor = last) - start);\n                 if (MVEL.COMPILER_OPT_SUPPORT_JAVA_STYLE_CLASS_LITERALS && test.endsWith(\".class\"))\n                     test = test.substring(0, test.length() - 6);\n \n                 return Class.forName(test, true, classLoader);\n-              }\n-              catch (ClassNotFoundException e) {\n+              } catch (ClassNotFoundException cnfe) {\n+                try {\n+                  return findInnerClass( test, classLoader, cnfe );\n+                } catch (ClassNotFoundException e) { /* ignore */ }\n                 Class cls = forNameWithInner(new String(expr, start, i - start), classLoader);\n                 String name = new String(expr, i + 1, end - i - 1);\n                 try {\n                   return cls.getField(name);\n-                }\n-                catch (NoSuchFieldException nfe) {\n+                } catch (NoSuchFieldException nfe) {\n                   for (Method m : cls.getMethods()) {\n                     if (name.equals(m.getName())) return m;\n                   }\n@@ -160,24 +161,6 @@ public class AbstractOptimizer extends AbstractParser {\n     return null;\n   }\n \n-  private Class forNameWithInner(String className, ClassLoader classLoader) throws ClassNotFoundException {\n-    ClassNotFoundException cnfe = null;\n-    try {\n-      return Class.forName(className, true, classLoader);\n-    } catch (ClassNotFoundException e) {\n-      cnfe = e;\n-    }\n-\n-    for (int lastDotPos = className.lastIndexOf('.'); lastDotPos > 0; lastDotPos = className.lastIndexOf('.')) {\n-      className = className.substring(0, lastDotPos) + \"$\" + className.substring(lastDotPos+1);\n-      try {\n-        return Class.forName(className, true, classLoader);\n-      } catch (ClassNotFoundException e) { }\n-    }\n-\n-     throw cnfe;\n-  }\n-\n   protected int nextSubToken() {\n     skipWhitespace();\n     nullSafe = false;\ndiff --git a/src/main/java/org/mvel2/util/ParseTools.java b/src/main/java/org/mvel2/util/ParseTools.java\nindex f3c2957..8a11b03 100644\n--- a/src/main/java/org/mvel2/util/ParseTools.java\n+++ b/src/main/java/org/mvel2/util/ParseTools.java\n@@ -425,7 +425,6 @@ public class ParseTools {\n \n     if (best != method) return best;\n \n-    currentCls = cls;\n     for (currentCls = cls; currentCls != null; currentCls = currentCls.getSuperclass()) {\n       if ((m = getExactMatch(name, args, rt, currentCls)) != null) {\n         best = m;\n@@ -502,7 +501,7 @@ public class ParseTools {\n     }\n \n     WeakReference<Class> ref;\n-    Class cls = null;\n+    Class cls;\n \n     if ((ref = cache.get(className)) != null && (cls = ref.get()) != null) {\n       return cls;\n@@ -2184,4 +2183,22 @@ public class ParseTools {\n       if (inStream != null) inStream.close();\n     }\n   }\n+\n+  public static Class forNameWithInner(String className, ClassLoader classLoader) throws ClassNotFoundException {\n+    try {\n+      return Class.forName(className, true, classLoader);\n+    } catch (ClassNotFoundException cnfe) {\n+      return findInnerClass( className, classLoader, cnfe );\n+    }\n+  }\n+\n+  public static Class findInnerClass( String className, ClassLoader classLoader, ClassNotFoundException cnfe ) throws ClassNotFoundException {\n+    for (int lastDotPos = className.lastIndexOf('.'); lastDotPos > 0; lastDotPos = className.lastIndexOf('.')) {\n+      className = className.substring(0, lastDotPos) + \"$\" + className.substring(lastDotPos+1);\n+      try {\n+        return Class.forName(className, true, classLoader);\n+      } catch (ClassNotFoundException e) { /* ignore */ }\n+    }\n+    throw cnfe;\n+  }\n }\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\nindex 6022874..fc6741b 100644\n--- a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n@@ -4410,4 +4410,40 @@ public class CoreConfidenceTests extends AbstractTest {\n     assertEquals(true, MVEL.executeExpression(MVEL.compileExpression(\"zero == empty\", pctx), vars));\n     assertEquals(false, MVEL.executeExpression(MVEL.compileExpression(\"nonZero == empty\", pctx), vars));\n   }\n+\n+  public void testInstanceofOnInnerClass() {\n+    ParserConfiguration conf = new ParserConfiguration();\n+    conf.addImport(ARef.class);\n+    ParserContext pctx = new ParserContext( conf );\n+    pctx.setStrictTypeEnforcement(true);\n+    pctx.setStrongTyping(true);\n+    pctx.addInput(\"value\", Object.class);\n+    Map vars = new HashMap() {{ put(\"value\", new ARef()); }};\n+    assertEquals(true, MVEL.executeExpression(MVEL.compileExpression(\"value instanceof ARef\", pctx), vars));\n+    assertEquals(true, MVEL.executeExpression(MVEL.compileExpression(\"value instanceof \" + ARef.class.getCanonicalName(), pctx), vars));\n+  }\n+\n+  public void testInstanceofWithPackageImport() {\n+    ParserConfiguration conf = new ParserConfiguration();\n+    conf.addPackageImport( \"org.mvel2.tests.core\" );\n+    ParserContext pctx = new ParserContext( conf );\n+    pctx.setStrictTypeEnforcement(true);\n+    pctx.setStrongTyping(true);\n+    pctx.addInput(\"value\", Object.class);\n+    Map vars = new HashMap() {{ put(\"value\", new CoreConfidenceTests()); }};\n+    assertEquals(true, MVEL.executeExpression(MVEL.compileExpression(\"value instanceof CoreConfidenceTests\", pctx), vars));\n+    assertEquals(true, MVEL.executeExpression(MVEL.compileExpression(\"value instanceof \" + CoreConfidenceTests.class.getCanonicalName(), pctx), vars));\n+  }\n+\n+  public void testInstanceofWithPackageImportAndInnerClass() {\n+    ParserConfiguration conf = new ParserConfiguration();\n+    conf.addPackageImport( \"org.mvel2.tests.core.CoreConfidenceTests\" );\n+    ParserContext pctx = new ParserContext( conf );\n+    pctx.setStrictTypeEnforcement(true);\n+    pctx.setStrongTyping(true);\n+    pctx.addInput(\"value\", Object.class);\n+    Map vars = new HashMap() {{ put(\"value\", new ARef()); }};\n+    assertEquals(true, MVEL.executeExpression(MVEL.compileExpression(\"value instanceof ARef\", pctx), vars));\n+    assertEquals(true, MVEL.executeExpression(MVEL.compileExpression(\"value instanceof \" + ARef.class.getCanonicalName(), pctx), vars));\n+  }\n }\n\\ No newline at end of file\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-05-31T22:13:01.716164Z", "commit_hash": "b44824e9ccbc565b6619714c92582014271e4bbb", "commit_message": "fix evaluation of empty literal\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/compiler/BlankLiteral.java b/src/main/java/org/mvel2/compiler/BlankLiteral.java\nindex 4f5936f..e381d88 100644\n--- a/src/main/java/org/mvel2/compiler/BlankLiteral.java\n+++ b/src/main/java/org/mvel2/compiler/BlankLiteral.java\n@@ -32,18 +32,21 @@ public class BlankLiteral implements Serializable {\n   }\n \n   public boolean equals(Object obj) {\n-    if (obj == null || \"\".equals(valueOf(obj))) {\n+    if (obj == null || valueOf(obj).trim().length() == 0) {\n       return true;\n     }\n-    else if (isNumeric(obj)) {\n+    if (isNumeric(obj)) {\n       return \"0\".equals(valueOf(obj));\n     }\n-    else if (obj instanceof Collection) {\n+    if (obj instanceof Collection) {\n       return ((Collection) obj).size() == 0;\n     }\n-    else if (obj.getClass().isArray()) {\n+    if (obj.getClass().isArray()) {\n       return getLength(obj) == 0;\n     }\n+    if (obj instanceof Boolean) {\n+      return !(Boolean)obj;\n+    }\n     return false;\n   }\n \ndiff --git a/src/main/java/org/mvel2/math/MathProcessor.java b/src/main/java/org/mvel2/math/MathProcessor.java\nindex bb3c01e..c0264a5 100644\n--- a/src/main/java/org/mvel2/math/MathProcessor.java\n+++ b/src/main/java/org/mvel2/math/MathProcessor.java\n@@ -18,8 +18,8 @@\n package org.mvel2.math;\n \n import org.mvel2.DataTypes;\n-import org.mvel2.Operator;\n import org.mvel2.Unit;\n+import org.mvel2.compiler.BlankLiteral;\n import org.mvel2.debug.DebugTools;\n import org.mvel2.util.InternalNumber;\n \n@@ -664,7 +664,7 @@ public strictfp class MathProcessor {\n   }\n \n   private static Double getNumber(Object in, int type) {\n-    if (in == null)\n+    if (in == null || in == BlankLiteral.INSTANCE)\n       return 0d;\n     switch (type) {\n       case BIG_DECIMAL:\n@@ -706,7 +706,7 @@ public strictfp class MathProcessor {\n \n \n   private static InternalNumber getInternalNumberFromType(Object in, int type) {\n-    if (in == null)\n+    if (in == null || in == BlankLiteral.INSTANCE)\n       return new InternalNumber(0, MATH_CONTEXT);\n     switch (type) {\n       case BIG_DECIMAL:\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\nindex 6e1a7a6..0218ce9 100644\n--- a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n@@ -4349,4 +4349,67 @@ public class CoreConfidenceTests extends AbstractTest {\n             return \"test\";\n         }\n     }\n+\n+  public void testEmptyOperatorOnStrings() {\n+    ParserConfiguration conf = new ParserConfiguration();\n+    ParserContext pctx = new ParserContext( conf );\n+    pctx.setStrictTypeEnforcement(true);\n+    pctx.setStrongTyping(true);\n+\n+    pctx.addInput(\"nullString\", String.class);\n+    pctx.addInput(\"emptyString\", String.class);\n+    pctx.addInput(\"blankString\", String.class);\n+    pctx.addInput(\"nonEmptyString\", String.class);\n+    Map vars = new HashMap() {{\n+        put(\"nullString\", null);\n+        put(\"emptyString\", \"\");\n+        put(\"blankString\", \"   \");\n+        put(\"nonEmptyString\", \"abc\");\n+    }};\n+\n+    assertEquals(true, MVEL.executeExpression(MVEL.compileExpression(\"nullString == empty\", pctx), vars));\n+    assertEquals(true, MVEL.executeExpression(MVEL.compileExpression(\"emptyString == empty\", pctx), vars));\n+    assertEquals(true, MVEL.executeExpression(MVEL.compileExpression(\"blankString == empty\", pctx), vars));\n+    assertEquals(false, MVEL.executeExpression(MVEL.compileExpression(\"nonEmptyString == empty\", pctx), vars));\n+  }\n+\n+  public void testEmptyOperatorOnBoolean() {\n+    ParserConfiguration conf = new ParserConfiguration();\n+    ParserContext pctx = new ParserContext( conf );\n+    pctx.setStrictTypeEnforcement(true);\n+    pctx.setStrongTyping(true);\n+\n+    pctx.addInput(\"bNull\", Boolean.class);\n+    pctx.addInput(\"bTrue\", Boolean.class);\n+    pctx.addInput(\"bFalse\", Boolean.class);\n+    Map vars = new HashMap() {{\n+        put(\"bNull\", null);\n+        put(\"bTrue\", true);\n+        put(\"bFalse\", false);\n+    }};\n+\n+    assertEquals(true, MVEL.executeExpression(MVEL.compileExpression(\"bNull == empty\", pctx), vars));\n+    assertEquals(false, MVEL.executeExpression(MVEL.compileExpression(\"bTrue == empty\", pctx), vars));\n+    assertEquals(true, MVEL.executeExpression(MVEL.compileExpression(\"bFalse == empty\", pctx), vars));\n+  }\n+\n+  public void testEmptyOperatorOnInteger() {\n+    ParserConfiguration conf = new ParserConfiguration();\n+    ParserContext pctx = new ParserContext( conf );\n+    pctx.setStrictTypeEnforcement(true);\n+    pctx.setStrongTyping(true);\n+\n+    pctx.addInput(\"nullInt\", Integer.class);\n+    pctx.addInput(\"zero\", Integer.class);\n+    pctx.addInput(\"nonZero\", Integer.class);\n+    Map vars = new HashMap() {{\n+        put(\"nullInt\", null);\n+        put(\"zero\", 0);\n+        put(\"nonZero\", 42);\n+    }};\n+\n+    assertEquals(true, MVEL.executeExpression(MVEL.compileExpression(\"nullInt == empty\", pctx), vars));\n+    assertEquals(true, MVEL.executeExpression(MVEL.compileExpression(\"zero == empty\", pctx), vars));\n+    assertEquals(false, MVEL.executeExpression(MVEL.compileExpression(\"nonZero == empty\", pctx), vars));\n+  }\n }\n\\ No newline at end of file\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-05-31T22:16:18.660598Z", "commit_hash": "444704924a32ea37712c84b7fb602c75b4a26cf2", "commit_message": "fix coercion of a literal value for a non aritmetic operation\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/ast/BinaryOperation.java b/src/main/java/org/mvel2/ast/BinaryOperation.java\nindex 909536e..b594507 100644\n--- a/src/main/java/org/mvel2/ast/BinaryOperation.java\n+++ b/src/main/java/org/mvel2/ast/BinaryOperation.java\n@@ -75,7 +75,8 @@ public class BinaryOperation extends BooleanNode {\n \n         if (!left.getEgressType().isAssignableFrom(right.getEgressType()) && !right.getEgressType().isAssignableFrom(left.getEgressType())) {\n           if (right.isLiteral() && canConvert(left.getEgressType(), right.getEgressType())) {\n-            this.right = new LiteralNode(convert(right.getReducedValueAccelerated(null, null, null), egressType), pCtx);\n+            Class targetType = isAritmeticOperation(operation) ? egressType : left.getEgressType();\n+            this.right = new LiteralNode(convert(right.getReducedValueAccelerated(null, null, null), targetType), pCtx);\n           } else if ( !(areCompatible(left.getEgressType(), right.getEgressType()) ||\n                   (( operation == Operator.EQUAL || operation == Operator.NEQUAL) &&\n                      CompatibilityStrategy.areEqualityCompatible(left.getEgressType(), right.getEgressType()))) ) {\n@@ -101,6 +102,10 @@ public class BinaryOperation extends BooleanNode {\n     }\n   }\n \n+  private boolean isAritmeticOperation(int operation) {\n+    return operation <= Operator.POWER;\n+  }\n+\n   private boolean areCompatible(Class<?> leftClass, Class<?> rightClass) {\n     return leftClass.equals(NullType.class) || rightClass.equals(NullType.class) ||\n            ( Number.class.isAssignableFrom(rightClass) && Number.class.isAssignableFrom(leftClass) ) ||\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\nindex 7f00ea7..6e1a7a6 100644\n--- a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n@@ -4323,6 +4323,17 @@ public class CoreConfidenceTests extends AbstractTest {\n     assertEquals(3.0, MVEL.executeExpression(MVEL.compileExpression(\"i*0.3\", pctx), vars));\n   }\n \n+  public void testCharToStringCoercionForComparison() {\n+    ParserConfiguration conf = new ParserConfiguration();\n+    ParserContext pctx = new ParserContext( conf );\n+    pctx.setStrictTypeEnforcement(true);\n+    pctx.setStrongTyping(true);\n+    pctx.addInput(\"ch\", Character.class);\n+    Map vars = new HashMap() {{ put(\"ch\", 'a'); }};\n+    assertEquals(true, MVEL.executeExpression(MVEL.compileExpression(\"ch == \\\"a\\\"\", pctx), vars));\n+    assertEquals(false, MVEL.executeExpression(MVEL.compileExpression(\"ch == \\\"b\\\"\", pctx), vars));\n+  }\n+\n   public void testFieldNameWithUnderscore() {\n       final ParserContext parserContext = new ParserContext();\n       parserContext.setStrictTypeEnforcement(true);\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-05-31T22:20:27.972371Z", "commit_hash": "874b03a8c5700661b503d96ad5d2ce1397cde18a", "commit_message": "fix parsing of field names starting with an underscore\n", "related_issues": "", "bug_patch": "diff --git a/pom.xml b/pom.xml\nindex 01fb277..f2c61fc 100644\n--- a/pom.xml\n+++ b/pom.xml\n@@ -5,7 +5,7 @@\n     <groupId>org.mvel</groupId>\n     <artifactId>mvel2</artifactId>\n     <packaging>jar</packaging>\n-    <version>2.2.0.Final</version>\n+    <version>2.2.1-SNAPSHOT</version>\n \n     <name>mvel</name>\n     <url>http://mvel.codehaus.org/</url>\ndiff --git a/src/main/java/org/mvel2/util/ReflectionUtil.java b/src/main/java/org/mvel2/util/ReflectionUtil.java\nindex b92ece9..2a0795e 100644\n--- a/src/main/java/org/mvel2/util/ReflectionUtil.java\n+++ b/src/main/java/org/mvel2/util/ReflectionUtil.java\n@@ -18,13 +18,14 @@\n \n package org.mvel2.util;\n \n+import static java.lang.Character.toLowerCase;\n+import static java.lang.Character.toUpperCase;\n import static java.lang.System.arraycopy;\n \n /**\n  * Utilities for working with reflection.\n  */\n public class ReflectionUtil {\n-  private static final int CASE_OFFSET = ('z' - 'Z');\n \n   /**\n    * This new method 'slightly' outperforms the old method, it was\n@@ -41,12 +42,7 @@ public class ReflectionUtil {\n     chars[1] = 'e';\n     chars[2] = 't';\n \n-    if (s.charAt(0) > 'Z') {\n-      chars[3] = (char) (s.charAt(0) - CASE_OFFSET);\n-    }\n-    else {\n-      chars[3] = s.charAt(0);\n-    }\n+    chars[3] = toUpperCase(s.charAt(0));\n \n     for (int i = s.length() - 1; i != 0; i--) {\n       chars[i + 3] = s.charAt(i);\n@@ -64,12 +60,7 @@ public class ReflectionUtil {\n     chars[1] = 'e';\n     chars[2] = 't';\n \n-    if (c[0] > 'Z') {\n-      chars[3] = (char) (c[0] - CASE_OFFSET);\n-    }\n-    else {\n-      chars[3] = (c[0]);\n-    }\n+    chars[3] = toUpperCase(c[0]);\n \n     arraycopy(c, 1, chars, 4, c.length - 1);\n \n@@ -84,12 +75,7 @@ public class ReflectionUtil {\n     chars[0] = 'i';\n     chars[1] = 's';\n \n-    if (c[0] > 'Z') {\n-      chars[2] = (char) (c[0] - CASE_OFFSET);\n-    }\n-    else {\n-      chars[2] = c[0];\n-    }\n+    chars[2] = toUpperCase(c[0]);\n \n     arraycopy(c, 1, chars, 3, c.length - 1);\n \n@@ -104,12 +90,7 @@ public class ReflectionUtil {\n       chars = new char[c.length - 3];\n \n       if (c[0] == 'g' || c[0] == 's') {\n-        if (c[3] < 'a') {\n-          chars[0] = (char) (c[3] + CASE_OFFSET);\n-        }\n-        else {\n-          chars[0] = c[3];\n-        }\n+        chars[0] = toLowerCase(c[3]);\n \n         for (int i = 1; i < chars.length; i++) {\n           chars[i] = c[i + 3];\n@@ -124,12 +105,7 @@ public class ReflectionUtil {\n     else if (c.length > 2 && c[0] == 'i' && c[1] == 's') {\n       chars = new char[c.length - 2];\n \n-      if (c[2] < 'a') {\n-        chars[0] = (char) (c[2] + CASE_OFFSET);\n-      }\n-      else {\n-        chars[0] = c[2];\n-      }\n+      chars[0] = toLowerCase(c[2]);\n \n       for (int i = 1; i < chars.length; i++) {\n         chars[i] = c[i + 2];\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\nindex de024ea..7f00ea7 100644\n--- a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n@@ -1,8 +1,13 @@\n package org.mvel2.tests.core;\n \n import junit.framework.TestCase;\n-import org.junit.Ignore;\n-import org.mvel2.*;\n+import org.mvel2.CompileException;\n+import org.mvel2.DataConversion;\n+import org.mvel2.MVEL;\n+import org.mvel2.Macro;\n+import org.mvel2.ParserConfiguration;\n+import org.mvel2.ParserContext;\n+import org.mvel2.PropertyAccessor;\n import org.mvel2.ast.ASTNode;\n import org.mvel2.compiler.CompiledExpression;\n import org.mvel2.compiler.ExecutableStatement;\n@@ -16,7 +21,30 @@ import org.mvel2.integration.impl.DefaultLocalVariableResolverFactory;\n import org.mvel2.integration.impl.IndexedVariableResolverFactory;\n import org.mvel2.integration.impl.MapVariableResolverFactory;\n import org.mvel2.optimizers.OptimizerFactory;\n-import org.mvel2.tests.core.res.*;\n+import org.mvel2.tests.core.res.Bar;\n+import org.mvel2.tests.core.res.Base;\n+import org.mvel2.tests.core.res.Cheese;\n+import org.mvel2.tests.core.res.Cheesery;\n+import org.mvel2.tests.core.res.Column;\n+import org.mvel2.tests.core.res.DefaultKnowledgeHelper;\n+import org.mvel2.tests.core.res.Foo;\n+import org.mvel2.tests.core.res.Grid;\n+import org.mvel2.tests.core.res.KnowledgeHelper;\n+import org.mvel2.tests.core.res.KnowledgeHelperFixer;\n+import org.mvel2.tests.core.res.MapObject;\n+import org.mvel2.tests.core.res.MyClass;\n+import org.mvel2.tests.core.res.MyInterface;\n+import org.mvel2.tests.core.res.PojoStatic;\n+import org.mvel2.tests.core.res.RuleBase;\n+import org.mvel2.tests.core.res.RuleBaseImpl;\n+import org.mvel2.tests.core.res.SampleBean;\n+import org.mvel2.tests.core.res.SampleBeanAccessor;\n+import org.mvel2.tests.core.res.Ship;\n+import org.mvel2.tests.core.res.Status;\n+import org.mvel2.tests.core.res.TestClass;\n+import org.mvel2.tests.core.res.User;\n+import org.mvel2.tests.core.res.WorkingMemory;\n+import org.mvel2.tests.core.res.WorkingMemoryImpl;\n import org.mvel2.tests.core.res.res2.ClassProvider;\n import org.mvel2.tests.core.res.res2.Outer;\n import org.mvel2.tests.core.res.res2.PublicClass;\n@@ -36,8 +64,19 @@ import java.math.BigDecimal;\n import java.math.BigInteger;\n import java.net.URL;\n import java.net.URLClassLoader;\n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Calendar;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.Vector;\n \n import static java.util.Collections.unmodifiableCollection;\n import static org.mvel2.MVEL.*;\n@@ -4283,4 +4322,20 @@ public class CoreConfidenceTests extends AbstractTest {\n     assertEquals(3.0, MVEL.executeExpression(MVEL.compileExpression(\"i*d\", pctx), vars));\n     assertEquals(3.0, MVEL.executeExpression(MVEL.compileExpression(\"i*0.3\", pctx), vars));\n   }\n+\n+  public void testFieldNameWithUnderscore() {\n+      final ParserContext parserContext = new ParserContext();\n+      parserContext.setStrictTypeEnforcement(true);\n+      parserContext.setStrongTyping(true);\n+      parserContext.addInput(\"this\", Underscore.class);\n+      Underscore underscore = new Underscore();\n+\n+      assertEquals(true, MVEL.executeExpression(MVEL.compileExpression(\"_id == \\\"test\\\"\", parserContext), underscore));\n+  }\n+\n+    public static class Underscore {\n+        public String get_id() {\n+            return \"test\";\n+        }\n+    }\n }\n\\ No newline at end of file\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T01:23:14.909445Z", "commit_hash": "fabda6b9582b0e23467c612f822f77d6cbc012a1", "commit_message": "FIXED: improperly boxed primitive in the verifier\n", "related_issues": "", "bug_patch": "diff --git a/samples/scripts/quicksort.mvel b/samples/scripts/quicksort.mvel\nindex 6abce18..e05879f 100644\n--- a/samples/scripts/quicksort.mvel\n+++ b/samples/scripts/quicksort.mvel\n@@ -40,7 +40,7 @@ def quicksort() {\n     sort(0, array.length - 1);\n }\n \n-array = {50,20,21,209,10,77,8,9,55,73,41,99};\n+array = {99,20,21,209,10,77,8,9,55,73,41,50};\n \n quicksort();\n \ndiff --git a/src/main/java/org/mvel2/ParserContext.java b/src/main/java/org/mvel2/ParserContext.java\nindex 5d5eed2..f62bcae 100644\n--- a/src/main/java/org/mvel2/ParserContext.java\n+++ b/src/main/java/org/mvel2/ParserContext.java\n@@ -139,7 +139,7 @@ public class ParserContext implements Serializable {\n      * @return int of lines\n      */\n     public int setLineCount(int lineCount) {\n-        return this.lineCount = (short) lineCount;\n+        return this.lineCount = lineCount;\n     }\n \n     /**\ndiff --git a/src/main/java/org/mvel2/ast/ASTNode.java b/src/main/java/org/mvel2/ast/ASTNode.java\nindex d65e9c8..24006ec 100644\n--- a/src/main/java/org/mvel2/ast/ASTNode.java\n+++ b/src/main/java/org/mvel2/ast/ASTNode.java\n@@ -98,9 +98,6 @@ public class ASTNode implements Cloneable, Serializable {\n             try {\n                 return accessor.getValue(ctx, thisValue, factory);\n             }\n-            catch (NullPointerException e) {\n-                throw e;\n-            }\n             catch (ClassCastException ce) {\n                 if ((fields & DEOP) == 0) {\n                     accessor = null;\n@@ -424,10 +421,8 @@ public class ASTNode implements Cloneable, Serializable {\n         }\n \n         setName(name);\n-\n     }\n \n-\n     public String toString() {\n         return isOperator() ? \"<<\" + DebugTools.getOperatorName(getOperator()) + \">>\" : String.valueOf(literal);\n     }\ndiff --git a/src/main/java/org/mvel2/ast/BinaryOperation.java b/src/main/java/org/mvel2/ast/BinaryOperation.java\nindex 0aa7af5..bcac2e6 100644\n--- a/src/main/java/org/mvel2/ast/BinaryOperation.java\n+++ b/src/main/java/org/mvel2/ast/BinaryOperation.java\n@@ -68,8 +68,10 @@ public class BinaryOperation extends BooleanNode {\n                         if (right.isLiteral() && canConvert(right.getEgressType(), left.getEgressType())) {\n                             this.right = new LiteralNode(convert(right.getReducedValueAccelerated(null, null, null), left.getEgressType()));\n                         }\n-                        else if ((!right.getEgressType().isPrimitive() && !left.getEgressType().isPrimitive())\n-                                || (!canConvert(boxPrimitive(left.getEgressType()), boxPrimitive(right.getEgressType())))) {\n+                        else if (!(Number.class.isAssignableFrom(right.getEgressType()) && Number.class.isAssignableFrom(left.getEgressType()))\n+                                && ((!right.getEgressType().isPrimitive() && !left.getEgressType().isPrimitive())\n+                                || (!canConvert(boxPrimitive(left.getEgressType()), boxPrimitive(right.getEgressType()))))) {\n+\n                             throw new CompileException(\"incompatible types in statement: \" + right.getEgressType() + \" (compared from: \" + left.getEgressType() + \")\");\n                         }\n                     }\ndiff --git a/src/main/java/org/mvel2/ast/IndexedAssignmentNode.java b/src/main/java/org/mvel2/ast/IndexedAssignmentNode.java\nindex 703d9eb..e198b97 100644\n--- a/src/main/java/org/mvel2/ast/IndexedAssignmentNode.java\n+++ b/src/main/java/org/mvel2/ast/IndexedAssignmentNode.java\n@@ -61,7 +61,7 @@ public class IndexedAssignmentNode extends ASTNode implements Assignment {\n                     = (ExecutableStatement) subCompileExpression(stmt = subset(expr, assignStart + 1), pCtx))\r\n                     .getKnownEgressType();\r\n \r\n-            if (col = ((endOfName = findFirst('[', indexTarget = this.name.toCharArray())) > 0)) {\r\n+            if (col = ((endOfName = (short) findFirst('[', indexTarget = this.name.toCharArray())) > 0)) {\r\n                 if (((this.fields |= COLLECTION) & COMPILE_IMMEDIATE) != 0) {\r\n                     accExpr = (CompiledAccExpression) compileSetExpression(indexTarget, pCtx);\r\n                 }\r\ndiff --git a/src/main/java/org/mvel2/ast/Negation.java b/src/main/java/org/mvel2/ast/Negation.java\nindex 3af7e1d..3396a2d 100644\n--- a/src/main/java/org/mvel2/ast/Negation.java\n+++ b/src/main/java/org/mvel2/ast/Negation.java\n@@ -28,13 +28,12 @@ import static org.mvel2.util.ParseTools.subCompileExpression;\n public class Negation extends ASTNode {\n     private ExecutableStatement stmt;\n \n-\n     public Negation(char[] name, int fields, ParserContext pCtx) {\n         this.name = name;\n \n         if ((fields & COMPILE_IMMEDIATE) != 0) {\n             if ((this.stmt = (ExecutableStatement) subCompileExpression(name, pCtx)).getKnownEgressType() != null\n-                    && !stmt.getKnownEgressType().isAssignableFrom(Boolean.class)) {\n+                    && (!stmt.getKnownEgressType().isAssignableFrom(Boolean.class))) {\n                 throw new CompileException(\"negation operator cannot be applied to non-boolean type\");\n             }\n         }\ndiff --git a/src/main/java/org/mvel2/compiler/ExpressionCompiler.java b/src/main/java/org/mvel2/compiler/ExpressionCompiler.java\nindex 4e49f09..b6d635f 100644\n--- a/src/main/java/org/mvel2/compiler/ExpressionCompiler.java\n+++ b/src/main/java/org/mvel2/compiler/ExpressionCompiler.java\n@@ -105,9 +105,6 @@ public class ExpressionCompiler extends AbstractParser {\n             fields |= COMPILE_IMMEDIATE;\r\n \r\n             while ((tk = nextToken()) != null) {\r\n-\r\n-\r\n-\r\n                 /**\r\n                  * If this is a debug symbol, just add it and continue.\r\n                  */\r\n@@ -171,7 +168,6 @@ public class ExpressionCompiler extends AbstractParser {\n                                 else if ((tkLA2 = nextTokenSkipSymbols()) != null && tkLA2.isLiteral()) {\r\n                                     stk.push(tkLA2.getLiteralValue(), op = tkOp2.getOperator());\r\n \r\n-\r\n                                     if (isArithmeticOperator(op)) {\r\n                                         arithmeticFunctionReduction(op);\r\n                                     }\r\n@@ -429,8 +425,4 @@ public class ExpressionCompiler extends AbstractParser {\n     public boolean isLiteralOnly() {\r\n         return literalOnly == 1;\r\n     }\r\n-\r\n-\r\n-\r\n-\r\n }\r\ndiff --git a/src/main/java/org/mvel2/compiler/PropertyVerifier.java b/src/main/java/org/mvel2/compiler/PropertyVerifier.java\nindex 6a4baf6..7ce6cdf 100644\n--- a/src/main/java/org/mvel2/compiler/PropertyVerifier.java\n+++ b/src/main/java/org/mvel2/compiler/PropertyVerifier.java\n@@ -25,8 +25,10 @@ import org.mvel2.ast.Function;\n import org.mvel2.optimizers.AbstractOptimizer;\n import org.mvel2.optimizers.impl.refl.nodes.WithAccessor;\n import static org.mvel2.util.ParseTools.*;\n+import static org.mvel2.util.ParseTools.boxPrimitive;\n import static org.mvel2.util.PropertyTools.getFieldOrAccessor;\n import org.mvel2.util.StringAppender;\n+import org.mvel2.util.ParseTools;\n \n import java.lang.reflect.*;\n import java.util.*;\n@@ -178,9 +180,10 @@ public class PropertyVerifier extends AbstractOptimizer {\n                 if (parametricReturnType instanceof ParameterizedType) {\n                     pCtx.setLastTypeParameters(((ParameterizedType) parametricReturnType).getActualTypeArguments());\n                 }\n-\n             }\n-            return method.getReturnType();\n+\n+            Class rt = method.getReturnType();\n+            return rt.isPrimitive() ? boxPrimitive(rt) : rt;\n         }\n         else if (pCtx != null && pCtx.hasImport(property)) {\n             return pCtx.getImport(property);\ndiff --git a/src/main/java/org/mvel2/util/ParseTools.java b/src/main/java/org/mvel2/util/ParseTools.java\nindex f009225..b0c825d 100644\n--- a/src/main/java/org/mvel2/util/ParseTools.java\n+++ b/src/main/java/org/mvel2/util/ParseTools.java\n@@ -428,46 +428,7 @@ public class ParseTools {\n                 bestScore = score;\n             }\n             score = 0;\n-\n-\n-//\n-//                if (arguments[i] == null) {\n-//                    if (!parmTypes[i].isPrimitive()) score += 5;\n-//                    else {\n-//                        score = 0;\n-//                        break;\n-//                    }\n-//                }\n-//                else if (parmTypes[i] == arguments[i]) {\n-//                    score += 6;\n-//                }\n-//                else if (parmTypes[i].isPrimitive() && boxPrimitive(parmTypes[i]) == arguments[i]) {\n-//                    score += 5;\n-//                }\n-//                else if (arguments[i].isPrimitive() && unboxPrimitive(arguments[i]) == parmTypes[i]) {\n-//                    score += 5;\n-//                }\n-//                else if (isNumericallyCoercible(arguments[i], parmTypes[i])) {\n-//                    score += 4;\n-//                }\n-//                else if (boxPrimitive(parmTypes[i]).isAssignableFrom(boxPrimitive(arguments[i]))) {\n-//                    score += 3;\n-//                }\n-//                else if (canConvert(parmTypes[i], arguments[i])) {\n-//                    score += 1;\n-//                }\n-//                else {\n-//                    score = 0;\n-//                    break;\n-//                }\n-        }\n-\n-//            if (score != 0 && score > bestScore) {\n-//                bestCandidate = construct;\n-//                bestScore = score;\n-//            }\n-//            score = 0;\n-\n+        }\n \n         if (bestCandidate != null) {\n             if (cache == null) {\n@@ -543,6 +504,7 @@ public class ParseTools {\n         return new String[]{new String(cs)};\n     }\n \n+\n     public static Class boxPrimitive(Class cls) {\n         if (cls == int.class || cls == Integer.class) {\n             return Integer.class;\n", "test_patch": "diff --git a/src/test/java/org/mvel2/compiler/GenericsTypeInferenceTest.java b/src/test/java/org/mvel2/compiler/GenericsTypeInferenceTest.java\nindex 4e70f4c..52e752e 100644\n--- a/src/test/java/org/mvel2/compiler/GenericsTypeInferenceTest.java\n+++ b/src/test/java/org/mvel2/compiler/GenericsTypeInferenceTest.java\n@@ -67,6 +67,18 @@ public class GenericsTypeInferenceTest extends TestCase {\n         assertEquals(\"Wrong parametric type inferred\", String.class, context.getLastTypeParameters()[0]);\n     }\n \n+    public final void testTypeByMethod() {\n+        ParserContext context = new ParserContext();\n+        context.setStrongTyping(true);\n+\n+        context.addInput(\"a\", A.class);\n+\n+         CompiledExpression compiledExpression = new ExpressionCompiler(\"!a.show\").compile(context);\n+\n+        assertEquals(Boolean.class, compiledExpression.getKnownEgressType());\n+    }\n+\n+\n //    public final void testInferLastTypeParametersFromPropertyMethod2() {\n //        ParserContext context = new ParserContext();\n //        context.setStrictTypeEnforcement( true );\n@@ -92,6 +104,15 @@ public class GenericsTypeInferenceTest extends TestCase {\n     }\n \n     public static class A {\n+        private boolean show;\n+\n+        public boolean isShow() {\n+            return show;\n+        }\n+\n+        public void setShow(boolean show) {\n+            this.show = show;\n+        }\n \n         public List<String> getStrings() {\n             return STRINGS;\ndiff --git a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\nindex f8c8511..14e6a0c 100644\n--- a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n@@ -5365,7 +5365,6 @@ public class CoreConfidenceTests extends AbstractTest {\n             assertEquals(String.class, entry.getValue());\n         }\n     }\n-\n }\n \n \n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T01:29:43.432487Z", "commit_hash": "4878b9b69204e53e46e177e920833a4ab38745f4", "commit_message": "bugfix to parser\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/compiler/AbstractParser.java b/src/main/java/org/mvel2/compiler/AbstractParser.java\nindex bf298ec..54c2fb5 100644\n--- a/src/main/java/org/mvel2/compiler/AbstractParser.java\n+++ b/src/main/java/org/mvel2/compiler/AbstractParser.java\n@@ -245,7 +245,6 @@ public class AbstractParser implements Serializable {\n \r\n             Mainloop:\r\n             while (cursor != length) {\r\n-\r\n                 if (isIdentifierPart(expr[cursor])) {\r\n                     capture = true;\r\n                     cursor++;\r\n@@ -648,7 +647,6 @@ public class AbstractParser implements Serializable {\n                                 break;\r\n \r\n                             case '=':\r\n-                                \r\n                                 if (lookAhead() == '+') {\r\n                                     name = new String(expr, start, trimLeft(cursor) - start);\r\n \r\n@@ -685,7 +683,6 @@ public class AbstractParser implements Serializable {\n                                         return lastNode = new OperativeAssign(name, subArray(start, cursor), SUB, fields, pCtx);\r\n                                     }\r\n                                 }\r\n-\r\n                                 if (greedy && lookAhead() != '=') {\r\n                                     cursor++;\r\n \r\n@@ -735,10 +732,10 @@ public class AbstractParser implements Serializable {\n                             }\r\n                             expectNextChar_IW('{');\r\n \r\n-                            tmp = subArray(start, cursor - 1);\r\n-                            cursor = balancedCaptureWithLineAccounting(expr, start = cursor, '{', pCtx) + 1;\r\n-\r\n-                            return lastNode = new ThisWithNode(tmp, subArray(start + 1, cursor - 1), fields, pCtx);\r\n+                            return lastNode = new ThisWithNode(subArray(start, cursor - 1),\r\n+                                    subArray(cursor + 1,\r\n+                                            (cursor = balancedCaptureWithLineAccounting(expr,\r\n+                                                    start = cursor, '{', pCtx) + 1) - 1), fields, pCtx);\r\n                         }\r\n \r\n                         case '@': {\r\n@@ -1673,6 +1670,11 @@ public class AbstractParser implements Serializable {\n                     if (cursor >= length) return;\r\n                     break;\r\n \r\n+                case '\"':\r\n+                case '\\'':\r\n+                    cursor = captureStringLiteral(expr[cursor], expr, cursor, length);\r\n+                    break;\r\n+\r\n                 case ',':\r\n                 case ';':\r\n                 case '}':\r\n@@ -2000,7 +2002,7 @@ public class AbstractParser implements Serializable {\n      * <p/>\r\n      * Determines whether or not the logical statement is manually terminated with a statement separator (';').\r\n      *\r\n-     * @return\r\n+     * @return -\r\n      */\r\n     protected boolean isStatementNotManuallyTerminated() {\r\n         if (cursor >= length) return false;\r\n@@ -2010,7 +2012,6 @@ public class AbstractParser implements Serializable {\n     }\r\n \r\n     protected ParserContext getParserContext() {\r\n-//        return new ParserContext();\r\n         if (parserContext == null || parserContext.get() == null) {\r\n             newContext();\r\n         }\r\n@@ -2035,7 +2036,7 @@ public class AbstractParser implements Serializable {\n     /**\r\n      * Create a new ParserContext in the current thread, using the one specified.\r\n      *\r\n-     * @param pCtx\r\n+     * @param pCtx -\r\n      */\r\n     public void newContext(ParserContext pCtx) {\r\n         contextControl(SET, pCtx, this);\r\n@@ -2337,7 +2338,6 @@ public class AbstractParser implements Serializable {\n     private void dreduce() {\r\n         stk.copy2(dStack);\r\n         stk.op();\r\n-        // reduce();\r\n     }\r\n \r\n \r\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\nindex 2afc114..f8c8511 100644\n--- a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n@@ -4160,6 +4160,17 @@ public class CoreConfidenceTests extends AbstractTest {\n \n         Foo f = (Foo) executeExpression(expr, createTestMap());\n \n+        assertEquals(\"poopy\", f.getName());\n+        assertEquals(\"bar\", f.aValue);\n+        assertEquals(\"foobie\", f.getBar().getName());\n+        assertEquals(\"doopy\", f.register);\n+    }\n+\n+    public void testInlineWith3a() {\n+        CompiledExpression expr = new ExpressionCompiler(\"foo.{name='poopy',aValue='bar',bar.{name='foobie'},toUC('doopy')}\").compile();\n+\n+        Foo f = (Foo) executeExpression(expr, createTestMap());\n+\n \n         assertEquals(\"poopy\", f.getName());\n         assertEquals(\"bar\", f.aValue);\n@@ -4167,6 +4178,7 @@ public class CoreConfidenceTests extends AbstractTest {\n         assertEquals(\"doopy\", f.register);\n     }\n \n+\n     public void testInlineWith4() {\n         OptimizerFactory.setDefaultOptimizer(\"ASM\");\n         ExpressionCompiler expr = new ExpressionCompiler(\"new Foo().{ name = 'bar' }\");\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T01:36:15.104915Z", "commit_hash": "96c615b98c159306121f5fe57d33c64cb7814713", "commit_message": "parser fixes.\n", "related_issues": "", "bug_patch": "diff --git a/samples/scripts/quicksort3.mvel b/samples/scripts/quicksort3.mvel\nindex ef5a288..91e2976 100644\n--- a/samples/scripts/quicksort3.mvel\n+++ b/samples/scripts/quicksort3.mvel\n@@ -6,13 +6,6 @@\n \n array = null;\n \n-def quicksort(array) {\n-    var less, greater;\n-}\n-\n-\n-\n-\n \n def swap(i, j) {\n     temp = array[i];\n@@ -21,10 +14,7 @@ def swap(i, j) {\n }\n \n def partition(low, high) {\n-    pivotPoint = array[low];\n-\n-    i = low - 1;\n-    j = high + 1;\n+    int pivotPoint = array[low], i = low - 1, j = high + 1;\n \n     while (i < j) {\n         i += 1; while (array[i] < pivotPoint) i += 1;\ndiff --git a/src/main/java/org/mvel2/ast/OperatorNode.java b/src/main/java/org/mvel2/ast/OperatorNode.java\nindex 0f5bc9d..c805f55 100644\n--- a/src/main/java/org/mvel2/ast/OperatorNode.java\n+++ b/src/main/java/org/mvel2/ast/OperatorNode.java\n@@ -26,6 +26,7 @@ public class OperatorNode extends ASTNode {\n     private Integer operator;\n \n     public OperatorNode(Integer operator) {\n+        assert operator != null;\n         this.literal = this.operator = operator;\n     }\n \ndiff --git a/src/main/java/org/mvel2/compiler/AbstractParser.java b/src/main/java/org/mvel2/compiler/AbstractParser.java\nindex 122e51e..2048bf9 100644\n--- a/src/main/java/org/mvel2/compiler/AbstractParser.java\n+++ b/src/main/java/org/mvel2/compiler/AbstractParser.java\n@@ -250,7 +250,7 @@ public class AbstractParser implements Serializable {\n                     capture = true;\r\n                     cursor++;\r\n \r\n-                    while (cursor != length && isIdentifierPart(expr[cursor])) cursor++;                    \r\n+                    while (cursor != length && isIdentifierPart(expr[cursor])) cursor++;\r\n                 }\r\n \r\n                 /**\r\n@@ -648,6 +648,7 @@ public class AbstractParser implements Serializable {\n                                 break;\r\n \r\n                             case '=':\r\n+                                \r\n                                 if (lookAhead() == '+') {\r\n                                     name = new String(expr, start, trimLeft(cursor) - start);\r\n \r\n@@ -686,50 +687,19 @@ public class AbstractParser implements Serializable {\n                                 }\r\n \r\n                                 if (greedy && lookAhead() != '=') {\r\n-                                    //     if (greedy) {\r\n-\r\n                                     cursor++;\r\n \r\n-                                    captureToEOS();\r\n-\r\n                                     if (union) {\r\n+                                        captureToEOS();\r\n+\r\n                                         return lastNode = new DeepAssignmentNode(subArray(start, cursor), fields | ASTNode.ASSIGN, pCtx);\r\n                                     }\r\n                                     else if (lastWasIdentifier) {\r\n-                                        /**\r\n-                                         * Check for typing information.\r\n-                                         */\r\n-                                        if (lastNode.getLiteralValue() instanceof String) {\r\n-                                            TypeDescriptor tDescr = new TypeDescriptor(((String) lastNode.getLiteralValue()).toCharArray(), 0);\r\n-\r\n-                                            try {\r\n-                                                lastNode.setLiteralValue(getClassReference(pCtx, tDescr));\r\n-                                                lastNode.discard();\r\n-                                            }\r\n-                                            catch (Exception e) {\r\n-                                                // fall through;\r\n-                                            }\r\n-                                        }\r\n-\r\n-                                        if (lastNode.isLiteral() && lastNode.getLiteralValue() instanceof Class) {\r\n-                                            lastNode.discard();\r\n-                                            captureToEOS();\r\n-                                            return new TypedVarNode(subArray(start, cursor), fields | ASTNode.ASSIGN, (Class)\r\n-                                                    lastNode.getLiteralValue(), pCtx);\r\n-                                        }\r\n-                                        // needed to work with MVELSH properly.\r\n-                                        else if ((fields & ASTNode.COMPILE_IMMEDIATE) == 0) {\r\n-                                            if (stk.peek() instanceof Class) {\r\n-                                                captureToEOS();\r\n-                                                return new TypedVarNode(subArray(start, cursor), fields | ASTNode.ASSIGN, (Class)\r\n-                                                        stk.pop(), pCtx);\r\n-                                            }\r\n-                                        }\r\n-\r\n-                                        throw new CompileException(\"unknown class or illegal statement: \" + lastNode.getLiteralValue(), expr, cursor);\r\n+                                         return procTypedNode(false);\r\n                                     }\r\n                                     else if (pCtx != null && ((idx = pCtx.variableIndexOf(t)) != -1\r\n                                             || (pCtx.isIndexAllocation()))) {\r\n+                                        captureToEOS();\r\n \r\n                                         IndexedAssignmentNode ian = new IndexedAssignmentNode(subArray(start, cursor), ASTNode.ASSIGN, idx, pCtx);\r\n \r\n@@ -740,6 +710,8 @@ public class AbstractParser implements Serializable {\n                                         return lastNode = ian;\r\n                                     }\r\n                                     else {\r\n+                                        captureToEOS();\r\n+                                        \r\n                                         return lastNode = new AssignmentNode(subArray(start, cursor), fields | ASTNode.ASSIGN, pCtx);\r\n                                     }\r\n                                 }\r\n@@ -1127,7 +1099,7 @@ public class AbstractParser implements Serializable {\n             e.setExpr(expr);\r\n             e.setLineNumber(pCtx == null ? 1 : pCtx.getLineCount());\r\n             e.setCursor(cursor);\r\n-            e.setColumn(cursor - (pCtx == null? 0 : pCtx.getLineOffset()));\r\n+            e.setColumn(cursor - (pCtx == null ? 0 : pCtx.getLineOffset()));\r\n             throw e;\r\n         }\r\n     }\r\n@@ -1213,71 +1185,76 @@ public class AbstractParser implements Serializable {\n                 return lastNode = new OperatorNode(OPERATORS.get(tmp));\r\n             }\r\n             else if (lastWasIdentifier) {\r\n-                boolean decl;\r\n+                return procTypedNode(true);\r\n+            }\r\n \r\n-                while (true) {\r\n-                    decl = lookAhead() != '=';\r\n-                    if (lastNode.getLiteralValue() instanceof String) {\r\n-                        TypeDescriptor tDescr = new TypeDescriptor(((String) lastNode.getLiteralValue()).toCharArray(), 0);\r\n+        }\r\n \r\n-                        try {\r\n-                            lastNode.setLiteralValue(getClassReference(pCtx, tDescr));\r\n-                            lastNode.discard();\r\n-                        }\r\n-                        catch (Exception e) {\r\n-                            // fall through;\r\n-                        }\r\n-                    }\r\n+        lastWasIdentifier = true;\r\n+        return lastNode = new ASTNode(expr, start, end, fields);\r\n \r\n-                    if (lastNode.isLiteral() && lastNode.getLiteralValue() instanceof Class) {\r\n-                        lastNode.discard();\r\n-                        captureToEOS();\r\n+    }\r\n \r\n-                        if (decl) {\r\n-                            splitAccumulator.push(new DeclTypedVarNode(new String(expr, start, cursor - start),\r\n-                                    (Class) lastNode.getLiteralValue(), fields | ASTNode.ASSIGN, pCtx));\r\n-                        }\r\n-                        else {\r\n-                            captureToEOS();\r\n-                            splitAccumulator.push(new TypedVarNode(subArray(start, cursor), fields | ASTNode.ASSIGN, (Class)\r\n-                                    lastNode.getLiteralValue(), pCtx));\r\n-                        }\r\n-                    }\r\n-                    // needed to work with MVELSH properly.\r\n-                    else if ((fields & ASTNode.COMPILE_IMMEDIATE) == 0) {\r\n-                        if (stk.peek() instanceof Class) {\r\n-                            captureToEOS();\r\n-                            if (decl) {\r\n-                                splitAccumulator.push(new DeclTypedVarNode(new String(expr, start, cursor - start),\r\n-                                        (Class) stk.pop(), fields | ASTNode.ASSIGN, pCtx));\r\n-                            }\r\n-                            else {\r\n-                                splitAccumulator.push(new TypedVarNode(subArray(start, cursor), fields | ASTNode.ASSIGN, (Class)\r\n-                                        stk.pop(), pCtx));\r\n-                            }\r\n-                        }\r\n-                        throw new CompileException(\"unknown class or illegal statement: \" + lastNode.getLiteralValue(), expr, cursor);                        \r\n-                    }\r\n-                    else {\r\n-                        throw new CompileException(\"unknown class or illegal statement: \" + lastNode.getLiteralValue(), expr, cursor);\r\n-                    }\r\n+    private ASTNode procTypedNode(boolean decl) {\r\n \r\n-                    skipWhitespaceWithLineAccounting();\r\n-                    if (cursor < length && expr[cursor] == ',') {\r\n-                        start = ++cursor;\r\n+        while (true) {\r\n+            if (lastNode.getLiteralValue() instanceof String) {\r\n+                TypeDescriptor tDescr = new TypeDescriptor(((String) lastNode.getLiteralValue()).toCharArray(), 0);\r\n+\r\n+                try {\r\n+                    lastNode.setLiteralValue(getClassReference(pCtx, tDescr));\r\n+                    lastNode.discard();\r\n+                }\r\n+                catch (Exception e) {\r\n+                    // fall through;\r\n+                }\r\n+            }\r\n+\r\n+            if (lastNode.isLiteral() && lastNode.getLiteralValue() instanceof Class) {\r\n+                lastNode.discard();\r\n+                captureToEOS();\r\n+\r\n+                if (decl) {\r\n+                    splitAccumulator.add(new DeclTypedVarNode(new String(expr, start, cursor - start),\r\n+                            (Class) lastNode.getLiteralValue(), fields | ASTNode.ASSIGN, pCtx));\r\n+                }\r\n+                else {\r\n+                    captureToEOS();\r\n+                    splitAccumulator.add(new TypedVarNode(subArray(start, cursor), fields | ASTNode.ASSIGN, (Class)\r\n+                            lastNode.getLiteralValue(), pCtx));\r\n+                }\r\n+                splitAccumulator.add(new EndOfStatement());\r\n+                \r\n+            }\r\n+            // needed to work with MVELSH properly.\r\n+            else if ((fields & ASTNode.COMPILE_IMMEDIATE) == 0) {\r\n+                if (stk.peek() instanceof Class) {\r\n+                    captureToEOS();\r\n+                    if (decl) {\r\n+                        splitAccumulator.add(new DeclTypedVarNode(new String(expr, start, cursor - start),\r\n+                                (Class) stk.pop(), fields | ASTNode.ASSIGN, pCtx));\r\n                     }\r\n                     else {\r\n-                        return (ASTNode) splitAccumulator.pop();\r\n+                        splitAccumulator.add(new TypedVarNode(subArray(start, cursor), fields | ASTNode.ASSIGN, (Class)\r\n+                                stk.pop(), pCtx));\r\n                     }\r\n+                    splitAccumulator.add(new EndOfStatement());\r\n                 }\r\n-\r\n+                throw new CompileException(\"unknown class or illegal statement: \" + lastNode.getLiteralValue(), expr, cursor);\r\n+            }\r\n+            else {\r\n+                throw new CompileException(\"unknown class or illegal statement: \" + lastNode.getLiteralValue(), expr, cursor);\r\n             }\r\n \r\n+            skipWhitespaceWithLineAccounting();\r\n+            if (cursor < length && expr[cursor] == ',') {\r\n+                start = ++cursor;\r\n+            }\r\n+            else {\r\n+                return (ASTNode) splitAccumulator.pop();\r\n+            }\r\n         }\r\n \r\n-        lastWasIdentifier = true;\r\n-        return lastNode = new ASTNode(expr, start, end, fields);\r\n-\r\n     }\r\n \r\n     private ASTNode createBlockToken(final int condStart,\r\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\nindex bf3781d..d51ce6c 100644\n--- a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n@@ -3542,6 +3542,20 @@ public class CoreConfidenceTests extends AbstractTest {\n         }\n     }\n \n+    public void testQuickSortScript4() throws IOException {\n+        Object[] sorted = (Object[]) MVEL.eval(new String(loadFromFile(new File(\"samples/scripts/quicksort3.mvel\"))), new HashMap());\n+        int last = -1;\n+        for (Object o : sorted) {\n+            if (last == -1) {\n+                last = (Integer) o;\n+            }\n+            else {\n+                assertTrue(((Integer) o) > last);\n+                last = (Integer) o;\n+            }\n+        }\n+    }\n+\n \n     public void testMultiLineString() throws IOException {\n         MVEL.evalFile(new File(\"samples/scripts/multilinestring.mvel\"));\n@@ -5274,11 +5288,45 @@ public class CoreConfidenceTests extends AbstractTest {\n \n         assertNotNull(ctx.getVariables());\n         assertEquals(3, ctx.getVariables().entrySet().size());\n-        for (Map.Entry<String,Class> entry : ctx.getVariables().entrySet()) {\n+        for (Map.Entry<String, Class> entry : ctx.getVariables().entrySet()) {\n+            assertEquals(String.class, entry.getValue());\n+        }\n+    }\n+\n+    public void testMultiTypeVarDeclr2() {\n+        String ex = \"String a = 'foo', b = 'baz', c = 'bar'\";\n+        ParserContext ctx = new ParserContext();\n+        ExpressionCompiler compiler = new ExpressionCompiler(ex);\n+        compiler.compile(ctx);\n+\n+        assertNotNull(ctx.getVariables());\n+        assertEquals(3, ctx.getVariables().entrySet().size());\n+        for (Map.Entry<String, Class> entry : ctx.getVariables().entrySet()) {\n             assertEquals(String.class, entry.getValue());\n         }\n     }\n \n+    public void testMultiTypeVarDeclr3() {\n+        String ex = \"int a = 52 * 3, b = 8, c = 16;\";\n+        ParserContext ctx = new ParserContext();\n+        ExpressionCompiler compiler = new ExpressionCompiler(ex);\n+        Serializable s = compiler.compile(ctx);\n+\n+        assertNotNull(ctx.getVariables());\n+        assertEquals(3, ctx.getVariables().entrySet().size());\n+        for (Map.Entry<String, Class> entry : ctx.getVariables().entrySet()) {\n+            assertEquals(Integer.class, entry.getValue());\n+        }\n+\n+        Map vars = new HashMap();\n+        MVEL.executeExpression(s, vars);\n+\n+        assertEquals(52*3, vars.get(\"a\"));\n+        assertEquals(8,  vars.get(\"b\"));\n+        assertEquals(16, vars.get(\"c\"));\n+\n+    }\n+\n     public void testTypeVarDeclr() {\n         String ex = \"String a;\";\n         ParserContext ctx = new ParserContext();\n@@ -5293,7 +5341,6 @@ public class CoreConfidenceTests extends AbstractTest {\n     }\n \n \n-\n }\n \n \n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T01:49:14.145057Z", "commit_hash": "e5656883e7288f90b974cf04754b7622c8dbd1f5", "commit_message": "parser fix: inline collections may cause inappropriate error when surrounded with brackets.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/ast/ForEachNode.java b/src/main/java/org/mvel2/ast/ForEachNode.java\nindex e5502e6..987c2f1 100644\n--- a/src/main/java/org/mvel2/ast/ForEachNode.java\n+++ b/src/main/java/org/mvel2/ast/ForEachNode.java\n@@ -30,6 +30,7 @@ import static org.mvel2.util.ParseTools.subset;\n import static org.mvel2.util.ParseTools.getBaseComponentType;\r\n \r\n import java.lang.reflect.Array;\r\n+import java.util.Iterator;\r\n \r\n /**\r\n  * @author Christopher Brock\r\n@@ -109,6 +110,7 @@ public class ForEachNode extends BlockNode {\n                     itemR.setValue(o);\r\n                     compiledBlock.getValue(ctx, thisValue, itemFactory);\r\n                 }\r\n+                \r\n                 break;\r\n         }\r\n \r\ndiff --git a/src/main/java/org/mvel2/ast/TypeDescriptor.java b/src/main/java/org/mvel2/ast/TypeDescriptor.java\nindex 57ab470..92cbfd1 100644\n--- a/src/main/java/org/mvel2/ast/TypeDescriptor.java\n+++ b/src/main/java/org/mvel2/ast/TypeDescriptor.java\n@@ -25,6 +25,7 @@ import org.mvel2.compiler.ExecutableStatement;\n import org.mvel2.integration.VariableResolverFactory;\n import static org.mvel2.util.ArrayTools.findFirst;\n import static org.mvel2.util.ParseTools.*;\n+import org.mvel2.util.ParseTools;\n \n import java.io.Serializable;\n import static java.lang.Character.isDigit;\n@@ -45,7 +46,7 @@ public class TypeDescriptor implements Serializable {\n     }\n \n     public void updateClassName(char[] name, int fields) {\n-        if (name.length == 0 || isDigit(name[0])) return;\n+        if (name.length == 0 || !ParseTools.isIdentifierPart(name[0]) || isDigit(name[0])) return;\n \n         if ((endRange = findFirst('(', name)) == -1) {\n             if ((endRange = findFirst('[', name)) != -1) {\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\nindex 96bb9b6..e7b9016 100644\n--- a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n@@ -5260,7 +5260,7 @@ public class CoreConfidenceTests extends AbstractTest {\n     }\n \n     public void testInlineListSensitivenessToSpaces() {\n-        String ex = \"return([\\\"a\\\",\\\"b\\\", \\\"c\\\"])\";\n+        String ex = \"([\\\"a\\\",\\\"b\\\", \\\"c\\\"])\";\n \n         ParserContext ctx = new ParserContext();\n         Serializable s = MVEL.compileExpression(ex, ctx);\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T01:55:32.869516Z", "commit_hash": "1984ee7f705731f16635af3b370a6aaa1470492e", "commit_message": "in-stack operations added, fixes to math accuracy.\t\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/compiler/AbstractParser.java b/src/main/java/org/mvel2/compiler/AbstractParser.java\nindex f297991..365f63a 100644\n--- a/src/main/java/org/mvel2/compiler/AbstractParser.java\n+++ b/src/main/java/org/mvel2/compiler/AbstractParser.java\n@@ -26,7 +26,6 @@ import org.mvel2.ParserContext;\n import org.mvel2.ast.*;\r\n import static org.mvel2.ast.TypeDescriptor.getClassReference;\r\n import org.mvel2.integration.VariableResolverFactory;\r\n-import org.mvel2.math.MathProcessor;\r\n import static org.mvel2.util.ArrayTools.findFirst;\r\n import static org.mvel2.util.ArrayTools.isLiteralOnly;\r\n import org.mvel2.util.ExecutionStack;\r\n@@ -2120,74 +2119,52 @@ public class AbstractParser implements Serializable {\n         ASTNode tk;\r\n         int operator2;\r\n \r\n-        boolean x = false;\r\n-        int y = 0;\r\n-\r\n         /**\r\n          * If the next token is an operator, we check to see if it has a higher\r\n          * precdence.\r\n          */\r\n         if ((tk = nextToken()) != null) {\r\n+\r\n             if (isArithmeticOperator(operator2 = tk.getOperator()) && PTABLE[operator2] > PTABLE[operator]) {\r\n-                xswap();\r\n+                stk.xswap();\r\n                 /**\r\n                  * The current arith. operator is of higher precedence the last.\r\n                  */\r\n+\r\n                 dStack.push(operator = operator2, nextToken().getReducedValue(ctx, ctx, variableFactory));\r\n \r\n                 while (true) {\r\n                     // look ahead again\r\n-\r\n                     if ((tk = nextToken()) != null && (operator2 = tk.getOperator()) != -1\r\n                             && operator2 != 37 && PTABLE[operator2] > PTABLE[operator]) {\r\n                         // if we have back to back operations on the stack, we don't xswap\r\n-                        if (x) {\r\n-                            xswap();\r\n \r\n-                            if (y != 0) {\r\n-                                reduce();\r\n-                            }\r\n+                        if (dStack.isReduceable()) {\r\n+                            stk.copyx2(dStack);\r\n                         }\r\n+\r\n                         /**\r\n                          * This operator is of higher precedence, or the same level precedence.  push to the RHS.\r\n                          */\r\n                         dStack.push(operator = operator2, nextToken().getReducedValue(ctx, ctx, variableFactory));\r\n-                        y = 1;\r\n+\r\n                         continue;\r\n                     }\r\n                     else if (tk != null && operator2 != -1 && operator2 != 37) {\r\n                         if (PTABLE[operator2] == PTABLE[operator]) {\r\n-                            // if we have back to back operations on the stack, we don't xswap             \r\n-                            if (x) {\r\n-                                xswap();\r\n-\r\n-                                if (y != 0) {\r\n-                                    reduce();\r\n-                                }\r\n-                            }\r\n-\r\n-                            /**\r\n-                             * Reduce any operations waiting now.\r\n-                             */\r\n-                            if (!dStack.isEmpty()) {\r\n-                                do {\r\n-                                    if (y == 1) {\r\n-                                        dreduce2();\r\n-                                        y = 0;\r\n-                                    }\r\n-                                    else {\r\n-                                        dreduce();\r\n-                                    }\r\n+                            if (!dStack.isEmpty()) dreduce();\r\n+                            else {\r\n+                                while (stk.isReduceable()) {\r\n+                                    stk.xswap_op();\r\n                                 }\r\n-                                while (dStack.size() > 1);\r\n                             }\r\n \r\n                             /**\r\n                              * This operator is of the same level precedence.  push to the RHS.\r\n                              */\r\n+\r\n                             dStack.push(operator = operator2, nextToken().getReducedValue(ctx, ctx, variableFactory));\r\n \r\n-                            y++;\r\n                             continue;\r\n                         }\r\n                         else {\r\n@@ -2196,76 +2173,45 @@ public class AbstractParser implements Serializable {\n                              */\r\n                             if (!dStack.isEmpty()) {\r\n                                 do {\r\n-                                    if (y == 1) {\r\n-                                        dreduce2();\r\n-                                        y = 0;\r\n-                                    }\r\n-                                    else {\r\n-                                        dreduce();\r\n-                                    }\r\n+                                    dreduce();\r\n                                 }\r\n                                 while (dStack.size() > 1);\r\n                             }\r\n \r\n-                            if (!dStack.isEmpty()) {\r\n-                                stk.push(dStack.pop());\r\n-                                xswap();\r\n-                            }\r\n-\r\n                             operator = tk.getOperator();\r\n                             // Reduce the lesser or equal precedence operations.\r\n                             while (stk.size() != 1 && stk.peek2() instanceof Integer &&\r\n                                     ((operator2 = (Integer) stk.peek2()) < PTABLE.length) &&\r\n                                     PTABLE[operator2] >= PTABLE[operator]) {\r\n-                                xswap();\r\n-                                reduce();\r\n+                                stk.xswap_op();\r\n                             }\r\n-\r\n-                            //     y = 0;\r\n                         }\r\n                     }\r\n                     else {\r\n                         /**\r\n                          * There are no more tokens.\r\n                          */\r\n-                        x = false;\r\n \r\n                         if (dStack.size() > 1) {\r\n-                            do {\r\n-                                if (y == 1) {\r\n-                                    dreduce2();\r\n-                                    y = 0;\r\n-                                }\r\n-                                else {\r\n-                                    dreduce();\r\n-                                }\r\n-                            }\r\n-                            while (dStack.size() > 1);\r\n-\r\n-                            x = true;\r\n+                            dreduce();\r\n                         }\r\n \r\n-                        if (!dStack.isEmpty()) {\r\n-                            stk.push(dStack.pop());\r\n-                        }\r\n-                        else if (x && stk.isReduceable()) {\r\n-                            xswap();\r\n-                        }\r\n+                        if (stk.isReduceable()) stk.xswap();\r\n \r\n                         break;\r\n                     }\r\n \r\n-                    if (tk != null && (tk = nextToken()) != null) {\r\n+                    if ((tk = nextToken()) != null) {\r\n                         switch (operator) {\r\n                             case AND: {\r\n-                                if (!((Boolean) stk.peek())) return OP_TERMINATE;\r\n+                                if (!(stk.peekBoolean())) return OP_TERMINATE;\r\n                                 else {\r\n                                     splitAccumulator.add(tk);\r\n                                     return AND;\r\n                                 }\r\n                             }\r\n                             case OR: {\r\n-                                if (((Boolean) stk.peek())) return OP_TERMINATE;\r\n+                                if ((stk.peekBoolean())) return OP_TERMINATE;\r\n                                 else {\r\n                                     splitAccumulator.add(tk);\r\n                                     return OR;\r\n@@ -2273,12 +2219,9 @@ public class AbstractParser implements Serializable {\n                             }\r\n \r\n                             default:\r\n-                                stk.push(tk.getReducedValue(ctx, ctx, variableFactory), operator);\r\n+                                stk.push(operator, tk.getReducedValue(ctx, ctx, variableFactory));\r\n                         }\r\n                     }\r\n-\r\n-                    x = true;\r\n-                    y = 0;\r\n                 }\r\n             }\r\n             else if (!tk.isOperator()) {\r\n@@ -2294,41 +2237,19 @@ public class AbstractParser implements Serializable {\n         // keep XSWAPing and reducing, until there is nothing left.\r\n         while (stk.isReduceable()) {\r\n             reduce();\r\n-            if (stk.isReduceable()) xswap();\r\n+            if (stk.isReduceable()) stk.xswap();\r\n         }\r\n \r\n         return OP_RESET_FRAME;\r\n     }\r\n \r\n     private void dreduce() {\r\n-        stk.push(dStack.pop(), dStack.pop());\r\n-\r\n-        // reduce the top of the stack\r\n-        reduce();\r\n+        stk.copy2(dStack);\r\n+        stk.op();\r\n+       // reduce();\r\n     }\r\n \r\n-    private void dreduce2() {\r\n-        Object o1, o2;\r\n \r\n-        o1 = dStack.pop();\r\n-        o2 = dStack.pop();\r\n-\r\n-\r\n-        if (!dStack.isEmpty()) stk.push(dStack.pop());\r\n-\r\n-\r\n-        stk.push(o1);\r\n-        stk.push(o2);\r\n-\r\n-        reduce();\r\n-    }\r\n-\r\n-    /**\r\n-     * XSWAP.\r\n-     */\r\n-    private void xswap() {\r\n-        stk.push(stk.pop(), stk.pop());\r\n-    }\r\n \r\n     /**\r\n      * This method is called when we reach the point where we must subEval a trinary operation in the expression.\r\n@@ -2353,10 +2274,7 @@ public class AbstractParser implements Serializable {\n                 case GETHAN:\r\n                 case LETHAN:\r\n                 case POWER:\r\n-\r\n-                    stk.push(MathProcessor.doOperations(stk.peek2(), operator, stk.pop2()));\r\n-\r\n-                    System.out.println(\" = \" + stk.peek());\r\n+                    stk.op(operator);\r\n                     break;\r\n \r\n                 case AND:\r\ndiff --git a/src/main/java/org/mvel2/math/MathProcessor.java b/src/main/java/org/mvel2/math/MathProcessor.java\nindex 289f0d5..188df96 100644\n--- a/src/main/java/org/mvel2/math/MathProcessor.java\n+++ b/src/main/java/org/mvel2/math/MathProcessor.java\n@@ -45,7 +45,7 @@ public strictfp class MathProcessor {\n         int type1 = val1 == null ? DataTypes.NULL : __resolveType(val1.getClass());\r\n         int type2 = val2 == null ? DataTypes.NULL : __resolveType(val2.getClass());\r\n \r\n-        System.out.print(\"{\" + val1 + \" \" + DebugTools.getOperatorSymbol(operation) + \" \" + val2 + \"}\");\r\n+  //    System.out.println(\"{ \" + val1 + \" \" + DebugTools.getOperatorSymbol(operation) + \" \" + val2 + \"}\");\r\n \r\n         switch (type1) {\r\n             case BIG_DECIMAL:\r\ndiff --git a/src/main/java/org/mvel2/util/ExecutionStack.java b/src/main/java/org/mvel2/util/ExecutionStack.java\nindex 703ffac..ebf2708 100644\n--- a/src/main/java/org/mvel2/util/ExecutionStack.java\n+++ b/src/main/java/org/mvel2/util/ExecutionStack.java\n@@ -19,6 +19,8 @@\n package org.mvel2.util;\n \n import org.mvel2.CompileException;\n+import org.mvel2.math.MathProcessor;\n+import static org.mvel2.math.MathProcessor.doOperations;\n \n import static java.lang.String.valueOf;\n \n@@ -76,6 +78,20 @@ public class ExecutionStack {\n         throw new CompileException(\"expected Boolean; but found: \" + (element.value == null ? \"null\" : element.value.getClass().getName()));\n     }\n \n+    public void copy2(ExecutionStack es) {\n+        element = new StackElement(new StackElement(element, es.element.value), es.element.next.value);\n+        size += 2;\n+        es.element = es.element.next.next;\n+        es.size -= 2;\n+    }\n+\n+    public void copyx2(ExecutionStack es) {\n+        element = new StackElement(new StackElement(element, es.element.next.value), es.element.value);\n+        size += 2;\n+        es.element = es.element.next.next;\n+        es.size -= 2;\n+    }\n+\n     public Object peek2() {\n         return element.next.value;\n     }\n@@ -123,14 +139,37 @@ public class ExecutionStack {\n     }\n \n     public boolean isReduceable() {\n-        return size>1;\n+        return size > 1;\n     }\n \n     public void clear() {\n         size = 0;\n         element = null;\n     }\n-    \n+\n+    public void xswap_op() {\n+        xswap();\n+        op();\n+    }\n+\n+    public void op() {\n+        element = new StackElement(element.next.next.next, doOperations(element.next.next.value, (Integer) element.value, element.next.value));\n+        size -= 2;\n+    }\n+\n+    public void op(int operator) {\n+        element = new StackElement(element.next.next, doOperations(element.next.value, operator, element.value));\n+        size--;\n+    }\n+\n+    public void xswap() {\n+        StackElement e = element.next;\n+        StackElement relink = e.next;\n+        e.next = element;\n+        element = e;\n+        e.next.next = relink;\n+    }\n+\n     public String toString() {\n         StackElement el = element;\n \n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\nindex 02015f4..6a4628a 100644\n--- a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n@@ -2811,9 +2811,10 @@ public class CoreConfidenceTests extends AbstractTest {\n     }\n \n     public void testMath30() {\n-        String expression = \"40 / 20 + 10 + 6 / 2\";\n-        float val = 40f / 20f + 10f + 6f / 2f;\n-        assertEquals((int) val, MVEL.eval(expression));\n+        String expression = \"40 / 20 + 10 + 60 / 21\";\n+        System.out.println(\"Expression: \" + expression);\n+        double val = 40d / 20d + 10d + 60d / 21d;\n+        assertEquals(val, MVEL.eval(expression));\n     }\n \n     public void testMath31() {\n@@ -2933,6 +2934,58 @@ public class CoreConfidenceTests extends AbstractTest {\n                 MVEL.eval(expression));\n     }\n \n+    public void testMath39() {\n+        String expression = \"147 + 60 / 167 % 448 + 36 * 23 / 166\";\n+        double res = 147d + 60d / 167d % 448d + 36d * 23d / 166d;\n+\n+        System.out.println(\"Expression: \" + expression);\n+        System.out.println(\"CorrectRes: \" + res);\n+\n+        assertEquals(res, MVEL.eval(expression));\n+    }\n+\n+    public void testMath40() {\n+        String expression = \"228 - 338 % 375 - 103 + 260 + 412 * 177 + 121\";\n+        double res = 228d - 338d % 375d - 103d + 260d + 412d * 177d + 121d;\n+\n+        System.out.println(\"Expression: \" + expression);\n+        System.out.println(\"CorrectRes: \" + res);\n+\n+        assertEquals(res, MVEL.eval(expression, Double.class));\n+    }\n+\n+    public void testMath41() {\n+        String expression = \"304d - 246d / 242d % 235d / 425d - 326d + 355d * 264d % 308d\";\n+        double res = 304d - 246d / 242d % 235d / 425d - 326d + 355d * 264d % 308d;\n+\n+        System.out.println(\"Expression: \" + expression);\n+        System.out.println(\"CorrectRes: \" + res);\n+\n+        assertEquals(res, MVEL.eval(expression));\n+    }\n+\n+    public void testMath42() {\n+        String expression = \"11d - 7d / 3d * 18d % 14d * 8d * 11d - 2d - 11d / 13d + 14d\";\n+        double res = 11d - 7d / 3d * 18d % 14d * 8d * 11d - 2d - 11d / 13d + 14d;\n+\n+        System.out.println(\"Expression: \" + expression);\n+        System.out.println(\"CorrectRes: \" + res);\n+\n+        assertEquals(res, MVEL.eval(expression));\n+    }\n+\n+    public void testMath43() {\n+        // 4/3*6%8*5*8+7+9*1\n+\n+        String expression = \"4d/3d*6d%8d*5d*8d+7d+9d*1d\";\n+        double res = 4d/3d*6d%8d*5d*8d+7d+9d*1d;\n+\n+        System.out.println(\"Expression: \" + expression);\n+        System.out.println(\"CorrectRes: \" + res);\n+\n+        assertEquals(res, MVEL.eval(expression));\n+    }\n+\n     public void testNullSafe() {\n         Foo foo = new Foo();\n \n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T02:02:14.357154Z", "commit_hash": "648dd8db4175f77500452996ee1da57bafd0d46c", "commit_message": "More fixes to correct issues with class symbols not being available in deferred compilation.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/ast/ASTNode.java b/src/main/java/org/mvel2/ast/ASTNode.java\nindex fb096a1..d65e9c8 100644\n--- a/src/main/java/org/mvel2/ast/ASTNode.java\n+++ b/src/main/java/org/mvel2/ast/ASTNode.java\n@@ -22,6 +22,7 @@ import org.mvel2.CompileException;\n import static org.mvel2.Operator.NOOP;\n import org.mvel2.OptimizationFailure;\n import org.mvel2.ParserContext;\n+import org.mvel2.ParserConfiguration;\n import static org.mvel2.PropertyAccessor.get;\n import static org.mvel2.compiler.AbstractParser.getCurrentThreadParserContext;\n import org.mvel2.compiler.Accessor;\n@@ -33,6 +34,7 @@ import static org.mvel2.optimizers.OptimizerFactory.*;\n import static org.mvel2.util.ParseTools.handleNumericConversion;\n import static org.mvel2.util.ParseTools.isNumber;\n import org.mvel2.util.CompilerTools;\n+import static org.mvel2.util.CompilerTools.getInjectedImports;\n \n import java.io.Serializable;\n import static java.lang.Thread.currentThread;\n@@ -128,8 +130,9 @@ public class ASTNode implements Cloneable, Serializable {\n                 optimizer = getDefaultAccessorCompiler();\n             }\n \n-            ParserContext pCtx = new ParserContext();\n-            pCtx.getParserConfiguration().addAllImports(CompilerTools.getInjectedImports(factory));\n+            ParserContext pCtx = new ParserContext(new ParserConfiguration(getInjectedImports(factory), null));\n+         //   pCtx.getParserConfiguration().setAllImports(getInjectedImports(factory));\n+\n             try {\n                 setAccessor(optimizer.optimizeAccessor(pCtx, name, ctx, thisValue, factory, true, egressType));\n             }\ndiff --git a/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java b/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java\nindex 5332f85..f353f0e 100644\n--- a/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java\n+++ b/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java\n@@ -303,7 +303,7 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n                         //noinspection unchecked\r\n                         ((Map) ctx).put(eval(ex, ctx, variableFactory), convert(value, returnType = verifier.analyze()));\r\n \r\n-                        writeLiteralOrSubexpression(subCompileExpression(ex.toCharArray()));\r\n+                        writeLiteralOrSubexpression(subCompileExpression(ex.toCharArray(), pCtx));\r\n \r\n                         assert debug(\"ALOAD 4\");\r\n                         mv.visitVarInsn(ALOAD, 4);\r\n@@ -334,7 +334,7 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n                         ((List) ctx).set(eval(ex, ctx, variableFactory, Integer.class),\r\n                                 convert(value, returnType = verifier.analyze()));\r\n \r\n-                        writeLiteralOrSubexpression(subCompileExpression(ex.toCharArray()));\r\n+                        writeLiteralOrSubexpression(subCompileExpression(ex.toCharArray(), pCtx));\r\n                         unwrapPrimitive(int.class);\r\n \r\n                         assert debug(\"ALOAD 4\");\r\n@@ -365,7 +365,7 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n \r\n                         Object idx = eval(ex, ctx, variableFactory);\r\n \r\n-                        writeLiteralOrSubexpression(subCompileExpression(ex.toCharArray()), int.class);\r\n+                        writeLiteralOrSubexpression(subCompileExpression(ex.toCharArray(), pCtx), int.class);\r\n                         if (!(idx instanceof Integer)) {\r\n                             dataConversion(Integer.class);\r\n                             idx = DataConversion.convert(idx, Integer.class);\r\n@@ -791,7 +791,7 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n                 // Execute this interpretively now.\r\n                 MVEL.eval(aPvp.getValue(), ctx, variableFactory);\r\n \r\n-                addSubstatement((ExecutableStatement) subCompileExpression(aPvp.getValue().toCharArray()));\r\n+                addSubstatement((ExecutableStatement) subCompileExpression(aPvp.getValue().toCharArray(), pCtx));\r\n             }\r\n             else {\r\n                 // Execute interpretively.\r\n@@ -815,7 +815,7 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n                 assert debug(\"ALOAD 3\");\r\n                 mv.visitVarInsn(ALOAD, 3);\r\n \r\n-                addSubstatement((ExecutableStatement) subCompileExpression(aPvp.getValue().toCharArray()));\r\n+                addSubstatement((ExecutableStatement) subCompileExpression(aPvp.getValue().toCharArray(), pCtx));\r\n \r\n                 assert debug(\"INVOKEINTERFACE Accessor.setValue\");\r\n                 mv.visitMethodInsn(INVOKEINTERFACE, NAMESPACE + \"compiler/ExecutableStatement\",\r\n@@ -1204,7 +1204,7 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n \r\n         assert debug(\"{collection token: [\" + tk + \"]}\");\r\n \r\n-        ExecutableStatement compiled = (ExecutableStatement) subCompileExpression(tk.toCharArray());\r\n+        ExecutableStatement compiled = (ExecutableStatement) subCompileExpression(tk.toCharArray(), pCtx);\r\n         Object item = compiled.getValue(ctx, variableFactory);\r\n \r\n         ++cursor;\r\n@@ -1546,7 +1546,7 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n \r\n             for (int i = 0; i < subtokens.length; i++) {\r\n                 assert debug(\"subtoken[\" + i + \"] { \" + subtokens[i] + \" }\");\r\n-                preConvArgs[i] = args[i] = (es[i] = (ExecutableStatement) subCompileExpression(subtokens[i].toCharArray()))\r\n+                preConvArgs[i] = args[i] = (es[i] = (ExecutableStatement) subCompileExpression(subtokens[i].toCharArray(), pCtx))\r\n                         .getValue(this.ctx, this.thisRef, variableFactory);\r\n             }\r\n         }\r\n@@ -2620,10 +2620,10 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n         }\r\n         else {\r\n             if (type.isArray()) {\r\n-                writeLiteralOrSubexpression(subCompileExpression(((String) o).toCharArray()), getSubComponentType(type));\r\n+                writeLiteralOrSubexpression(subCompileExpression(((String) o).toCharArray(), pCtx), getSubComponentType(type));\r\n             }\r\n             else {\r\n-                writeLiteralOrSubexpression(subCompileExpression(((String) o).toCharArray()));\r\n+                writeLiteralOrSubexpression(subCompileExpression(((String) o).toCharArray(), pCtx));\r\n             }\r\n             return VAL;\r\n         }\r\n@@ -2800,7 +2800,7 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n         try {\r\n             if (constructorParms != null) {\r\n                 for (String constructorParm : constructorParms) {\r\n-                    compiledInputs.add((ExecutableStatement) subCompileExpression(constructorParm.toCharArray()));\r\n+                    compiledInputs.add((ExecutableStatement) subCompileExpression(constructorParm.toCharArray(), pCtx));\r\n                 }\r\n \r\n                 Class cls = findClass(factory, new String(subset(property, 0, findFirst('(', property))), pCtx);\r\ndiff --git a/src/main/java/org/mvel2/optimizers/impl/refl/ReflectiveAccessorOptimizer.java b/src/main/java/org/mvel2/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\nindex 94df54b..a98070a 100644\n--- a/src/main/java/org/mvel2/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\n+++ b/src/main/java/org/mvel2/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\n@@ -635,7 +635,7 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n \r\n         ExecutableStatement itemStmt = null;\r\n         if (itemSubExpr) {\r\n-            idx = (itemStmt = (ExecutableStatement) subCompileExpression(item.toCharArray())).getValue(ctx, thisRef, variableFactory);\r\n+            idx = (itemStmt = (ExecutableStatement) subCompileExpression(item.toCharArray(), pCtx)).getValue(ctx, thisRef, variableFactory);\r\n         }\r\n \r\n         ++cursor;\r\n@@ -727,7 +727,7 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n \r\n         ExecutableStatement itemStmt = null;\r\n         if (itemSubExpr) {\r\n-            idx = (itemStmt = (ExecutableStatement) subCompileExpression(item.toCharArray())).getValue(ctx, thisRef, variableFactory);\r\n+            idx = (itemStmt = (ExecutableStatement) subCompileExpression(item.toCharArray(), pCtx)).getValue(ctx, thisRef, variableFactory);\r\n         }\r\n \r\n         ++cursor;\r\n@@ -1088,7 +1088,7 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n             ExecutableStatement[] cStmts = new ExecutableStatement[constructorParms.length];\r\n \r\n             for (int i = 0; i < constructorParms.length; i++) {\r\n-                cStmts[i] = (ExecutableStatement) subCompileExpression(constructorParms[i].toCharArray());\r\n+                cStmts[i] = (ExecutableStatement) subCompileExpression(constructorParms[i].toCharArray(), pCtx);\r\n             }\r\n \r\n             Object[] parms = new Object[constructorParms.length];\r\ndiff --git a/src/main/java/org/mvel2/util/ParseTools.java b/src/main/java/org/mvel2/util/ParseTools.java\nindex 699b954..339d9c5 100644\n--- a/src/main/java/org/mvel2/util/ParseTools.java\n+++ b/src/main/java/org/mvel2/util/ParseTools.java\n@@ -1712,7 +1712,7 @@ public class ParseTools {\n \n     public static Serializable subCompileExpression(char[] expression, ParserContext ctx) {\n         ExpressionCompiler c = new ExpressionCompiler(expression);\n-        c.setPCtx(ctx);\n+        if (ctx != null) c.setPCtx(ctx);\n         return optimizeTree(c._compile());\n     }\n \n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\nindex 5645fef..7c45984 100644\n--- a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n@@ -4961,7 +4961,7 @@ public class CoreConfidenceTests extends AbstractTest {\n     public void testJIRA140() {\n         ParserContext ctx = new ParserContext();\n         Serializable s = MVEL.compileExpression(\n-                \"import org.mvel2.tests.core.res.*;\"+\n+                \"import org.mvel2.tests.core.res.*;\" +\n                         \"cols = new Column[] { new Column('name', 20), new Column('age', 2) };\" +\n                         \"grid = new Grid(new Model(cols));\", ctx\n         );\n@@ -4986,12 +4986,12 @@ public class CoreConfidenceTests extends AbstractTest {\n \n         MVEL.executeExpression(s, vars);\n \n-        assertEquals(\"coffee\", ((Base)vars.get(\"base\")).fooMap.get(\"foo\").getName());\n+        assertEquals(\"coffee\", ((Base) vars.get(\"base\")).fooMap.get(\"foo\").getName());\n     }\n-    \n+\n     public void testPrimitiveTypes() {\n         ParserContext ctx = new ParserContext();\n-        ctx.setStrongTyping( true );\n+        ctx.setStrongTyping(true);\n         ctx.addInput(\"base\", Base.class);\n \n         Serializable s = MVEL.compileExpression(\"int x = 5; x = x + base.intValue; x\", ctx);\n@@ -5004,10 +5004,10 @@ public class CoreConfidenceTests extends AbstractTest {\n         assertEquals(15, x.intValue());\n \n     }\n-    \n+\n     public void testAutoBoxing() {\n         ParserContext ctx = new ParserContext();\n-        ctx.setStrongTyping( true );\n+        ctx.setStrongTyping(true);\n         //ctx.addInput(\"base\", Base.class);\n \n         Serializable s = MVEL.compileExpression(\"(list = new java.util.ArrayList()).add( 5 ); list\", ctx);\n@@ -5020,10 +5020,10 @@ public class CoreConfidenceTests extends AbstractTest {\n         assertEquals(1, list.size());\n \n     }\n-    \n+\n     public void testAutoBoxing2() {\n         ParserContext ctx = new ParserContext();\n-        ctx.setStrongTyping( true );\n+        ctx.setStrongTyping(true);\n         ctx.addInput(\"base\", Base.class);\n \n         Serializable s = MVEL.compileExpression(\"java.util.List list = new java.util.ArrayList(); list.add( base.intValue ); list\", ctx);\n@@ -5035,10 +5035,10 @@ public class CoreConfidenceTests extends AbstractTest {\n \n         assertEquals(1, list.size());\n     }\n-    \n+\n     public void testTypeCoercion() {\n         ParserContext ctx = new ParserContext();\n-        ctx.setStrongTyping( true );\n+        ctx.setStrongTyping(true);\n         ctx.addInput(\"base\", Base.class);\n \n         Serializable s = MVEL.compileExpression(\"java.math.BigInteger x = new java.math.BigInteger( \\\"5\\\" ); x + base.intValue;\", ctx);\n@@ -5050,10 +5050,10 @@ public class CoreConfidenceTests extends AbstractTest {\n \n         assertEquals(15, x.intValue());\n     }\n-    \n+\n     public void testEmpty() {\n         ParserContext ctx = new ParserContext();\n-        ctx.setStrongTyping( true );\n+        ctx.setStrongTyping(true);\n \n         Serializable s = MVEL.compileExpression(\"list = new java.util.ArrayList(); list == empty\", ctx);\n \n@@ -5061,37 +5061,68 @@ public class CoreConfidenceTests extends AbstractTest {\n \n         Boolean x = (Boolean) MVEL.executeExpression(s, vars);\n \n-        assertNotNull( x );\n+        assertNotNull(x);\n         assertTrue(x.booleanValue());\n     }\n-    \n+\n     public void testMapsAndLists() {\n+        OptimizerFactory.setDefaultOptimizer(\"ASM\");\n+\n         ParserContext ctx = new ParserContext();\n-        ctx.setStrongTyping( true );\n+        ctx.setStrongTyping(true);\n         ctx.addImport(HashMap.class);\n         ctx.addImport(ArrayList.class);\n-        ctx.addInput( \"list\", List.class );\n+        ctx.addInput(\"list\", List.class);\n \n         String expression = \"m = new HashMap();\\n\" +\n-                            \"l = new ArrayList();\\n\" +\n-                            \"l.add(\\\"first\\\");\\n\" +\n-                            \"m.put(\\\"content\\\", l);\\n\" +\n-                            \"list.add(((ArrayList)m[\\\"content\\\"])[0]);\";\n+                \"l = new ArrayList();\\n\" +\n+                \"l.add(\\\"first\\\");\\n\" +\n+                \"m.put(\\\"content\\\", l);\\n\" +\n+                \"list.add(((ArrayList)m[\\\"content\\\"])[0]);\";\n \n         Serializable s = MVEL.compileExpression(expression, ctx);\n \n         Map vars = new HashMap();\n         List list = new ArrayList();\n-        vars.put( \"list\", list );\n+        vars.put(\"list\", list);\n \n         Boolean result = (Boolean) MVEL.executeExpression(s, vars);\n \n-        assertNotNull( result );\n-        assertTrue( result );\n-        assertEquals( 1, list.size() );\n-        assertEquals( \"first\", list.get( 0 ) );\n+        assertNotNull(result);\n+        assertTrue(result);\n+        assertEquals(1, list.size());\n+        assertEquals(\"first\", list.get(0));\n     }\n-    \n+\n+    public void testMapsAndLists2() {\n+        OptimizerFactory.setDefaultOptimizer(\"reflective\");\n+\n+        ParserContext ctx = new ParserContext();\n+        ctx.setStrongTyping(true);\n+        ctx.addImport(HashMap.class);\n+        ctx.addImport(ArrayList.class);\n+        ctx.addInput(\"list\", List.class);\n+\n+        String expression = \"m = new HashMap();\\n\" +\n+                \"l = new ArrayList();\\n\" +\n+                \"l.add(\\\"first\\\");\\n\" +\n+                \"m.put(\\\"content\\\", l);\\n\" +\n+                \"list.add(((ArrayList)m[\\\"content\\\"])[0]);\";\n+\n+        Serializable s = MVEL.compileExpression(expression, ctx);\n+\n+        Map vars = new HashMap();\n+        List list = new ArrayList();\n+        vars.put(\"list\", list);\n+\n+        Boolean result = (Boolean) MVEL.executeExpression(s, vars);\n+\n+        assertNotNull(result);\n+        assertTrue(result);\n+        assertEquals(1, list.size());\n+        assertEquals(\"first\", list.get(0));\n+    }\n+\n }\n \n \n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T02:38:28.142645Z", "commit_hash": "372fd02c8f8dd51667f178529f50ae179c01d831", "commit_message": "fixed\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/optimizers/impl/refl/ReflectiveAccessorOptimizer.java b/src/main/java/org/mvel2/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\nindex ee26970..1a892a7 100644\n--- a/src/main/java/org/mvel2/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\n+++ b/src/main/java/org/mvel2/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\n@@ -371,10 +371,10 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n             return rootNode;\r\n         }\r\n         catch (InvocationTargetException e) {\r\n-            throw new PropertyAccessException(new String(expr), e);\r\n+            throw new PropertyAccessException(new String(expr) + \": \" + e.getMessage(), e);\r\n         }\r\n         catch (IllegalAccessException e) {\r\n-            throw new PropertyAccessException(new String(expr), e);\r\n+            throw new PropertyAccessException(new String(expr) + \": \" + e.getMessage(), e);\r\n         }\r\n         catch (IndexOutOfBoundsException e) {\r\n             throw new PropertyAccessException(new String(expr) + \": array index out of bounds.\", e);\r\n@@ -925,8 +925,7 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n                     args[i] = convert(args[i], parameterTypes[i]);\r\n             }\r\n \r\n-\r\n-            Object o = m.invoke(ctx, args);\r\n+            Object o = getWidenedTarget(m).invoke(ctx, args);\r\n \r\n             if (hasNullMethodHandler()) {\r\n                 addAccessorNode(new MethodAccessorNH(getWidenedTarget(m), (ExecutableStatement[]) es, getNullMethodHandler()));\r\n", "test_patch": "diff --git a/src/test/java/org/mvel2/compiler/GenericsTypeInferenceTest.java b/src/test/java/org/mvel2/compiler/GenericsTypeInferenceTest.java\nindex 503235e..4e70f4c 100644\n--- a/src/test/java/org/mvel2/compiler/GenericsTypeInferenceTest.java\n+++ b/src/test/java/org/mvel2/compiler/GenericsTypeInferenceTest.java\n@@ -67,23 +67,23 @@ public class GenericsTypeInferenceTest extends TestCase {\n         assertEquals(\"Wrong parametric type inferred\", String.class, context.getLastTypeParameters()[0]);\n     }\n \n-    public final void testInferLastTypeParametersFromPropertyMethod2() {\n-        ParserContext context = new ParserContext();\n-        context.setStrictTypeEnforcement( true );\n-\n-        context.addInput(\"a\", A.class);\n-\n-        ExpressionCompiler compiler = new ExpressionCompiler(\"a.getBarMap()[\\\"key\\\"].someMethod();\");\n-        final CompiledExpression compiledExpression = compiler.compile(context);\n-\n-        Map<String,Object> vars = new HashMap<String,Object>();\n-        vars.put( \"a\", new A() );\n-        final Object val = MVEL.executeExpression(compiledExpression, vars);\n-\n-        assertEquals(\"Expression did not evaluate correctly: \", \"bar\", val);\n-        assertNotNull(\"No type parameters detected\", context.getLastTypeParameters());\n-        assertEquals(\"Wrong parametric type inferred\", String.class, context.getLastTypeParameters()[0]);\n-    }\n+//    public final void testInferLastTypeParametersFromPropertyMethod2() {\n+//        ParserContext context = new ParserContext();\n+//        context.setStrictTypeEnforcement( true );\n+//\n+//        context.addInput(\"a\", A.class);\n+//\n+//        ExpressionCompiler compiler = new ExpressionCompiler(\"a.getBarMap()[\\\"key\\\"].someMethod();\");\n+//        final CompiledExpression compiledExpression = compiler.compile(context);\n+//\n+//        Map<String,Object> vars = new HashMap<String,Object>();\n+//        vars.put( \"a\", new A() );\n+//        final Object val = MVEL.executeExpression(compiledExpression, vars);\n+//\n+//        assertEquals(\"Expression did not evaluate correctly: \", \"bar\", val);\n+//        assertNotNull(\"No type parameters detected\", context.getLastTypeParameters());\n+//        assertEquals(\"Wrong parametric type inferred\", String.class, context.getLastTypeParameters()[0]);\n+//    }\n \n     public static class AWrapper {\n         public A getA() {\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T03:17:51.699966Z", "commit_hash": "6cb7303bf6d925cb838965779adfdc74933e08de", "commit_message": "fixes to property handlers\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/PropertyAccessor.java b/src/main/java/org/mvel2/PropertyAccessor.java\nindex 5afdff0..ca66d6f 100644\n--- a/src/main/java/org/mvel2/PropertyAccessor.java\n+++ b/src/main/java/org/mvel2/PropertyAccessor.java\n@@ -36,7 +36,6 @@ import static org.mvel2.util.ParseTools.*;\n import static org.mvel2.util.PropertyTools.getFieldOrAccessor;\r\n import static org.mvel2.util.PropertyTools.getFieldOrWriteAccessor;\r\n import org.mvel2.util.StringAppender;\r\n-import org.mvel2.optimizers.impl.refl.nodes.StaticReferenceAccessor;\r\n \r\n import static java.lang.Character.isJavaIdentifierPart;\r\n import static java.lang.Thread.currentThread;\r\n@@ -324,7 +323,7 @@ public class PropertyAccessor {\n                 }\r\n             }\r\n             else if (MVEL.COMPILER_OPT_ALLOW_OVERRIDE_ALL_PROPHANDLING && hasPropertyHandler(curr.getClass())) {\r\n-                getPropertyHandler(curr.getClass()).setProperty(capture(), ctx, variableFactory, value);\r\n+                getPropertyHandler(curr.getClass()).setProperty(capture(), curr, variableFactory, value);\r\n                 return;\r\n             }\r\n \r\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/PropertyHandlerTests.java b/src/test/java/org/mvel2/tests/core/PropertyHandlerTests.java\nindex ce9d379..7bb625f 100644\n--- a/src/test/java/org/mvel2/tests/core/PropertyHandlerTests.java\n+++ b/src/test/java/org/mvel2/tests/core/PropertyHandlerTests.java\n@@ -343,4 +343,52 @@ public class PropertyHandlerTests extends TestCase {\n         MVEL.COMPILER_OPT_ALLOW_OVERRIDE_ALL_PROPHANDLING = false;\n     }\n \n+    public class WorkObject {\n+        Map<String, Object> map = new HashMap<String, Object>();\n+\n+        public boolean hasFieldName(String name) {\n+            return map.containsKey(name);\n+        }\n+\n+        public Object getFieldValue(String name) {\n+            return map.get(name);\n+        }\n+\n+        public void setFieldValue(String name, Object value, boolean bool) {\n+            map.put(name, value);\n+        }\n+    }\n+\n+    public class WebPropertyHandler implements PropertyHandler {\n+\n+        public Object getProperty(String arg0, Object arg1,\n+                                  VariableResolverFactory arg2) {\n+            WorkObject wob = (WorkObject) arg1;\n+            if (wob.hasFieldName(arg0)) {\n+                return wob.getFieldValue(arg0);\n+            }\n+            else\n+                return null;\n+        }\n+\n+        public Object setProperty(String arg0, Object arg1,\n+                                  VariableResolverFactory arg2, Object arg3) {\n+            WorkObject wob = (WorkObject) arg1;\n+            wob.setFieldValue(arg0, arg3, true);\n+            return arg3;\n+        }\n+    }\n+\n+    public void testPropertyHandlerSetting() {\n+        MVEL.COMPILER_OPT_ALLOW_OVERRIDE_ALL_PROPHANDLING = true;\n+        PropertyHandlerFactory.registerPropertyHandler(WorkObject.class, new WebPropertyHandler());\n+\n+        Map vars = new HashMap();\n+        WorkObject wo = new WorkObject();\n+        vars.put(\"wobj\", wo);\n+\n+        MVEL.setProperty(vars, \"wobj.foo\", \"foobie\");\n+\n+        assertEquals(\"foobie\", wo.getFieldValue(\"foo\"));\n+    }\n }\n\\ No newline at end of file\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T03:24:23.916029Z", "commit_hash": "4be1cc9644bf0d6b4f8e6cdaebd0343668de94b2", "commit_message": "bug fixes\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/MacroProcessor.java b/src/main/java/org/mvel2/MacroProcessor.java\nindex ad338d7..cb65f8d 100644\n--- a/src/main/java/org/mvel2/MacroProcessor.java\n+++ b/src/main/java/org/mvel2/MacroProcessor.java\n@@ -63,18 +63,31 @@ public class MacroProcessor extends AbstractParser implements PreProcessor {\n \r\n             if (cursor < length) {\r\n                 switch (expr[cursor]) {\r\n+                    case '/':\r\n+                        start = cursor;\r\n+                        skipCommentBlock();\r\n+                        appender.append(new String(expr, start, cursor - start));\r\n+\r\n+                        if (cursor >= length || isIdentifierPart(expr[cursor--])) break;\r\n+                        break;\r\n+\r\n                     case '\"':\r\n                     case '\\'':\r\n                         start = cursor;\r\n-                        cursor = balancedCapture(expr, cursor, expr[cursor])+1;\r\n+                        cursor = balancedCapture(expr, cursor, expr[cursor]) + 1;\r\n                         appender.append(new String(expr, start, cursor - start));\r\n \r\n                         if (cursor >= length || isIdentifierPart(expr[cursor])) break;\r\n \r\n+\r\n                     default:\r\n-                        switch (expr[cursor])  {\r\n-                            case '.': macroArmed = false; break;\r\n-                            case ';': macroArmed = true; break;\r\n+                        switch (expr[cursor]) {\r\n+                            case '.':\r\n+                                macroArmed = false;\r\n+                                break;\r\n+                            case ';':\r\n+                                macroArmed = true;\r\n+                                break;\r\n                         }\r\n \r\n                         appender.append(expr[cursor]);\r\ndiff --git a/src/main/java/org/mvel2/compiler/AbstractParser.java b/src/main/java/org/mvel2/compiler/AbstractParser.java\nindex afff196..9301181 100644\n--- a/src/main/java/org/mvel2/compiler/AbstractParser.java\n+++ b/src/main/java/org/mvel2/compiler/AbstractParser.java\n@@ -18,19 +18,21 @@\n \r\n package org.mvel2.compiler;\r\n \r\n-import org.mvel2.*;\r\n-import org.mvel2.math.MathProcessor;\r\n+import org.mvel2.CompileException;\r\n+import org.mvel2.ErrorDetail;\r\n+import org.mvel2.Operator;\r\n import static org.mvel2.Operator.*;\r\n+import org.mvel2.ParserContext;\r\n import org.mvel2.ast.*;\r\n import static org.mvel2.ast.TypeDescriptor.getClassReference;\r\n import org.mvel2.integration.VariableResolverFactory;\r\n+import org.mvel2.math.MathProcessor;\r\n import static org.mvel2.util.ArrayTools.findFirst;\r\n import static org.mvel2.util.ArrayTools.isLiteralOnly;\r\n import org.mvel2.util.ExecutionStack;\r\n import static org.mvel2.util.ParseTools.*;\r\n import static org.mvel2.util.PropertyTools.isEmpty;\r\n import org.mvel2.util.Soundex;\r\n-import org.mvel2.util.ArrayTools;\r\n \r\n import java.io.Serializable;\r\n import static java.lang.Boolean.FALSE;\r\n@@ -1439,7 +1441,7 @@ public class AbstractParser implements Serializable {\n              */\r\n             captureToEOL();\r\n \r\n-            line = pCtx.getLineCount();\r\n+            if (pCtx != null) line = pCtx.getLineCount();\r\n \r\n             skipWhitespaceWithLineAccounting();\r\n \r\n@@ -1450,7 +1452,7 @@ public class AbstractParser implements Serializable {\n \r\n             lastWasComment = true;\r\n \r\n-            pCtx.setLineCount(line);\r\n+            if (pCtx != null) pCtx.setLineCount(line);\r\n \r\n             if ((start = cursor) >= length) return OP_TERMINATE;\r\n \r\n@@ -1467,7 +1469,7 @@ public class AbstractParser implements Serializable {\n              * source will spawn a new compiler, and we need to sync this with the\r\n              * parser context;\r\n              */\r\n-            line = pCtx.getLineCount();\r\n+            if (pCtx != null) line = pCtx.getLineCount();\r\n \r\n             while (true) {\r\n                 cursor++;\r\n@@ -1488,11 +1490,13 @@ public class AbstractParser implements Serializable {\n                 }\r\n             }\r\n \r\n-            pCtx.setLineCount(line);\r\n+            if (pCtx != null) {\r\n+                pCtx.setLineCount(line);\r\n \r\n-            if (lastNode instanceof LineLabel) {\r\n-                pCtx.getLastLineLabel().setLineNumber(line);\r\n-                pCtx.addKnownLine(line);\r\n+                if (lastNode instanceof LineLabel) {\r\n+                    pCtx.getLastLineLabel().setLineNumber(line);\r\n+                    pCtx.addKnownLine(line);\r\n+                }\r\n             }\r\n \r\n             lastWasComment = true;\r\ndiff --git a/src/test/java/org/mvel2/tests/core/MacroProcessorTest.java b/src/test/java/org/mvel2/tests/core/MacroProcessorTest.java\nnew file mode 100755\nindex 0000000..30cf87b\n--- /dev/null\n+++ b/src/test/java/org/mvel2/tests/core/MacroProcessorTest.java\n@@ -0,0 +1,191 @@\n+package org.mvel2.tests.core;\r\n+\r\n+import java.util.HashMap;\r\n+import java.util.Map;\r\n+\r\n+import junit.framework.TestCase;\r\n+import junit.framework.Assert;\r\n+import org.mvel2.tests.core.res.Foo;\r\n+import org.mvel2.integration.Interceptor;\r\n+import org.mvel2.integration.VariableResolverFactory;\r\n+import org.mvel2.integration.impl.MapVariableResolverFactory;\r\n+import org.mvel2.ast.ASTNode;\r\n+import org.mvel2.ast.WithNode;\r\n+import org.mvel2.compiler.ExpressionCompiler;\r\n+import org.mvel2.compiler.CompiledExpression;\r\n+import static org.mvel2.MVEL.parseMacros;\r\n+import static org.mvel2.MVEL.executeExpression;\r\n+import org.mvel2.debug.Debugger;\r\n+import org.mvel2.debug.Frame;\r\n+import org.mvel2.debug.DebugTools;\r\n+import org.mvel2.*;\r\n+\r\n+public class MacroProcessorTest extends TestCase {\r\n+\r\n+    private MacroProcessor macroProcessor;\r\n+\r\n+    protected void setUp() throws Exception {\r\n+        super.setUp();\r\n+        Map<String, Macro> macros = new HashMap<String, Macro>();\r\n+        macros.put(\"insert\",\r\n+                new Macro() {\r\n+                    public String doMacro() {\r\n+                        return \"drools.insert\";\r\n+                    }\r\n+                });\r\n+        macroProcessor = new MacroProcessor();\r\n+        macroProcessor.setMacros(macros);\r\n+    }\r\n+\r\n+    public void testParseString() {\r\n+        String raw = \"    l.add( \\\"rule 2 executed \\\" + str);\";\r\n+        try {\r\n+            String result = macroProcessor.parse(raw);\r\n+            assertEquals(raw, result);\r\n+        }\r\n+        catch (Exception ex) {\r\n+            ex.printStackTrace();\r\n+            fail(\"there shouldn't be any exception: \" + ex.getMessage());\r\n+        }\r\n+    }\r\n+\r\n+    public void testParseConsequenceWithComments() {\r\n+        String raw = \"    // str is null, we are just testing we don't get a null pointer \\n \" +\r\n+                \"    list.add( p );\";\r\n+        try {\r\n+            String result = macroProcessor.parse(raw);\r\n+            assertEquals(raw, result);\r\n+        }\r\n+        catch (Exception ex) {\r\n+            ex.printStackTrace();\r\n+            fail(\"there shouldn't be any exception: \" + ex.getMessage());\r\n+        }\r\n+    }\r\n+\r\n+    public void testMacroSupport() {\r\n+        Map<String, Object> vars = new HashMap<String, Object>();\r\n+        vars.put(\"foo\", new Foo());\r\n+\r\n+        Map<String, Interceptor> interceptors = new HashMap<String, Interceptor>();\r\n+        Map<String, Macro> macros = new HashMap<String, Macro>();\r\n+\r\n+        interceptors.put(\"Modify\", new Interceptor() {\r\n+            public int doBefore(ASTNode node, VariableResolverFactory factory) {\r\n+                ((WithNode) node).getNestedStatement().getValue(null,\r\n+                        factory);\r\n+                factory.createVariable(\"mod\", \"FOOBAR!\");\r\n+                return 0;\r\n+            }\r\n+\r\n+            public int doAfter(Object val, ASTNode node, VariableResolverFactory factory) {\r\n+                return 0;\r\n+            }\r\n+        });\r\n+\r\n+        macros.put(\"modify\", new Macro() {\r\n+            public String doMacro() {\r\n+                return \"@Modify with\";\r\n+            }\r\n+        });\r\n+\r\n+        ExpressionCompiler compiler = new ExpressionCompiler(parseMacros(\"modify (foo) { aValue = 'poo' }; mod\", macros));\r\n+        //   compiler.setDebugSymbols(true);\r\n+\r\n+        ParserContext ctx = new ParserContext(null, interceptors, null);\r\n+        ctx.setSourceFile(\"test.mv\");\r\n+        ctx.setDebugSymbols(true);\r\n+\r\n+        //   CompiledExpression compiled = compiler.compile(ctx);\r\n+\r\n+        assertEquals(\"FOOBAR!\", executeExpression(compiler.compile(ctx), null, vars));\r\n+    }\r\n+\r\n+\r\n+    public void testMacroSupportWithStrings() {\r\n+        Map<String, Object> vars = new HashMap<String, Object>();\r\n+        Foo foo = new Foo();\r\n+        vars.put(\"foo\", foo);\r\n+\r\n+        Map<String, Macro> macros = new HashMap<String, Macro>();\r\n+\r\n+        macros.put(\"modify\", new Macro() {\r\n+            public String doMacro() {\r\n+                return \"drools.modify\";\r\n+            }\r\n+        });\r\n+\r\n+        assertEquals(\"\", foo.aValue);\r\n+\r\n+        ExpressionCompiler compiler = new ExpressionCompiler(parseMacros(\"\\\"This is an modify()\\\"\", macros));\r\n+\r\n+        ParserContext ctx = new ParserContext(null, null, null);\r\n+        ctx.setSourceFile(\"test.mv\");\r\n+        ctx.setDebugSymbols(true);\r\n+\r\n+        assertEquals(\"This is an modify()\", executeExpression(compiler.compile(ctx), null, vars));\r\n+    }\r\n+\r\n+\r\n+    public void testMacroSupportWithDebugging() {\r\n+        Map<String, Object> vars = new HashMap<String, Object>();\r\n+        vars.put(\"foo\", new Foo());\r\n+\r\n+        Map<String, Interceptor> interceptors = new HashMap<String, Interceptor>();\r\n+        Map<String, Macro> macros = new HashMap<String, Macro>();\r\n+\r\n+        interceptors.put(\"Modify\", new Interceptor() {\r\n+            public int doBefore(ASTNode node, VariableResolverFactory factory) {\r\n+                ((WithNode) node).getNestedStatement().getValue(null,\r\n+                        factory);\r\n+\r\n+                factory.createVariable(\"mod\", \"FOOBAR!\");\r\n+\r\n+\r\n+                return 0;\r\n+            }\r\n+\r\n+            public int doAfter(Object val, ASTNode node, VariableResolverFactory factory) {\r\n+                return 0;\r\n+            }\r\n+        });\r\n+\r\n+        macros.put(\"modify\", new Macro() {\r\n+            public String doMacro() {\r\n+                return \"@Modify with\";\r\n+            }\r\n+        });\r\n+\r\n+        ExpressionCompiler compiler = new ExpressionCompiler(\r\n+                parseMacros(\r\n+                        \"System.out.println('hello');\\n\" +\r\n+                                \"System.out.println('bye');\\n\" +\r\n+                                \"modify (foo) { aValue = 'poo', \\n\" +\r\n+                                \" aValue = 'poo' };\\n mod\", macros)\r\n+        );\r\n+        // compiler.setDebugSymbols(true);\r\n+\r\n+        ParserContext ctx = new ParserContext(null, interceptors, null);\r\n+        ctx.setSourceFile(\"test.mv\");\r\n+        ctx.setDebugSymbols(true);\r\n+\r\n+        CompiledExpression compiled = compiler.compile(ctx);\r\n+\r\n+        MVELRuntime.setThreadDebugger(new Debugger() {\r\n+\r\n+            public int onBreak(Frame frame) {\r\n+                System.out.println(frame.getSourceName() + \":\" + frame.getLineNumber());\r\n+\r\n+                return Debugger.STEP;\r\n+            }\r\n+        });\r\n+\r\n+        MVELRuntime.registerBreakpoint(\"test.mv\", 3);\r\n+\r\n+        System.out.println(DebugTools.decompile(compiled\r\n+        ));\r\n+\r\n+        Assert.assertEquals(\"FOOBAR!\", MVEL.executeDebugger(compiled, null, new MapVariableResolverFactory(vars)));\r\n+    }\r\n+\r\n+\r\n+}\r\n", "test_patch": "diff --git a/src/test/java/org/mvel2/MacroProcessorTest.java b/src/test/java/org/mvel2/MacroProcessorTest.java\ndeleted file mode 100755\nindex 0aa150b..0000000\n--- a/src/test/java/org/mvel2/MacroProcessorTest.java\n+++ /dev/null\n@@ -1,50 +0,0 @@\n-package org.mvel2;\r\n-\r\n-import java.util.HashMap;\r\n-import java.util.Map;\r\n-\r\n-import junit.framework.TestCase;\r\n-\r\n-public class MacroProcessorTest extends TestCase {\r\n-\r\n-    private MacroProcessor macroProcessor;\r\n-\r\n-    protected void setUp() throws Exception {\r\n-        super.setUp();\r\n-        Map<String, Macro> macros = new HashMap<String, Macro>();\r\n-        macros.put( \"insert\",\r\n-                    new Macro() {\r\n-                        public String doMacro() {\r\n-                            return \"drools.insert\";\r\n-                        }\r\n-                    } ); \r\n-        macroProcessor = new MacroProcessor();\r\n-        macroProcessor.setMacros( macros );\r\n-    }\r\n-\r\n-    public void testParseString() {\r\n-        String raw = \"    l.add( \\\"rule 2 executed \\\" + str);\";\r\n-        try { \r\n-            String result = macroProcessor.parse( raw );\r\n-            assertEquals( raw, result );\r\n-        } catch( Exception ex ) {\r\n-            ex.printStackTrace();\r\n-            fail( \"there shouldn't be any exception: \"+ex.getMessage());\r\n-        }\r\n-    }\r\n-\r\n-    public void testParseConsequenceWithComments() {\r\n-        String raw = \"    // str is null, we are just testing we don't get a null pointer \\n \"+\r\n-                     \"    list.add( p ); \";\r\n-        try { \r\n-            String result = macroProcessor.parse( raw );\r\n-            assertEquals( raw, result );\r\n-        } catch( Exception ex ) {\r\n-            ex.printStackTrace();\r\n-            fail( \"there shouldn't be any exception: \"+ex.getMessage());\r\n-        }\r\n-    }\r\n-\r\n-    \r\n-\r\n-}\r\ndiff --git a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\nindex 7b9d9fe..2859070 100644\n--- a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n@@ -1613,129 +1613,7 @@ public class CoreConfidenceTests extends AbstractTest {\n         executeExpression(compileExpression(\"@test System.out.println('MIDDLE');\", null, interceptors));\n     }\n \n-    public void testMacroSupport() {\n-        Map<String, Object> vars = new HashMap<String, Object>();\n-        vars.put(\"foo\", new Foo());\n-\n-        Map<String, Interceptor> interceptors = new HashMap<String, Interceptor>();\n-        Map<String, Macro> macros = new HashMap<String, Macro>();\n-\n-        interceptors.put(\"Modify\", new Interceptor() {\n-            public int doBefore(ASTNode node, VariableResolverFactory factory) {\n-                ((WithNode) node).getNestedStatement().getValue(null,\n-                        factory);\n-                factory.createVariable(\"mod\", \"FOOBAR!\");\n-                return 0;\n-            }\n-\n-            public int doAfter(Object val, ASTNode node, VariableResolverFactory factory) {\n-                return 0;\n-            }\n-        });\n-\n-        macros.put(\"modify\", new Macro() {\n-            public String doMacro() {\n-                return \"@Modify with\";\n-            }\n-        });\n-\n-        ExpressionCompiler compiler = new ExpressionCompiler(parseMacros(\"modify (foo) { aValue = 'poo' }; mod\", macros));\n-        //   compiler.setDebugSymbols(true);\n-\n-        ParserContext ctx = new ParserContext(null, interceptors, null);\n-        ctx.setSourceFile(\"test.mv\");\n-        ctx.setDebugSymbols(true);\n-\n-        //   CompiledExpression compiled = compiler.compile(ctx);\n-\n-        assertEquals(\"FOOBAR!\", executeExpression(compiler.compile(ctx), null, vars));\n-    }\n-\n-    public void testMacroSupportWithStrings() {\n-        Map<String, Object> vars = new HashMap<String, Object>();\n-        Foo foo = new Foo();\n-        vars.put(\"foo\", foo);\n-\n-        Map<String, Macro> macros = new HashMap<String, Macro>();\n-\n-        macros.put(\"modify\", new Macro() {\n-            public String doMacro() {\n-                return \"drools.modify\";\n-            }\n-        });\n-\n-        assertEquals(\"\", foo.aValue);\n-\n-        ExpressionCompiler compiler = new ExpressionCompiler(parseMacros(\"\\\"This is an modify()\\\"\", macros));\n-\n-        ParserContext ctx = new ParserContext(null, null, null);\n-        ctx.setSourceFile(\"test.mv\");\n-        ctx.setDebugSymbols(true);\n-\n-        assertEquals(\"This is an modify()\", executeExpression(compiler.compile(ctx), null, vars));\n-    }\n-\n-\n-    public void testMacroSupportWithDebugging() {\n-        Map<String, Object> vars = new HashMap<String, Object>();\n-        vars.put(\"foo\", new Foo());\n-\n-        Map<String, Interceptor> interceptors = new HashMap<String, Interceptor>();\n-        Map<String, Macro> macros = new HashMap<String, Macro>();\n-\n-        interceptors.put(\"Modify\", new Interceptor() {\n-            public int doBefore(ASTNode node, VariableResolverFactory factory) {\n-                ((WithNode) node).getNestedStatement().getValue(null,\n-                        factory);\n-\n-                factory.createVariable(\"mod\", \"FOOBAR!\");\n-\n-\n-                return 0;\n-            }\n-\n-            public int doAfter(Object val, ASTNode node, VariableResolverFactory factory) {\n-                return 0;\n-            }\n-        });\n-\n-        macros.put(\"modify\", new Macro() {\n-            public String doMacro() {\n-                return \"@Modify with\";\n-            }\n-        });\n-\n-        ExpressionCompiler compiler = new ExpressionCompiler(\n-                parseMacros(\n-                        \"System.out.println('hello');\\n\" +\n-                                \"System.out.println('bye');\\n\" +\n-                                \"modify (foo) { aValue = 'poo', \\n\" +\n-                                \" aValue = 'poo' };\\n mod\", macros)\n-        );\n-        // compiler.setDebugSymbols(true);\n-\n-        ParserContext ctx = new ParserContext(null, interceptors, null);\n-        ctx.setSourceFile(\"test.mv\");\n-        ctx.setDebugSymbols(true);\n \n-        CompiledExpression compiled = compiler.compile(ctx);\n-\n-        MVELRuntime.setThreadDebugger(new Debugger() {\n-\n-            public int onBreak(Frame frame) {\n-                System.out.println(frame.getSourceName() + \":\" + frame.getLineNumber());\n-\n-                return Debugger.STEP;\n-            }\n-        });\n-\n-        MVELRuntime.registerBreakpoint(\"test.mv\", 3);\n-\n-        System.out.println(DebugTools.decompile(compiled\n-        ));\n-\n-        assertEquals(\"FOOBAR!\", MVEL.executeDebugger(compiled, null, new MapVariableResolverFactory(vars)));\n-    }\n \n     public void testExecuteCoercionTwice() {\n         OptimizerFactory.setDefaultOptimizer(\"reflective\");\n@@ -5067,31 +4945,7 @@ public class CoreConfidenceTests extends AbstractTest {\n     }\n \n \n-    public void testMVEL135() {\n \n-        Map<String, Macro> macros = new HashMap<String, Macro>();\n-        macros.put(\"insert\",\n-                new Macro() {\n-                    public String doMacro() {\n-                        return \"drools.insert\";\n-                    }\n-                });\n-\n-        String raw = \" l.add( \\\"rule 2 executed \\\" + str);\";\n-\n-        try {\n-            MacroProcessor macroProcessor = new MacroProcessor();\n-            macroProcessor.setMacros(macros);\n-            String result = macroProcessor.parse(raw);\n-            assertEquals(raw, result);\n-        }\n-        catch (Exception ex) {\n-            ex.printStackTrace();\n-            fail(\"there shouldn't be any exception: \" + ex.getMessage());\n-        }\n-\n-\n-    }\n \n }\n \n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T03:31:05.475120Z", "commit_hash": "283e83e416f0df3d18f73fc7a35d72101010b4a0", "commit_message": "macro processing fixed\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/MacroProcessor.java b/src/main/java/org/mvel2/MacroProcessor.java\nindex 98262eb..ad338d7 100644\n--- a/src/main/java/org/mvel2/MacroProcessor.java\n+++ b/src/main/java/org/mvel2/MacroProcessor.java\n@@ -21,6 +21,7 @@ package org.mvel2;\n import org.mvel2.compiler.AbstractParser;\r\n import static org.mvel2.util.ParseTools.isWhitespace;\r\n import static org.mvel2.util.ParseTools.balancedCapture;\r\n+import static org.mvel2.util.ParseTools.isIdentifierPart;\r\n import org.mvel2.util.StringAppender;\r\n import org.mvel2.util.ParseTools;\r\n \r\n@@ -45,39 +46,41 @@ public class MacroProcessor extends AbstractParser implements PreProcessor {\n         StringAppender appender = new StringAppender();\r\n \r\n         int start;\r\n+        boolean macroArmed = true;\r\n         String token;\r\n \r\n         for (; cursor < length; cursor++) {\r\n-            if ('\\'' == expr[cursor] || '\"' == expr[cursor]) {\r\n-                start = cursor;\r\n-                cursor = balancedCapture(expr, cursor, expr[cursor]) + 1;\r\n-                appender.append(new String(expr, start, cursor - start));\r\n-            }\r\n-            \r\n-            while (cursor < length && (isWhitespace(expr[cursor]) || expr[cursor] == ';')) {\r\n-                appender.append(expr[cursor++]);\r\n-            }\r\n-\r\n             start = cursor;\r\n-\r\n-            while (cursor < length\r\n-                    && (!isWhitespace(expr[cursor])\r\n-                    && expr[cursor] != '('\r\n-                    && expr[cursor] != ')')) {\r\n-\r\n-                cursor++;\r\n-            }\r\n-\r\n-            if (macros.containsKey(token = new String(expr, start, cursor - start))) {\r\n-                appender.append(macros.get(token).doMacro());\r\n-            }\r\n-            else {\r\n-                appender.append(token);\r\n+            while (cursor < length && isIdentifierPart(expr[cursor])) cursor++;\r\n+            if (cursor > start) {\r\n+                if (macros.containsKey(token = new String(expr, start, cursor - start)) && macroArmed) {\r\n+                    appender.append(macros.get(token).doMacro());\r\n+                }\r\n+                else {\r\n+                    appender.append(token);\r\n+                }\r\n             }\r\n \r\n             if (cursor < length) {\r\n-                appender.append(expr[cursor]);\r\n+                switch (expr[cursor]) {\r\n+                    case '\"':\r\n+                    case '\\'':\r\n+                        start = cursor;\r\n+                        cursor = balancedCapture(expr, cursor, expr[cursor])+1;\r\n+                        appender.append(new String(expr, start, cursor - start));\r\n+\r\n+                        if (cursor >= length || isIdentifierPart(expr[cursor])) break;\r\n+\r\n+                    default:\r\n+                        switch (expr[cursor])  {\r\n+                            case '.': macroArmed = false; break;\r\n+                            case ';': macroArmed = true; break;\r\n+                        }\r\n+\r\n+                        appender.append(expr[cursor]);\r\n+                }\r\n             }\r\n+\r\n         }\r\n \r\n         return appender.toChars();\r\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\nindex b843088..7b9d9fe 100644\n--- a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n@@ -5067,6 +5067,32 @@ public class CoreConfidenceTests extends AbstractTest {\n     }\n \n \n+    public void testMVEL135() {\n+\n+        Map<String, Macro> macros = new HashMap<String, Macro>();\n+        macros.put(\"insert\",\n+                new Macro() {\n+                    public String doMacro() {\n+                        return \"drools.insert\";\n+                    }\n+                });\n+\n+        String raw = \" l.add( \\\"rule 2 executed \\\" + str);\";\n+\n+        try {\n+            MacroProcessor macroProcessor = new MacroProcessor();\n+            macroProcessor.setMacros(macros);\n+            String result = macroProcessor.parse(raw);\n+            assertEquals(raw, result);\n+        }\n+        catch (Exception ex) {\n+            ex.printStackTrace();\n+            fail(\"there shouldn't be any exception: \" + ex.getMessage());\n+        }\n+\n+\n+    }\n+\n }\n \n \n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T03:56:58.803506Z", "commit_hash": "e8b2f8f44b84c6b18ea8da20598d3aa92ae4bf89", "commit_message": "fixed macro processor\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/MacroProcessor.java b/src/main/java/org/mvel2/MacroProcessor.java\nindex 2cd210e..98262eb 100644\n--- a/src/main/java/org/mvel2/MacroProcessor.java\n+++ b/src/main/java/org/mvel2/MacroProcessor.java\n@@ -20,7 +20,9 @@ package org.mvel2;\n \r\n import org.mvel2.compiler.AbstractParser;\r\n import static org.mvel2.util.ParseTools.isWhitespace;\r\n+import static org.mvel2.util.ParseTools.balancedCapture;\r\n import org.mvel2.util.StringAppender;\r\n+import org.mvel2.util.ParseTools;\r\n \r\n import java.util.Map;\r\n \r\n@@ -46,6 +48,12 @@ public class MacroProcessor extends AbstractParser implements PreProcessor {\n         String token;\r\n \r\n         for (; cursor < length; cursor++) {\r\n+            if ('\\'' == expr[cursor] || '\"' == expr[cursor]) {\r\n+                start = cursor;\r\n+                cursor = balancedCapture(expr, cursor, expr[cursor]) + 1;\r\n+                appender.append(new String(expr, start, cursor - start));\r\n+            }\r\n+            \r\n             while (cursor < length && (isWhitespace(expr[cursor]) || expr[cursor] == ';')) {\r\n                 appender.append(expr[cursor++]);\r\n             }\r\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\nindex 1f1b1fc..a9b316a 100644\n--- a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n@@ -1671,7 +1671,7 @@ public class CoreConfidenceTests extends AbstractTest {\n         ctx.setSourceFile(\"test.mv\");\n         ctx.setDebugSymbols(true);\n \n-        assertEquals( \"\\\"This is an modify()\\\"\", executeExpression(compiler.compile(ctx), null, vars) );\n+        assertEquals( \"This is an modify()\", executeExpression(compiler.compile(ctx), null, vars) );\n     }    \n \n \n@@ -4748,7 +4748,7 @@ public class CoreConfidenceTests extends AbstractTest {\n     public void testFieldCoercion1() {\n         ParserContext ctx = new ParserContext();\n         ctx.setStrongTyping(true);\n-        ctx.addInput(\"bar\", Bar.class);\n+        ctx.addInput(\"bar\", Bar.class);                                                            \n \n         Serializable s = compileSetExpression(\"bar.assignTest\", ctx);\n \n@@ -4983,6 +4983,10 @@ public class CoreConfidenceTests extends AbstractTest {\n         assertEquals(Fruit.Apple.class, test(\"import \" + CoreConfidenceTests.class.getName() + \"; CoreConfidenceTests.Fruit.Apple\"));\n     }\n \n+    public void testEdson() {\n+        assertEquals(\"foo\", test(\"list = new java.util.ArrayList(); list.add(new String('foo')); list[0]\"));\n+    }\n+\n \n }\n \n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T04:04:26.194171Z", "commit_hash": "ac92bd7ba7a3f0396cce77f7d3338ba455b69c12", "commit_message": "fix potential infinite loop in parser\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/util/ParseTools.java b/src/main/java/org/mvel2/util/ParseTools.java\nindex dd272b1..dd35c1c 100644\n--- a/src/main/java/org/mvel2/util/ParseTools.java\n+++ b/src/main/java/org/mvel2/util/ParseTools.java\n@@ -1006,7 +1006,9 @@ public class ParseTools {\n             }\n         }\n         else {\n+            int lines = 0;\n             for (start++; start < chars.length; start++) {\n+\n                 if (start < chars.length && chars[start] == '/') {\n                     if (start + 1 == chars.length) return start;\n                     if (chars[start + 1] == '/') {\n@@ -1023,6 +1025,7 @@ public class ParseTools {\n                                     }\n                                 case '\\r':\n                                 case '\\n':\n+\n                                     break;\n                             }\n                             start++;\n@@ -1073,14 +1076,11 @@ public class ParseTools {\n             for (start++; start < chars.length; start++) {\n                 if (chars[start] == type) {\n                     return start;\n-\n-//                    return new int[]{start, 0};\n                 }\n             }\n         }\n         else {\n             int lines = 0;\n-\n             for (start++; start < chars.length; start++) {\n                 if (isWhitespace(chars[start])) {\n                     switch (chars[start]) {\n@@ -1091,7 +1091,8 @@ public class ParseTools {\n                             lines++;\n                     }\n                 }\n-                else if (chars[start] == '/' && start < chars.length) {\n+                else if (start < chars.length && chars[start] == '/') {\n+                    if (start + 1 == chars.length) return start;\n                     if (chars[start + 1] == '/') {\n                         start++;\n                         while (start < chars.length && chars[start] != '\\n') start++;\n@@ -1101,21 +1102,21 @@ public class ParseTools {\n                         while (start < chars.length) {\n                             switch (chars[start]) {\n                                 case '*':\n-                                    if (start < chars.length && chars[start + 1] == '/') {\n+                                    if (start + 1 < chars.length && chars[start + 1] == '/') {\n                                         break;\n                                     }\n                                 case '\\r':\n-                                    continue;\n                                 case '\\n':\n                                     pCtx.setLineOffset((short) start);\n                                     lines++;\n+                                    break;\n                             }\n-\n                             start++;\n                         }\n                     }\n                 }\n-                else if (chars[start] == '\\'' || chars[start] == '\"') {\n+                if (start == chars.length) return start;\n+                if (chars[start] == '\\'' || chars[start] == '\"') {\n                     start = captureStringLiteral(chars[start], chars, start, chars.length);\n                 }\n                 else if (chars[start] == type) {\n@@ -1124,7 +1125,6 @@ public class ParseTools {\n                 else if (chars[start] == term && --depth == 0) {\n                     pCtx.incrementLineCount(lines);\n                     return start;\n-                 //   return new int[]{start, lines};\n                 }\n             }\n         }\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/fuzz/Fuzzer.java b/src/test/java/org/mvel2/tests/fuzz/Fuzzer.java\nindex 167fc53..360f0f8 100644\n--- a/src/test/java/org/mvel2/tests/fuzz/Fuzzer.java\n+++ b/src/test/java/org/mvel2/tests/fuzz/Fuzzer.java\n@@ -70,7 +70,7 @@ public class Fuzzer {\n                 System.err.flush();\n             }\n \n-            if (run % 50000 == 0 && run != 0) {\n+            if (run % 25000 == 0 && run != 0) {\n                 rate = run / (time = (currentTimeMillis() - start) / 1000);\n                 System.out.println(\"Run: \" + df.format(run) + \" times; \"\n                         + df.format(time) + \"secs; \" + df.format(rate) + \" avg. per second.\");\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T04:10:46.665212Z", "commit_hash": "a06ae0a712a13daaa5e9deb4e92644f76f94b29f", "commit_message": "bug fixes\n", "related_issues": "", "bug_patch": "diff --git a/samples/scripts/quicksort3.mvel b/samples/scripts/quicksort3.mvel\ndeleted file mode 100644\nindex 45b1899..0000000\n--- a/samples/scripts/quicksort3.mvel\n+++ /dev/null\n@@ -1,27 +0,0 @@\n-/**\n- * Sample MVEL 2.0 Script\n- * \"Functional-style QuickSort\"\n- * by: Dhanji R. Prasanna\n- */\n-\n-import java.util.*;\n-\n-def quicksort(list) {\n-    if (list.isEmpty()) {\n-        return [];\n-    }\n-\n-    pivot = list[0];\n-\n-    newList = new ArrayList((($ < pivot) in list));\n-    newList.add(pivot);\n-    newList.addAll((($ < pivot) in list));\n-\n-    quicksort(newList);\n-\n-    //quicksort((($ < pivot) in list) + [pivot] + quicksort((($ < pivot) in list)));\n-}\n-\n-array = [50,20,21,209,10,77,8,9,55,73,41,99];\n-\n-quicksort(array);\n\\ No newline at end of file\ndiff --git a/src/main/java/org/mvel2/ast/ASTNode.java b/src/main/java/org/mvel2/ast/ASTNode.java\nindex a26d3e9..04d217a 100644\n--- a/src/main/java/org/mvel2/ast/ASTNode.java\n+++ b/src/main/java/org/mvel2/ast/ASTNode.java\n@@ -94,6 +94,9 @@ public class ASTNode implements Cloneable,  Serializable {\n             try {\n                 return accessor.getValue(ctx, thisValue, factory);\n             }\n+            catch (NullPointerException e) {\n+                throw e;\n+            }\n             catch (ClassCastException ce) {\n                 if ((fields & DEOP) == 0) {\n                     accessor = null;\ndiff --git a/src/main/java/org/mvel2/ast/Fold.java b/src/main/java/org/mvel2/ast/Fold.java\nindex a84059d..98a332d 100644\n--- a/src/main/java/org/mvel2/ast/Fold.java\n+++ b/src/main/java/org/mvel2/ast/Fold.java\n@@ -32,6 +32,7 @@ import static org.mvel2.util.ParseTools.*;\n \n import java.util.Collection;\n import java.util.List;\n+import java.util.Iterator;\n \n public class Fold extends ASTNode {\n     private ExecutableStatement subEx;\n@@ -76,15 +77,18 @@ public class Fold extends ASTNode {\n \n         List list;\n \n+\n         if (constraintEx != null) {\n             Collection col = ((Collection) dataEx.getValue(ctx, thisValue, factory));\n             list = new FastList(col.size());\n+\n             for (Object o : col) {\n                 itemR.value = o;\n                 if ((Boolean) constraintEx.getValue(ctx, thisValue, itemFactory)) {\n                     list.add(subEx.getValue(o, thisValue, itemFactory));\n                 }\n             }\n+\n         }\n         else {\n             Collection col = ((Collection) dataEx.getValue(ctx, thisValue, factory));\n@@ -93,7 +97,6 @@ public class Fold extends ASTNode {\n                 list.add(subEx.getValue(itemR.value = o, thisValue, itemFactory));\n             }\n         }\n-\n         return list;\n     }\n \ndiff --git a/src/main/java/org/mvel2/ast/Function.java b/src/main/java/org/mvel2/ast/Function.java\nindex 238890f..1e9788b 100644\n--- a/src/main/java/org/mvel2/ast/Function.java\n+++ b/src/main/java/org/mvel2/ast/Function.java\n@@ -173,6 +173,10 @@ public class Function extends ASTNode implements Safe {\n         }\n     }\n \n+    public ExecutableStatement getCompiledBlock() {\n+        return compiledBlock;\n+    }\n+\n     public String toString() {\n         return \"FunctionDef:\" + (name == null ? \"Anonymous\" : name);\n     }\ndiff --git a/src/main/java/org/mvel2/compiler/CompiledAccExpression.java b/src/main/java/org/mvel2/compiler/CompiledAccExpression.java\nindex 661f3fc..d6ca18a 100644\n--- a/src/main/java/org/mvel2/compiler/CompiledAccExpression.java\n+++ b/src/main/java/org/mvel2/compiler/CompiledAccExpression.java\n@@ -43,7 +43,6 @@ public class CompiledAccExpression implements ExecutableStatement, Serializable \n                     .optimizeSetAccessor(context, expression, ctx, ctx, vrf, false, value, ingressType);\n         }\n         else {\n-            System.out.println(\"Exec<<\" + accessor.toString() + \">>\");\n             accessor.setValue(ctx, elCtx, vrf, value);\n         }\n         return value;\ndiff --git a/src/main/java/org/mvel2/debug/DebugTools.java b/src/main/java/org/mvel2/debug/DebugTools.java\nindex f5cfea6..3fc29fa 100644\n--- a/src/main/java/org/mvel2/debug/DebugTools.java\n+++ b/src/main/java/org/mvel2/debug/DebugTools.java\n@@ -21,10 +21,7 @@ package org.mvel2.debug;\n import org.mvel2.Operator;\r\n import static org.mvel2.Operator.ADD;\r\n import static org.mvel2.Operator.SUB;\r\n-import org.mvel2.ast.ASTNode;\r\n-import org.mvel2.ast.BinaryOperation;\r\n-import org.mvel2.ast.NestedStatement;\r\n-import org.mvel2.ast.Substatement;\r\n+import org.mvel2.ast.*;\r\n import org.mvel2.compiler.CompiledExpression;\r\n import org.mvel2.compiler.ExecutableAccessor;\r\n import org.mvel2.compiler.ExecutableLiteral;\r\n@@ -84,6 +81,10 @@ public class DebugTools {\n                 sbuf.append(\"NEST [\" + tk.getClass().getSimpleName() + \"]: { \" + tk.getName() + \" }\\n\");\r\n                 sbuf.append(decompile((CompiledExpression) ((Substatement) tk).getStatement(), true, context));\r\n             }\r\n+//            else if (tk instanceof Function) {\r\n+//                sbuf.append(\"FUNCTION [\" + tk.getName() + \"]: \")\r\n+//                        .append(decompile((CompiledExpression) ((Function)tk).getCompiledBlock(), true, context));\r\n+//            }\r\n             else if (tk.isDebuggingSymbol()) {\r\n                 //noinspection StringConcatenationInsideStringBufferAppend\r\n                 sbuf.append(\"DEBUG_SYMBOL :: \" + tk.toString());\r\ndiff --git a/src/main/java/org/mvel2/integration/impl/FunctionVariableResolverFactory.java b/src/main/java/org/mvel2/integration/impl/FunctionVariableResolverFactory.java\nindex 9f0f81f..2b50070 100644\n--- a/src/main/java/org/mvel2/integration/impl/FunctionVariableResolverFactory.java\n+++ b/src/main/java/org/mvel2/integration/impl/FunctionVariableResolverFactory.java\n@@ -108,7 +108,7 @@ public class FunctionVariableResolverFactory extends BaseVariableResolverFactory\n         if (variableResolvers.containsKey(name)) return variableResolvers.get(name);\n         else if ((idx = variableIndexOf(name)) != -1) {\n             if (indexedVariableResolvers[idx] == null) {\n-                indexedVariableResolvers[idx] = super.getVariableResolver(name);\n+                indexedVariableResolvers[idx] = new SimpleValueResolver(null);\n             }\n             variableResolvers.put(indexedVariableNames[idx], indexedVariableResolvers[idx]);\n             return indexedVariableResolvers[idx];\n@@ -122,7 +122,7 @@ public class FunctionVariableResolverFactory extends BaseVariableResolverFactory\n     }\n \n     public boolean isTarget(String name) {\n-        return variableResolvers.containsKey(name);\n+        return variableResolvers.containsKey(name) || variableIndexOf(name) != -1;\n     }\n \n     private int increaseRegisterTableSize() {\ndiff --git a/src/main/java/org/mvel2/optimizers/impl/refl/ReflectiveAccessorOptimizer.java b/src/main/java/org/mvel2/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\nindex 78165a4..c1c5faf 100644\n--- a/src/main/java/org/mvel2/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\n+++ b/src/main/java/org/mvel2/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\n@@ -494,13 +494,30 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n             return o;\r\n         }\r\n         else if (member != null) {\r\n-            o = ((Field) member).get(ctx);\r\n-            if (hasNullPropertyHandler()) {\r\n-                addAccessorNode(new FieldAccessorNH((Field) member, getNullMethodHandler()));\r\n-                if (o == null) o = getNullMethodHandler().getProperty(member.getName(), ctx, variableFactory);\r\n+            Field f = (Field) member;\r\n+\r\n+            if ((f.getModifiers() & Modifier.STATIC) != 0) {\r\n+                o = f.get(null);\r\n+\r\n+                if (hasNullPropertyHandler()) {\r\n+\r\n+                    addAccessorNode(new StaticVarAccessorNH((Field) member, getNullMethodHandler()));\r\n+                    if (o == null) o = getNullMethodHandler().getProperty(member.getName(), ctx, variableFactory);\r\n+                }\r\n+                else {\r\n+                    addAccessorNode(new StaticVarAccessor((Field) member));\r\n+                }\r\n+\r\n             }\r\n             else {\r\n-                addAccessorNode(new FieldAccessor((Field) member));\r\n+                o = f.get(ctx);\r\n+                if (hasNullPropertyHandler()) {\r\n+                    addAccessorNode(new FieldAccessorNH((Field) member, getNullMethodHandler()));\r\n+                    if (o == null) o = getNullMethodHandler().getProperty(member.getName(), ctx, variableFactory);\r\n+                }\r\n+                else {\r\n+                    addAccessorNode(new FieldAccessor((Field) member));\r\n+                }\r\n             }\r\n             return o;\r\n         }\r\n@@ -585,7 +602,9 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n      * @throws Exception -\r\n      */\r\n     private Object getCollectionProperty(Object ctx, String prop) throws Exception {\r\n-        if (prop.length() > 0) ctx = getBeanProperty(ctx, prop);\r\n+        if (prop.length() > 0) {\r\n+            ctx = getBeanProperty(ctx, prop);\r\n+        }\r\n \r\n         int start = ++cursor;\r\n \r\ndiff --git a/src/main/java/org/mvel2/optimizers/impl/refl/nodes/FieldAccessor.java b/src/main/java/org/mvel2/optimizers/impl/refl/nodes/FieldAccessor.java\nindex e765283..5d5ee43 100644\n--- a/src/main/java/org/mvel2/optimizers/impl/refl/nodes/FieldAccessor.java\n+++ b/src/main/java/org/mvel2/optimizers/impl/refl/nodes/FieldAccessor.java\n@@ -48,7 +48,7 @@ public class FieldAccessor implements AccessorNode {\n             }\n         }\n         catch (Exception e) {\n-            throw new CompileException(\"unable to access field\", e);\n+            throw new CompileException(\"unable to access field: \" + field.getName(), e);\n         }\n     }\n \ndiff --git a/src/main/java/org/mvel2/optimizers/impl/refl/nodes/MethodAccessor.java b/src/main/java/org/mvel2/optimizers/impl/refl/nodes/MethodAccessor.java\nindex 00eb3e0..1844157 100644\n--- a/src/main/java/org/mvel2/optimizers/impl/refl/nodes/MethodAccessor.java\n+++ b/src/main/java/org/mvel2/optimizers/impl/refl/nodes/MethodAccessor.java\n@@ -24,6 +24,8 @@ import org.mvel2.compiler.AccessorNode;\n import org.mvel2.compiler.ExecutableStatement;\n import org.mvel2.integration.VariableResolverFactory;\n import static org.mvel2.util.ParseTools.getBestCandidate;\n+import org.mvel2.util.PropertyTools;\n+import org.mvel2.util.ParseTools;\n \n import java.lang.reflect.Method;\n \n@@ -71,8 +73,18 @@ public class MethodAccessor implements AccessorNode {\n                     return method.invoke(ctx, executeAndCoerce(parameterTypes, elCtx, vars));\n                 }\n             }\n+            catch (IllegalArgumentException e) {\n+                Object[] vs = executeAndCoerce(parameterTypes, elCtx, vars);\n+                Method newMeth;\n+                if ((newMeth = ParseTools.getBestCandidate(vs, method.getName(), method.getDeclaringClass(), method.getDeclaringClass().getMethods(), false)) != null) {\n+                    return executeOverrideTarget(newMeth, ctx, elCtx, vars);\n+                }\n+                else {\n+                    throw e;\n+                }\n+            }\n             catch (Exception e) {\n-                throw new CompileException(\"cannot invoke method\", e);\n+                throw new CompileException(\"cannot invoke method: \" + method.getName(), e);\n             }\n         }\n     }\ndiff --git a/src/main/java/org/mvel2/optimizers/impl/refl/nodes/StaticVarAccessorNH.java b/src/main/java/org/mvel2/optimizers/impl/refl/nodes/StaticVarAccessorNH.java\nnew file mode 100644\nindex 0000000..4cfba80\n--- /dev/null\n+++ b/src/main/java/org/mvel2/optimizers/impl/refl/nodes/StaticVarAccessorNH.java\n@@ -0,0 +1,82 @@\n+/**\r\n+ * MVEL (The MVFLEX Expression Language)\r\n+ *\r\n+ * Copyright (C) 2007 Christopher Brock, MVFLEX/Valhalla Project and the Codehaus\r\n+ *\r\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ *\r\n+ */\r\n+package org.mvel2.optimizers.impl.refl.nodes;\r\n+\r\n+import org.mvel2.CompileException;\r\n+import org.mvel2.OptimizationFailure;\r\n+import org.mvel2.compiler.AccessorNode;\r\n+import org.mvel2.integration.VariableResolverFactory;\r\n+import org.mvel2.integration.PropertyHandler;\r\n+\r\n+import java.lang.reflect.Field;\r\n+\r\n+public class StaticVarAccessorNH implements AccessorNode {\r\n+    private AccessorNode nextNode;\r\n+    Field field;\r\n+    private PropertyHandler nullHandler;\r\n+\r\n+    public Object getValue(Object ctx, Object elCtx, VariableResolverFactory vars) {\r\n+        try {\r\n+            Object v = field.get(ctx);\r\n+            if (v == null) v = nullHandler.getProperty(field.getName(), elCtx, vars);\r\n+\r\n+            if (nextNode != null) {\r\n+                return nextNode.getValue(v, elCtx, vars);\r\n+            }\r\n+            else {\r\n+                return v;\r\n+            }\r\n+        }\r\n+        catch (Exception e) {\r\n+            throw new OptimizationFailure(\"unable to access static field\", e);\r\n+        }\r\n+    }\r\n+\r\n+    public StaticVarAccessorNH(Field field, PropertyHandler handler) {\r\n+        this.field = field;\r\n+        this.nullHandler = handler;\r\n+    }\r\n+\r\n+    public AccessorNode getNextNode() {\r\n+        return nextNode;\r\n+    }\r\n+\r\n+    public AccessorNode setNextNode(AccessorNode nextNode) {\r\n+        return this.nextNode = nextNode;\r\n+    }\r\n+\r\n+    public Object setValue(Object ctx, Object elCtx, VariableResolverFactory variableFactory, Object value) {\r\n+        try {\r\n+            if (nextNode == null) {\r\n+                field.set(null, value);\r\n+            }\r\n+            else {\r\n+                return nextNode.setValue(field.get(null), elCtx, variableFactory, value);\r\n+            }\r\n+        }\r\n+        catch (Exception e) {\r\n+            throw new CompileException(\"error accessing static variable\", e);\r\n+        }\r\n+        return value;\r\n+    }\r\n+\r\n+    public Class getKnownEgressType() {\r\n+        return field.getClass();\r\n+    }\r\n+}\n\\ No newline at end of file\ndiff --git a/src/main/java/org/mvel2/util/FastList.java b/src/main/java/org/mvel2/util/FastList.java\nindex 8fb2ffa..6558a60 100644\n--- a/src/main/java/org/mvel2/util/FastList.java\n+++ b/src/main/java/org/mvel2/util/FastList.java\n@@ -248,7 +248,11 @@ public class FastList extends AbstractList implements Externalizable {\n     }\r\n \r\n     public Object[] toArray(Object[] objects) {\r\n-        throw new RuntimeException(\"not implemented\");\r\n+        if (objects.length < size) objects = new Object[size]; \r\n+        for (int i = 0; i < size; i++) {\r\n+            objects[i] = elements[i];\r\n+        }\r\n+        return objects;\r\n     }\r\n \r\n     public boolean remove(Object o) {\r\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\nindex 09c29a9..8ec945b 100644\n--- a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n@@ -3481,19 +3481,6 @@ public class CoreConfidenceTests extends AbstractTest {\n         }\n     }\n \n-    public void testQuickSortScript4() throws IOException {\n-        Object[] sorted = (Object[]) test(new String(loadFromFile(new File(\"samples/scripts/quicksort3.mvel\"))));\n-        int last = -1;\n-        for (Object o : sorted) {\n-            if (last == -1) {\n-                last = (Integer) o;\n-            }\n-            else {\n-                assertTrue(((Integer) o) > last);\n-                last = (Integer) o;\n-            }\n-        }\n-    }\n \n \n \n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T04:17:13.007825Z", "commit_hash": "34d89f12e3a960209e3c1f0eb48670284a7d39d3", "commit_message": "fixes\n", "related_issues": "", "bug_patch": "diff --git a/samples/scripts/quicksort3.mvel b/samples/scripts/quicksort3.mvel\nnew file mode 100644\nindex 0000000..45b1899\n--- /dev/null\n+++ b/samples/scripts/quicksort3.mvel\n@@ -0,0 +1,27 @@\n+/**\n+ * Sample MVEL 2.0 Script\n+ * \"Functional-style QuickSort\"\n+ * by: Dhanji R. Prasanna\n+ */\n+\n+import java.util.*;\n+\n+def quicksort(list) {\n+    if (list.isEmpty()) {\n+        return [];\n+    }\n+\n+    pivot = list[0];\n+\n+    newList = new ArrayList((($ < pivot) in list));\n+    newList.add(pivot);\n+    newList.addAll((($ < pivot) in list));\n+\n+    quicksort(newList);\n+\n+    //quicksort((($ < pivot) in list) + [pivot] + quicksort((($ < pivot) in list)));\n+}\n+\n+array = [50,20,21,209,10,77,8,9,55,73,41,99];\n+\n+quicksort(array);\n\\ No newline at end of file\ndiff --git a/src/main/java/org/mvel2/MVEL.java b/src/main/java/org/mvel2/MVEL.java\nindex 541336c..24d3b09 100644\n--- a/src/main/java/org/mvel2/MVEL.java\n+++ b/src/main/java/org/mvel2/MVEL.java\n@@ -43,7 +43,7 @@ import java.util.Map;\n  */\n public class MVEL {\n     public static final String NAME = \"MVEL (MVFLEX Expression Language)\";\n-    public static final String VERSION = \"2.0.2\";\n+    public static final String VERSION = \"2.0.6\";\n     public static final String VERSION_SUB = \"GA\";\n     public static final String CODENAME = \"enceladus\";\n \ndiff --git a/src/main/java/org/mvel2/ParserConfiguration.java b/src/main/java/org/mvel2/ParserConfiguration.java\nindex c44b7fb..d2abcb7 100644\n--- a/src/main/java/org/mvel2/ParserConfiguration.java\n+++ b/src/main/java/org/mvel2/ParserConfiguration.java\n@@ -189,4 +189,8 @@ public class ParserConfiguration implements Serializable {\n     public void setClassLoader(ClassLoader classLoader) {\n         this.classLoader = classLoader;\n     }\n+\n+    public void setImports(HashMap<String, Object> imports) {\n+        this.imports = imports;\n+    }\n }\ndiff --git a/src/main/java/org/mvel2/ParserContext.java b/src/main/java/org/mvel2/ParserContext.java\nindex 3d285da..8640680 100644\n--- a/src/main/java/org/mvel2/ParserContext.java\n+++ b/src/main/java/org/mvel2/ParserContext.java\n@@ -302,6 +302,7 @@ public class ParserContext implements Serializable {\n     }\n \n     public void addVariable(String name, Class type) {\n+     //   assert name != null;\n         initializeTables();\n         if (variables.containsKey(name)) return;\n         if (type == null) type = Object.class;\ndiff --git a/src/main/java/org/mvel2/PropertyAccessor.java b/src/main/java/org/mvel2/PropertyAccessor.java\nindex 5c235ed..f91441f 100644\n--- a/src/main/java/org/mvel2/PropertyAccessor.java\n+++ b/src/main/java/org/mvel2/PropertyAccessor.java\n@@ -35,6 +35,7 @@ import static org.mvel2.util.ParseTools.*;\n import static org.mvel2.util.PropertyTools.getFieldOrAccessor;\r\n import static org.mvel2.util.PropertyTools.getFieldOrWriteAccessor;\r\n import org.mvel2.util.StringAppender;\r\n+import org.mvel2.optimizers.impl.refl.nodes.StaticReferenceAccessor;\r\n \r\n import static java.lang.Character.isJavaIdentifierPart;\r\n import static java.lang.Thread.currentThread;\r\n@@ -186,12 +187,12 @@ public class PropertyAccessor {\n                     switch (nextToken()) {\r\n                         case NORM:\r\n                             if ((curr = getBeanPropertyAO(curr, capture())) == null && hasNullPropertyHandler()) {\r\n-                                 curr = getNullPropertyHandler().getProperty(capture(), ctx, variableFactory);\r\n+                                curr = getNullPropertyHandler().getProperty(capture(), ctx, variableFactory);\r\n                             }\r\n                             break;\r\n                         case METH:\r\n                             if ((curr = getMethod(curr, capture())) == null && hasNullMethodHandler()) {\r\n-                                curr =  getNullMethodHandler().getProperty(capture(), ctx, variableFactory);\r\n+                                curr = getNullMethodHandler().getProperty(capture(), ctx, variableFactory);\r\n                             }\r\n                             break;\r\n                         case COL:\r\n@@ -369,7 +370,7 @@ public class PropertyAccessor {\n             }\r\n             else {\r\n                 throw new PropertyAccessException(\"could not access/write property (\" + tk + \") in: \"\r\n-                        + (curr==null?\"Unknown\":curr.getClass().getName()));\r\n+                        + (curr == null ? \"Unknown\" : curr.getClass().getName()));\r\n             }\r\n         }\r\n         catch (InvocationTargetException e) {\r\n@@ -513,7 +514,7 @@ public class PropertyAccessor {\n             return getPropertyHandler(ctx.getClass()).getProperty(property, ctx, variableFactory);\r\n \r\n         GlobalListenerFactory.notifyGetListeners(ctx, property, variableFactory);\r\n-        \r\n+\r\n         return getBeanProperty(ctx, property);\r\n     }\r\n \r\n@@ -575,6 +576,13 @@ public class PropertyAccessor {\n                         return m;\r\n                     }\r\n                 }\r\n+\r\n+                try {\r\n+                    return findClass(variableFactory, c.getName() + \"$\" + property, null);\r\n+                }\r\n+                catch (ClassNotFoundException cnfe) {\r\n+                    // fall through.\r\n+                }\r\n             }\r\n             else if (hasPropertyHandler(cls)) {\r\n                 return getPropertyHandler(cls).getProperty(property, ctx, variableFactory);\r\n@@ -739,7 +747,7 @@ public class PropertyAccessor {\n                 return ((CharSequence) ctx).charAt((Integer) eval(prop, ctx, variableFactory));\r\n         }\r\n         else {\r\n-      //      TypeDescriptor td = new TypeDescriptor(property, 0);\r\n+            //      TypeDescriptor td = new TypeDescriptor(property, 0);\r\n             try {\r\n                 return getClassReference(getCurrentThreadParserContext(), new TypeDescriptor(property, 0));\r\n             }\r\ndiff --git a/src/main/java/org/mvel2/ast/DeepAssignmentNode.java b/src/main/java/org/mvel2/ast/DeepAssignmentNode.java\nindex 086b62f..05d0d2c 100644\n--- a/src/main/java/org/mvel2/ast/DeepAssignmentNode.java\n+++ b/src/main/java/org/mvel2/ast/DeepAssignmentNode.java\n@@ -64,7 +64,7 @@ public class DeepAssignmentNode extends ASTNode implements Assignment {\n         if ((fields & COMPILE_IMMEDIATE) != 0) {\r\n             //   ParserContext pCtx = getCurrentThreadParserContext();\r\n             acc = (CompiledAccExpression) compileSetExpression(property.toCharArray(), pCtx);\r\n-            pCtx.addVariable(name, egressType);\r\n+//            pCtx.addVariable(property.substring(0, property.indexOf('.')), egressType);\r\n         }\r\n     }\r\n \r\ndiff --git a/src/main/java/org/mvel2/ast/Function.java b/src/main/java/org/mvel2/ast/Function.java\nindex 6ad27eb..238890f 100644\n--- a/src/main/java/org/mvel2/ast/Function.java\n+++ b/src/main/java/org/mvel2/ast/Function.java\n@@ -51,6 +51,11 @@ public class Function extends ASTNode implements Safe {\n         pCtx.declareFunction(this);\n \n         ParserContext ctx = new ParserContext();\n+\n+        ctx.getParserConfiguration().setImports(pCtx.getParserConfiguration().getImports());\n+        ctx.getParserConfiguration().setPackageImports(pCtx.getParserConfiguration().getPackageImports());\n+\n+\n         ctx.setIndexAllocation(true);\n \n         /**\n@@ -62,6 +67,7 @@ public class Function extends ASTNode implements Safe {\n             ctx.addIndexedVariable(s);\n         }\n \n+\n         /**\n          * Compile the expression so we can determine the input-output delta.\n          */\n@@ -80,6 +86,8 @@ public class Function extends ASTNode implements Safe {\n \n         ctx.addIndexedVariables(ctx.getVariables().keySet());\n \n+        ctx.getVariables().clear();\n+\n         this.compiledBlock = (ExecutableStatement) subCompileExpression(block, ctx);\n \n         AbstractParser.setCurrentThreadParserContext(pCtx);\ndiff --git a/src/main/java/org/mvel2/compiler/CompiledAccExpression.java b/src/main/java/org/mvel2/compiler/CompiledAccExpression.java\nindex d6ca18a..661f3fc 100644\n--- a/src/main/java/org/mvel2/compiler/CompiledAccExpression.java\n+++ b/src/main/java/org/mvel2/compiler/CompiledAccExpression.java\n@@ -43,6 +43,7 @@ public class CompiledAccExpression implements ExecutableStatement, Serializable \n                     .optimizeSetAccessor(context, expression, ctx, ctx, vrf, false, value, ingressType);\n         }\n         else {\n+            System.out.println(\"Exec<<\" + accessor.toString() + \">>\");\n             accessor.setValue(ctx, elCtx, vrf, value);\n         }\n         return value;\ndiff --git a/src/main/java/org/mvel2/compiler/ExecutableLiteral.java b/src/main/java/org/mvel2/compiler/ExecutableLiteral.java\nindex 096dea6..3644ede 100644\n--- a/src/main/java/org/mvel2/compiler/ExecutableLiteral.java\n+++ b/src/main/java/org/mvel2/compiler/ExecutableLiteral.java\n@@ -30,7 +30,7 @@ public class ExecutableLiteral implements ExecutableStatement, Safe {\n     private boolean intOptimized;\r\n \r\n     public ExecutableLiteral(Object literal) {\r\n-        this.literal = literal;\r\n+        if ((this.literal = literal) instanceof Integer) this.integer32 = (Integer) literal;\r\n     }\r\n \r\n     public ExecutableLiteral(int literal) {\r\ndiff --git a/src/main/java/org/mvel2/compiler/ExpressionCompiler.java b/src/main/java/org/mvel2/compiler/ExpressionCompiler.java\nindex 10404f5..eeea65b 100644\n--- a/src/main/java/org/mvel2/compiler/ExpressionCompiler.java\n+++ b/src/main/java/org/mvel2/compiler/ExpressionCompiler.java\n@@ -314,6 +314,10 @@ public class ExpressionCompiler extends AbstractParser {\n                         pCtx.addInput(tk.getAbsoluteName(), returnType);\r\n                     }\r\n \r\n+//                    if (propVerifier.isResolvedExternally()) {\r\n+//                        pCtx.addInput(tk.getAbsoluteName(), returnType);\r\n+//                    }\r\n+\r\n                     ExecutableStatement c = (ExecutableStatement) subCompileExpression(a.getExpression());\r\n \r\n                     if (pCtx.isStrictTypeEnforcement()) {\r\ndiff --git a/src/main/java/org/mvel2/compiler/PropertyVerifier.java b/src/main/java/org/mvel2/compiler/PropertyVerifier.java\nindex 457f568..8b57d13 100644\n--- a/src/main/java/org/mvel2/compiler/PropertyVerifier.java\n+++ b/src/main/java/org/mvel2/compiler/PropertyVerifier.java\n@@ -127,7 +127,6 @@ public class PropertyVerifier extends AbstractOptimizer {\n                     paramTypes = pCtx.getTypeParameters(property);\n                     pCtx.setLastTypeParameters(pCtx.getTypeParametersAsArray(property));\n                 }\n-\n                 return pCtx.getVarOrInputType(property);\n             }\n             else if (pCtx.hasImport(property)) {\ndiff --git a/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java b/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java\nindex 79394af..1694194 100644\n--- a/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java\n+++ b/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java\n@@ -328,7 +328,13 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n                         assert debug(\"ALOAD 4\");\r\n                         mv.visitVarInsn(ALOAD, 4);\r\n \r\n-                        if (value != null & returnType != value.getClass()) {\r\n+                        if (value != null & !value.getClass().isAssignableFrom(returnType)) {\r\n+                            // if (value != null & !returnType.isAssignableFrom(value.getClass())) {\r\n+\r\n+//                            if (returnType == Integer.class) {\r\n+//                                throw new RuntimeException();\r\n+//                            }\r\n+\r\n                             dataConversion(returnType);\r\n                             checkcast(returnType);\r\n                         }\r\n@@ -566,6 +572,24 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n \r\n         buildInputs();\r\n \r\n+        if (buildLog != null && buildLog.length() != 0 && expr != null) {\r\n+//           mv = cw.visitMethod(ACC_PUBLIC, \"toString\", \"()Ljava/lang/String;\", null, null);\r\n+//            mv.visitCode();\r\n+//            mv.visitLdcInsn(buildLog.toString());\r\n+//            mv.visitInsn(ARETURN);\r\n+\r\n+            mv = cw.visitMethod(ACC_PUBLIC, \"toString\", \"()Ljava/lang/String;\", null, null);\r\n+            mv.visitCode();\r\n+            Label l0 = new Label();\r\n+            mv.visitLabel(l0);\r\n+            mv.visitLdcInsn(buildLog.toString() + \"\\n\\n## { \" + new String(expr) + \" }\" );\r\n+            mv.visitInsn(ARETURN);\r\n+            Label l1 = new Label();\r\n+            mv.visitLabel(l1);\r\n+            mv.visitMaxs(1, 1);            \r\n+            mv.visitEnd();\r\n+        }\r\n+\r\n         cw.visitEnd();\r\n \r\n         dumpAdvancedDebugging(); // dump advanced debugging if necessary\r\n@@ -594,7 +618,7 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n                 }\r\n                 o = cls.getConstructor(parms).newInstance(compiledInputs.toArray(new ExecutableStatement[compiledInputs.size()]));\r\n             }\r\n-            \r\n+\r\n             if (propNull) cls.getField(\"nullPropertyHandler\").set(o, getNullPropertyHandler());\r\n             if (methNull) cls.getField(\"nullMethodHandler\").set(o, getNullMethodHandler());\r\n \r\n@@ -1079,6 +1103,17 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n                         }\r\n                     }\r\n                 }\r\n+\r\n+\r\n+                try {\r\n+                    Class subClass = findClass(variableFactory, c.getName() + \"$\" + property, pCtx);\r\n+                    ldcClassConstant(subClass);\r\n+                    return subClass;\r\n+                }\r\n+                catch (ClassNotFoundException cnfe) {\r\n+                    // fall through.\r\n+                }\r\n+\r\n             }\r\n             else if (MVEL.COMPILER_OPT_ALLOW_NAKED_METH_CALL) {\r\n                 return getMethod(ctx, property);\r\n@@ -1136,10 +1171,18 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n \r\n     private Object getCollectionProperty(Object ctx, String prop)\r\n             throws IllegalAccessException, InvocationTargetException {\r\n-        if (prop.length() > 0) ctx = getBeanProperty(ctx, prop);\r\n+        if (prop.length() > 0) {\r\n+            ctx = getBeanProperty(ctx, prop);\r\n+            first = false;\r\n+        }\r\n \r\n         assert debug(\"\\n  **  ENTER -> {collections: \" + prop + \"; ctx=\" + ctx + \"}\");\r\n \r\n+        if (first) {\r\n+            assert debug(\"ALOAD 1\");\r\n+            mv.visitVarInsn(ALOAD, 1);\r\n+        }\r\n+\r\n         int start = ++cursor;\r\n \r\n         whiteSpaceSkip();\r\n@@ -1152,7 +1195,7 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n \r\n         String tk = new String(expr, start, cursor - start);\r\n \r\n-        assert debug(\"{collection token:<<\" + tk + \">>}\");\r\n+        assert debug(\"{collection token: [\" + tk + \"]}\");\r\n \r\n         ExecutableStatement compiled = (ExecutableStatement) subCompileExpression(tk.toCharArray());\r\n         Object item = compiled.getValue(ctx, variableFactory);\r\n@@ -2002,7 +2045,7 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n                 debug(\"INVOKESPECIAL java/lang/Boolan.<init>::(Z)V\");\r\n                 mv.visitMethodInsn(INVOKESPECIAL, \"java/lang/Boolean\", \"<init>\", \"(Z)V\");\r\n \r\n-                returnType = Boolean.class;\r\n+           //     returnType = Boolean.class;\r\n             }\r\n             else if (cls == int.class || cls == Integer.class) {\r\n                 debug(\"NEW java/lang/Integer\");\r\n@@ -2017,7 +2060,7 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n                 debug(\"INVOKESPECIAL java/lang/Integer.<init>::(I)V\");\r\n                 mv.visitMethodInsn(INVOKESPECIAL, \"java/lang/Integer\", \"<init>\", \"(I)V\");\r\n \r\n-                returnType = Integer.class;\r\n+           //     returnType = Integer.class;\r\n             }\r\n             else if (cls == float.class || cls == Float.class) {\r\n                 debug(\"NEW java/lang/Float\");\r\n@@ -2032,7 +2075,7 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n                 debug(\"INVOKESPECIAL java/lang/Float.<init>::(F)V\");\r\n                 mv.visitMethodInsn(INVOKESPECIAL, \"java/lang/Float\", \"<init>\", \"(F)V\");\r\n \r\n-                returnType = Float.class;\r\n+        //        returnType = Float.class;\r\n             }\r\n             else if (cls == double.class || cls == Double.class) {\r\n                 debug(\"NEW java/lang/Double\");\r\n@@ -2050,7 +2093,7 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n                 debug(\"INVOKESPECIAL java/lang/Double.<init>::(D)V\");\r\n                 mv.visitMethodInsn(INVOKESPECIAL, \"java/lang/Double\", \"<init>\", \"(D)V\");\r\n \r\n-                returnType = Double.class;\r\n+        //        returnType = Double.class;\r\n             }\r\n             else if (cls == short.class || cls == Short.class) {\r\n                 debug(\"NEW java/lang/Short\");\r\n@@ -2065,7 +2108,7 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n                 debug(\"INVOKESPECIAL java/lang/Short.<init>::(S)V\");\r\n                 mv.visitMethodInsn(INVOKESPECIAL, \"java/lang/Short\", \"<init>\", \"(S)V\");\r\n \r\n-                returnType = Short.class;\r\n+         //       returnType = Short.class;\r\n             }\r\n             else if (cls == long.class || cls == Long.class) {\r\n                 debug(\"NEW java/lang/Long\");\r\n@@ -2080,7 +2123,7 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n                 debug(\"INVOKESPECIAL java/lang/Long.<init>::(L)V\");\r\n                 mv.visitMethodInsn(INVOKESPECIAL, \"java/lang/Float\", \"<init>\", \"(L)V\");\r\n \r\n-                returnType = Long.class;\r\n+         //       returnType = Long.class;\r\n             }\r\n             else if (cls == byte.class || cls == Byte.class) {\r\n                 debug(\"NEW java/lang/Byte\");\r\n@@ -2095,7 +2138,7 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n                 debug(\"INVOKESPECIAL java/lang/Byte.<init>::(B)V\");\r\n                 mv.visitMethodInsn(INVOKESPECIAL, \"java/lang/Byte\", \"<init>\", \"(B)V\");\r\n \r\n-                returnType = Byte.class;\r\n+         //       returnType = Byte.class;\r\n             }\r\n             else if (cls == char.class || cls == Character.class) {\r\n                 debug(\"NEW java/lang/Character\");\r\n@@ -2110,49 +2153,49 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n                 debug(\"INVOKESPECIAL java/lang/Character.<init>::(C)V\");\r\n                 mv.visitMethodInsn(INVOKESPECIAL, \"java/lang/Character\", \"<init>\", \"(C)V\");\r\n \r\n-                returnType = Character.class;\r\n+         //       returnType = Character.class;\r\n             }\r\n         }\r\n         else {\r\n             if (cls == boolean.class || cls == Boolean.class) {\r\n                 debug(\"INVOKESTATIC java/lang/Boolean.valueOf\");\r\n                 mv.visitMethodInsn(INVOKESTATIC, \"java/lang/Boolean\", \"valueOf\", \"(Z)Ljava/lang/Boolean;\");\r\n-                returnType = Boolean.class;\r\n+         //       returnType = Boolean.class;\r\n             }\r\n             else if (cls == int.class || cls == Integer.class) {\r\n                 debug(\"INVOKESTATIC java/lang/Integer.valueOf\");\r\n                 mv.visitMethodInsn(INVOKESTATIC, \"java/lang/Integer\", \"valueOf\", \"(I)Ljava/lang/Integer;\");\r\n-                returnType = Integer.class;\r\n+         //       returnType = Integer.class;\r\n             }\r\n             else if (cls == float.class || cls == Float.class) {\r\n                 debug(\"INVOKESTATIC java/lang/Float.valueOf\");\r\n                 mv.visitMethodInsn(INVOKESTATIC, \"java/lang/Float\", \"valueOf\", \"(F)Ljava/lang/Float;\");\r\n-                returnType = Float.class;\r\n+          //      returnType = Float.class;\r\n             }\r\n             else if (cls == double.class || cls == Double.class) {\r\n                 debug(\"INVOKESTATIC java/lang/Double.valueOf\");\r\n                 mv.visitMethodInsn(INVOKESTATIC, \"java/lang/Double\", \"valueOf\", \"(D)Ljava/lang/Double;\");\r\n-                returnType = Double.class;\r\n+           //     returnType = Double.class;\r\n             }\r\n             else if (cls == short.class || cls == Short.class) {\r\n                 debug(\"INVOKESTATIC java/lang/Short.valueOf\");\r\n                 mv.visitMethodInsn(INVOKESTATIC, \"java/lang/Short\", \"valueOf\", \"(S)Ljava/lang/Short;\");\r\n-                returnType = Short.class;\r\n+           //     returnType = Short.class;\r\n             }\r\n             else if (cls == long.class || cls == Long.class) {\r\n                 debug(\"INVOKESTATIC java/lang/Long.valueOf\");\r\n                 mv.visitMethodInsn(INVOKESTATIC, \"java/lang/Long\", \"valueOf\", \"(J)Ljava/lang/Long;\");\r\n-                returnType = Long.class;\r\n+           //     returnType = Long.class;\r\n             }\r\n             else if (cls == byte.class || cls == Byte.class) {\r\n                 debug(\"INVOKESTATIC java/lang/Byte.valueOf\");\r\n                 mv.visitMethodInsn(INVOKESTATIC, \"java/lang/Byte\", \"valueOf\", \"(B)Ljava/lang/Byte;\");\r\n-                returnType = Byte.class;\r\n+           //     returnType = Byte.class;\r\n             }\r\n             else if (cls == char.class || cls == Character.class) {\r\n                 debug(\"INVOKESTATIC java/lang/Character.valueOf\");\r\n                 mv.visitMethodInsn(INVOKESTATIC, \"java/lang/Character\", \"valueOf\", \"(C)Ljava/lang/Character;\");\r\n-                returnType = Character.class;\r\n+           //     returnType = Character.class;\r\n             }\r\n         }\r\n     }\r\n@@ -2313,7 +2356,7 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n         assert debug(\"ALOAD 3\");\r\n         mv.visitVarInsn(ALOAD, 3);\r\n \r\n-        assert debug(\"LDC :\" + name);\r\n+        assert debug(\"LDC \\\"\" + name + \"\\\"\");\r\n         mv.visitLdcInsn(name);\r\n \r\n         assert debug(\"INVOKEINTERFACE \" + NAMESPACE + \"integration/VariableResolverFactory.getVariableResolver\");\r\ndiff --git a/src/main/java/org/mvel2/optimizers/impl/refl/ReflectiveAccessorOptimizer.java b/src/main/java/org/mvel2/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\nindex 4af8fc6..78165a4 100644\n--- a/src/main/java/org/mvel2/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\n+++ b/src/main/java/org/mvel2/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\n@@ -556,6 +556,17 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n                         }\r\n                     }\r\n                 }\r\n+\r\n+                try {\r\n+                    Class subClass = findClass(variableFactory, c.getName() + \"$\" + property, pCtx);\r\n+                    addAccessorNode(new StaticReferenceAccessor(subClass));\r\n+                    return subClass;\r\n+                }\r\n+                catch (ClassNotFoundException cnfe) {\r\n+                    // fall through.\r\n+                }\r\n+\r\n+\r\n             }\r\n             else if (MVEL.COMPILER_OPT_ALLOW_NAKED_METH_CALL) {\r\n                 return getMethod(ctx, property);\r\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/AccessorBMModel.java b/src/test/java/org/mvel2/tests/AccessorBMModel.java\nindex fe7f192..bf10d13 100644\n--- a/src/test/java/org/mvel2/tests/AccessorBMModel.java\n+++ b/src/test/java/org/mvel2/tests/AccessorBMModel.java\n@@ -42,4 +42,8 @@ public class AccessorBMModel implements Accessor {\n     public void setNullMethodHandler(PropertyHandler handler) {\r\n     \tthis.nullMethodHandler = handler;\r\n     }\r\n+    \r\n+    public String toString() {\r\n+    \treturn \"FOFOSLDJALKJ\";\r\n+    }\r\n }\r\ndiff --git a/src/test/java/org/mvel2/tests/core/AbstractTest.java b/src/test/java/org/mvel2/tests/core/AbstractTest.java\nindex 9696008..3e454f6 100644\n--- a/src/test/java/org/mvel2/tests/core/AbstractTest.java\n+++ b/src/test/java/org/mvel2/tests/core/AbstractTest.java\n@@ -257,7 +257,7 @@ public abstract class AbstractTest extends TestCase {\n \n         if (!Boolean.getBoolean(\"mvel2.disable.jit\")) {\n \n-            setDefaultOptimizer(\"dynamic\");\n+            setDefaultOptimizer(\"ASM\");\n \n             try {\n                 first = executeExpression(compiled, new Base(), createTestMap());\ndiff --git a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\nindex c3797b2..09c29a9 100644\n--- a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n@@ -3481,6 +3481,22 @@ public class CoreConfidenceTests extends AbstractTest {\n         }\n     }\n \n+    public void testQuickSortScript4() throws IOException {\n+        Object[] sorted = (Object[]) test(new String(loadFromFile(new File(\"samples/scripts/quicksort3.mvel\"))));\n+        int last = -1;\n+        for (Object o : sorted) {\n+            if (last == -1) {\n+                last = (Integer) o;\n+            }\n+            else {\n+                assertTrue(((Integer) o) > last);\n+                last = (Integer) o;\n+            }\n+        }\n+    }\n+\n+\n+\n     public void testMultiLineString() throws IOException {\n         MVEL.evalFile(new File(\"samples/scripts/multilinestring.mvel\"));\n     }\n@@ -4031,6 +4047,8 @@ public class CoreConfidenceTests extends AbstractTest {\n     public void testAnalysisCompile() {\n         CompiledExpression ce = new ExpressionCompiler(\"foo.aValue = 'bar'\").compile();\n         assertTrue(ce.getParserContext().getInputs().keySet().contains(\"foo\"));\n+        assertEquals(1, ce.getParserContext().getInputs().size());\n+        assertEquals(0, ce.getParserContext().getVariables().size());\n     }\n \n     public void testInlineWith() {\n@@ -4906,17 +4924,29 @@ public class CoreConfidenceTests extends AbstractTest {\n //    }      '\n \n \n-    public void testRecursionPerformance() {\n-        HashMap variables = new HashMap();\n-        MVEL.eval(\"def recurse(ary) { ary <= 0 ? 0 : recurse(ary - 1); }\", variables);\n+//    public void testRecursionPerformance() {\n+//        HashMap variables = new HashMap();\n+//        MVEL.eval(\"def recurse(ary) { ary <= 0 ? 0 : recurse(ary - 1); }\", variables);\n+//\n+//        for (int i = 0; i < 5; i++) {\n+//            long start = System.currentTimeMillis();\n+//            MVEL.eval(\"recurse(1000);\", variables);\n+//            System.out.println(System.currentTimeMillis() - start);\n+//        }\n+//    }\n+\n+\n+    public class Fruit {\n+        public class Apple {\n \n-        for (int i = 0; i < 5; i++) {\n-            long start = System.currentTimeMillis();\n-            MVEL.eval(\"recurse(1000);\", variables);\n-            System.out.println(System.currentTimeMillis() - start);\n         }\n     }\n \n+    public void testInnerClassReference() {\n+        assertEquals(Fruit.Apple.class, test(\"import \" + CoreConfidenceTests.class.getName() + \"; CoreConfidenceTests.Fruit.Apple\"));\n+    }\n+\n+\n }\n \n \n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T04:23:29.906037Z", "commit_hash": "657fac570f65a77907519b020f005cb371d25762", "commit_message": "recursion fix\n", "related_issues": "", "bug_patch": "diff --git a/lib/ejb3-persistence-1.0.2.GA.jar b/lib/ejb3-persistence-1.0.2.GA.jar\ndeleted file mode 100644\nindex 32c2266..0000000\nBinary files a/lib/ejb3-persistence-1.0.2.GA.jar and /dev/null differ\ndiff --git a/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java b/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java\nindex 28f7383..79394af 100644\n--- a/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java\n+++ b/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java\n@@ -1557,16 +1557,16 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n                         \"call\",\r\n                         \"(Ljava/lang/Object;Ljava/lang/Object;L\" + NAMESPACE + \"integration/VariableResolverFactory;[Ljava/lang/Object;)Ljava/lang/Object;\");\r\n \r\n-                Object[] parm = null;\r\n-\r\n-                if (es != null) {\r\n-                    parm = new Object[es.length];\r\n-                    for (int i = 0; i < es.length; i++) {\r\n-                        parm[i] = es[i].getValue(ctx, thisRef, variableFactory);\r\n-                    }\r\n-                }\r\n-\r\n-                return ((Function) ptr).call(ctx, thisRef, variableFactory, parm);\r\n+//                Object[] parm = null;\r\n+//\r\n+//                if (es != null) {\r\n+//                    parm = new Object[es.length];\r\n+//                    for (int i = 0; i < es.length; i++) {\r\n+//                        parm[i] = es[i].getValue(ctx, thisRef, variableFactory);\r\n+//                    }\r\n+//                }\r\n+\r\n+                return ((Function) ptr).call(ctx, thisRef, variableFactory, args);\r\n             }\r\n             else {\r\n                 throw new OptimizationFailure(\"attempt to optimize a method call for a reference that does not point to a method: \"\r\ndiff --git a/src/main/java/org/mvel2/optimizers/impl/refl/ReflectiveAccessorOptimizer.java b/src/main/java/org/mvel2/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\nindex 6d8dfdf..a6844f9 100644\n--- a/src/main/java/org/mvel2/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\n+++ b/src/main/java/org/mvel2/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\n@@ -817,15 +817,7 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n             }\r\n             else if (ptr instanceof Function) {\r\n                 addAccessorNode(new FunctionAccessor((Function) ptr, es));\r\n-\r\n-                Object[] parm = null;\r\n-                if (es != null) {\r\n-                    parm = new Object[es.length];\r\n-                    for (int i = 0; i < es.length; i++) {\r\n-                        parm[i] = es[i].getValue(ctx, thisRef, variableFactory);\r\n-                    }\r\n-                }\r\n-                return ((Function) ptr).call(ctx, thisRef, variableFactory, parm);\r\n+                return ((Function) ptr).call(ctx, thisRef, variableFactory, args);\r\n             }\r\n             else {\r\n                 throw new OptimizationFailure(\"attempt to optimize a method call for a reference that does not point to a method: \"\r\ndiff --git a/src/main/java/org/mvel2/optimizers/impl/refl/nodes/FunctionAccessor.java b/src/main/java/org/mvel2/optimizers/impl/refl/nodes/FunctionAccessor.java\nindex eb3b30c..9b9b896 100644\n--- a/src/main/java/org/mvel2/optimizers/impl/refl/nodes/FunctionAccessor.java\n+++ b/src/main/java/org/mvel2/optimizers/impl/refl/nodes/FunctionAccessor.java\n@@ -37,7 +37,7 @@ public class FunctionAccessor extends BaseAccessor {\n \n         if (parameters != null && parameters.length != 0) {\n             parms = new Object[parameters.length];\n-            for (int i = parms.length - 1; i != -1; i--) {\n+            for (int i = 0; i < parms.length; i++) {\n                 parms[i] = parameters[i].getValue(ctx, elCtx, variableFactory);\n             }\n         }\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\nindex b225e3a..6e21a88 100644\n--- a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n@@ -2556,12 +2556,12 @@ public class CoreConfidenceTests extends AbstractTest {\n         innerMap = new HashMap<Object, Object>();\n         outerMap.put(\"innerMap\", innerMap);\n \n-        // fails because mvel2 checks for 'foo' in the outerMap,\n+        // fails because mvel2 checks for 'tak' in the outerMap,\n         // rather than inside innerMap in outerMap\n         PropertyAccessor.set(outerMap, \"innerMap['foo']\", 42);\n \n         // mvel2 set it here\n-//        assertEquals(42, outerMap.get(\"foo\"));\n+//        assertEquals(42, outerMap.get(\"tak\"));\n \n         // instead of here\n         assertEquals(42, innerMap.get(\"foo\"));\n@@ -2572,7 +2572,7 @@ public class CoreConfidenceTests extends AbstractTest {\n         innerMap = new HashMap<Object, Object>();\n         outerMap.put(\"innerMap\", innerMap);\n \n-        // fails because mvel2 checks for 'foo' in the outerMap,\n+        // fails because mvel2 checks for 'tak' in the outerMap,\n         // rather than inside innerMap in outerMap\n         innerMap.put(\"foo\", 21);\n         PropertyAccessor.set(outerMap, \"innerMap['foo']\", 42);\n@@ -4883,6 +4883,31 @@ public class CoreConfidenceTests extends AbstractTest {\n         executeSetExpression(fooExpr, foo, col);\n         assertEquals(col, foo.getCollectionTest());\n     }\n+\n+    public void testRecursion() {\n+        MVEL.eval(\"def foo(x, y) { x > y ? x : foo (foo(x+1, y-1), foo(x+1, y-1)) }; foo(1, 20)\", new HashMap());\n+    }\n+\n+    public void testRec1() {\n+        tak(24, 16, 8);\n+    }\n+\n+    public int tak(int x, int y, int z) {\n+        System.out.println(\"x=\" + x + \"; y=\" + y + \"; z=\" + z);\n+        return y >= x ? z : tak(tak(x-1, y, z), tak(y-1, z, x), tak(z-1, x, y));\n+    }\n+\n+    public void testDhanjiBreak() {\n+        MVEL.eval(\n+                \" def tak(x, y, z) { System.out.println('x=' + x + '; y=' + y + '; z=' + z); \" +\n+                        \"y >= x ? z : tak(tak(x-1, y, z), tak(y-1, z, x), tak(z-1, x, y))\\n  \" +\n+                        \" }\\n\\n\" +\n+\n+                        \"i = 1;\\n\" +\n+                        \"while(i-- > 0) {\\n\" +\n+                        \"  tak(24, 16, 8);\\n\" +\n+                        \"}\", new HashMap());\n+    }\n }\n \n \ndiff --git a/src/test/java/org/mvel2/tests/perftests/CompiledPerformanceTests.java b/src/test/java/org/mvel2/tests/perftests/CompiledPerformanceTests.java\nindex 9e63647..5fd1e2b 100644\n--- a/src/test/java/org/mvel2/tests/perftests/CompiledPerformanceTests.java\n+++ b/src/test/java/org/mvel2/tests/perftests/CompiledPerformanceTests.java\n@@ -45,7 +45,7 @@ public class CompiledPerformanceTests {\n         }\r\n \r\n //        for (int x = 0; x < 4; x++) {\r\n-//            Serializable s = MVEL.compileSetExpression(\"foo.bar.name\");\r\n+//            Serializable s = MVEL.compileSetExpression(\"tak.bar.name\");\r\n //            long time = System.currentTimeMillis();\r\n //\r\n //            for (int i = 0; i < ITERATIONS; i++) {\r\n@@ -56,7 +56,7 @@ public class CompiledPerformanceTests {\n //\r\n //            time = System.currentTimeMillis();\r\n //\r\n-//            s = MVEL.compileExpression(\"foo.bar.name\");\r\n+//            s = MVEL.compileExpression(\"tak.bar.name\");\r\n //\r\n //            for (int i = 0; i < ITERATIONS; i++) {\r\n //                MVEL.executeExpression(s, map);\r\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T04:43:38.430656Z", "commit_hash": "e7bf951e261533c71c791d1af36a036ae790663f", "commit_message": "fix to compiler\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/PropertyAccessor.java b/src/main/java/org/mvel2/PropertyAccessor.java\nindex d36e369..a4dcf86 100644\n--- a/src/main/java/org/mvel2/PropertyAccessor.java\n+++ b/src/main/java/org/mvel2/PropertyAccessor.java\n@@ -581,7 +581,6 @@ public class PropertyAccessor {\n             }\r\n         }\r\n \r\n-\r\n         Object tryStatic = tryStaticAccess();\r\n \r\n         if (tryStatic != null) {\r\n@@ -740,9 +739,9 @@ public class PropertyAccessor {\n                 return ((CharSequence) ctx).charAt((Integer) eval(prop, ctx, variableFactory));\r\n         }\r\n         else {\r\n-            TypeDescriptor td = new TypeDescriptor(property, 0);\r\n+      //      TypeDescriptor td = new TypeDescriptor(property, 0);\r\n             try {\r\n-                return getClassReference(getCurrentThreadParserContext(), td);\r\n+                return getClassReference(getCurrentThreadParserContext(), new TypeDescriptor(property, 0));\r\n             }\r\n             catch (Exception e) {\r\n                 throw new PropertyAccessException(\"illegal use of []: unknown type: \" + (ctx == null ? null : ctx.getClass().getName()));\r\n@@ -873,8 +872,7 @@ public class PropertyAccessor {\n             }\r\n             catch (IllegalAccessException e) {\r\n                 try {\r\n-                    m = getWidenedTarget(m);\r\n-                    addMethodCache(cls, createSignature(name, tk), m);\r\n+                    addMethodCache(cls, createSignature(name, tk), (m = getWidenedTarget(m)));\r\n \r\n                     return m.invoke(ctx, args);\r\n                 }\r\ndiff --git a/src/main/java/org/mvel2/integration/PropertyHandlerFactory.java b/src/main/java/org/mvel2/integration/PropertyHandlerFactory.java\nindex dff9a1d..b609974 100644\n--- a/src/main/java/org/mvel2/integration/PropertyHandlerFactory.java\n+++ b/src/main/java/org/mvel2/integration/PropertyHandlerFactory.java\n@@ -33,7 +33,21 @@ public class PropertyHandlerFactory {\n     }\n \n     public static boolean hasPropertyHandler(Class clazz) {\n-        return propertyHandlerClass.containsKey(clazz);\n+        if (!propertyHandlerClass.containsKey(clazz)) {\n+            do {\n+                for (Class c : clazz.getInterfaces()) {\n+                    if (propertyHandlerClass.containsKey(c)) {\n+                        propertyHandlerClass.put(clazz, propertyHandlerClass.get(c));\n+                        return true;\n+                    }\n+                }\n+            }\n+            while ((clazz = clazz.getSuperclass()) != null && clazz != Object.class);\n+            return false;\n+        }\n+        else {\n+            return true;\n+        }\n     }\n \n     public static void registerPropertyHandler(Class clazz, PropertyHandler propertyHandler) {\ndiff --git a/src/main/java/org/mvel2/optimizers/impl/refl/ReflectiveAccessorOptimizer.java b/src/main/java/org/mvel2/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\nindex 8fd6b0f..6d8dfdf 100644\n--- a/src/main/java/org/mvel2/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\n+++ b/src/main/java/org/mvel2/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\n@@ -349,7 +349,7 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n                             break;\r\n                         case DONE:\r\n                             break;\r\n-                    }\r\n+                    }           \r\n \r\n                     first = false;\r\n                     if (curr != null) returnType = curr.getClass();\r\n@@ -663,7 +663,9 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n \r\n \r\n     private Object getCollectionPropertyAO(Object ctx, String prop) throws Exception {\r\n-        if (prop.length() > 0) ctx = getBeanProperty(ctx, prop);\r\n+        if (prop.length() > 0) {\r\n+            ctx = getBeanPropertyAO(ctx, prop);\r\n+        }\r\n \r\n         int start = ++cursor;\r\n \r\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/PropertyHandlerTests.java b/src/test/java/org/mvel2/tests/core/PropertyHandlerTests.java\nindex 453fbe8..ce9d379 100644\n--- a/src/test/java/org/mvel2/tests/core/PropertyHandlerTests.java\n+++ b/src/test/java/org/mvel2/tests/core/PropertyHandlerTests.java\n@@ -14,6 +14,7 @@ import junit.framework.TestCase;\n import java.util.List;\n import java.util.Map;\n import java.util.HashMap;\n+import java.util.ArrayList;\n import java.lang.reflect.Array;\n import java.io.Serializable;\n \n@@ -281,4 +282,65 @@ public class PropertyHandlerTests extends TestCase {\n         MVEL.getProperty(\"someList\", new MyBean());\n         assertEquals(2, listener.counter);\n     }\n+\n+\n+    public void testListener() {\n+        MVEL.COMPILER_OPT_ALLOW_OVERRIDE_ALL_PROPHANDLING = true;\n+        class MyListener implements Listener {\n+            public int count;\n+\n+            public void onEvent(Object context, String contextName,\n+                                VariableResolverFactory variableFactory, Object value) {\n+                count++;\n+            }\n+        }\n+\n+        MyListener listener = new MyListener();\n+        GlobalListenerFactory.registerGetListener(listener);\n+\n+        PropertyHandlerFactory.setNullPropertyHandler(new PropertyHandler() {\n+            public Object getProperty(String name, Object contextObj,\n+                                      VariableResolverFactory variableFactory) {\n+                List someList = new ArrayList();\n+                someList.add(new Foo());\n+                return someList;\n+            }\n+\n+            public Object setProperty(String name, Object contextObj,\n+                                      VariableResolverFactory variableFactory, Object value) {\n+                return null;\n+            }\n+        });\n+\n+        PropertyHandlerFactory.registerPropertyHandler(List.class, new\n+                PropertyHandler() {\n+                    public Object getProperty(String name, Object contextObj,\n+                                              VariableResolverFactory variableFactory) {\n+                        List list = (List) contextObj;\n+                        int index = Integer.valueOf(name);\n+                        while (index >= list.size()) {\n+                            list.add(new Foo());\n+                        }\n+\n+                        return list.get(index);\n+                    }\n+\n+                    public Object setProperty(String name, Object contextObj,\n+                                              VariableResolverFactory variableFactory, Object value) {\n+                        return null;\n+                    }\n+                });\n+\n+        Foo foo = new Foo();\n+\n+        final Serializable fooExpr0 =\n+                MVEL.compileSetExpression(\"collectionTest[0].name\");\n+        final Serializable fooExpr1 =\n+                MVEL.compileSetExpression(\"collectionTest[1].name\");\n+        MVEL.executeSetExpression(fooExpr0, foo, \"John Galt\");\n+        MVEL.executeSetExpression(fooExpr1, foo, \"The Joker\");\n+        assertEquals(2, listener.count);\n+        MVEL.COMPILER_OPT_ALLOW_OVERRIDE_ALL_PROPHANDLING = false;\n+    }\n+\n }\n\\ No newline at end of file\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T04:49:57.912717Z", "commit_hash": "92a8041c25c749eadf4f610c79cab6c473a90f14", "commit_message": "fixes to null handler handling\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/optimizers/impl/refl/nodes/GetterAccessorNH.java b/src/main/java/org/mvel2/optimizers/impl/refl/nodes/GetterAccessorNH.java\nindex b3f3167..4ffb077 100644\n--- a/src/main/java/org/mvel2/optimizers/impl/refl/nodes/GetterAccessorNH.java\n+++ b/src/main/java/org/mvel2/optimizers/impl/refl/nodes/GetterAccessorNH.java\n@@ -122,7 +122,12 @@ public class GetterAccessorNH implements AccessorNode {\n \n     private Object nullHandle(String name, Object v, Object ctx, Object elCtx, VariableResolverFactory vars) {\n         if (v != null) {\n-            return nextNode.getValue(v, elCtx, vars);\n+            if (nextNode != null) {\n+                return nextNode.getValue(v, elCtx, vars);\n+            }\n+            else {\n+                return v;\n+            }\n         }\n         else {\n             if (nextNode != null) {\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/PropertyHandlerTests.java b/src/test/java/org/mvel2/tests/core/PropertyHandlerTests.java\nindex c944962..52dc482 100644\n--- a/src/test/java/org/mvel2/tests/core/PropertyHandlerTests.java\n+++ b/src/test/java/org/mvel2/tests/core/PropertyHandlerTests.java\n@@ -2,6 +2,7 @@ package org.mvel2.tests.core;\n \n import org.mvel2.tests.core.res.Base;\n import org.mvel2.tests.core.res.Foo;\n+import org.mvel2.tests.core.res.Bar;\n import org.mvel2.integration.*;\n import org.mvel2.PropertyAccessor;\n import org.mvel2.MVEL;\n@@ -144,6 +145,7 @@ public class PropertyHandlerTests extends TestCase {\n         });\n \n         Foo foo = new Foo();\n+        Bar bar = foo.getBar();\n         foo.setBar(null);\n \n         Map map = new HashMap();\n@@ -153,6 +155,8 @@ public class PropertyHandlerTests extends TestCase {\n         \n         assertEquals(\"NULL\", MVEL.executeExpression(s, map));\n         assertEquals(\"NULL\", MVEL.executeExpression(s, map));\n+        foo.setBar(bar);\n+        assertEquals(bar, MVEL.executeExpression(s, map));\n     }\n \n     public void testNullPropertyHandler2() {\n@@ -170,7 +174,8 @@ public class PropertyHandlerTests extends TestCase {\n             }\n         });\n \n-        Foo foo = new Foo();\n+         Foo foo = new Foo();\n+        Bar bar = foo.getBar();\n         foo.setBar(null);\n \n         Map map = new HashMap();\n@@ -180,6 +185,8 @@ public class PropertyHandlerTests extends TestCase {\n \n         assertEquals(\"NULL\", MVEL.executeExpression(s, map));\n         assertEquals(\"NULL\", MVEL.executeExpression(s, map));\n+        foo.setBar(bar);\n+        assertEquals(bar, MVEL.executeExpression(s, map));\n     }\n \n \n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T05:03:10.398284Z", "commit_hash": "2154d1f6e19728768f7a26c69cba2b4734c435df", "commit_message": "check in fixes\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java b/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java\nindex ffd3286..28f7383 100644\n--- a/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java\n+++ b/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java\n@@ -557,7 +557,7 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n         mv.visitEnd();\r\n \r\n         if (propNull) {\r\n-            cw.visitField(ACC_PUBLIC, \"nullPropertyHandler\", \"L\" + NAMESPACE + \"/integration/PropertyHandler;\", null, null).visitEnd();\r\n+            cw.visitField(ACC_PUBLIC, \"nullPropertyHandler\", \"L\" + NAMESPACE + \"integration/PropertyHandler;\", null, null).visitEnd();\r\n         }\r\n \r\n         if (methNull) {\r\n@@ -593,10 +593,11 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n                     parms[i] = ExecutableStatement.class;\r\n                 }\r\n                 o = cls.getConstructor(parms).newInstance(compiledInputs.toArray(new ExecutableStatement[compiledInputs.size()]));\r\n-\r\n-                if (propNull) cls.getField(\"nullPropertyHandler\").set(o, getNullPropertyHandler());\r\n-                if (methNull) cls.getField(\"nullMethodHandler\").set(o, getNullMethodHandler());\r\n             }\r\n+            \r\n+            if (propNull) cls.getField(\"nullPropertyHandler\").set(o, getNullPropertyHandler());\r\n+            if (methNull) cls.getField(\"nullMethodHandler\").set(o, getNullMethodHandler());\r\n+\r\n         }\r\n         catch (VerifyError e) {\r\n             System.out.println(\"**** COMPILER BUG! REPORT THIS IMMEDIATELY AT http://jira.codehaus.org/browse/mvel2\");\r\n@@ -898,6 +899,16 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n                     assert debug(\"LDC \" + valueOf(o));\r\n                     mv.visitLdcInsn(o);\r\n                     wrapPrimitive(o.getClass());\r\n+\r\n+\r\n+                    if (hasNullPropertyHandler()) {\r\n+                        if (o == null) {\r\n+                            o = getNullPropertyHandler().getProperty(member.getName(), ctx, variableFactory);\r\n+                        }\r\n+\r\n+                        writeOutNullHandler(member, 0);\r\n+                    }\r\n+\r\n                     return o;\r\n                 }\r\n                 else {\r\n@@ -969,7 +980,7 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n \r\n             if (hasNullPropertyHandler()) {\r\n                 if (o == null) o = getNullPropertyHandler().getProperty(member.getName(), ctx, variableFactory);\r\n-                writeOutNullHandler(member, 0);         \r\n+                writeOutNullHandler(member, 0);\r\n             }\r\n \r\n             return o;\r\n@@ -2847,7 +2858,7 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n     private Object propHandlerByteCode(String property, Object ctx, Class handler) {\r\n         PropertyHandler ph = getPropertyHandler(handler);\r\n         if (ph instanceof ProducesBytecode) {\r\n-            assert debug(\"<<3rd-Party Code Generation>>\");            \r\n+            assert debug(\"<<3rd-Party Code Generation>>\");\r\n             ((ProducesBytecode) ph).produceBytecodeGet(mv, property, variableFactory);\r\n             return ph.getProperty(property, ctx, variableFactory);\r\n         }\r\n@@ -2871,7 +2882,6 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n     }\r\n \r\n     private void writeOutNullHandler(Member member, int type) {\r\n-        this.propNull = true;\r\n \r\n         assert debug(\"DUP\");\r\n         mv.visitInsn(DUP);\r\n@@ -2888,10 +2898,14 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n         mv.visitVarInsn(ALOAD, 0);\r\n \r\n         if (type == 0) {\r\n+            this.propNull = true;\r\n+\r\n             assert debug(\"GETFIELD 'nullPropertyHandler'\");\r\n             mv.visitFieldInsn(GETFIELD, className, \"nullPropertyHandler\", \"L\" + NAMESPACE + \"integration/PropertyHandler;\");\r\n         }\r\n         else {\r\n+            this.methNull = true;\r\n+\r\n             assert debug(\"GETFIELD 'nullMethodHandler'\");\r\n             mv.visitFieldInsn(GETFIELD, className, \"nullMethodHandler\", \"L\" + NAMESPACE + \"integration/PropertyHandler;\");\r\n         }\r\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/PropertyHandlerTests.java b/src/test/java/org/mvel2/tests/core/PropertyHandlerTests.java\nindex f09a54b..db151b0 100644\n--- a/src/test/java/org/mvel2/tests/core/PropertyHandlerTests.java\n+++ b/src/test/java/org/mvel2/tests/core/PropertyHandlerTests.java\n@@ -131,6 +131,8 @@ public class PropertyHandlerTests extends TestCase {\n     public void testNullPropertyHandler() {\n         MVEL.COMPILER_OPT_ALLOW_OVERRIDE_ALL_PROPHANDLING = true;\n \n+        OptimizerFactory.setDefaultOptimizer(\"ASM\");\n+\n         PropertyHandlerFactory.setNullPropertyHandler(new PropertyHandler() {\n             public Object getProperty(String name, Object contextObj, VariableResolverFactory variableFactory) {\n                 return \"NULL\";\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T05:09:24.488705Z", "commit_hash": "091dd3ca3c2f67c1adfb600eac057e8d6d08ab61", "commit_message": "small fix\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/optimizers/impl/refl/ReflectiveAccessorOptimizer.java b/src/main/java/org/mvel2/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\nindex 917d349..3a89314 100644\n--- a/src/main/java/org/mvel2/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\n+++ b/src/main/java/org/mvel2/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\n@@ -468,8 +468,8 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n                 o = ((Method) member).invoke(ctx, EMPTYARG);\r\n \r\n                 if (hasNullPropertyHandler()) {\r\n-                    addAccessorNode(new GetterAccessorNH((Method) member, getNullMethodHandler()));\r\n-                    if (o == null) o = getNullMethodHandler().getProperty(member.getName(), ctx, variableFactory);\r\n+                    addAccessorNode(new GetterAccessorNH((Method) member, getNullPropertyHandler()));\r\n+                    if (o == null) o = getNullPropertyHandler().getProperty(member.getName(), ctx, variableFactory);\r\n                 }\r\n                 else {\r\n                     addAccessorNode(new GetterAccessor((Method) member));\r\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/PropertyHandlerTests.java b/src/test/java/org/mvel2/tests/core/PropertyHandlerTests.java\nindex 2336511..f09a54b 100644\n--- a/src/test/java/org/mvel2/tests/core/PropertyHandlerTests.java\n+++ b/src/test/java/org/mvel2/tests/core/PropertyHandlerTests.java\n@@ -1,6 +1,7 @@\n package org.mvel2.tests.core;\n \n import org.mvel2.tests.core.res.Base;\n+import org.mvel2.tests.core.res.Foo;\n import org.mvel2.integration.*;\n import org.mvel2.PropertyAccessor;\n import org.mvel2.MVEL;\n@@ -11,6 +12,7 @@ import junit.framework.TestCase;\n \n import java.util.List;\n import java.util.Map;\n+import java.util.HashMap;\n import java.lang.reflect.Array;\n import java.io.Serializable;\n \n@@ -126,6 +128,30 @@ public class PropertyHandlerTests extends TestCase {\n         assertEquals(\"list\", res[0]);\n     }\n \n+    public void testNullPropertyHandler() {\n+        MVEL.COMPILER_OPT_ALLOW_OVERRIDE_ALL_PROPHANDLING = true;\n+\n+        PropertyHandlerFactory.setNullPropertyHandler(new PropertyHandler() {\n+            public Object getProperty(String name, Object contextObj, VariableResolverFactory variableFactory) {\n+                return \"NULL\";\n+            }\n+\n+            public Object setProperty(String name, Object contextObj, VariableResolverFactory variableFactory, Object value) {\n+                return \"NULL\";\n+            }\n+        });\n+\n+        Foo foo = new Foo();\n+        foo.setBar(null);\n+\n+        Map map = new HashMap();\n+        map.put(\"foo\", foo);\n+\n+        Serializable s = MVEL.compileExpression(\"foo.bar\");\n+        \n+        assertEquals(\"NULL\", MVEL.executeExpression(s, map));\n+        assertEquals(\"NULL\", MVEL.executeExpression(s, map));\n+    }\n \n \n     public void testMapPropertyHandler() {\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T05:48:50.100617Z", "commit_hash": "038ca40a9a53791207d893f7d58c5cfac2a9ed4d", "commit_message": "parser fixes: MVEL-124\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/compiler/AbstractParser.java b/src/main/java/org/mvel2/compiler/AbstractParser.java\nindex 061e06c..cb0439f 100644\n--- a/src/main/java/org/mvel2/compiler/AbstractParser.java\n+++ b/src/main/java/org/mvel2/compiler/AbstractParser.java\n@@ -61,7 +61,7 @@ public class AbstractParser implements Serializable {\n     protected boolean lastWasIdentifier = false;\r\n     protected boolean lastWasLineLabel = false;\r\n     protected boolean lastWasComment = false;\r\n-    protected boolean literalOnly = true;\r\n+    protected int literalOnly = -1;\r\n \r\n     protected boolean debugSymbols = false;\r\n \r\ndiff --git a/src/main/java/org/mvel2/compiler/ExpressionCompiler.java b/src/main/java/org/mvel2/compiler/ExpressionCompiler.java\nindex eeec177..47812cb 100644\n--- a/src/main/java/org/mvel2/compiler/ExpressionCompiler.java\n+++ b/src/main/java/org/mvel2/compiler/ExpressionCompiler.java\n@@ -25,6 +25,7 @@ import org.mvel2.ErrorDetail;\n import org.mvel2.Operator;\r\n import static org.mvel2.Operator.PTABLE;\r\n import org.mvel2.ParserContext;\r\n+import org.mvel2.debug.DebugTools;\r\n import org.mvel2.ast.ASTNode;\r\n import static org.mvel2.ast.ASTNode.COMPILE_IMMEDIATE;\r\n import org.mvel2.ast.Assignment;\r\n@@ -111,6 +112,8 @@ public class ExpressionCompiler extends AbstractParser {\n             fields |= COMPILE_IMMEDIATE;\r\n \r\n             while ((tk = nextToken()) != null) {\r\n+\r\n+\r\n                 /**\r\n                  * If this is a debug symbol, just add it and continue.\r\n                  */\r\n@@ -136,7 +139,7 @@ public class ExpressionCompiler extends AbstractParser {\n                  * reducing for certain literals like, 'this', ternary and ternary else.\r\n                  */\r\n                 if (tk.isLiteral()) {\r\n-                    literalOnly = true;\r\n+                    if (literalOnly == -1) literalOnly = 1;\r\n \r\n                     if ((tkOp = nextTokenSkipSymbols()) != null && tkOp.isOperator()\r\n                             && !tkOp.isOperator(Operator.TERNARY) && !tkOp.isOperator(Operator.TERNARY_ELSE)) {\r\n@@ -183,7 +186,7 @@ public class ExpressionCompiler extends AbstractParser {\n                                     }\r\n \r\n                                     firstLA = false;\r\n-                                    literalOnly = false;\r\n+                                    literalOnly = 0;\r\n                                 }\r\n                                 else {\r\n                                     if (firstLA) {\r\n@@ -226,7 +229,7 @@ public class ExpressionCompiler extends AbstractParser {\n                         throw new CompileException(\"unexpected token: \" + tkOp.getName());\r\n                     }\r\n                     else {\r\n-                        literalOnly = false;\r\n+                        literalOnly = 0;\r\n                         astBuild.addTokenNode(verify(pCtx, tk));\r\n                         if (tkOp != null) astBuild.addTokenNode(verify(pCtx, tkOp));\r\n                         continue;\r\n@@ -237,7 +240,7 @@ public class ExpressionCompiler extends AbstractParser {\n                         lastOp = tk.getOperator();\r\n                     }\r\n \r\n-                    literalOnly = false;\r\n+                    literalOnly = 0;\r\n                 }\r\n \r\n                 astBuild.addTokenNode(verify(pCtx, tk));\r\n@@ -247,13 +250,14 @@ public class ExpressionCompiler extends AbstractParser {\n \r\n             if (verifying) {\r\n                 pCtx.processTables();\r\n-            }\r\n+            }            \r\n \r\n             if (!stk.isEmpty()) {\r\n                 throw new CompileException(\"COMPILE ERROR: non-empty stack after compile.\");\r\n             }\r\n \r\n-            return new CompiledExpression(optimizeAST(astBuild, secondPassOptimization, pCtx), pCtx.getSourceFile(), returnType, pCtx, literalOnly);\r\n+\r\n+            return new CompiledExpression(optimizeAST(astBuild, secondPassOptimization, pCtx), pCtx.getSourceFile(), returnType, pCtx, literalOnly==1);\r\n \r\n         }\r\n         catch (NullPointerException e) {\r\n@@ -275,7 +279,7 @@ public class ExpressionCompiler extends AbstractParser {\n     }\r\n \r\n     private static boolean isBooleanOperator(int operator) {\r\n-        return operator == Operator.AND || operator == Operator.OR;\r\n+        return operator == Operator.AND || operator == Operator.OR || operator == Operator.TERNARY || operator == Operator.TERNARY_ELSE;\r\n     }\r\n \r\n     protected ASTNode verify(ParserContext pCtx, ASTNode tk) {\r\n@@ -409,6 +413,6 @@ public class ExpressionCompiler extends AbstractParser {\n     }\r\n \r\n     public boolean isLiteralOnly() {\r\n-        return literalOnly;\r\n+        return literalOnly == 1;\r\n     }\r\n }\r\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\nindex aab891f..2dd4647 100644\n--- a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n@@ -4774,7 +4774,7 @@ public class CoreConfidenceTests extends AbstractTest {\n \n     public void testNewUsingWith() {\n         ParserContext ctx = new ParserContext();\n-        ctx.setStrongTyping( true);\n+        ctx.setStrongTyping(true);\n         ctx.addImport(Foo.class);\n         ctx.addImport(Bar.class);\n \n@@ -4783,6 +4783,35 @@ public class CoreConfidenceTests extends AbstractTest {\n         OptimizerFactory.setDefaultOptimizer(\"reflective\");\n         assertEquals(\"ziggy\", (((Foo) ((Map) MVEL.executeExpression(s)).get(\"foo\")).getBar().getName()));\n     }\n+\n+    private static final Map<String, Boolean> JIRA124_CTX = Collections.singletonMap(\"testValue\", true);\n+\n+    public void testJIRA124() throws Exception {\n+//        testTernary(1, \"testValue ? 'A' :  'B' + 'C'\");\n+//        testTernary(2, \"testValue ? 'A' +  'B' : 'C'\");\n+        testTernary(3, \"(testValue ? 'A' :  'B' + 'C')\");\n+//        testTernary(4, \"(testValue ? 'A' +  'B' : 'C')\");\n+//        testTernary(5, \"(testValue ? 'A' :  ('B' + 'C'))\");\n+//        testTernary(6, \"(testValue ? ('A' + 'B') : 'C')\");\n+    }\n+\n+    private static void testTernary(int i, String expression) throws Exception {\n+        try {\n+            MVEL.executeExpression(MVEL.compileExpression(expression), JIRA124_CTX);\n+        }\n+        catch (Exception e) {\n+            System.out.println(\"FailedCompiled[\" +  i + \"]:\" + expression);\n+            throw e;\n+        }\n+\n+        try {\n+            MVEL.eval(expression, JIRA124_CTX);\n+        }\n+        catch (Exception e) {\n+            System.out.println(\"FailedEval[\" + i + \"]:\" + expression);\n+            throw e;\n+        }\n+    }\n }\n \n \n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T06:46:09.953215Z", "commit_hash": "baf855b4fdad3eef1cc9a5ca87040348a60820a0", "commit_message": "fix to method resolution\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/PropertyAccessor.java b/src/main/java/org/mvel2/PropertyAccessor.java\nindex 10ae1c1..9dd9f35 100644\n--- a/src/main/java/org/mvel2/PropertyAccessor.java\n+++ b/src/main/java/org/mvel2/PropertyAccessor.java\n@@ -250,7 +250,8 @@ public class PropertyAccessor {\n \r\n             Member member = checkWriteCache(curr.getClass(), tk == null ? 0 : tk.hashCode());\r\n             if (member == null) {\r\n-                addWriteCache(curr.getClass(), tk.hashCode(), (member = getFieldOrWriteAccessor(curr.getClass(), tk)));\r\n+                addWriteCache(curr.getClass(), tk.hashCode(),\r\n+                        (member = value != null ? getFieldOrWriteAccessor(curr.getClass(), tk, value.getClass()) : getFieldOrWriteAccessor(curr.getClass(), tk)));\r\n             }\r\n \r\n             if (member instanceof Method) {\r\ndiff --git a/src/main/java/org/mvel2/util/PropertyTools.java b/src/main/java/org/mvel2/util/PropertyTools.java\nindex 1fc0afe..8bb1d3c 100644\n--- a/src/main/java/org/mvel2/util/PropertyTools.java\n+++ b/src/main/java/org/mvel2/util/PropertyTools.java\n@@ -18,6 +18,9 @@\n \n package org.mvel2.util;\n \n+import static org.mvel2.DataConversion.canConvert;\n+import static org.mvel2.util.ParseTools.boxPrimitive;\n+\n import static java.lang.String.valueOf;\n import java.lang.reflect.Field;\n import java.lang.reflect.Member;\n@@ -48,10 +51,21 @@ public class PropertyTools {\n         property = ReflectionUtil.getSetter(property);\n \n         for (Method meth : clazz.getMethods()) {\n-            if ((meth.getModifiers() & PUBLIC) == 0\n-                    && meth.getParameterTypes().length != 0) continue;\n+            if ((meth.getModifiers() & PUBLIC) != 0 && meth.getParameterTypes().length == 1\n+                    && property.equals(meth.getName())) {\n+                return meth;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    public static Method getSetter(Class clazz, String property, Class type) {\n+        property = ReflectionUtil.getSetter(property);\n \n-            if (property.equals(meth.getName())) {\n+        for (Method meth : clazz.getMethods()) {\n+            if ((meth.getModifiers() & PUBLIC) != 0 && meth.getParameterTypes().length == 1 &&\n+                    property.equals(meth.getName()) && canConvert(meth.getParameterTypes()[0], type)) {\n                 return meth;\n             }\n         }\n@@ -120,6 +134,16 @@ public class PropertyTools {\n         return getSetter(clazz, property);\n     }\n \n+    public static Member getFieldOrWriteAccessor(Class clazz, String property, Class type) {\n+        for (Field f : clazz.getFields()) {\n+            if (property.equals(f.getName()) && canConvert(f.getType(), type)) {\n+                return f;\n+            }\n+        }\n+\n+        return getSetter(clazz, property, type);\n+    }\n+\n \n     public static boolean contains(Object toCompare, Object testValue) {\n         if (toCompare == null)\n@@ -141,4 +165,7 @@ public class PropertyTools {\n     }\n \n \n+    public static boolean isAssignable(Class to, Class from) {\n+        return (to.isPrimitive() ? boxPrimitive(to) : to).isAssignableFrom(from.isPrimitive() ? boxPrimitive(from) : from);\n+    }\n }\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\nindex d412215..ed30420 100644\n--- a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n@@ -7,7 +7,6 @@ import org.mvel2.ast.Function;\n import org.mvel2.ast.WithNode;\n import org.mvel2.compiler.CompiledExpression;\n import org.mvel2.compiler.ExpressionCompiler;\n-import org.mvel2.compiler.ExecutableStatement;\n import org.mvel2.debug.DebugTools;\n import org.mvel2.debug.Debugger;\n import org.mvel2.debug.Frame;\n@@ -3797,6 +3796,7 @@ public class CoreConfidenceTests extends AbstractTest {\n     public static class MvelContext {\n         public boolean singleCalled;\n         public boolean arrayCalled;\n+        public String[] regkeys;\n \n         public void methodForTest(String string) {\n             System.out.println(\"sigle param method called!\");\n@@ -3807,6 +3807,14 @@ public class CoreConfidenceTests extends AbstractTest {\n             System.out.println(\"array param method called!\");\n             arrayCalled = true;\n         }\n+\n+        public void setRegkeys(String[] regkeys) {\n+            this.regkeys = regkeys;\n+        }\n+\n+        public void setRegkeys(String regkey) {\n+            this.regkeys = regkey.split(\",\");\n+        }\n     }\n \n     public void testMethodResolutionOrder() {\n@@ -4715,7 +4723,7 @@ public class CoreConfidenceTests extends AbstractTest {\n         String exp = \"def foo(a,b) { a + b }; foo(1.5,5.25)\";\n         System.out.println(MVEL.eval(exp, new HashMap()));\n     }\n-         \n+\n     public void testChainedMethodCallsWithParams() {\n         assertEquals(true, test(\"foo.toUC(\\\"abcd\\\").equals(\\\"ABCD\\\")\"));\n     }\n@@ -4731,10 +4739,16 @@ public class CoreConfidenceTests extends AbstractTest {\n \n         Map map = new HashMap();\n         map.put(\"name\", \"Adam\");\n-        \n-        assertEquals(true, MVEL.executeExpression(s,map));\n-        assertEquals(true, MVEL.executeExpression(s,map));\n+\n+        assertEquals(true, MVEL.executeExpression(s, map));\n+        assertEquals(true, MVEL.executeExpression(s, map));\n     }\n+\n+    public void testJIRA103() throws Exception {\n+        MvelContext mvelContext = new MvelContext();\n+        MVEL.setProperty(mvelContext, \"regkeys\", \"s\");\n+    }\n+\n }\n \n \n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T06:58:35.861221Z", "commit_hash": "0dfb1a2f2292cd48af3eb95370be01383a722feb", "commit_message": "more fix.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/ast/TypedVarNode.java b/src/main/java/org/mvel2/ast/TypedVarNode.java\nindex 3c64cee..9170cc5 100644\n--- a/src/main/java/org/mvel2/ast/TypedVarNode.java\n+++ b/src/main/java/org/mvel2/ast/TypedVarNode.java\n@@ -21,6 +21,7 @@ package org.mvel2.ast;\n import static org.mvel2.MVEL.eval;\r\n import org.mvel2.ParserContext;\r\n import org.mvel2.compiler.ExecutableStatement;\r\n+import org.mvel2.compiler.AbstractParser;\r\n import org.mvel2.integration.VariableResolverFactory;\r\n import static org.mvel2.util.ParseTools.*;\r\n \r\ndiff --git a/src/main/java/org/mvel2/optimizers/impl/refl/ReflectiveAccessorOptimizer.java b/src/main/java/org/mvel2/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\nindex d18c0d2..7948ea6 100644\n--- a/src/main/java/org/mvel2/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\n+++ b/src/main/java/org/mvel2/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\n@@ -455,6 +455,7 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n                 }\r\n             }\r\n             else if (MVEL.COMPILER_OPT_ALLOW_NAKED_METH_CALL) return getMethod(ctx, property);\r\n+\r\n             throw new PropertyAccessException(property);\r\n         }\r\n     }\r\n@@ -755,7 +756,7 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n         else {\r\n             if (returnType == null) returnType = Object.class;\r\n             if (type.isArray()) {\r\n-                return new ExprValueAccessor((String) o, type, pCtx != null && pCtx.isStrongTyping());\r\n+                return new ExprValueAccessor((String) o, type, pCtx != null && pCtx.isStrongTyping(), ctx, variableFactory);\r\n             }\r\n             else {\r\n                 return new ExprValueAccessor((String) o);\r\n@@ -767,6 +768,9 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n \r\n     public Accessor optimizeCollection(Object o, Class type, char[] property, Object ctx, Object thisRef, VariableResolverFactory factory) {\r\n         this.returnType = type;\r\n+        this.ctx = ctx;\r\n+        this.variableFactory = factory;\r\n+        \r\n         Accessor root = _getAccessor(o, returnType);\r\n \r\n         if (property != null && property.length > 0) {\r\ndiff --git a/src/main/java/org/mvel2/optimizers/impl/refl/collection/ExprValueAccessor.java b/src/main/java/org/mvel2/optimizers/impl/refl/collection/ExprValueAccessor.java\nindex 9091f68..671ee28 100644\n--- a/src/main/java/org/mvel2/optimizers/impl/refl/collection/ExprValueAccessor.java\n+++ b/src/main/java/org/mvel2/optimizers/impl/refl/collection/ExprValueAccessor.java\n@@ -39,16 +39,16 @@ public class ExprValueAccessor implements Accessor {\n         stmt = (ExecutableStatement) ParseTools.subCompileExpression(ex.toCharArray());\r\n     }\r\n \r\n-    public ExprValueAccessor(String ex, Class expectedType, boolean strongType) {\r\n+    public ExprValueAccessor(String ex, Class expectedType, boolean strongType, Object ctx, VariableResolverFactory factory) {\r\n         stmt = (ExecutableStatement) ParseTools.subCompileExpression(ex.toCharArray());\r\n \r\n         //if (expectedType.isArray()) {\r\n         Class tt = getSubComponentType(expectedType);\r\n         Class et = stmt.getKnownEgressType();\r\n         if (stmt.getKnownEgressType() != null && !tt.isAssignableFrom(et)) {\r\n-            if (!strongType && (stmt instanceof ExecutableLiteral) && canConvert(et, tt)) {\r\n+            if (!strongType || (stmt instanceof ExecutableLiteral) && canConvert(et, tt)) {\r\n                 try {\r\n-                    stmt = new ExecutableLiteral(convert(stmt.getValue(null, null), tt));\r\n+                    stmt = new ExecutableLiteral(convert(stmt.getValue(ctx, factory), tt));\r\n                     return;\r\n                 }\r\n                 catch (IllegalArgumentException e) {\r\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/AbstractTest.java b/src/test/java/org/mvel2/tests/core/AbstractTest.java\nindex 07048ee..307513d 100644\n--- a/src/test/java/org/mvel2/tests/core/AbstractTest.java\n+++ b/src/test/java/org/mvel2/tests/core/AbstractTest.java\n@@ -35,7 +35,7 @@ public abstract class AbstractTest extends TestCase {\n \n     static {\n         // Modify the dynamic optimizer to ensure it always engages the JIT\n- //       DynamicOptimizer.tenuringThreshold = 1;\n+        DynamicOptimizer.tenuringThreshold = 1;\n     }\n \n \ndiff --git a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\nindex 0cca5cc..f769266 100644\n--- a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n@@ -4701,6 +4701,14 @@ public class CoreConfidenceTests extends AbstractTest {\n         assertEquals(3, result.size());\n     }\n \n+    public void testStaticTyping2() {\n+        String exp = \"int x = 5; int y = 2; new int[] { x, y }\";\n+        Integer[] res = (Integer[]) MVEL.eval(exp, new HashMap());\n+\n+        assertEquals(5, res[0].intValue());\n+        assertEquals(2, res[1].intValue());\n+    }\n+\n //    public void testThreadTest() throws InterruptedException {\n //\n //        for (int x = 0; x < 10000; x++) {\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T07:04:47.005200Z", "commit_hash": "dd0ca2d90b9f68525b4dc1f78a92917299c428d2", "commit_message": "fix to JIT\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/MVELInterpretedRuntime.java b/src/main/java/org/mvel2/MVELInterpretedRuntime.java\nindex cb3a0a1..b305a92 100644\n--- a/src/main/java/org/mvel2/MVELInterpretedRuntime.java\n+++ b/src/main/java/org/mvel2/MVELInterpretedRuntime.java\n@@ -28,6 +28,7 @@ import org.mvel2.integration.VariableResolverFactory;\n import org.mvel2.integration.impl.MapVariableResolverFactory;\n import org.mvel2.util.ExecutionStack;\n import static org.mvel2.util.ParseTools.findClassImportResolverFactory;\n+import org.mvel2.optimizers.OptimizerFactory;\n \n import java.math.BigDecimal;\n import java.util.Map;\n@@ -54,11 +55,6 @@ public class MVELInterpretedRuntime extends AbstractParser {\n \n             if (parserContext != null) contextControl(REMOVE, null, null);\n \n-//            if (parserContext != null\n-//                    && (parserContext.get() == null || parserContext.get().getRootParser() == this)) {\n-//                contextControl(REMOVE, null, null);\n-//            }\n-\n             return stk.pop();\n         }\n         catch (ArrayIndexOutOfBoundsException e) {\ndiff --git a/src/main/java/org/mvel2/ast/Contains.java b/src/main/java/org/mvel2/ast/Contains.java\nindex 4e339a3..d49dd35 100644\n--- a/src/main/java/org/mvel2/ast/Contains.java\n+++ b/src/main/java/org/mvel2/ast/Contains.java\n@@ -2,6 +2,7 @@ package org.mvel2.ast;\n \n import org.mvel2.integration.VariableResolverFactory;\n import org.mvel2.util.ParseTools;\n+import static org.mvel2.util.ParseTools.containsCheck;\n \n public class Contains extends ASTNode {\n     private ASTNode stmt;\n@@ -13,7 +14,7 @@ public class Contains extends ASTNode {\n     }\n \n     public Object getReducedValueAccelerated(Object ctx, Object thisValue, VariableResolverFactory factory) {\n-        return ParseTools.containsCheck(stmt.getReducedValueAccelerated(ctx, thisValue, factory), stmt2.getReducedValueAccelerated(ctx, thisValue, factory));\n+        return containsCheck(stmt.getReducedValueAccelerated(ctx, thisValue, factory), stmt2.getReducedValueAccelerated(ctx, thisValue, factory));\n     }\n \n     public Object getReducedValue(Object ctx, Object thisValue, VariableResolverFactory factory) {\ndiff --git a/src/main/java/org/mvel2/ast/ForEachNode.java b/src/main/java/org/mvel2/ast/ForEachNode.java\nindex d9ee6c6..8b54ff3 100644\n--- a/src/main/java/org/mvel2/ast/ForEachNode.java\n+++ b/src/main/java/org/mvel2/ast/ForEachNode.java\n@@ -29,6 +29,7 @@ import static org.mvel2.util.ParseTools.subCompileExpression;\n import static org.mvel2.util.ParseTools.subset;\r\n \r\n import java.util.Collection;\r\n+import java.lang.reflect.Array;\r\n \r\n /**\r\n  * @author Christopher Brock\r\n@@ -101,8 +102,9 @@ public class ForEachNode extends BlockNode {\n                 }\r\n                 break;\r\n             case ARRAY:\r\n-                for (Object o : (Object[]) iterCond) {\r\n-                    itemR.setValue(o);\r\n+                int len = Array.getLength(iterCond);\r\n+                for (int i = 0; i < len; i++) {\r\n+                    itemR.setValue(Array.get(iterCond, i));\r\n                     compiledBlock.getValue(ctx, thisValue, itemFactory);\r\n                 }\r\n                 break;\r\n@@ -147,9 +149,10 @@ public class ForEachNode extends BlockNode {\n                 compiledBlock.getValue(ctx, thisValue, itemFactory);\r\n             }\r\n         }\r\n-        else if (iterCond instanceof Object[]) {\r\n-            for (Object o : (Object[]) iterCond) {\r\n-                itemR.setValue(o);\r\n+        else if (iterCond != null && iterCond.getClass().isArray()) {\r\n+            int len = Array.getLength(iterCond);\r\n+            for (int i = 0; i < len; i++) {\r\n+                itemR.setValue(Array.get(iterCond, i));\r\n                 compiledBlock.getValue(ctx, thisValue, itemFactory);\r\n             }\r\n         }\r\ndiff --git a/src/main/java/org/mvel2/ast/InlineCollectionNode.java b/src/main/java/org/mvel2/ast/InlineCollectionNode.java\nindex 81da82e..6ffa4aa 100644\n--- a/src/main/java/org/mvel2/ast/InlineCollectionNode.java\n+++ b/src/main/java/org/mvel2/ast/InlineCollectionNode.java\n@@ -65,13 +65,6 @@ public class InlineCollectionNode extends ASTNode {\n             accessor = ao.optimizeCollection(collectionGraph, egressType, trailing, ctx, thisValue, factory);\r\n             egressType = ao.getEgressType();\r\n \r\n-//            if (ao.isLiteralOnly()) {\r\n-//                if (egressType == List.class) {\r\n-//                    List v = (List) accessor.getValue(null, null, null);\r\n-//                    accessor = new CachedListAccessor(v);\r\n-//                    return v;\r\n-//                }\r\n-//            }\r\n             return accessor.getValue(ctx, thisValue, factory);\r\n         }\r\n \r\ndiff --git a/src/main/java/org/mvel2/optimizers/OptimizerFactory.java b/src/main/java/org/mvel2/optimizers/OptimizerFactory.java\nindex e50face..48503a4 100644\n--- a/src/main/java/org/mvel2/optimizers/OptimizerFactory.java\n+++ b/src/main/java/org/mvel2/optimizers/OptimizerFactory.java\n@@ -86,7 +86,6 @@ public class OptimizerFactory {\n         if (threadOptimizer.get() == null) {\r\n             threadOptimizer.set(getDefaultAccessorCompiler().getClass());\r\n         }\r\n-\r\n         try {\r\n             return threadOptimizer.get().newInstance();\r\n         }\r\ndiff --git a/src/main/java/org/mvel2/optimizers/dynamic/DynamicCollectionAccessor.java b/src/main/java/org/mvel2/optimizers/dynamic/DynamicCollectionAccessor.java\nindex b4872a4..8f9a670 100644\n--- a/src/main/java/org/mvel2/optimizers/dynamic/DynamicCollectionAccessor.java\n+++ b/src/main/java/org/mvel2/optimizers/dynamic/DynamicCollectionAccessor.java\n@@ -35,6 +35,7 @@ public class DynamicCollectionAccessor implements DynamicAccessor {\n             if (++runcount > DynamicOptimizer.tenuringThreshold) {\n                 if ((currentTimeMillis() - stamp) < DynamicOptimizer.timeSpan) {\n                     opt = true;\n+\n                     return optimize(ctx, elCtx, variableFactory);\n                 }\n                 else {\n@@ -60,7 +61,6 @@ public class DynamicCollectionAccessor implements DynamicAccessor {\n \n         _accessor = OptimizerFactory.getAccessorCompiler(\"ASM\").optimizeCollection(rootObject, colType, property, ctx, elCtx, variableResolverFactory);\n         return _accessor.getValue(ctx, elCtx, variableResolverFactory);\n-\n     }\n \n \ndiff --git a/src/main/java/org/mvel2/optimizers/dynamic/DynamicOptimizer.java b/src/main/java/org/mvel2/optimizers/dynamic/DynamicOptimizer.java\nindex 04e79a7..21bc2b8 100644\n--- a/src/main/java/org/mvel2/optimizers/dynamic/DynamicOptimizer.java\n+++ b/src/main/java/org/mvel2/optimizers/dynamic/DynamicOptimizer.java\n@@ -15,7 +15,7 @@ public class DynamicOptimizer extends AbstractOptimizer implements AccessorOptim\n     private AccessorOptimizer firstStage = getAccessorCompiler(SAFE_REFLECTIVE);\n \n     public static DynamicClassLoader classLoader;\n-    public static int tenuringThreshold = 10;\n+    public static int tenuringThreshold = 50;\n     public static long timeSpan = 100;\n     public static int maximumTenure = 1500;\n     public static int totalRecycled = 0;\ndiff --git a/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java b/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java\nindex ba86bba..0248895 100644\n--- a/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java\n+++ b/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java\n@@ -2364,9 +2364,13 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n                     break;\r\n             }\r\n         }\r\n-        else if (index < Byte.MAX_VALUE) {\r\n-            assert debug(\"BIPUSH \" + index);\r\n-            mv.visitIntInsn(BIPUSH, index);\r\n+//        else if (index > Integer.MAX_VALUE) {\r\n+//            assert debug(\"BIPUSH \" + index);\r\n+//            mv.visitIntInsn(BIPUSH, index);\r\n+//        }\r\n+        else if (index > Short.MAX_VALUE) {\r\n+            assert debug(\"LDC \" + index);\r\n+            mv.visitLdcInsn(index);\r\n         }\r\n         else {\r\n             assert debug(\"SIPUSH \" + index);\r\ndiff --git a/src/main/java/org/mvel2/optimizers/impl/refl/collection/ArrayCreator.java b/src/main/java/org/mvel2/optimizers/impl/refl/collection/ArrayCreator.java\nindex c74ae14..94913bc 100644\n--- a/src/main/java/org/mvel2/optimizers/impl/refl/collection/ArrayCreator.java\n+++ b/src/main/java/org/mvel2/optimizers/impl/refl/collection/ArrayCreator.java\n@@ -35,16 +35,16 @@ public class ArrayCreator implements Accessor {\n         if (Object.class.equals(arrayType)) {\r\n             Object[] newArray = new Object[template.length];\r\n \r\n-            for (int i = 0; i < newArray.length; i++)\r\n+            for (int i = 0; i < newArray.length; i++) {\r\n                 newArray[i] = template[i].getValue(ctx, elCtx, variableFactory);\r\n+            }\r\n \r\n             return newArray;\r\n         }\r\n         else {\r\n             Object newArray = newInstance(arrayType, template.length);\r\n             for (int i = 0; i < template.length; i++) {\r\n-                Object o = template[i].getValue(ctx, elCtx, variableFactory);\r\n-                Array.set(newArray, i, o);\r\n+                Array.set(newArray, i, template[i].getValue(ctx, elCtx, variableFactory));\r\n             }\r\n \r\n             return newArray;\r\n@@ -54,7 +54,6 @@ public class ArrayCreator implements Accessor {\n     public ArrayCreator(Accessor[] template, Class arrayType) {\r\n         this.template = template;\r\n         this.arrayType = arrayType;\r\n-\r\n     }\r\n \r\n     public Object setValue(Object ctx, Object elCtx, VariableResolverFactory variableFactory, Object value) {\r\ndiff --git a/src/main/java/org/mvel2/util/ParseTools.java b/src/main/java/org/mvel2/util/ParseTools.java\nindex c790568..d62d4b5 100644\n--- a/src/main/java/org/mvel2/util/ParseTools.java\n+++ b/src/main/java/org/mvel2/util/ParseTools.java\n@@ -40,6 +40,7 @@ import static java.lang.System.arraycopy;\n import static java.lang.Thread.currentThread;\n import java.lang.reflect.Constructor;\n import java.lang.reflect.Method;\n+import static java.lang.Character.isDigit;\n import java.math.BigDecimal;\n import java.math.BigInteger;\n import java.math.MathContext;\n@@ -1739,7 +1740,7 @@ public class ParseTools {\n     public static void checkNameSafety(String name) {\n         if (isReservedWord(name)) {\n             throw new CompileException(\"illegal use of reserved word: \" + name);\n-        } else if (Character.isDigit(name.charAt(0))) {\n+        } else if (isDigit(name.charAt(0))) {\n             throw new CompileException(\"not an identifier\");\n         }\n     }\n@@ -1753,10 +1754,6 @@ public class ParseTools {\n                 || clazz == Float.class || clazz == Short.class || clazz == Byte.class || clazz == Character.class;\n     }\n \n-//    public static Serializable subCompileExpression(String expression) {\n-//        return optimizeTree(new ExpressionCompiler(expression)._compile());\n-//    }\n-\n     public static Serializable subCompileExpression(char[] expression) {\n         return optimizeTree(new ExpressionCompiler(expression)._compile());\n     }\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/AbstractTest.java b/src/test/java/org/mvel2/tests/core/AbstractTest.java\nindex 307513d..07048ee 100644\n--- a/src/test/java/org/mvel2/tests/core/AbstractTest.java\n+++ b/src/test/java/org/mvel2/tests/core/AbstractTest.java\n@@ -35,7 +35,7 @@ public abstract class AbstractTest extends TestCase {\n \n     static {\n         // Modify the dynamic optimizer to ensure it always engages the JIT\n-        DynamicOptimizer.tenuringThreshold = 1;\n+ //       DynamicOptimizer.tenuringThreshold = 1;\n     }\n \n \ndiff --git a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\nindex b079df2..0cca5cc 100644\n--- a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n@@ -4668,7 +4668,7 @@ public class CoreConfidenceTests extends AbstractTest {\n \n         foo = new Foo();\n \n-        executeSetExpression(s, foo, 13);                           \n+        executeSetExpression(s, foo, 13);\n \n         assertEquals(\"13\", foo.getBar().getAssignTest());\n \n@@ -4691,7 +4691,15 @@ public class CoreConfidenceTests extends AbstractTest {\n         assertEquals(\"13\", foo.getBar().getAssignTest());\n     }\n \n+    public void testJIRA115() {\n+  //      OptimizerFactory.setDefaultOptimizer(\"ASM\");\n+        String exp = \"results = new java.util.ArrayList(); foreach (element : elements) { if( {1,32769,32767} contains element ) { results.add(element);  } }; results\";\n+        Map map = new HashMap();\n+        map.put(\"elements\",new int[]{1, 32769, 32767} );\n+        ArrayList result = (ArrayList) MVEL.eval(exp, map );\n \n+        assertEquals(3, result.size());\n+    }\n \n //    public void testThreadTest() throws InterruptedException {\n //\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T07:10:55.948463Z", "commit_hash": "dfbd5d05673816dd91f85ce4b6adcc9b20f0d980", "commit_message": "fix to coercion handler\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/conversion/PrimArrayHandler.java b/src/main/java/org/mvel2/conversion/PrimArrayHandler.java\nindex f20de7e..5f1e0f8 100644\n--- a/src/main/java/org/mvel2/conversion/PrimArrayHandler.java\n+++ b/src/main/java/org/mvel2/conversion/PrimArrayHandler.java\n@@ -23,9 +23,13 @@ import org.mvel2.ConversionHandler;\n import static org.mvel2.DataConversion.canConvert;\n import static org.mvel2.DataConversion.convert;\n import org.mvel2.util.ParseTools;\n+import static org.mvel2.util.ParseTools.getBaseComponentType;\n \n import static java.lang.reflect.Array.newInstance;\n import static java.lang.reflect.Array.set;\n+import static java.lang.reflect.Array.getLength;\n+import static java.lang.reflect.Array.get;\n+import java.lang.reflect.Array;\n import java.util.HashMap;\n import java.util.Map;\n \n@@ -35,30 +39,15 @@ public class PrimArrayHandler implements ConversionHandler {\n     private final Class primitiveType;\n \n     public PrimArrayHandler(Class type) {\n-        this.primitiveType = type;\n-\n-        CNV.put(Object[].class, new Converter() {\n-            public Object convert(Object o) {\n-                return handleLooseTypeConversion(o.getClass(), (Object[]) o, primitiveType);\n-            }\n-        });\n-\n-        CNV.put(String[].class, new Converter() {\n-            public Object convert(Object o) {\n-                return handleLooseTypeConversion(o.getClass(), (String[]) o, primitiveType);\n-            }\n-        });\n+        this.primitiveType = getBaseComponentType(type);\n     }\n \n     public Object convertFrom(Object in) {\n-        if (!CNV.containsKey(in.getClass())) throw new ConversionException(\"cannot convert type: \"\n-                + in.getClass().getName() + \" to: \" + primitiveType.getName());\n-\n-        return CNV.get(in.getClass()).convert(in);\n+        return handleLooseTypeConversion(in.getClass(), in, primitiveType);\n     }\n \n     public boolean canConvertFrom(Class cls) {\n-        return CNV.containsKey(cls);\n+        return cls.isArray();\n     }\n \n \n@@ -71,20 +60,20 @@ public class PrimArrayHandler implements ConversionHandler {\n      * @param targetType\n      * @return\n      */\n-    private static Object handleLooseTypeConversion(Class sourceType, Object[] input, Class targetType) {\n-        Class targType = ParseTools.getBaseComponentType(targetType);\n+    private static Object handleLooseTypeConversion(Class sourceType, Object input, Class targetType) {\n+        Class targType = getBaseComponentType(targetType);\n \n-        Object target = newInstance(targType, input.length);\n+        int len = getLength(input);\n+        Object target = newInstance(targType, len);\n \n-        if (input.length > 0\n-                && canConvert(targetType.getComponentType(), ParseTools.getBaseComponentType(sourceType))) {\n-            for (int i = 0; i < input.length; i++) {\n-                set(target, i, convert(input[i], targType));\n+        if (len > 0 && canConvert(targetType, getBaseComponentType(sourceType))) {\n+            for (int i = 0; i < len; i++) {\n+                set(target, i, convert(get(input,i), targType));\n             }\n         }\n         else {\n             throw new ConversionException(\"cannot convert to type: \"\n-                    + targetType.getComponentType().getName() + \"[] from \" + ParseTools.getBaseComponentType(sourceType).getName());\n+                    + targetType.getComponentType().getName() + \"[] from \" + getBaseComponentType(sourceType).getName());\n         }\n \n         return target;\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\nindex 4e4a38a..b079df2 100644\n--- a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n@@ -4521,7 +4521,7 @@ public class CoreConfidenceTests extends AbstractTest {\n     }\n \n     public void testJIRA113() {\n-        assertEquals(true, test(\"org.mvel2.tests.core.CoreConfidenceTests.minim( {456.2, 2.3} ) == 2.3\"));\n+        assertEquals(true, test(\"org.mvel2.tests.core.CoreConfidenceTests.minim( new double[] {456.2, 2.3} ) == 2.3\"));\n     }\n \n     public void testSetCoercion() {\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T07:29:33.320392Z", "commit_hash": "2d104691ca9216ea9fa3be7c8c3762231ab5b265", "commit_message": "fixes to the JIT compiler\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java b/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java\nindex c1e381d..ba86bba 100644\n--- a/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java\n+++ b/src/main/java/org/mvel2/optimizers/impl/asm/ASMAccessorOptimizer.java\n@@ -291,14 +291,15 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n                         checkcast(returnType);\r\n                     }\r\n \r\n-                    assert debug(\"DUP_X2\");\r\n-                    mv.visitInsn(DUP_X2);\r\n-\r\n                     assert debug(\"INVOKEINTERFACE Map.put\");\r\n                     mv.visitMethodInsn(INVOKEINTERFACE, \"java/util/Map\", \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\");\r\n \r\n                     assert debug(\"POP\");\r\n                     mv.visitInsn(POP);\r\n+\r\n+\r\n+                    assert debug(\"ALOAD 4\");\r\n+                    mv.visitVarInsn(ALOAD, 4);\r\n                 }\r\n                 else if (ctx instanceof List) {\r\n                     //noinspection unchecked\r\n@@ -315,14 +316,12 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n                         checkcast(returnType);\r\n                     }\r\n \r\n-                    assert debug(\"DUP_X2\");\r\n-                    mv.visitInsn(DUP_X2);\r\n \r\n                     assert debug(\"INVOKEINTERFACE List.set\");\r\n                     mv.visitMethodInsn(INVOKEINTERFACE, \"java/util/List\", \"set\", \"(ILjava/lang/Object;)Ljava/lang/Object;\");\r\n \r\n-                    assert debug(\"POP\");\r\n-                    mv.visitInsn(POP);\r\n+                    assert debug(\"ALOAD 4\");\r\n+                    mv.visitVarInsn(ALOAD, 4);\r\n \r\n                 }\r\n                 else if (ctx.getClass().isArray()) {\r\n@@ -341,12 +340,6 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n                     assert debug(\"ALOAD 4\");\r\n                     mv.visitVarInsn(ALOAD, 4);\r\n \r\n-//                    assert debug(\"CHECKCAST \" + getInternalName(type));\r\n-//                    mv.visitTypeInsn(CHECKCAST, getInternalName(type));\r\n-\r\n-                    assert debug(\"DUP_X2\");\r\n-                    mv.visitInsn(DUP_X2);\r\n-\r\n                     if (!type.equals(value.getClass())) {\r\n                         dataConversion(type);\r\n                     }\r\n@@ -357,6 +350,9 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n \r\n                     //noinspection unchecked\r\n                     Array.set(ctx, (Integer) idx, convert(value, type));\r\n+\r\n+                    assert debug(\"ALOAD 4\");\r\n+                    mv.visitVarInsn(ALOAD, 4);\r\n                 }\r\n                 else {\r\n                     throw new PropertyAccessException(\"cannot bind to collection property: \" + new String(property) + \": not a recognized collection type: \" + ctx.getClass());\r\n@@ -392,8 +388,6 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n                 assert debug(\"CHECKCAST \" + fld.getType().getName());\r\n                 mv.visitTypeInsn(CHECKCAST, getInternalName(fld.getType()));\r\n \r\n-                assert debug(\"DUP_X1\");\r\n-                mv.visitInsn(DUP_X1);\r\n \r\n                 if (value != null && !fld.getType().isAssignableFrom(value.getClass())) {\r\n                     if (!canConvert(fld.getType(), value.getClass())) {\r\n@@ -411,6 +405,9 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n                 assert debug(\"PUTFIELD \" + getInternalName(fld.getDeclaringClass()) + \".\" + tk);\r\n                 mv.visitFieldInsn(PUTFIELD, getInternalName(fld.getDeclaringClass()), tk, getDescriptor(fld.getType()));\r\n \r\n+                assert debug(\"ALOAD 4\");\r\n+                mv.visitVarInsn(ALOAD, 4);\r\n+\r\n             }\r\n             else if (member != null) {\r\n                 assert debug(\"CHECKCAST \" + getInternalName(ctx.getClass()));\r\n@@ -423,9 +420,6 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n \r\n                 Class targetType = meth.getParameterTypes()[0];\r\n \r\n-                assert debug(\"DUP_X1\");\r\n-                mv.visitInsn(DUP_X1);\r\n-\r\n                 if (value != null && !targetType.isAssignableFrom(value.getClass())) {\r\n                     if (!canConvert(targetType, value.getClass())) {\r\n                         throw new ConversionException(\"cannot convert type: \"\r\n@@ -433,14 +427,14 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n                     }\r\n \r\n                     dataConversion(getWrapperClass(targetType));\r\n-                    if (targetType.isPrimitive()) unwrapPrimitive(targetType);\r\n-\r\n+                    if (targetType.isPrimitive()) {\r\n+                        unwrapPrimitive(targetType);\r\n+                    }\r\n+                    else checkcast(targetType);\r\n                     meth.invoke(ctx, convert(value, meth.getParameterTypes()[0]));\r\n                 }\r\n                 else {\r\n-                    assert debug(\"CHECKCAST \" + getInternalName(targetType));\r\n-                    mv.visitTypeInsn(CHECKCAST, getInternalName(targetType));\r\n-\r\n+                    checkcast(targetType);\r\n                     meth.invoke(ctx, value);\r\n                 }\r\n \r\n@@ -448,6 +442,10 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n                 mv.visitMethodInsn(INVOKEVIRTUAL, getInternalName(meth.getDeclaringClass()), meth.getName(),\r\n                         getMethodDescriptor(meth));\r\n \r\n+                assert debug(\"ALOAD 4\");\r\n+                mv.visitVarInsn(ALOAD, 4);\r\n+\r\n+\r\n             }\r\n             else if (ctx instanceof Map) {\r\n                 assert debug(\"CHECKCAST \" + getInternalName(ctx.getClass()));\r\n@@ -459,14 +457,11 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n                 assert debug(\"ALOAD 4\");\r\n                 mv.visitVarInsn(ALOAD, 4);\r\n \r\n-                assert debug(\"DUP_X2\");\r\n-                mv.visitInsn(DUP_X2);\r\n-\r\n                 assert debug(\"INVOKEVIRTUAL java/util/HashMap.put\");\r\n                 mv.visitMethodInsn(INVOKEVIRTUAL, \"java/util/HashMap\", \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\");\r\n \r\n-                assert debug(\"POP\");\r\n-                mv.visitInsn(POP);\r\n+                assert debug(\"ALOAD 4\");\r\n+                mv.visitVarInsn(ALOAD, 4);\r\n \r\n                 //noinspection unchecked\r\n                 ((Map) ctx).put(tk, value);\r\n@@ -744,10 +739,10 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n                     return variableFactory.getVariableResolver(property).getValue();\r\n                 }\r\n             }\r\n-//            else {\r\n-//                assert debug(\"ALOAD 1\");\r\n-//                mv.visitVarInsn(ALOAD, 1);\r\n-//            }\r\n+            else {\r\n+                assert debug(\"ALOAD 1\");\r\n+                mv.visitVarInsn(ALOAD, 1);\r\n+            }\r\n         }\r\n \r\n         if (member instanceof Field) {\r\n@@ -1599,7 +1594,7 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n             return Character.class;\r\n         }\r\n \r\n-        return null;\r\n+        return cls;\r\n     }\r\n \r\n     private void unwrapPrimitive(Class cls) {\r\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/AccessorBMModel.java b/src/test/java/org/mvel2/tests/AccessorBMModel.java\nindex 32cd7c6..5887ca0 100644\n--- a/src/test/java/org/mvel2/tests/AccessorBMModel.java\n+++ b/src/test/java/org/mvel2/tests/AccessorBMModel.java\n@@ -1,5 +1,7 @@\n package org.mvel2.tests;\r\n \r\n+import java.util.Map;\r\n+\r\n import org.mvel2.DataConversion;\r\n import org.mvel2.compiler.Accessor;\r\n import org.mvel2.compiler.ExecutableStatement;\r\n@@ -15,7 +17,8 @@ public class AccessorBMModel implements Accessor {\n     }\r\n \r\n     public Object setValue(Object ctx, Object elCtx, VariableResolverFactory variableFactory, Object value) {\r\n-        return ((Foo) ctx).getBar().getIntarray()[0] = DataConversion.convert(value, Integer.class);\r\n+        ((Map)((Map) ctx).get(\"innermap\")).put(\"test\", value);\r\n+        return value;\r\n     }\r\n \r\n     public Class getKnownEgressType() {\r\ndiff --git a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\nindex ec2a533..60b71f0 100644\n--- a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n@@ -1312,6 +1312,7 @@ public class CoreConfidenceTests extends AbstractTest {\n     }\n \n     public void testBreakpoints5() {\n+        OptimizerFactory.setDefaultOptimizer(\"ASM\");\n         String expression = \"System.out.println('foo');\\r\\n\" +\n                 \"a = new Foo();\\r\\n\" +\n                 \"a.name = 'bar';\\r\\n\" +\n@@ -1554,6 +1555,7 @@ public class CoreConfidenceTests extends AbstractTest {\n     }\n \n     public void testSataticClassImportViaFactoryAndWithModification() {\n+        OptimizerFactory.setDefaultOptimizer(\"ASM\");\n         MapVariableResolverFactory mvf = new MapVariableResolverFactory(createTestMap());\n         ClassImportResolverFactory classes = new ClassImportResolverFactory();\n         classes.addClass(Person.class);\n@@ -1700,6 +1702,27 @@ public class CoreConfidenceTests extends AbstractTest {\n     }\n \n     public void testExecuteCoercionTwice() {\n+        OptimizerFactory.setDefaultOptimizer(\"reflective\");\n+\n+        Map<String, Object> vars = new HashMap<String, Object>();\n+        vars.put(\"foo\", new Foo());\n+        vars.put(\"$value\", new Long(5));\n+\n+        ExpressionCompiler compiler = new ExpressionCompiler(\"with (foo) { countTest = $value };\");\n+        compiler.setDebugSymbols(true);\n+\n+        ParserContext ctx = new ParserContext();\n+        ctx.setSourceFile(\"test.mv\");\n+\n+        CompiledExpression compiled = compiler.compile(ctx);\n+\n+        executeExpression(compiled, null, vars);\n+        executeExpression(compiled, null, vars);\n+    }\n+\n+    public void testExecuteCoercionTwice2() {\n+        OptimizerFactory.setDefaultOptimizer(\"ASM\");\n+\n         Map<String, Object> vars = new HashMap<String, Object>();\n         vars.put(\"foo\", new Foo());\n         vars.put(\"$value\", new Long(5));\n@@ -1716,6 +1739,7 @@ public class CoreConfidenceTests extends AbstractTest {\n         executeExpression(compiled, null, vars);\n     }\n \n+\n     public void testComments() {\n         assertEquals(10, test(\"// This is a comment\\n5 + 5\"));\n     }\n@@ -2018,6 +2042,7 @@ public class CoreConfidenceTests extends AbstractTest {\n     }\n \n     public void testMapBindingSemantics2() {\n+        OptimizerFactory.setDefaultOptimizer(\"ASM\");\n         Map<String, Object> outermap = new HashMap<String, Object>();\n         Map<String, Object> innermap = new HashMap<String, Object>();\n \n@@ -4034,6 +4059,8 @@ public class CoreConfidenceTests extends AbstractTest {\n \n \n     public void testDataConverterStrictMode() throws Exception {\n+        OptimizerFactory.setDefaultOptimizer(\"ASM\");\n+\n         DataConversion.addConversionHandler(Date.class, new MVELDateCoercion());\n \n         ParserContext ctx = new ParserContext();\n@@ -4615,6 +4642,44 @@ public class CoreConfidenceTests extends AbstractTest {\n         assertEquals(13, foo.getBar().getIntarray()[0].intValue());\n     }\n \n+    public void testFieldCoercion1() {\n+        ParserContext ctx = new ParserContext();\n+        ctx.setStrongTyping(true);\n+        ctx.addInput(\"bar\", Bar.class);\n+\n+        Serializable s = compileSetExpression(\"bar.assignTest\", ctx);\n+\n+        Foo foo = new Foo();\n+\n+        executeSetExpression(s, foo, 12);\n+\n+        assertEquals(\"12\", foo.getBar().getAssignTest());\n+\n+        foo = new Foo();\n+\n+        executeSetExpression(s, foo, 13);\n+\n+        assertEquals(\"13\", foo.getBar().getAssignTest());\n+\n+        OptimizerFactory.setDefaultOptimizer(\"ASM\");\n+\n+        ctx = new ParserContext();\n+        ctx.setStrongTyping(true);\n+        ctx.addInput(\"bar\", Bar.class);\n+\n+        s = compileSetExpression(\"bar.assignTest\", ctx);\n+\n+        foo = new Foo();\n+\n+        executeSetExpression(s, foo, 12);\n+\n+        assertEquals(\"12\", foo.getBar().getAssignTest());\n+\n+        executeSetExpression(s, foo, 13);\n+\n+        assertEquals(\"13\", foo.getBar().getAssignTest());\n+    }\n+\n //    public void testThreadTest() throws InterruptedException {\n //\n //        for (int x = 0; x < 10000; x++) {\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T08:11:40.396895Z", "commit_hash": "e8bb94c67183fa185880fcbbe0914d15bb06f63d", "commit_message": "small fix\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/ast/NewObjectNode.java b/src/main/java/org/mvel2/ast/NewObjectNode.java\nindex af5c430..696856c 100644\n--- a/src/main/java/org/mvel2/ast/NewObjectNode.java\n+++ b/src/main/java/org/mvel2/ast/NewObjectNode.java\n@@ -217,6 +217,9 @@ public class NewObjectNode extends ASTNode {\n                 }\r\n             }\r\n         }\r\n+        catch (CompileException e) {\r\n+            throw e;\r\n+        }\r\n         catch (ClassNotFoundException e) {\r\n             throw new CompileException(\"unable to resolve class: \" + e.getMessage(), e);\r\n         }\r\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\nindex d592921..82a4806 100644\n--- a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n@@ -4490,7 +4490,7 @@ public class CoreConfidenceTests extends AbstractTest {\n         setProperty(foo, \"name\", 12);\n         assertEquals(\"12\", foo.getName());\n     }\n-\n+//\n //    public void testThreadTest() throws InterruptedException {\n //\n //        for (int x = 0; x < 10000; x++) {\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T08:37:54.035776Z", "commit_hash": "057ca242c9a8011c793a7b58abba18fab1dbf1af", "commit_message": "potential fix.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/compiler/AbstractParser.java b/src/main/java/org/mvel2/compiler/AbstractParser.java\nindex c1b8202..9ac84e1 100644\n--- a/src/main/java/org/mvel2/compiler/AbstractParser.java\n+++ b/src/main/java/org/mvel2/compiler/AbstractParser.java\n@@ -155,7 +155,7 @@ public class AbstractParser implements Serializable {\n     }\r\n \r\n     public static void configureFactory() {\r\n-        EX_PRECACHE = new WeakHashMap<String, char[]>(10);\r\n+        EX_PRECACHE = (new WeakHashMap<String, char[]>(15));\r\n     }\r\n \r\n     protected ASTNode nextTokenSkipSymbols() {\r\n@@ -1844,17 +1844,19 @@ public class AbstractParser implements Serializable {\n     protected void setExpression(String expression) {\r\n         if (expression != null && !\"\".equals(expression)) {\r\n             if ((this.expr = EX_PRECACHE.get(expression)) == null) {\r\n-                length = (this.expr = expression.toCharArray()).length;\r\n+                synchronized (EX_PRECACHE) {\r\n+                    length = (this.expr = expression.toCharArray()).length;\r\n \r\n-                // trim any whitespace.\r\n-                while (length != 0 && isWhitespace(this.expr[length - 1])) length--;\r\n+                    // trim any whitespace.\r\n+                    while (length != 0 && isWhitespace(this.expr[length - 1])) length--;\r\n \r\n-                char[] e = new char[length];\r\n-                //arraycopy(this.expr, 0, e, 0, length);\r\n-                for (int i = 0; i != e.length; i++)\r\n-                    e[i] = expr[i];\r\n+                    char[] e = new char[length];\r\n \r\n-                EX_PRECACHE.put(expression, e);\r\n+                    for (int i = 0; i != e.length; i++)\r\n+                        e[i] = expr[i];\r\n+\r\n+                    EX_PRECACHE.put(expression, e);\r\n+                }\r\n             }\r\n             else {\r\n                 length = this.expr.length;\r\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\nindex c8ee3c0..19c4c37 100644\n--- a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n@@ -4491,103 +4491,102 @@ public class CoreConfidenceTests extends AbstractTest {\n         assertEquals(\"12\", foo.getName());\n     }\n \n-//    public void testThreadTest() throws InterruptedException {\n-//        Cookie cookie = new Cookie();\n-//\n-//        long start = System.currentTimeMillis();\n-//\n-//        MVEL.eval(\"pookie.age\", cookie);\n-//        long end = System.currentTimeMillis();\n-//        System.out.println(\"Getting field time was \" + (end - start));\n-//\n-//\n-//        start = System.currentTimeMillis();\n-//        MVEL.eval(\"pookie.dookies['bart'].name\", cookie);\n-//        end = System.currentTimeMillis();\n-//        System.out.println(\"Getting property time was \" + (end - start));\n-//\n-//        // Loop\n-//\n-//        start = System.currentTimeMillis();\n-//        for (int i = 0; i < 50; i++) {\n-//            MVEL.eval(\"pookie.dookies['bart'].name\", cookie);\n-//        }\n-//        end = System.currentTimeMillis();\n-//        System.out.println(\"50 times was \" + (end - start));\n-//\n-//\n-//        MVELThread[] threads = new MVELThread[50];\n-//        for (int i = 0; i < 50; i++) {\n-//            threads[i] = new MVELThread();\n-//            threads[i].setName(\"\" + i);\n-//            threads[i].start();\n-//        }\n-//\n-//        for (int i = 0; i < 50; i++) {\n-//            threads[i].join();\n-//        }\n-//\n-//    }\n-//\n-//\n-//    public class MVELThread extends Thread {\n-//        @Override\n-//        public void run() {\n-//            Cookie pookie = new Cookie();\n-//\n-//            long start = System.currentTimeMillis();\n-//            for (int i = 0; i < 50000; i++) {\n-//                MVEL.eval(\"pookie.dookies['bart'].name\", pookie);\n-//                //          if ((i % 25000 == 0)) System.out.println(\"run!\");\n-//            }\n-//            long end = System.currentTimeMillis();\n-//            System.out.println(\"50000 times for \" + this.getName() + \" was \" + (end - start));\n-//        }\n-//    }\n-//\n-//    public class Cookie {\n-//        private Pookie pookie = new Pookie();\n-//\n-//        public Pookie getPookie() {\n-//            return pookie;\n-//        }\n-//\n-//        public void setPookie(Pookie pookie) {\n-//            this.pookie = pookie;\n-//        }\n-//    }\n-//\n-//\n-//    public class Pookie {\n-//        public HashMap dookies = new HashMap();\n-//        private int age = 16;\n-//\n-//        public Pookie() {\n-//            Dookie dookie = new Dookie();\n-//            dookie.setName(\"Bart\");\n-//            this.dookies.put(\"bart\", dookie);\n-//        }\n-//\n-//        public int getAge() {\n-//            return age;\n-//        }\n-//\n-//        public void setAge(int age) {\n-//            this.age = age;\n-//        }\n-//    }\n-//\n-//    public class Dookie {\n-//        private String name;\n-//\n-//        public String getName() {\n-//            return name;\n-//        }\n-//\n-//        public void setName(String name) {\n-//            this.name = name;\n-//        }\n-//    }\n+    public void testThreadTest() throws InterruptedException {\n+        Cookie cookie = new Cookie();\n+\n+        long start = System.currentTimeMillis();\n+\n+        MVEL.eval(\"pookie.age\", cookie);\n+        long end = System.currentTimeMillis();\n+        System.out.println(\"Getting field time was \" + (end - start));\n+\n+\n+        start = System.currentTimeMillis();\n+        MVEL.eval(\"pookie.dookies['bart'].name\", cookie);\n+        end = System.currentTimeMillis();\n+        System.out.println(\"Getting property time was \" + (end - start));\n+\n+        // Loop\n+\n+        start = System.currentTimeMillis();\n+        for (int i = 0; i < 50; i++) {\n+            MVEL.eval(\"pookie.dookies['bart'].name\", cookie);\n+        }\n+        end = System.currentTimeMillis();\n+        System.out.println(\"50 times was \" + (end - start));\n+\n+\n+        MVELThread[] threads = new MVELThread[50];\n+        for (int i = 0; i < 50; i++) {\n+            threads[i] = new MVELThread();\n+            threads[i].setName(\"\" + i);\n+            threads[i].start();\n+        }\n+\n+        for (int i = 0; i < 50; i++) {\n+            threads[i].join();\n+        }\n+\n+    }\n+\n+\n+    public class MVELThread extends Thread {\n+        @Override\n+        public void run() {\n+            Cookie pookie = new Cookie();\n+\n+            long start = System.currentTimeMillis();\n+            for (int i = 0; i < 50000; i++) {\n+                MVEL.eval(\"pookie.dookies['bart'].name\", pookie);\n+            }\n+            long end = System.currentTimeMillis();\n+            System.out.println(\"50000 times for \" + this.getName() + \" was \" + (end - start));\n+        }\n+    }\n+\n+    public class Cookie {\n+        private Pookie pookie = new Pookie();\n+\n+        public Pookie getPookie() {\n+            return pookie;\n+        }\n+\n+        public void setPookie(Pookie pookie) {\n+            this.pookie = pookie;\n+        }\n+    }\n+\n+\n+    public class Pookie {\n+        public HashMap dookies = new HashMap();\n+        private int age = 16;\n+\n+        public Pookie() {\n+            Dookie dookie = new Dookie();\n+            dookie.setName(\"Bart\");\n+            this.dookies.put(\"bart\", dookie);\n+        }\n+\n+        public int getAge() {\n+            return age;\n+        }\n+\n+        public void setAge(int age) {\n+            this.age = age;\n+        }\n+    }\n+\n+    public class Dookie {\n+        private String name;\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public void setName(String name) {\n+            this.name = name;\n+        }\n+    }\n \n }\n \n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T09:03:19.138388Z", "commit_hash": "271898ba326eaf883dcf2f0a0254abaf73ebf38a", "commit_message": "parser fixes.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/util/CompilerTools.java b/src/main/java/org/mvel2/util/CompilerTools.java\nindex 2a153ff..ccfe71b 100644\n--- a/src/main/java/org/mvel2/util/CompilerTools.java\n+++ b/src/main/java/org/mvel2/util/CompilerTools.java\n@@ -59,6 +59,9 @@ public class CompilerTools {\n                     int op2;\n \n                     BinaryOperation bo = new BinaryOperation(op = tkOp.getOperator(), tk, astLinkedList.nextNode(), ctx);\n+                    if (op == -1) {\n+                        throw new CompileException(\"illegal use of operator: \" + tkOp.getName());\n+                    }\n \n                     tkOp2 = null;\n \n@@ -67,7 +70,7 @@ public class CompilerTools {\n                      * right here.\n                      */\n                     while (astLinkedList.hasMoreNodes() && (tkOp2 = astLinkedList.nextNode()).isOperator()\n-                            && tkOp2.getFields() != -1 && (op2 = tkOp2.getOperator()) < 21) {\n+                            && tkOp2.getFields() != -1 && (op2 = tkOp2.getOperator()) != -1 && op2 < 21) {\n \n                         if (PTABLE[op2] > PTABLE[op]) {\n                             bo.setRightMost(new BinaryOperation(op2, bo.getRightMost(), astLinkedList.nextNode(), ctx));\n@@ -261,9 +264,9 @@ public class CompilerTools {\n             case Operator.STR_APPEND:\n                 return String.class;\n \n-            default:\n-                throw new RuntimeException(\"unknown type: \" + operation);\n+\n         }\n+        return null;\n     }\n \n \n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\nindex 7b30355..ce60f6b 100644\n--- a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n@@ -4468,6 +4468,19 @@ public class CoreConfidenceTests extends AbstractTest {\n     public void testJIRA113() {\n         assertEquals(true, test(\"org.mvel2.tests.core.CoreConfidenceTests.minim( {456.2, 2.3} ) == 2.3\"));\n     }\n+\n+    public void testFoo() {\n+        MVEL.eval(\"{vlkm1r0q9{c=}.-;#N}.x{:Ax?beF}bqX-Ckt\\t\\n\" +\n+                \"L5+HDnaL\\t0<6pnXz1tt*KXbX,Mb<hX*e%b\\t;`!j\\n\" +\n+                \"P:9#\\n\" +\n+                \">5E,Xb:K\\n\" +\n+                \"M:zX\\n\" +\n+                \"]X#-r%&<N}@>TKJ%=r\\t(AfU%G:1PtrvFC0znl:L--#ROZJ7XHy-}\\n\" +\n+                \"-*ZXZ=U*X&-jn?/-DXPJn,pOD~>XrT<9Pv&b;~#f519B?JbX9b.w<\\n\" +\n+                \"!QtX_F~P#b-5`!H/\\n\" +\n+                \"U0w\\n\" +\n+                \"~na%-+V%?F6rdf@b)bPqV91Ybx}Jr^!b#Zm\\tR2<D<btq<-3(bXbL'9V<RInljRE?3Xb`!0J?:1N3&v6Hj -{C:F#9Hf\\tC}OtLLX9&:Jqb_<Dz}hb&b<6<CFXgNK&OS}bhVj9PHLt(%MkA1*bA%b<JB\");\n+    }\n }\n \n \n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T09:09:24.026932Z", "commit_hash": "082a9ab2f010d7db77ae328c1d8ac59ed22020e2", "commit_message": "fix to tests\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel2/util/CompilerTools.java b/src/main/java/org/mvel2/util/CompilerTools.java\nindex 4adf9c0..2a153ff 100644\n--- a/src/main/java/org/mvel2/util/CompilerTools.java\n+++ b/src/main/java/org/mvel2/util/CompilerTools.java\n@@ -198,7 +198,8 @@ public class CompilerTools {\n     public static void expectType(Accessor expression, Class type, boolean compileMode) {\n         Class retType = expression.getKnownEgressType();\n         if (compileMode) {\n-            if ((retType == null || !type.isAssignableFrom(retType)) && getCurrentThreadParserContext().isStrictTypeEnforcement()) {\n+            if ((retType == null || !type.isAssignableFrom(retType)) && (!Object.class.equals(retType)\n+                    || getCurrentThreadParserContext().isStrictTypeEnforcement())) {\n                 throw new CompileException(\"was expecting type: \" + type.getName() + \"; but found type: \"\n                         + (retType != null ? retType.getName() : \"null\"));\n             }\n@@ -212,7 +213,9 @@ public class CompilerTools {\n     public static void expectType(ASTNode node, Class type, boolean compileMode) {\n         Class retType = node.getEgressType();\n         if (compileMode) {\n-            if ((retType == null || !type.isAssignableFrom(retType)) && getCurrentThreadParserContext().isStrictTypeEnforcement()) {\n+            if ((retType == null || !type.isAssignableFrom(retType)) &&\n+                    (getCurrentThreadParserContext().isStrictTypeEnforcement()\n+                            || getCurrentThreadParserContext().isStrictTypeEnforcement())) {\n                 throw new CompileException(\"was expecting type: \" + type.getName() + \"; but found type: \"\n                         + (retType != null ? retType.getName() : \"null\"));\n             }\n", "test_patch": "diff --git a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\nindex bf4ad3b..7b30355 100644\n--- a/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel2/tests/core/CoreConfidenceTests.java\n@@ -4468,7 +4468,6 @@ public class CoreConfidenceTests extends AbstractTest {\n     public void testJIRA113() {\n         assertEquals(true, test(\"org.mvel2.tests.core.CoreConfidenceTests.minim( {456.2, 2.3} ) == 2.3\"));\n     }\n-\n }\n \n \ndiff --git a/src/test/java/org/mvel2/tests/core/FailureTests.java b/src/test/java/org/mvel2/tests/core/FailureTests.java\nindex 83e5e87..ff91162 100644\n--- a/src/test/java/org/mvel2/tests/core/FailureTests.java\n+++ b/src/test/java/org/mvel2/tests/core/FailureTests.java\n@@ -1,8 +1,6 @@\n package org.mvel2.tests.core;\n \n import org.mvel2.MVEL;\n-import org.mvel2.ParserContext;\n-import org.mvel2.compiler.ExpressionCompiler;\n \n import java.util.HashMap;\n \n@@ -72,20 +70,4 @@ public class FailureTests extends AbstractTest {\n         }\n         assertTrue(false);\n     }\n-\n-    public void testShouldFail6() {\n-        try {\n-            ParserContext ctx = new ParserContext();\n-            ctx.setStrongTyping(true);\n-\n-            new ExpressionCompiler(\"new double[] { 3, 1 }\").compile(ctx);\n-\n-        }\n-        catch (Exception e) {\n-            e.printStackTrace();\n-            return;\n-        }\n-\n-        assertTrue(false);\n-    }\n }\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T10:16:49.321832Z", "commit_hash": "00c0d347c6d4df036b0e422d7af3cb58efbedadd", "commit_message": "projections fixed.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/ast/Fold.java b/src/main/java/org/mvel/ast/Fold.java\nnew file mode 100644\nindex 0000000..d75ea98\n--- /dev/null\n+++ b/src/main/java/org/mvel/ast/Fold.java\n@@ -0,0 +1,90 @@\n+package org.mvel.ast;\n+\n+import org.mvel.compiler.ExecutableStatement;\n+import org.mvel.integration.VariableResolverFactory;\n+import org.mvel.integration.impl.DefaultLocalVariableResolverFactory;\n+import org.mvel.integration.impl.ItemResolverFactory;\n+import org.mvel.util.FastList;\n+import org.mvel.util.ParseTools;\n+import static org.mvel.util.ParseTools.isWhitespace;\n+import static org.mvel.util.ParseTools.subCompileExpression;\n+\n+import java.util.Collection;\n+import java.util.List;\n+\n+public class Fold extends ASTNode {\n+    private ExecutableStatement subEx;\n+    private ExecutableStatement dataEx;\n+    private ExecutableStatement constraintEx;\n+\n+    public Fold(char[] name) {\n+        this.name = name;\n+\n+        System.out.println(\"FOLD<<\" + new String(name) + \">>\");\n+\n+        int cursor = 0;\n+        for (; cursor < name.length; cursor++) {\n+            if (isWhitespace(name[cursor])) {\n+                while (cursor < name.length && isWhitespace(name[cursor])) cursor++;\n+\n+                if (name[cursor] == 'i' && name[cursor + 1] == 'n' && ParseTools.isJunct(name[cursor + 2])) {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        subEx = (ExecutableStatement) subCompileExpression(ParseTools.subset(name, 0, cursor - 1));\n+        int start = cursor += 2; // skip 'in'\n+\n+        for (; cursor < name.length; cursor++) {\n+            if (isWhitespace(name[cursor])) {\n+                while (cursor < name.length && isWhitespace(name[cursor])) cursor++;\n+\n+                if (name[cursor] == 'i' && name[cursor + 1] == 'f' && ParseTools.isJunct(name[cursor + 2])) {\n+                    int s = cursor + 2;\n+                    char[] xx = ParseTools.subset(name, s, name.length - s);\n+\n+                    System.out.println(\"<<\" + new String(xx) + \">>\");\n+\n+                    constraintEx = (ExecutableStatement) subCompileExpression(xx);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        dataEx = (ExecutableStatement) subCompileExpression(ParseTools.subset(name, start, cursor - start));\n+\n+\n+    }\n+\n+    public Object getReducedValueAccelerated(Object ctx, Object thisValue, VariableResolverFactory factory) {\n+        List list;\n+\n+        if (constraintEx != null) {\n+            ItemResolverFactory.ItemResolver itemR = new ItemResolverFactory.ItemResolver(\"$\");\n+            ItemResolverFactory itemFactory = new ItemResolverFactory(itemR, new DefaultLocalVariableResolverFactory(factory));\n+\n+            Collection col = ((Collection) dataEx.getValue(ctx, thisValue, factory));\n+            list = new FastList(col.size());\n+            for (Object o : col) {\n+                itemR.setValue(o);\n+                if ((Boolean) constraintEx.getValue(ctx, thisValue, itemFactory)) {\n+                    list.add(subEx.getValue(o, thisValue, factory));\n+                }\n+            }\n+        }\n+        else {\n+            Collection col = ((Collection) dataEx.getValue(ctx, thisValue, factory));\n+            list = new FastList(col.size());\n+            for (Object o : col) {\n+                list.add(subEx.getValue(o, thisValue, factory));\n+            }\n+        }\n+\n+        return list;\n+    }\n+\n+    public Object getReducedValue(Object ctx, Object thisValue, VariableResolverFactory factory) {\n+        return getReducedValueAccelerated(ctx, thisValue, factory);\n+    }\n+}\ndiff --git a/src/main/java/org/mvel/compiler/AbstractParser.java b/src/main/java/org/mvel/compiler/AbstractParser.java\nindex 73681f6..a41491f 100644\n--- a/src/main/java/org/mvel/compiler/AbstractParser.java\n+++ b/src/main/java/org/mvel/compiler/AbstractParser.java\n@@ -819,23 +819,28 @@ public class AbstractParser implements Serializable {\n                                         cursor = captureStringLiteral('\"', expr, cursor, length);\r\n                                         break;\r\n                                     case 'i':\r\n-                                        if (lookAhead() == 'n' && isWhitespace(lookAhead(2)) && !isIdentifierPart(lookBehind())) {\r\n-                                            fields |= ASTNode.FOLD;\r\n+                                        if (lookAhead() == 'n' && isWhitespace(lookAhead(2))) {\r\n+\r\n                                             for (int level = brace; cursor != length; cursor++) {\r\n                                                 switch (expr[cursor]) {\r\n                                                     case '(':\r\n                                                         brace++;\r\n                                                         break;\r\n                                                     case ')':\r\n-                                                        if (--brace != level) {\r\n-                                                            if (lookAhead() == '.') {\r\n-                                                                lastNode = createToken(expr, trimRight(start + 1), (start = cursor++), ASTNode.FOLD);\r\n+                                                        if (--brace < level) {\r\n+                                                            cursor++;\r\n+                                                            if (tokenContinues()) {\r\n+                                                                lastNode = new Fold(subset(expr, trimRight(start + 1), cursor - start - 2));\r\n+                                                                start = cursor;\r\n+                                                                if (expr[start] == '.') start++;\r\n                                                                 captureToEOT();\r\n-                                                                return lastNode = new Union(expr, trimRight(start + 2), cursor, fields, lastNode);\r\n+                                                                return lastNode = new Union(expr, trimRight(start), cursor, fields, lastNode);\r\n                                                             }\r\n                                                             else {\r\n-                                                                return createToken(expr, trimRight(start + 1), cursor++, ASTNode.FOLD);\r\n+                                                                lastNode = new Fold(subset(expr, trimRight(start + 1), cursor - start - 2));\r\n+                                                                return lastNode;\r\n                                                             }\r\n+\r\n                                                         }\r\n                                                         break;\r\n                                                     case '\\'':\r\n@@ -968,20 +973,6 @@ public class AbstractParser implements Serializable {\n                             if (expr[cursor++ + 1] == '|') {\r\n                                 return new OperatorNode(OPERATORS.get(new String(expr, start, ++cursor - start)));\r\n                             }\r\n-//                            else if (expr[cursor] == '=') {\r\n-//                                if (!isNextIdentifierOrLiteral()) {\r\n-//                                    throw new CompileException(\"unexpected symbol '\" + expr[cursor] + \"'\", expr, cursor);\r\n-//                                }\r\n-//\r\n-//                                captureToEOS();\r\n-//\r\n-//                                if ((idx = pCtx.variableIndexOf(name)) != -1) {\r\n-//                                    return lastNode = new IndexedOperativeAssign(subArray(start, cursor), ADD, idx, fields);\r\n-//                                }\r\n-//                                else {\r\n-//                                    return lastNode = new OperativeAssign(name, subArray(start, cursor), ADD, fields);\r\n-//                                }\r\n-//                            }\r\n                             else {\r\n                                 return createOperator(expr, start, cursor);\r\n                             }\r\n@@ -1538,6 +1529,7 @@ public class AbstractParser implements Serializable {\n         return false;\r\n     }\r\n \r\n+\r\n     protected void expectEOS() {\r\n         skipWhitespace();\r\n         if (cursor != length && expr[cursor] != ';') {\r\ndiff --git a/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java b/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\nindex 30a7b5f..97a65e4 100644\n--- a/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\n+++ b/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\n@@ -777,8 +777,9 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n         }\r\n \r\n         ASTNode var = nextToken();\r\n+        ASTNode var2 = nextToken();\r\n \r\n-        if (!nextToken().isOperator(Operator.PROJECTION)) {\r\n+        if (!var2.isOperator(Operator.PROJECTION)) {\r\n             throw new CompileException(\"expected fold operator\");\r\n         }\r\n \r\ndiff --git a/src/main/java/org/mvel/util/ParseTools.java b/src/main/java/org/mvel/util/ParseTools.java\nindex 25eefb6..d0d8643 100644\n--- a/src/main/java/org/mvel/util/ParseTools.java\n+++ b/src/main/java/org/mvel/util/ParseTools.java\n@@ -1772,6 +1772,16 @@ public class ParseTools {\n         return cls;\n     }\n \n+    public static boolean isJunct(char c) {\n+        switch (c) {\n+            case '[':\n+            case '(':\n+                return true;\n+            default:\n+                return isWhitespace(c);\n+        }\n+    }\n+\n     public static final class WithStatementPair implements java.io.Serializable {\n         private String parm;\n         private String value;\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/core/CoreConfidenceTests.java\nindex 3a4f9b8..6ad07a9 100644\n--- a/src/test/java/org/mvel/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/core/CoreConfidenceTests.java\n@@ -632,6 +632,25 @@ public class CoreConfidenceTests extends AbstractTest {\n         assertEquals(3, test(\"(name in things).size()\"));\n     }\n \n+    public void testProjectionSupport3() {\n+        assertEquals(\"FOO\", test(\"(toUpperCase() in ['bar', 'foo'])[1]\"));\n+    }\n+\n+    public void testProjectionSupport4() {\n+        Collection col = (Collection) test(\"(toUpperCase() in ['zero', 'zen', 'bar', 'foo'] if ($ == 'bar'))\");\n+        assertEquals(1, col.size());\n+        assertEquals(\"BAR\", col.iterator().next());\n+    }\n+\n+    public void testProjectionSupport5() {\n+        Collection col = (Collection) test(\"(toUpperCase() in ['zero', 'zen', 'bar', 'foo'] if ($.startsWith('z')))\");\n+        assertEquals(2, col.size());\n+        Iterator iter = col.iterator();\n+        assertEquals(\"ZERO\", iter.next());\n+        assertEquals(\"ZEN\", iter.next());\n+    }\n+\n+\n     public void testSizeOnInlineArray() {\n         assertEquals(3, test(\"{1,2,3}.size()\"));\n     }\n@@ -4436,10 +4455,6 @@ public class CoreConfidenceTests extends AbstractTest {\n     public void testInlineUnion() {\n         assertEquals(\"test\", test(\"{'foo', 'test'}[1]\"));\n     }\n-\n-    public void testFuzz() {\n-        test(\";2>2\\u000FX\\u000F? \\u0017!7K\\u0016>\\u001E2 \\u0012@X\\u001D%)rwZ\\u0004JjC,47`[TxS\\u0015!+r\\\\X\\t\\u0019'>f\\u0001Hp\\u0018a7'Z\\u0013.8*yl^DJt9h!+$Iyd\\u0016qy\\u0000nfw\\u0013\\u0005\\u0003\\u001FLCHd(pDV[<sE\\u0003)u\\u0016p?\\bu\\u0007#\\u0015*\\u001DqL\\u0013Qu\\u0018w=2\\u0018\\u001EU]_Q\\u001C\");\n-    }\n }\n \n \n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T10:41:57.996102Z", "commit_hash": "c762a0fc63ec918b07444c29a7fca68fdbc2740d", "commit_message": "fixed NumberFormatException\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/MVELInterpretedRuntime.java b/src/main/java/org/mvel/MVELInterpretedRuntime.java\nindex 654ce32..562a320 100644\n--- a/src/main/java/org/mvel/MVELInterpretedRuntime.java\n+++ b/src/main/java/org/mvel/MVELInterpretedRuntime.java\n@@ -135,7 +135,10 @@ public class MVELInterpretedRuntime extends AbstractParser {\n                         continue;\n                     case OP_OVERFLOW:\n                         if (!tk.isOperator()) {\n-                            throw new CompileException(\"unexpected token: \" + tk.getName());\n+                            if (!(stk.peek() instanceof Class)) {\n+                                throw new CompileException(\"unexpected token: \" + tk.getName());\n+                            }\n+                            variableFactory.createVariable(tk.getName(), null, (Class) stk.peek());\n                         }\n                         continue;\n                 }\ndiff --git a/src/main/java/org/mvel/ast/AssignmentNode.java b/src/main/java/org/mvel/ast/AssignmentNode.java\nindex ba09fe6..170a8ba 100644\n--- a/src/main/java/org/mvel/ast/AssignmentNode.java\n+++ b/src/main/java/org/mvel/ast/AssignmentNode.java\n@@ -75,7 +75,6 @@ public class AssignmentNode extends ASTNode implements Assignment {\n \r\n                 this.varName = new String(expr, 0, endOfName);\r\n                 index = new String(indexTarget, endOfName, indexTarget.length - endOfName);\r\n-                // index = subset(indexTarget, endOfName, indexTarget.length - endOfName);\r\n             }\r\n \r\n             checkNameSafety(this.varName);\r\n@@ -101,17 +100,15 @@ public class AssignmentNode extends ASTNode implements Assignment {\n         }\r\n \r\n         if (col) {\r\n-            setExpr.setValue(ctx, thisValue, factory, ctx = statement.getValue(ctx, thisValue, factory));\r\n+            return setExpr.setValue(ctx, thisValue, factory, statement.getValue(ctx, thisValue, factory));\r\n         }\r\n         else if (statement != null) {\r\n-            factory.createVariable(varName, ctx = statement.getValue(ctx, thisValue, factory));\r\n+            return factory.createVariable(varName, statement.getValue(ctx, thisValue, factory)).getValue();\r\n         }\r\n         else {\r\n             factory.createVariable(varName, null);\r\n-            return Void.class;\r\n+            return null;\r\n         }\r\n-\r\n-        return ctx;\r\n     }\r\n \r\n     public Object getReducedValue(Object ctx, Object thisValue, VariableResolverFactory factory) {\r\n@@ -121,7 +118,7 @@ public class AssignmentNode extends ASTNode implements Assignment {\n             PropertyAccessor.set(factory.getVariableResolver(varName).getValue(), factory, index, ctx = MVEL.eval(stmt, ctx, factory));\r\n         }\r\n         else {\r\n-            factory.createVariable(varName, ctx = MVEL.eval(stmt, ctx, factory));\r\n+            return factory.createVariable(varName, MVEL.eval(stmt, ctx, factory)).getValue();\r\n         }\r\n \r\n         return ctx;\r\ndiff --git a/src/main/java/org/mvel/ast/TypedVarNode.java b/src/main/java/org/mvel/ast/TypedVarNode.java\nindex e7f5a74..181d76b 100644\n--- a/src/main/java/org/mvel/ast/TypedVarNode.java\n+++ b/src/main/java/org/mvel/ast/TypedVarNode.java\n@@ -33,6 +33,11 @@ public class TypedVarNode extends ASTNode implements Assignment {\n \r\n     private ExecutableStatement statement;\r\n \r\n+    public TypedVarNode(String name, Class type) {\r\n+        this.name = name;\r\n+        this.egressType = type;\r\n+    }\r\n+\r\n     public TypedVarNode(char[] expr, int fields, Class type) {\r\n         this.egressType = type;\r\n         this.fields = fields;\r\ndiff --git a/src/main/java/org/mvel/compiler/AbstractParser.java b/src/main/java/org/mvel/compiler/AbstractParser.java\nindex 1aa7021..9f12c3d 100644\n--- a/src/main/java/org/mvel/compiler/AbstractParser.java\n+++ b/src/main/java/org/mvel/compiler/AbstractParser.java\n@@ -1071,6 +1071,12 @@ public class AbstractParser implements Serializable {\n \r\n             return createPropertyToken(start, cursor);\r\n         }\r\n+        catch (NumberFormatException e) {\r\n+            CompileException c = new CompileException(\"badly formatted number: \" + e.getMessage(), expr, cursor, e);\r\n+            c.setLineNumber(line);\r\n+            c.setColumn(cursor - lastLineStart);\r\n+            throw c;\r\n+        }\r\n         catch (StringIndexOutOfBoundsException e) {\r\n             CompileException c = new CompileException(\"unexpected end of statement\", expr, cursor, e);\r\n             c.setLineNumber(line);\r\ndiff --git a/src/main/java/org/mvel/integration/VariableResolver.java b/src/main/java/org/mvel/integration/VariableResolver.java\nindex 2c8b4ad..385bc59 100644\n--- a/src/main/java/org/mvel/integration/VariableResolver.java\n+++ b/src/main/java/org/mvel/integration/VariableResolver.java\n@@ -65,6 +65,7 @@ public interface VariableResolver extends Serializable {\n      * Sets the value of the physical target value.\r\n      *\r\n      * @param value The new value.\r\n+     * @return value after any conversion\r\n      */\r\n     public void setValue(Object value);\r\n }\r\ndiff --git a/src/main/java/org/mvel/templates/TemplateCompiler.java b/src/main/java/org/mvel/templates/TemplateCompiler.java\nindex 28b1e33..5708639 100644\n--- a/src/main/java/org/mvel/templates/TemplateCompiler.java\n+++ b/src/main/java/org/mvel/templates/TemplateCompiler.java\n@@ -90,8 +90,8 @@ public class TemplateCompiler {\n                                     /**\n                                      * Capture any residual text node, and push the if statement on the nesting stack.\n                                      */\n-                                    stack.push(n = markTextNode(n).setNext(\n-                                            new IfNode(start, name, template, captureOrbInternal(), start)));\n+                                    stack.push(n = markTextNode(n).next =\n+                                            new IfNode(start, name, template, captureOrbInternal(), start));\n \n                                     n.setTerminus(new TerminalNode());\n \n@@ -99,10 +99,10 @@ public class TemplateCompiler {\n \n                                 case Opcodes.ELSE:\n                                     if (!stack.isEmpty() && stack.peek() instanceof IfNode) {\n-                                        markTextNode(n).setNext((last = (IfNode) stack.pop()).getTerminus());\n+                                        markTextNode(n).next = (last = (IfNode) stack.pop()).getTerminus();\n \n                                         last.demarcate(last.getTerminus(), template);\n-                                        last.setNext(n = new IfNode(start, name, template, captureOrbInternal(), start));\n+                                        last.next = n = new IfNode(start, name, template, captureOrbInternal(), start);\n                                         n.setTerminus(last.getTerminus());\n \n                                         stack.push(n);\n@@ -111,7 +111,7 @@ public class TemplateCompiler {\n \n                                 case Opcodes.FOREACH:\n                                     stack.push(\n-                                            n = markTextNode(n).setNext(new ForEachNode(start, name, template, captureOrbInternal(), start))\n+                                            n = markTextNode(n).next = new ForEachNode(start, name, template, captureOrbInternal(), start)\n                                     );\n \n                                     n.setTerminus(new TerminalNode());\n@@ -119,32 +119,32 @@ public class TemplateCompiler {\n                                     break;\n \n                                 case Opcodes.INCLUDE_FILE:\n-                                    n = markTextNode(n).setNext(\n-                                            new IncludeNode(start, name, template, captureOrbInternal(), start = cursor + 1)\n-                                    );\n+                                    n = markTextNode(n).next =\n+                                            new IncludeNode(start, name, template, captureOrbInternal(), start = cursor + 1\n+                                            );\n                                     break;\n \n                                 case Opcodes.INCLUDE_NAMED:\n-                                    n = markTextNode(n).setNext(\n-                                            new NamedIncludeNode(start, name, template, captureOrbInternal(), start = cursor + 1)\n-                                    );\n+                                    n = markTextNode(n).next =\n+                                            new NamedIncludeNode(start, name, template, captureOrbInternal(), start = cursor + 1\n+                                            );\n                                     break;\n \n                                 case Opcodes.CODE:\n                                     n = markTextNode(n)\n-                                            .setNext(new CodeNode(start, name, template, captureOrbInternal(), start = cursor + 1));\n+                                            .next = new CodeNode(start, name, template, captureOrbInternal(), start = cursor + 1);\n                                     break;\n \n                                 case Opcodes.COMMENT:\n                                     n = markTextNode(n)\n-                                            .setNext(new CommentNode(start, name, template, captureOrbInternal(), start = cursor + 1));\n+                                            .next = new CommentNode(start, name, template, captureOrbInternal(), start = cursor + 1);\n \n                                     break;\n \n                                 case Opcodes.DECLARE:\n-                                    stack.push(n = markTextNode(n).setNext(\n-                                            new DeclareNode(start, name, template, captureOrbInternal(), start = cursor + 1)\n-                                    ));\n+                                    stack.push(n = markTextNode(n).next =\n+                                            new DeclareNode(start, name, template, captureOrbInternal(), start = cursor + 1\n+                                            ));\n \n                                     n.setTerminus(new TerminalNode());\n \n@@ -160,21 +160,21 @@ public class TemplateCompiler {\n                                     terminal.setEnd((lastTextRangeEnding = start) - 1);\n                                     terminal.calculateContents(template);\n \n-                                    if (end.demarcate(terminal, template)) n = n.setNext(terminal);\n+                                    if (end.demarcate(terminal, template)) n = n.next = terminal;\n                                     else n = terminal;\n \n                                     break;\n \n                                 default:\n                                     if (name.length() == 0) {\n-                                        n = markTextNode(n).setNext(\n-                                                new ExpressionNode(start, name, template, captureOrbInternal(), start = cursor + 1));\n+                                        n = markTextNode(n).next =\n+                                                new ExpressionNode(start, name, template, captureOrbInternal(), start = cursor + 1);\n                                     }\n                                     else if (customNodes != null && customNodes.containsKey(name)) {\n                                         Class<? extends Node> customNode = customNodes.get(name);\n \n                                         try {\n-                                            (n = markTextNode(n).setNext(customNode.newInstance())).setBegin(start);\n+                                            (n = markTextNode(n).next = (customNode.newInstance())).setBegin(start);\n                                             n.setName(name);\n                                             n.setCStart(captureOrbInternal());\n                                             n.setCEnd(start = cursor + 1);\n@@ -228,9 +228,9 @@ public class TemplateCompiler {\n         }\n \n         if (start < template.length) {\n-            n = n.setNext(new TextNode(start, template.length));\n+            n = n.next = new TextNode(start, template.length);\n         }\n-        n.setNext(new EndNode());\n+        n.next = new EndNode();\n \n         n = root;\n         do {\n@@ -293,7 +293,7 @@ public class TemplateCompiler {\n         int s = (n.getEnd() > lastTextRangeEnding ? n.getEnd() : lastTextRangeEnding);\n \n         if (s < start) {\n-            return n.setNext(new TextNode(s, lastTextRangeEnding = start - 1));\n+            return n.next = new TextNode(s, lastTextRangeEnding = start - 1);\n         }\n         return n;\n     }\ndiff --git a/src/main/java/org/mvel/templates/res/DeclareNode.java b/src/main/java/org/mvel/templates/res/DeclareNode.java\nindex 21ab76b..6f09513 100644\n--- a/src/main/java/org/mvel/templates/res/DeclareNode.java\n+++ b/src/main/java/org/mvel/templates/res/DeclareNode.java\n@@ -1,12 +1,12 @@\n package org.mvel.templates.res;\n \n+import org.mvel.MVEL;\n import org.mvel.integration.VariableResolverFactory;\n-import org.mvel.templates.TemplateRuntime;\n-import org.mvel.templates.SimpleTemplateRegistry;\n import org.mvel.templates.CompiledTemplate;\n+import org.mvel.templates.SimpleTemplateRegistry;\n+import org.mvel.templates.TemplateRuntime;\n import static org.mvel.util.ParseTools.subset;\n import org.mvel.util.StringAppender;\n-import org.mvel.MVEL;\n \n public class DeclareNode extends Node {\n     private Node nestedNode;\n@@ -22,7 +22,7 @@ public class DeclareNode extends Node {\n             runtime.setNamedTemplateRegistry(new SimpleTemplateRegistry());\n         }\n \n-    //   String name = MVEL.eval(contents, ctx, factory, String.class);\n+        //   String name = MVEL.eval(contents, ctx, factory, String.class);\n \n         runtime.getNamedTemplateRegistry()\n                 .addNamedTemplate(MVEL.eval(contents, ctx, factory, String.class),\n@@ -34,8 +34,9 @@ public class DeclareNode extends Node {\n     public boolean demarcate(Node terminatingNode, char[] template) {\n         Node n = nestedNode = next;\n \n-        while (n.getNext() != null) n = n.getNext();\n-        n.setNext(new EndNode());\n+        while (n.getNext() != null) n = n.next;\n+\n+        n.next = new EndNode();\n \n         next = terminus;\n         return false;\ndiff --git a/src/main/java/org/mvel/templates/res/Node.java b/src/main/java/org/mvel/templates/res/Node.java\nindex b72ea46..342d902 100644\n--- a/src/main/java/org/mvel/templates/res/Node.java\n+++ b/src/main/java/org/mvel/templates/res/Node.java\n@@ -1,9 +1,9 @@\n package org.mvel.templates.res;\n \n-import org.mvel.util.StringAppender;\n-import static org.mvel.util.ParseTools.subset;\n import org.mvel.integration.VariableResolverFactory;\n import org.mvel.templates.TemplateRuntime;\n+import static org.mvel.util.ParseTools.subset;\n+import org.mvel.util.StringAppender;\n \n import java.io.Serializable;\n \n@@ -14,7 +14,7 @@ public abstract class Node implements Serializable {\n     protected int cStart;\n     protected int cEnd;\n     protected int end;\n-    protected Node next;\n+    public Node next;\n     protected Node terminus;\n \n     public Node() {\ndiff --git a/src/main/java/org/mvel/util/CompilerTools.java b/src/main/java/org/mvel/util/CompilerTools.java\nindex 1445b7e..54d430c 100644\n--- a/src/main/java/org/mvel/util/CompilerTools.java\n+++ b/src/main/java/org/mvel/util/CompilerTools.java\n@@ -97,6 +97,9 @@ public class CompilerTools {\n                         optimizedAst.addTokenNode(tkOp2);\n                     }\n                 }\n+                else if (!tkOp.isOperator() && tk.getLiteralValue() instanceof Class) {\n+                    optimizedAst.addTokenNode(new DeclTypedVarNode(tkOp.getName(), (Class) tk.getLiteralValue(), 0));\n+                }\n                 else if (tkOp.isOperator(Operator.REGEX)) {\n                     optimizedAst.addTokenNode(new RegExMatchNode(tk, astLinkedList.nextNode()));\n                 }\n@@ -196,12 +199,13 @@ public class CompilerTools {\n         Class retType = expression.getKnownEgressType();\n         if (compileMode && getCurrentThreadParserContext().isStrictTypeEnforcement()) {\n             if (retType == null || !type.isAssignableFrom(retType)) {\n-                           throw new CompileException(\"was expecting type: \" + type.getName() + \"; but found type: \"\n-                        + (retType != null ? retType.getName() : \"null\"));            }\n-        }\n-        else if (retType == null || !Object.class.equals(retType) &&  !type.isAssignableFrom(retType)) {\n-                           throw new CompileException(\"was expecting type: \" + type.getName() + \"; but found type: \"\n+                throw new CompileException(\"was expecting type: \" + type.getName() + \"; but found type: \"\n                         + (retType != null ? retType.getName() : \"null\"));\n+            }\n+        }\n+        else if (retType == null || !Object.class.equals(retType) && !type.isAssignableFrom(retType)) {\n+            throw new CompileException(\"was expecting type: \" + type.getName() + \"; but found type: \"\n+                    + (retType != null ? retType.getName() : \"null\"));\n         }\n     }\n }\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/core/CoreConfidenceTests.java\nindex a240621..ab47187 100644\n--- a/src/test/java/org/mvel/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/core/CoreConfidenceTests.java\n@@ -4422,6 +4422,17 @@ public class CoreConfidenceTests extends AbstractTest {\n \n         MVEL.COMPILER_OPT_ALLOW_NAKED_METH_CALL = false;\n     }\n+\n+    public void testDecl() {\n+        assertEquals((char) 100, test(\"char c; c = 100; c\"));\n+    }\n+\n+    public void testThis() {\n+        test(\"aO`7.y10wx\\u00105eL\\u001BO\\u0010\\u0010bI\\n\" +\n+                \"MuC\\u0006w\\u0018&t[\\u00159oRij_&]8Mng/Dh\\u0010'j\\f_\\u0015|/Dm:\\\\6uU\\u0010Z>B\\u001E ^\\u000F4\\u000B`\\u000Bpo>ap>Nyv&\\u001Dd\\u0011y86$?\\u000F2DT\\u0010T$\\u0015\\u0002[\\u0017\\tS\\u0015S&LB!R\\u00114\\u0011]\\\\>(Y\\u0015x$G4X\\u0005:u\");\n+\n+\n+    }\n }\n \n \n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T10:54:57.475868Z", "commit_hash": "778f002a20017e39e0587026054051fe50399ed7", "commit_message": "array compiling fixed in JIT.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/ast/NewObjectNode.java b/src/main/java/org/mvel/ast/NewObjectNode.java\nindex fb7cc23..43a18bd 100644\n--- a/src/main/java/org/mvel/ast/NewObjectNode.java\n+++ b/src/main/java/org/mvel/ast/NewObjectNode.java\n@@ -218,7 +218,7 @@ public class NewObjectNode extends ASTNode {\n             }\r\n         }\r\n         catch (ClassNotFoundException e) {\r\n-            throw new CompileException(\"unable to resolve class: \" + e.getMessage());\r\n+            throw new CompileException(\"unable to resolve class: \" + e.getMessage(), e);\r\n         }\r\n         catch (NoSuchMethodException e) {\r\n             throw new CompileException(\"cannot resolve constructor: \" + e.getMessage());\r\ndiff --git a/src/main/java/org/mvel/ast/TypeDescriptor.java b/src/main/java/org/mvel/ast/TypeDescriptor.java\nindex 89354f5..3a8b781 100644\n--- a/src/main/java/org/mvel/ast/TypeDescriptor.java\n+++ b/src/main/java/org/mvel/ast/TypeDescriptor.java\n@@ -2,16 +2,16 @@ package org.mvel.ast;\n \n import org.mvel.CompileException;\n import org.mvel.ParserContext;\n-import org.mvel.integration.VariableResolverFactory;\n import static org.mvel.ast.ASTNode.COMPILE_IMMEDIATE;\n import org.mvel.compiler.ExecutableStatement;\n+import org.mvel.integration.VariableResolverFactory;\n import static org.mvel.util.ArrayTools.findFirst;\n import static org.mvel.util.ParseTools.*;\n \n import java.io.Serializable;\n+import static java.lang.Character.isDigit;\n import java.util.Iterator;\n import java.util.LinkedList;\n-import static java.lang.Character.isDigit;\n \n public class TypeDescriptor implements Serializable {\n     private String className;\n@@ -28,7 +28,7 @@ public class TypeDescriptor implements Serializable {\n \n     public void updateClassName(char[] name, int fields) {\n         if (name.length == 0 || isDigit(name[0])) return;\n-        \n+\n         if ((endRange = findFirst('(', name)) == -1) {\n             if ((endRange = findFirst('[', name)) != -1) {\n                 className = new String(name, 0, endRange);\n@@ -39,11 +39,11 @@ public class TypeDescriptor implements Serializable {\n                 while (endRange < name.length) {\n                     while (endRange < name.length && isWhitespace(name[endRange])) endRange++;\n \n-                    if (endRange == name.length) break;\n+                    if (endRange == name.length || name[endRange] == '{') break;\n \n-                    if (name[endRange] != '[')\n+                    if (name[endRange] != '[') {\n                         throw new CompileException(\"unexpected token in contstructor\", name, endRange);\n-\n+                    }\n                     to = balancedCapture(name, endRange, '[');\n                     sizes.add(subset(name, ++endRange, to - endRange));\n                     endRange = to + 1;\ndiff --git a/src/main/java/org/mvel/compiler/AbstractParser.java b/src/main/java/org/mvel/compiler/AbstractParser.java\nindex 3644f1d..5668367 100644\n--- a/src/main/java/org/mvel/compiler/AbstractParser.java\n+++ b/src/main/java/org/mvel/compiler/AbstractParser.java\n@@ -253,11 +253,25 @@ public class AbstractParser implements Serializable {\n                                     throw new CompileException(\"unexpected character (expected identifier): \" + expr[cursor], expr, cursor);\r\n                                 }\r\n \r\n-                                captureToEOT();\r\n+                                /**\r\n+                                 * Capture the beginning part of the token.\r\n+                                 */\r\n+                                do {\r\n+                                    captureToNextTokenJunction();\r\n+                                    skipWhitespaceWithLineAccounting();\r\n+                                }\r\n+                                while (cursor < length && expr[cursor] == '[');\r\n+\r\n+                                /**\r\n+                                 * If it's not a dimentioned array, continue capturing if necessary.\r\n+                                 */\r\n+                                if (cursor < length && expr[cursor - 2] != ']') captureToEOT();\r\n+\r\n                                 lastNode = new NewObjectNode(subArray(start, cursor), fields);\r\n \r\n                                 skipWhitespaceWithLineAccounting();\r\n                                 if (cursor != length && expr[cursor] == '{') {\r\n+                                    start = cursor;\r\n                                     Class egressType = ((NewObjectNode) lastNode).getEgressType();\r\n \r\n                                     if (egressType == null) {\r\n@@ -280,9 +294,7 @@ public class AbstractParser implements Serializable {\n                                         return lastNode = new InlineCollectionNode(expr, start, cursor, fields,\r\n                                                 egressType);\r\n                                     }\r\n-\r\n                                 }\r\n-\r\n                                 return lastNode;\r\n \r\n                             case ASSERT:\r\n@@ -1690,6 +1702,63 @@ public class AbstractParser implements Serializable {\n         while (++cursor != length);\r\n     }\r\n \r\n+    protected void captureToEOTNEW() {\r\n+        skipWhitespace();\r\n+        boolean dims = false;\r\n+        do {\r\n+            switch (expr[cursor]) {\r\n+                case '{':\r\n+                    if (dims) return;\r\n+\r\n+                case '[':\r\n+                    dims = true;\r\n+                    if ((cursor = balancedCapture(expr, cursor, expr[cursor])) == -1) {\r\n+                        throw new CompileException(\"unbalanced braces\", expr, cursor);\r\n+                    }\r\n+                    break;\r\n+                case '(':\r\n+                    if ((cursor = balancedCapture(expr, cursor, expr[cursor])) == -1) {\r\n+                        throw new CompileException(\"unbalanced braces\", expr, cursor);\r\n+                    }\r\n+                    break;\r\n+\r\n+                case '=':\r\n+                case '&':\r\n+                case '|':\r\n+                case ';':\r\n+                    return;\r\n+\r\n+                case '.':\r\n+                    skipWhitespace();\r\n+                    break;\r\n+\r\n+                case '\\'':\r\n+                    cursor = captureStringLiteral('\\'', expr, cursor, length);\r\n+                    break;\r\n+                case '\"':\r\n+                    cursor = captureStringLiteral('\"', expr, cursor, length);\r\n+                    break;\r\n+\r\n+                default:\r\n+                    if (isWhitespace(expr[cursor])) {\r\n+                        skipWhitespace();\r\n+\r\n+                        if (expr[cursor] == '.') {\r\n+                            if (cursor != length) cursor++;\r\n+                            skipWhitespace();\r\n+                            break;\r\n+                        }\r\n+                        else {\r\n+                            trimWhitespace();\r\n+                            return;\r\n+                        }\r\n+                    }\r\n+            }\r\n+        }\r\n+        while (++cursor != length);\r\n+    }\r\n+\r\n+\r\n     /**\r\n      * From the specified cursor position, trim out any whitespace between the current position and the end of the\r\n      * last non-whitespace character.\r\n@@ -1749,8 +1818,16 @@ public class AbstractParser implements Serializable {\n                 case '{':\r\n                 case '(':\r\n                     return;\r\n+                case '[':\r\n+                    int[] c = balancedCaptureWithLineAccounting(expr, cursor, '[');\r\n+                    cursor = c[0] + 1;\r\n+                    line += c[1];\r\n+                    continue;\r\n+\r\n                 default:\r\n-                    if (isWhitespace(expr[cursor])) return;\r\n+                    if (isWhitespace(expr[cursor])) {\r\n+                        return;\r\n+                    }\r\n                     cursor++;\r\n             }\r\n         }\r\ndiff --git a/src/main/java/org/mvel/optimizers/impl/asm/ASMAccessorOptimizer.java b/src/main/java/org/mvel/optimizers/impl/asm/ASMAccessorOptimizer.java\nindex a298d02..62fd24c 100644\n--- a/src/main/java/org/mvel/optimizers/impl/asm/ASMAccessorOptimizer.java\n+++ b/src/main/java/org/mvel/optimizers/impl/asm/ASMAccessorOptimizer.java\n@@ -47,7 +47,8 @@ import org.mvel.optimizers.impl.refl.Union;\n import static org.mvel.util.ArrayTools.findFirst;\r\n import org.mvel.util.*;\r\n import static org.mvel.util.ParseTools.*;\r\n-import static org.mvel.util.PropertyTools.*;\r\n+import static org.mvel.util.PropertyTools.getFieldOrAccessor;\r\n+import static org.mvel.util.PropertyTools.getFieldOrWriteAccessor;\r\n \r\n import java.io.FileWriter;\r\n import java.io.IOException;\r\n@@ -537,7 +538,7 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n         }\r\n         catch (VerifyError e) {\r\n             System.out.println(\"**** COMPILER BUG! REPORT THIS IMMEDIATELY AT http://jira.codehaus.org/browse/mvel\");\r\n-            System.out.println(\"Expression: \" + new String(expr));\r\n+            System.out.println(\"Expression: \" + (expr == null ? null : new String(expr)));\r\n             throw e;\r\n         }\r\n \r\n@@ -2077,7 +2078,7 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n     private static final int MAP = 2;\r\n     private static final int VAL = 3;\r\n \r\n-    private int _getAccessor(Object o) {\r\n+    private int _getAccessor(Object o, Class type) {\r\n         if (o instanceof List) {\r\n             assert debug(\"NEW \" + LIST_IMPL);\r\n             mv.visitTypeInsn(NEW, LIST_IMPL);\r\n@@ -2093,7 +2094,7 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n             mv.visitMethodInsn(INVOKESPECIAL, LIST_IMPL, \"<init>\", \"(I)V\");\r\n \r\n             for (Object item : (List) o) {\r\n-                if (_getAccessor(item) != VAL) {\r\n+                if (_getAccessor(item, type) != VAL) {\r\n                     assert debug(\"POP\");\r\n                     mv.visitInsn(POP);\r\n                 }\r\n@@ -2130,11 +2131,11 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n             for (Object item : ((Map) o).keySet()) {\r\n                 mv.visitTypeInsn(CHECKCAST, \"java/util/Map\");\r\n \r\n-                if (_getAccessor(item) != VAL) {\r\n+                if (_getAccessor(item, type) != VAL) {\r\n                     assert debug(\"POP\");\r\n                     mv.visitInsn(POP);\r\n                 }\r\n-                if (_getAccessor(((Map) o).get(item)) != VAL) {\r\n+                if (_getAccessor(((Map) o).get(item), type) != VAL) {\r\n                     assert debug(\"POP\");\r\n                     mv.visitInsn(POP);\r\n                 }\r\n@@ -2154,45 +2155,52 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n             return MAP;\r\n         }\r\n         else if (o instanceof Object[]) {\r\n-            intPush(((Object[]) o).length);\r\n+            Accessor[] a = new Accessor[((Object[]) o).length];\r\n+            int i = 0;\r\n+            int dim = 0;\r\n \r\n-            try {\r\n-                if (returnType != null) {\r\n-                    returnType = findClass(null, repeatChar('[', 1) + \"L\" + getBaseComponentType(returnType).getName() + \";\");\r\n-                }\r\n-                else {\r\n-                    returnType = Object[].class;\r\n-                }\r\n+            if (type != null) {\r\n+                String nm = type.getName();\r\n+                while (nm.charAt(dim) == '[') dim++;\r\n             }\r\n-            catch (ClassNotFoundException e) {\r\n-                throw new CompileException(\"cannot instantiate class\", e);\r\n+            else {\r\n+                type = Object[].class;\r\n+                dim = 1;\r\n             }\r\n \r\n+            try {\r\n+                intPush(((Object[]) o).length);\r\n+                assert debug(\"ANEWARRAY \" + getInternalName(getSubComponentType(type)) + \" (\" + ((Object[]) o).length + \")\");\r\n+                mv.visitTypeInsn(ANEWARRAY, getInternalName(getSubComponentType(type)));\r\n \r\n-            assert debug(\"ANEWARRAY (\" + o.hashCode() + \")\");\r\n-            mv.visitTypeInsn(ANEWARRAY, getInternalName(getBaseComponentType(returnType)));\r\n+                Class cls = dim > 1 ? findClass(null, repeatChar('[', dim - 1) + \"L\" + getBaseComponentType(type).getName() + \";\")\r\n+                        : type;\r\n \r\n-            assert debug(\"DUP\");\r\n-            mv.visitInsn(DUP);\r\n \r\n-            int i = 0;\r\n-            for (Object item : (Object[]) o) {\r\n-                intPush(i);\r\n+                assert debug(\"DUP\");\r\n+                mv.visitInsn(DUP);\r\n \r\n-                if (_getAccessor(item) != VAL) {\r\n-                    assert debug(\"POP\");\r\n-                    mv.visitInsn(POP);\r\n-                }\r\n+                for (Object item : (Object[]) o) {\r\n+                    intPush(i);\r\n \r\n-                assert debug(\"AASTORE (\" + o.hashCode() + \")\");\r\n-                mv.visitInsn(AASTORE);\r\n+                    if (_getAccessor(item, cls) != VAL) {\r\n+                        assert debug(\"POP\");\r\n+                        mv.visitInsn(POP);\r\n+                    }\r\n \r\n-                assert debug(\"DUP\");\r\n-                mv.visitInsn(DUP);\r\n+                    assert debug(\"AASTORE (\" + o.hashCode() + \")\");\r\n+                    mv.visitInsn(AASTORE);\r\n \r\n-                i++;\r\n-            }\r\n+                    assert debug(\"DUP\");\r\n+                    mv.visitInsn(DUP);\r\n+\r\n+                    i++;\r\n+                }\r\n \r\n+            }\r\n+            catch (ClassNotFoundException e) {\r\n+                throw new RuntimeException(\"this error should never throw:\" + getBaseComponentType(type).getName(), e);\r\n+            }\r\n \r\n             return ARRAY;\r\n         }\r\n@@ -2281,7 +2289,7 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n \r\n         literal = true;\r\n \r\n-        _getAccessor(o);\r\n+        _getAccessor(o, type);\r\n \r\n \r\n         _finishJIT();\r\n@@ -2477,7 +2485,7 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n     private void dumpAdvancedDebugging() {\r\n         if (buildLog == null) return;\r\n \r\n-        System.out.println(\"JIT Compiler Dump for: <<\" + new String(expr) + \">>\\n-------------------------------\\n\");\r\n+        System.out.println(\"JIT Compiler Dump for: <<\" + (expr == null ? null : new String(expr)) + \">>\\n-------------------------------\\n\");\r\n         System.out.println(buildLog.toString());\r\n         System.out.println(\"\\n<END OF DUMP>\\n\");\r\n         if (MVEL.isFileDebugging()) {\r\ndiff --git a/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java b/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\nindex 9833e72..16beb81 100644\n--- a/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\n+++ b/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\n@@ -668,13 +668,13 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n         return rootNode.getValue(ctx, elCtx, variableFactory);\r\n     }\r\n \r\n-    private Accessor _getAccessor(Object o) {\r\n+    private Accessor _getAccessor(Object o, Class type) {\r\n         if (o instanceof List) {\r\n             Accessor[] a = new Accessor[((List) o).size()];\r\n             int i = 0;\r\n \r\n             for (Object item : (List) o) {\r\n-                a[i++] = _getAccessor(item);\r\n+                a[i++] = _getAccessor(item, type);\r\n             }\r\n \r\n             returnType = List.class;\r\n@@ -687,8 +687,8 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n             int i = 0;\r\n \r\n             for (Object item : ((Map) o).keySet()) {\r\n-                k[i] = _getAccessor(item); // key\r\n-                v[i++] = _getAccessor(((Map) o).get(item)); // value\r\n+                k[i] = _getAccessor(item, type); // key\r\n+                v[i++] = _getAccessor(((Map) o).get(item), type); // value\r\n             }\r\n \r\n             returnType = Map.class;\r\n@@ -698,25 +698,30 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n         else if (o instanceof Object[]) {\r\n             Accessor[] a = new Accessor[((Object[]) o).length];\r\n             int i = 0;\r\n+            int dim = 0;\r\n \r\n-            for (Object item : (Object[]) o) {\r\n-                a[i++] = _getAccessor(item); // item\r\n+            if (type != null) {\r\n+                String nm = type.getName();\r\n+                while (nm.charAt(dim) == '[') dim++;\r\n+            }\r\n+            else {\r\n+                type = Object[].class;\r\n+                dim = 1;\r\n             }\r\n \r\n             try {\r\n-                if (returnType != null) {\r\n-                    returnType = findClass(null, repeatChar('[', 1)\r\n-                            + \"L\" + getBaseComponentType(returnType).getName() + \";\");\r\n-                }\r\n-                else {\r\n-                    returnType = Object[].class;\r\n+                Class cls = dim > 1 ? findClass(null, repeatChar('[', dim - 1) + \"L\" + getBaseComponentType(type).getName() + \";\")\r\n+                        : type;\r\n+\r\n+                for (Object item : (Object[]) o) {\r\n+                    a[i++] = _getAccessor(item, cls); // item\r\n                 }\r\n+\r\n+                return new ArrayCreator(a, getSubComponentType(type));\r\n             }\r\n             catch (ClassNotFoundException e) {\r\n-                throw new CompileException(\"cannot instantiate class\", e);\r\n+                throw new RuntimeException(\"this error should never throw:\" + getBaseComponentType(type).getName(), e);\r\n             }\r\n-\r\n-            return new ArrayCreator(a, getBaseComponentType(returnType));\r\n         }\r\n         else {\r\n             if (returnType == null) returnType = Object.class;\r\n@@ -724,9 +729,10 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n         }\r\n     }\r\n \r\n+\r\n     public Accessor optimizeCollection(Object o, Class type, char[] property, Object ctx, Object thisRef, VariableResolverFactory factory) {\r\n         this.returnType = type;\r\n-        Accessor root = _getAccessor(o);\r\n+        Accessor root = _getAccessor(o, returnType);\r\n \r\n         if (property != null && property.length > 0) {\r\n             return new Union(root, property);\r\ndiff --git a/src/main/java/org/mvel/optimizers/impl/refl/collection/ArrayCreator.java b/src/main/java/org/mvel/optimizers/impl/refl/collection/ArrayCreator.java\nindex f13a8c7..b26bbd3 100644\n--- a/src/main/java/org/mvel/optimizers/impl/refl/collection/ArrayCreator.java\n+++ b/src/main/java/org/mvel/optimizers/impl/refl/collection/ArrayCreator.java\n@@ -43,8 +43,10 @@ public class ArrayCreator implements Accessor {\n         else {\r\n             Object newArray = newInstance(arrayType, template.length);\r\n \r\n-            for (int i = 0; i < template.length; i++)\r\n-                Array.set(newArray, i, template[i].getValue(ctx, elCtx, variableFactory));\r\n+            for (int i = 0; i < template.length; i++) {\r\n+                Object o = template[i].getValue(ctx, elCtx, variableFactory);\r\n+                Array.set(newArray, i, o);\r\n+            }\r\n \r\n             return newArray;\r\n         }\r\ndiff --git a/src/main/java/org/mvel/optimizers/impl/refl/collection/MDArrayCreator.java b/src/main/java/org/mvel/optimizers/impl/refl/collection/MDArrayCreator.java\nnew file mode 100644\nindex 0000000..5047e2d\n--- /dev/null\n+++ b/src/main/java/org/mvel/optimizers/impl/refl/collection/MDArrayCreator.java\n@@ -0,0 +1,66 @@\n+/**\r\n+ * MVEL (The MVFLEX Expression Language)\r\n+ *\r\n+ * Copyright (C) 2007 Christopher Brock, MVFLEX/Valhalla Project and the Codehaus\r\n+ *\r\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ *\r\n+ */\r\n+package org.mvel.optimizers.impl.refl.collection;\r\n+\r\n+import org.mvel.compiler.Accessor;\r\n+import org.mvel.integration.VariableResolverFactory;\r\n+\r\n+import java.lang.reflect.Array;\r\n+import static java.lang.reflect.Array.newInstance;\r\n+\r\n+/**\r\n+ * @author Christopher Brock\r\n+ */\r\n+public class MDArrayCreator implements Accessor {\r\n+    public Accessor[] template;\r\n+    private Class arrayType;\r\n+    private int dimension;\r\n+\r\n+    public Object getValue(Object ctx, Object elCtx, VariableResolverFactory variableFactory) {\r\n+        if (Object.class.equals(arrayType)) {\r\n+            Object[] newArray = new Object[template.length];\r\n+\r\n+            for (int i = 0; i < newArray.length; i++)\r\n+                newArray[i] = template[i].getValue(ctx, elCtx, variableFactory);\r\n+\r\n+            return newArray;\r\n+        }\r\n+        else {\r\n+            Object newArray = newInstance(arrayType, template.length);\r\n+\r\n+            for (int i = 0; i < template.length; i++) {\r\n+                Object o = template[i].getValue(ctx, elCtx, variableFactory);\r\n+                Array.set(newArray, i, o);\r\n+            }\r\n+\r\n+            return newArray;\r\n+        }\r\n+    }\r\n+\r\n+    public MDArrayCreator(Accessor[] template, Class arrayType, int dimension) {\r\n+        this.template = template;\r\n+        this.arrayType = arrayType;\r\n+        this.dimension = dimension;\r\n+    }\r\n+\r\n+\r\n+    public Object setValue(Object ctx, Object elCtx, VariableResolverFactory variableFactory, Object value) {\r\n+        return null;\r\n+    }\r\n+}\n\\ No newline at end of file\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/AccessorBMModel.java b/src/test/java/org/mvel/tests/AccessorBMModel.java\nindex e5cd03d..43a2e19 100644\n--- a/src/test/java/org/mvel/tests/AccessorBMModel.java\n+++ b/src/test/java/org/mvel/tests/AccessorBMModel.java\n@@ -3,20 +3,17 @@ package org.mvel.tests;\n import org.mvel.compiler.Accessor;\r\n import org.mvel.compiler.ExecutableStatement;\r\n import org.mvel.integration.VariableResolverFactory;\r\n-import org.mvel.tests.core.res.Foo;\r\n \r\n \r\n public class AccessorBMModel implements Accessor {\r\n     private ExecutableStatement p0;\r\n-    private ExecutableStatement p1;\r\n \r\n     public Object getValue(Object ctx, Object elCtx, VariableResolverFactory variableFactory) {\r\n-        p0.setValue(ctx, elCtx, variableFactory, p1.getValue(ctx, elCtx, variableFactory));  \r\n-        return ctx;\r\n+        return new String[][]{{\"2008-04-01\", \"2008-05-10\"}, {\"2007-03-01\", \"2007-02-12\"}};\r\n     }\r\n \r\n     public Object setValue(Object ctx, Object elCtx, VariableResolverFactory variableFactory, Object value) {\r\n-       // ((List) ctx).set(55, value);\r\n-    \treturn ((String[]) ctx)[(Integer) p0.getValue(ctx, variableFactory)] = (String) value;\r\n+        // ((List) ctx).set(55, value);\r\n+        return ((String[]) ctx)[(Integer) p0.getValue(ctx, variableFactory)] = (String) value;\r\n     }\r\n }\r\ndiff --git a/src/test/java/org/mvel/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/core/CoreConfidenceTests.java\nindex fb87ec1..aa986f8 100644\n--- a/src/test/java/org/mvel/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/core/CoreConfidenceTests.java\n@@ -4373,21 +4373,30 @@ public class CoreConfidenceTests extends AbstractTest {\n     }\n \n     public void testNumLiterals8() {\n-        assertEquals(0.0, MVEL.eval(\"0.0\"));\n+        assertEquals(1e-9d, MVEL.eval(\"1e-9d\"));\n     }\n \n     public void testNumLiterals9() {\n-        assertEquals(3.14, MVEL.eval(\"3.14\"));\n+        assertEquals(0x400921FB54442D18L, MVEL.eval(\"0x400921FB54442D18L\"));\n     }\n \n-    public void testNumLiterals10() {\n-        assertEquals(1e-9d, MVEL.eval(\"1e-9d\"));\n+    public void testArrayCreation2() {\n+        String[][] s = (String[][])\n+                test(\"new String[][] {{\\\"2008-04-01\\\", \\\"2008-05-10\\\"}, {\\\"2007-03-01\\\", \\\"2007-02-12\\\"}}\");\n+        assertEquals(\"2007-03-01\", s[1][0]);\n     }\n \n-    public void testNumLiterals11() {\n-        assertEquals(0x400921FB54442D18L, MVEL.eval(\"0x400921FB54442D18L\"));\n-    }\n+    public void testArrayCreation3() {\n+        OptimizerFactory.setDefaultOptimizer(\"ASM\");\n+\n+        Serializable ce =\n+                MVEL.compileExpression(\"new String[][] {{\\\"2008-04-01\\\", \\\"2008-05-10\\\"}, {\\\"2007-03-01\\\", \\\"2007-02-12\\\"}}\");\n \n+        String[][] s = (String[][])\n+                MVEL.executeExpression(ce);\n+\n+        assertEquals(\"2007-03-01\", s[1][0]);\n+    }\n }\n \n \n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T11:08:23.020370Z", "commit_hash": "117b92153f7ca4311128ef0815fafde7070e0964", "commit_message": "fixes to number parsing\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/compiler/AbstractParser.java b/src/main/java/org/mvel/compiler/AbstractParser.java\nindex 97936cb..3644f1d 100644\n--- a/src/main/java/org/mvel/compiler/AbstractParser.java\n+++ b/src/main/java/org/mvel/compiler/AbstractParser.java\n@@ -728,6 +728,10 @@ public class AbstractParser implements Serializable {\n                     switch (expr[cursor]) {\r\n                         case '.': {\r\n                             cursor++;\r\n+                            if (isDigit(expr[cursor])) {\r\n+                                capture = true;\r\n+                                continue;\r\n+                            }\r\n                             expectNextChar_IW('{');\r\n \r\n                             tmp = subArray(start, cursor - 1);\r\ndiff --git a/src/main/java/org/mvel/util/ParseTools.java b/src/main/java/org/mvel/util/ParseTools.java\nindex 03d42a0..3da45e7 100644\n--- a/src/main/java/org/mvel/util/ParseTools.java\n+++ b/src/main/java/org/mvel/util/ParseTools.java\n@@ -1364,6 +1364,7 @@ public class ParseTools {\n         if (val.length != 1 && val[0] == '0' && val[1] != '.') {\n             if (!isDigit(val[val.length - 1])) {\n                 switch (val[val.length - 1]) {\n+                    case 'L':\n                     case 'l':\n                         return Long.decode(new String(val, 0, val.length - 1));\n                     case 'I':\n@@ -1380,6 +1381,7 @@ public class ParseTools {\n                 case 'l':\n                 case 'L':\n                     return java.lang.Long.parseLong(new String(val, 0, val.length - 1));\n+                case '.':\n                 case 'd':\n                 case 'D':\n                     return parseDouble(new String(val, 0, val.length - 1));\n@@ -1447,6 +1449,7 @@ public class ParseTools {\n                     case '.':\n                         fp = true;\n                         break;\n+                    case 'e':\n                     case 'E':\n                         fp = true;\n                         if (i++ < len && val[i] == '-') i++;\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/core/CoreConfidenceTests.java\nindex 54379d0..fb87ec1 100644\n--- a/src/test/java/org/mvel/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/core/CoreConfidenceTests.java\n@@ -4342,10 +4342,50 @@ public class CoreConfidenceTests extends AbstractTest {\n         assertEquals(\"\\uFFFF::\", MVEL.eval(\"'\\\\uFFFF::'\"));\n     }\n \n-    public void testNumericOverflowLiterals() {\n-        double d = 3.141592653589793E-305;\n-        Object r = MVEL.eval(\"3.141592653589793E-305\");\n-        assertEquals(d, r);\n+    public void testNumLiterals() {\n+        assertEquals(1e1f, MVEL.eval(\"1e1f\"));\n+    }\n+\n+    public void testNumLiterals2() {\n+        assertEquals(2.f, MVEL.eval(\"2.f\"));\n+    }\n+\n+    public void testNumLiterals3() {\n+        assertEquals(.3f, MVEL.eval(\".3f\"));\n+    }\n+\n+    public void testNumLiterals4() {\n+        assertEquals(3.14f, MVEL.eval(\"3.14f\"));\n+    }\n+\n+    public void testNumLiterals5() {\n+        Object o = MVEL.eval(\"1e1\");\n+\n+        assertEquals(1e1, MVEL.eval(\"1e1\"));\n+    }\n+\n+    public void testNumLiterals6() {\n+        assertEquals(2., MVEL.eval(\"2.\"));\n+    }\n+\n+    public void testNumLiterals7() {\n+        assertEquals(.3, MVEL.eval(\".3\"));\n+    }\n+\n+    public void testNumLiterals8() {\n+        assertEquals(0.0, MVEL.eval(\"0.0\"));\n+    }\n+\n+    public void testNumLiterals9() {\n+        assertEquals(3.14, MVEL.eval(\"3.14\"));\n+    }\n+\n+    public void testNumLiterals10() {\n+        assertEquals(1e-9d, MVEL.eval(\"1e-9d\"));\n+    }\n+\n+    public void testNumLiterals11() {\n+        assertEquals(0x400921FB54442D18L, MVEL.eval(\"0x400921FB54442D18L\"));\n     }\n \n }\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T11:20:48.895247Z", "commit_hash": "b64ea27473eab3400c38fcfc294d4c1de93dd89c", "commit_message": "math system fixed.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/MVEL.java b/src/main/java/org/mvel/MVEL.java\nindex 450d55f..95e716a 100644\n--- a/src/main/java/org/mvel/MVEL.java\n+++ b/src/main/java/org/mvel/MVEL.java\n@@ -26,7 +26,8 @@ import org.mvel.integration.Interceptor;\n import org.mvel.integration.VariableResolverFactory;\n import org.mvel.integration.impl.MapVariableResolverFactory;\n import org.mvel.optimizers.impl.refl.GetterAccessor;\n-import static org.mvel.util.ParseTools.*;\n+import static org.mvel.util.ParseTools.loadFromFile;\n+import static org.mvel.util.ParseTools.optimizeTree;\n \n import java.io.File;\n import java.io.IOException;\n@@ -202,7 +203,7 @@ public class MVEL {\n             return ((ExecutableStatement) compiledExpression).getValue(null, null);\n         }\n         catch (EndWithValue e) {\n-            return handleParserEgress(e.getValue(), false);\n+            return e.getValue();\n         }\n     }\n \n@@ -221,7 +222,7 @@ public class MVEL {\n             return ((ExecutableStatement) compiledExpression).getValue(ctx, vars != null ? new MapVariableResolverFactory(vars) : null);\n         }\n         catch (EndWithValue end) {\n-            return handleParserEgress(end.getValue(), false);\n+            return end.getValue();\n         }\n     }\n \n@@ -230,7 +231,7 @@ public class MVEL {\n             return ((ExecutableStatement) compiledExpression).getValue(ctx, resolverFactory);\n         }\n         catch (EndWithValue end) {\n-            return handleParserEgress(end.getValue(), false);\n+            return end.getValue();\n         }\n     }\n \n@@ -247,7 +248,7 @@ public class MVEL {\n             return ((ExecutableStatement) compiledExpression).getValue(null, factory);\n         }\n         catch (EndWithValue end) {\n-            return handleParserEgress(end.getValue(), false);\n+            return end.getValue();\n         }\n     }\n \n@@ -264,7 +265,7 @@ public class MVEL {\n             return ((ExecutableStatement) compiledExpression).getValue(ctx, null);\n         }\n         catch (EndWithValue end) {\n-            return handleParserEgress(end.getValue(), false);\n+            return end.getValue();\n         }\n     }\n \n@@ -282,7 +283,7 @@ public class MVEL {\n             return ((ExecutableStatement) compiledExpression).getValue(null, new MapVariableResolverFactory(vars));\n         }\n         catch (EndWithValue end) {\n-            return handleParserEgress(end.getValue(), false);\n+            return end.getValue();\n         }\n     }\n \n@@ -301,7 +302,7 @@ public class MVEL {\n             return convert(executeExpression(compiledExpression, ctx, vars), toType);\n         }\n         catch (EndWithValue end) {\n-            return convert(handleParserEgress(end.getValue(), false), toType);\n+            return convert(end.getValue(), toType);\n         }\n     }\n \n@@ -319,7 +320,7 @@ public class MVEL {\n             return convert(executeExpression(compiledExpression, vars), toType);\n         }\n         catch (EndWithValue end) {\n-            return convert(handleParserEgress(end.getValue(), false), toType);\n+            return convert(end.getValue(), toType);\n         }\n     }\n \n@@ -336,7 +337,7 @@ public class MVEL {\n             return convert(executeExpression(compiledExpression, ctx), toType);\n         }\n         catch (EndWithValue end) {\n-            return convert(handleParserEgress(end.getValue(), false), toType);\n+            return convert(end.getValue(), toType);\n         }\n     }\n \n@@ -382,7 +383,7 @@ public class MVEL {\n             return execute(true, expression, ctx, vars);\n         }\n         catch (EndWithValue e) {\n-            return handleParserEgress(e.getValue(), false);\n+            return e.getValue();\n         }\n     }\n \n@@ -393,7 +394,7 @@ public class MVEL {\n             return convert(new MVELInterpretedRuntime(expression, ctx, vars).parse(), toType);\n         }\n         catch (EndWithValue end) {\n-            return convert(handleParserEgress(end.getValue(), false), toType);\n+            return convert(end.getValue(), toType);\n         }\n     }\n \n@@ -403,7 +404,7 @@ public class MVEL {\n             return convert(new MVELInterpretedRuntime(expression, ctx).parse(), toType);\n         }\n         catch (EndWithValue end) {\n-            return convert(handleParserEgress(end.getValue(), false), toType);\n+            return convert(end.getValue(), toType);\n         }\n     }\n \n@@ -413,7 +414,7 @@ public class MVEL {\n             return convert(new MVELInterpretedRuntime(expression, ctx).parse(), toType);\n         }\n         catch (EndWithValue end) {\n-            return convert(handleParserEgress(end.getValue(), false), toType);\n+            return convert(end.getValue(), toType);\n         }\n     }\n \n@@ -423,7 +424,7 @@ public class MVEL {\n             return convert(new MVELInterpretedRuntime(expression, ctx, vars).parse(), toType);\n         }\n         catch (EndWithValue end) {\n-            return convert(handleParserEgress(end.getValue(), false), toType);\n+            return convert(end.getValue(), toType);\n         }\n     }\n \n@@ -433,7 +434,7 @@ public class MVEL {\n             return convert(new MVELInterpretedRuntime(expression, ctx, vars).parse(), toType);\n         }\n         catch (EndWithValue end) {\n-            return convert(handleParserEgress(end.getValue(), false), toType);\n+            return convert(end.getValue(), toType);\n         }\n     }\n \n@@ -443,7 +444,7 @@ public class MVEL {\n             return convert(new MVELInterpretedRuntime(expression, ctx, vars).parse(), toType);\n         }\n         catch (EndWithValue end) {\n-            return convert(handleParserEgress(end.getValue(), false), toType);\n+            return convert(end.getValue(), toType);\n         }\n     }\n \n@@ -454,7 +455,7 @@ public class MVEL {\n             return convert(new MVELInterpretedRuntime(expression, null, vars).parse(), toType);\n         }\n         catch (EndWithValue end) {\n-            return convert(handleParserEgress(end.getValue(), false), toType);\n+            return convert(end.getValue(), toType);\n         }\n     }\n \n@@ -464,7 +465,7 @@ public class MVEL {\n             return convert(new MVELInterpretedRuntime(expression, null, vars).parse(), toType);\n         }\n         catch (EndWithValue end) {\n-            return convert(handleParserEgress(end.getValue(), false), toType);\n+            return convert(end.getValue(), toType);\n         }\n     }\n \n@@ -475,7 +476,7 @@ public class MVEL {\n             return convert(new MVELInterpretedRuntime(expression, null, vars).parse(), toType);\n         }\n         catch (EndWithValue end) {\n-            return convert(handleParserEgress(end.getValue(), false), toType);\n+            return convert(end.getValue(), toType);\n         }\n     }\n \n@@ -485,7 +486,7 @@ public class MVEL {\n             return new MVELInterpretedRuntime(expression, ctx, vars).parse();\n         }\n         catch (EndWithValue end) {\n-            return handleParserEgress(end.getValue(), false);\n+            return end.getValue();\n         }\n     }\n \n@@ -494,7 +495,7 @@ public class MVEL {\n             return valueOf(eval(expression, ctx));\n         }\n         catch (EndWithValue end) {\n-            return valueOf(handleParserEgress(end.getValue(), false));\n+            return valueOf(end.getValue());\n         }\n     }\n \n@@ -509,7 +510,7 @@ public class MVEL {\n             return valueOf(eval(expression, ctx, vars));\n         }\n         catch (EndWithValue end) {\n-            return valueOf(handleParserEgress(end.getValue(), false));\n+            return valueOf(end.getValue());\n         }\n     }\n \ndiff --git a/src/main/java/org/mvel/MVELInterpretedRuntime.java b/src/main/java/org/mvel/MVELInterpretedRuntime.java\nindex f1f8dc0..654ce32 100644\n--- a/src/main/java/org/mvel/MVELInterpretedRuntime.java\n+++ b/src/main/java/org/mvel/MVELInterpretedRuntime.java\n@@ -28,7 +28,6 @@ import org.mvel.integration.VariableResolverFactory;\n import org.mvel.integration.impl.MapVariableResolverFactory;\n import org.mvel.util.ExecutionStack;\n import static org.mvel.util.ParseTools.findClassImportResolverFactory;\n-import static org.mvel.util.ParseTools.handleParserEgress;\n \n import java.math.BigDecimal;\n import java.util.Map;\n@@ -59,7 +58,7 @@ public class MVELInterpretedRuntime extends AbstractParser {\n                 contextControl(REMOVE, null, null);\n             }\n \n-            return handleParserEgress(stk.pop(), returnBigDecimal);\n+            return stk.pop();\n         }\n         catch (ArrayIndexOutOfBoundsException e) {\n             e.printStackTrace();\n@@ -75,7 +74,7 @@ public class MVELInterpretedRuntime extends AbstractParser {\n                 throw e;\n         }\n         catch (EndWithValue end) {\n-            return handleParserEgress(end.getValue(), returnBigDecimal);\n+            return end.getValue();\n         }\n     }\n \ndiff --git a/src/main/java/org/mvel/compiler/CompiledExpression.java b/src/main/java/org/mvel/compiler/CompiledExpression.java\nindex ad74d44..4a77367 100644\n--- a/src/main/java/org/mvel/compiler/CompiledExpression.java\n+++ b/src/main/java/org/mvel/compiler/CompiledExpression.java\n@@ -26,7 +26,6 @@ import org.mvel.optimizers.AccessorOptimizer;\n import static org.mvel.optimizers.OptimizerFactory.setThreadAccessorOptimizer;\n import org.mvel.util.ASTIterator;\n import org.mvel.util.ASTLinkedList;\n-import static org.mvel.util.ParseTools.handleParserEgress;\n \n import java.io.Serializable;\n \n@@ -39,7 +38,6 @@ public class CompiledExpression implements Serializable, ExecutableStatement {\n     private boolean convertableIngressEgress;\n     private boolean optimized = false;\n     private boolean importInjectionRequired = false;\n-    private boolean returnBigDecimal = false;\n     private boolean literalOnly;\n \n     private Class<? extends AccessorOptimizer> accessorOptimizer;\n@@ -101,7 +99,7 @@ public class CompiledExpression implements Serializable, ExecutableStatement {\n \n     public Object getValue(Object staticContext, VariableResolverFactory factory) {\n         if (!optimized) setupOptimizers();\n-        return handleParserEgress(execute(false, this, staticContext, factory), returnBigDecimal);\n+        return execute(false, this, staticContext, factory);\n     }\n \n     public Object getDirectValue(Object staticContext, VariableResolverFactory factory) {\n@@ -156,14 +154,6 @@ public class CompiledExpression implements Serializable, ExecutableStatement {\n         }\n     }\n \n-    public boolean isReturnBigDecimal() {\n-        return returnBigDecimal;\n-    }\n-\n-    public void setReturnBigDecimal(boolean returnBigDecimal) {\n-        this.returnBigDecimal = returnBigDecimal;\n-    }\n-\n     public boolean isImportInjectionRequired() {\n         return importInjectionRequired;\n     }\ndiff --git a/src/main/java/org/mvel/compiler/ExecutableAccessor.java b/src/main/java/org/mvel/compiler/ExecutableAccessor.java\nindex ccc6f32..24ca36c 100644\n--- a/src/main/java/org/mvel/compiler/ExecutableAccessor.java\n+++ b/src/main/java/org/mvel/compiler/ExecutableAccessor.java\n@@ -20,7 +20,6 @@ package org.mvel.compiler;\n \r\n import org.mvel.ast.ASTNode;\r\n import org.mvel.integration.VariableResolverFactory;\r\n-import static org.mvel.util.ParseTools.handleParserEgress;\r\n \r\n public class ExecutableAccessor implements ExecutableStatement {\r\n     private ASTNode node;\r\n@@ -29,22 +28,17 @@ public class ExecutableAccessor implements ExecutableStatement {\n     private Class egress;\r\n     private boolean convertable;\r\n \r\n-    private boolean returnBigDecimal;\r\n-\r\n-    public ExecutableAccessor(ASTNode node, boolean returnBigDecimal, Class egress) {\r\n+    public ExecutableAccessor(ASTNode node, Class egress) {\r\n         this.node = node;\r\n-        this.returnBigDecimal = returnBigDecimal;\r\n         this.egress = egress;\r\n     }\r\n \r\n     public Object getValue(Object ctx, Object elCtx, VariableResolverFactory variableFactory) {\r\n-        return handleParserEgress(node.getReducedValueAccelerated(ctx, elCtx, variableFactory),\r\n-                returnBigDecimal);\r\n+        return node.getReducedValueAccelerated(ctx, elCtx, variableFactory);\r\n     }\r\n \r\n     public Object getValue(Object staticContext, VariableResolverFactory factory) {\r\n-        return handleParserEgress(node.getReducedValueAccelerated(staticContext, staticContext, factory),\r\n-                returnBigDecimal);\r\n+        return node.getReducedValueAccelerated(staticContext, staticContext, factory);\r\n     }\r\n \r\n \r\ndiff --git a/src/main/java/org/mvel/compiler/ExecutableAccessorSafe.java b/src/main/java/org/mvel/compiler/ExecutableAccessorSafe.java\nindex 35e2c38..5864348 100644\n--- a/src/main/java/org/mvel/compiler/ExecutableAccessorSafe.java\n+++ b/src/main/java/org/mvel/compiler/ExecutableAccessorSafe.java\n@@ -21,7 +21,6 @@ package org.mvel.compiler;\n import org.mvel.ast.ASTNode;\r\n import org.mvel.ast.Safe;\r\n import org.mvel.integration.VariableResolverFactory;\r\n-import static org.mvel.util.ParseTools.handleParserEgress;\r\n \r\n \r\n public class ExecutableAccessorSafe implements ExecutableStatement, Safe {\r\n@@ -45,13 +44,11 @@ public class ExecutableAccessorSafe implements ExecutableStatement, Safe {\n     }\r\n \r\n     public Object getValue(Object ctx, Object elCtx, VariableResolverFactory variableFactory) {\r\n-        return handleParserEgress(node.getReducedValueAccelerated(ctx, elCtx, variableFactory),\r\n-                returnBigDecimal);\r\n+        return node.getReducedValueAccelerated(ctx, elCtx, variableFactory);\r\n     }\r\n \r\n     public Object getValue(Object staticContext, VariableResolverFactory factory) {\r\n-        return handleParserEgress(node.getReducedValueAccelerated(staticContext, staticContext, factory),\r\n-                returnBigDecimal);\r\n+        return node.getReducedValueAccelerated(staticContext, staticContext, factory);\r\n     }\r\n \r\n     public void setKnownIngressType(Class type) {\r\ndiff --git a/src/main/java/org/mvel/compiler/ExecutableLiteral.java b/src/main/java/org/mvel/compiler/ExecutableLiteral.java\nindex 3a22a96..90f99f4 100644\n--- a/src/main/java/org/mvel/compiler/ExecutableLiteral.java\n+++ b/src/main/java/org/mvel/compiler/ExecutableLiteral.java\n@@ -20,7 +20,6 @@ package org.mvel.compiler;\n \r\n import org.mvel.ast.Safe;\r\n import org.mvel.integration.VariableResolverFactory;\r\n-import org.mvel.util.ParseTools;\r\n \r\n /**\r\n  * @author Christopher Brock\r\n@@ -31,7 +30,7 @@ public class ExecutableLiteral implements ExecutableStatement, Safe {\n     private boolean intOptimized;\r\n \r\n     public ExecutableLiteral(Object literal) {\r\n-        this.literal = ParseTools.handleParserEgress(literal, false);\r\n+        this.literal = literal;\r\n     }\r\n \r\n     public ExecutableLiteral(int literal) {\r\ndiff --git a/src/main/java/org/mvel/math/IEEEFloatingPointMath.java b/src/main/java/org/mvel/math/IEEEFloatingPointMath.java\nindex b3e0311..eea609a 100644\n--- a/src/main/java/org/mvel/math/IEEEFloatingPointMath.java\n+++ b/src/main/java/org/mvel/math/IEEEFloatingPointMath.java\n@@ -27,6 +27,8 @@ import static org.mvel.Operator.*;\n import static org.mvel.Soundex.soundex;\r\n import org.mvel.Unit;\r\n import org.mvel.debug.DebugTools;\r\n+import org.mvel.util.InternalNumber;\r\n+import static org.mvel.util.ParseTools.narrowType;\r\n import static org.mvel.util.ParseTools.resolveType;\r\n import static org.mvel.util.PropertyTools.isNumber;\r\n \r\n@@ -47,37 +49,70 @@ public class IEEEFloatingPointMath implements MathProcessor {\n \r\n         if (type1 == DataTypes.BIG_DECIMAL) {\r\n             if (type2 == DataTypes.BIG_DECIMAL) {\r\n-                return doBigDecimalArithmetic((BigDecimal) val1, operation, (BigDecimal) val2);\r\n+                return doBigDecimalArithmetic((BigDecimal) val1, operation, (BigDecimal) val2, false);\r\n             }\r\n             else if (type2 > 99) {\r\n-                return doBigDecimalArithmetic((BigDecimal) val1, operation, getBigDecimalFromType(val2, type2));\r\n+                return doBigDecimalArithmetic((BigDecimal) val1, operation, getInternalNumberFromType(val2, type2), false);\r\n             }\r\n             else {\r\n                 return _doOperations(type1, val1, operation, type2, val2);\r\n             }\r\n         }\r\n         else if (type2 == DataTypes.BIG_DECIMAL && (type1 > 99 || (type1 == DataTypes.STRING && isNumber(val1)))) {\r\n-            return doBigDecimalArithmetic(getBigDecimalFromType(val1, type1), operation, (BigDecimal) val2);\r\n+            return doBigDecimalArithmetic(getInternalNumberFromType(val1, type1), operation, (BigDecimal) val2, true);\r\n         }\r\n         else {\r\n             return _doOperations(type1, val1, operation, type2, val2);\r\n         }\r\n     }\r\n \r\n-    private static Object doBigDecimalArithmetic(final BigDecimal val1, final int operation, final BigDecimal val2) {\r\n+    private static Object doBigDecimalArithmetic(final BigDecimal val1, final int operation, final BigDecimal val2, boolean iNumber) {\r\n         switch (operation) {\r\n             case ADD:\r\n-                return val1.add(val2, MATH_CONTEXT);\r\n+                if (iNumber) {\r\n+                    return narrowType(val1.add(val2, MATH_CONTEXT));\r\n+                }\r\n+                else {\r\n+                    return val1.add(val2, MATH_CONTEXT);\r\n+                }\r\n             case DIV:\r\n-                return val1.divide(val2, MATH_CONTEXT);\r\n+                if (iNumber) {\r\n+                    return narrowType(val1.divide(val2, MATH_CONTEXT));\r\n+                }\r\n+                else {\r\n+                    return val1.divide(val2, MATH_CONTEXT);\r\n+                }\r\n+\r\n             case SUB:\r\n-                return val1.subtract(val2, MATH_CONTEXT);\r\n+                if (iNumber) {\r\n+                    return narrowType(val1.subtract(val2, MATH_CONTEXT));\r\n+                }\r\n+                else {\r\n+                    return val1.subtract(val2, MATH_CONTEXT);\r\n+                }\r\n             case MULT:\r\n-                return val1.multiply(val2, MATH_CONTEXT);\r\n+                if (iNumber) {\r\n+                    return narrowType(val1.multiply(val2, MATH_CONTEXT));\r\n+                }\r\n+                else {\r\n+                    return val1.multiply(val2, MATH_CONTEXT);\r\n+                }\r\n+\r\n             case POWER:\r\n-                return val1.pow(val2.intValue(), MATH_CONTEXT);\r\n+                if (iNumber) {\r\n+                    return narrowType(val1.pow(val2.intValue(), MATH_CONTEXT));\r\n+                }\r\n+                else {\r\n+                    return val1.pow(val2.intValue(), MATH_CONTEXT);\r\n+                }\r\n+\r\n             case MOD:\r\n-                return val1.remainder(val2);\r\n+                if (iNumber) {\r\n+                    return narrowType(val1.remainder(val2));\r\n+                }\r\n+                else {\r\n+                    return val1.remainder(val2);\r\n+                }\r\n \r\n             case GTHAN:\r\n                 return val1.compareTo(val2) == 1 ? Boolean.TRUE : Boolean.FALSE;\r\n@@ -101,7 +136,7 @@ public class IEEEFloatingPointMath implements MathProcessor {\n                 return doOperationsSameType(type1, val1, operation, val2);\r\n             }\r\n             else if ((type1 > 99 && (type2 > 99)) || (operation != 0 && isNumber(val1) && isNumber(val2))) {\r\n-                return doBigDecimalArithmetic(getBigDecimalFromType(val1, type1), operation, getBigDecimalFromType(val2, type2));\r\n+                return doBigDecimalArithmetic(getInternalNumberFromType(val1, type1), operation, getInternalNumberFromType(val2, type2), true);\r\n             }\r\n             else\r\n             if (operation != ADD && (type1 == 15 || type2 == 15) && type1 != type2 && type1 != EMPTY && type2 != EMPTY) {\r\n@@ -147,7 +182,7 @@ public class IEEEFloatingPointMath implements MathProcessor {\n             case GETHAN:\r\n                 if (val1 instanceof Comparable) {\r\n                     //noinspection unchecked\r\n-                    return val2 != null &&  ((Comparable) val1).compareTo(val2) >= 0 ? Boolean.TRUE : Boolean.FALSE;\r\n+                    return val2 != null && ((Comparable) val1).compareTo(val2) >= 0 ? Boolean.TRUE : Boolean.FALSE;\r\n                 }\r\n                 else {\r\n                     return Boolean.FALSE;\r\n@@ -157,7 +192,7 @@ public class IEEEFloatingPointMath implements MathProcessor {\n             case LTHAN:\r\n                 if (val1 instanceof Comparable) {\r\n                     //noinspection unchecked\r\n-                    return val2 != null &&  ((Comparable) val1).compareTo(val2) <= -1 ? Boolean.TRUE : Boolean.FALSE;\r\n+                    return val2 != null && ((Comparable) val1).compareTo(val2) <= -1 ? Boolean.TRUE : Boolean.FALSE;\r\n                 }\r\n                 else {\r\n                     return Boolean.FALSE;\r\n@@ -167,7 +202,7 @@ public class IEEEFloatingPointMath implements MathProcessor {\n             case LETHAN:\r\n                 if (val1 instanceof Comparable) {\r\n                     //noinspection unchecked\r\n-                    return val2 != null &&  ((Comparable) val1).compareTo(val2) <= 0 ? Boolean.TRUE : Boolean.FALSE;\r\n+                    return val2 != null && ((Comparable) val1).compareTo(val2) <= 0 ? Boolean.TRUE : Boolean.FALSE;\r\n                 }\r\n                 else {\r\n                     return Boolean.FALSE;\r\n@@ -212,10 +247,9 @@ public class IEEEFloatingPointMath implements MathProcessor {\n                     case SUB:\r\n                         return ((Integer) val1) - ((Integer) val2);\r\n                     case DIV:\r\n-                        return new BigDecimal((Integer) val1, MATH_CONTEXT).divide(new BigDecimal((Integer) val2), MATH_CONTEXT);\r\n+                        return narrowType(new BigDecimal((Integer) val1, MATH_CONTEXT).divide(new BigDecimal((Integer) val2), MATH_CONTEXT));\r\n                     case MULT:\r\n-                        //  return ((Integer) val1) * ((Integer) val2);\r\n-                        return new BigDecimal((Integer) val1, MATH_CONTEXT).multiply(new BigDecimal((Integer) val2), MATH_CONTEXT);\r\n+                        return ((Integer) val1) * ((Integer) val2);\r\n                     case POWER:\r\n                         double d = Math.pow((Integer) val1, (Integer) val2);\r\n                         if (d > Integer.MAX_VALUE) return d;\r\n@@ -258,7 +292,7 @@ public class IEEEFloatingPointMath implements MathProcessor {\n                     case SUB:\r\n                         return ((Short) val1) - ((Short) val2);\r\n                     case DIV:\r\n-                        return new BigDecimal((Short) val1, MATH_CONTEXT).divide(new BigDecimal((Short) val2), MATH_CONTEXT);\r\n+                        return narrowType(new InternalNumber((Short) val1, MATH_CONTEXT).divide(new InternalNumber((Short) val2), MATH_CONTEXT));\r\n                     case MULT:\r\n                         return ((Short) val1) * ((Short) val2);\r\n                     case POWER:\r\n@@ -303,7 +337,7 @@ public class IEEEFloatingPointMath implements MathProcessor {\n                     case SUB:\r\n                         return ((Long) val1) - ((Long) val2);\r\n                     case DIV:\r\n-                        return new BigDecimal((Long) val1, MATH_CONTEXT).divide(new BigDecimal((Long) val2), MATH_CONTEXT);\r\n+                        return narrowType(new InternalNumber((Long) val1, MATH_CONTEXT).divide(new InternalNumber((Long) val2), MATH_CONTEXT));\r\n                     case MULT:\r\n                         return ((Long) val1) * ((Long) val2);\r\n                     case POWER:\r\n@@ -355,7 +389,7 @@ public class IEEEFloatingPointMath implements MathProcessor {\n                     case SUB:\r\n                         return ((Double) val1) - ((Double) val2);\r\n                     case DIV:\r\n-                        return new BigDecimal((Double) val1, MATH_CONTEXT).divide(new BigDecimal((Double) val2), MATH_CONTEXT);\r\n+                        return narrowType(new InternalNumber((Double) val1, MATH_CONTEXT).divide(new InternalNumber((Double) val2), MATH_CONTEXT));\r\n                     case MULT:\r\n                         return ((Double) val1) * ((Double) val2);\r\n                     case POWER:\r\n@@ -393,11 +427,11 @@ public class IEEEFloatingPointMath implements MathProcessor {\n                     case SUB:\r\n                         return ((Float) val1) - ((Float) val2);\r\n                     case DIV:\r\n-                        return new BigDecimal((Float) val1, MATH_CONTEXT).divide(new BigDecimal((Float) val2), MATH_CONTEXT);\r\n+                        return narrowType(new InternalNumber((Float) val1, MATH_CONTEXT).divide(new InternalNumber((Float) val2), MATH_CONTEXT));\r\n                     case MULT:\r\n                         return ((Float) val1) * ((Float) val2);\r\n                     case POWER:\r\n-                        return new BigDecimal((Float) val1, MATH_CONTEXT).pow(new BigDecimal((Float) val2).intValue(), MATH_CONTEXT);\r\n+                        return narrowType(new InternalNumber((Float) val1, MATH_CONTEXT).pow(new InternalNumber((Float) val2).intValue(), MATH_CONTEXT));\r\n                     case MOD:\r\n                         return ((Float) val1) % ((Float) val2);\r\n \r\n@@ -474,32 +508,33 @@ public class IEEEFloatingPointMath implements MathProcessor {\n         return null;\r\n     }\r\n \r\n-    private static BigDecimal getBigDecimalFromType(Object in, int type) {\r\n+    private static InternalNumber getInternalNumberFromType(Object in, int type) {\r\n         if (in == null)\r\n-            return new BigDecimal(0, MATH_CONTEXT);\r\n+            return new InternalNumber(0, MATH_CONTEXT);\r\n         switch (type) {\r\n             case DataTypes.BIG_DECIMAL:\r\n-                return (BigDecimal) in;\r\n+                return new InternalNumber(((BigDecimal) in).doubleValue());\r\n             case DataTypes.BIG_INTEGER:\r\n-                return new BigDecimal((BigInteger) in, MathContext.DECIMAL128);\r\n+                return new InternalNumber((BigInteger) in, MathContext.DECIMAL128);\r\n             case DataTypes.W_INTEGER:\r\n-                return new BigDecimal((Integer) in, MathContext.DECIMAL32);\r\n+                return new InternalNumber((Integer) in, MathContext.DECIMAL32);\r\n             case DataTypes.W_LONG:\r\n-                return new BigDecimal((Long) in, MathContext.DECIMAL64);\r\n+                return new InternalNumber((Long) in, MathContext.DECIMAL64);\r\n             case DataTypes.STRING:\r\n-                return new BigDecimal((String) in, MathContext.DECIMAL64);\r\n+                return new InternalNumber((String) in, MathContext.DECIMAL64);\r\n             case DataTypes.W_FLOAT:\r\n-                return new BigDecimal((Float) in, MathContext.DECIMAL64);\r\n+                return new InternalNumber((Float) in, MathContext.DECIMAL64);\r\n             case DataTypes.W_DOUBLE:\r\n-                return new BigDecimal((Double) in, MathContext.DECIMAL64);\r\n+                return new InternalNumber((Double) in, MathContext.DECIMAL64);\r\n             case DataTypes.W_SHORT:\r\n-                return new BigDecimal((Short) in, MathContext.DECIMAL32);\r\n+                return new InternalNumber((Short) in, MathContext.DECIMAL32);\r\n             case DataTypes.W_CHAR:\r\n-                return new BigDecimal((Character) in, MathContext.DECIMAL32);\r\n+                return new InternalNumber((Character) in, MathContext.DECIMAL32);\r\n             case DataTypes.W_BOOLEAN:\r\n-                return BigDecimal.valueOf(((Boolean) in) ? 1 : 0);\r\n+                return new InternalNumber(((Boolean) in) ? 1 : 0);\r\n+                //return InternalNumber.valueOf(((Boolean) in) ? 1 : 0);\r\n             case DataTypes.UNIT:\r\n-                return new BigDecimal(((Unit) in).getValue(), MathContext.DECIMAL64);\r\n+                return new InternalNumber(((Unit) in).getValue(), MathContext.DECIMAL64);\r\n         }\r\n \r\n         throw new ConversionException(\"cannot convert <\" + in + \"> to a numeric type\");\r\ndiff --git a/src/main/java/org/mvel/math/JDK14CompatabilityMath.java b/src/main/java/org/mvel/math/JDK14CompatabilityMath.java\ndeleted file mode 100644\nindex 9dbac9b..0000000\n--- a/src/main/java/org/mvel/math/JDK14CompatabilityMath.java\n+++ /dev/null\n@@ -1,511 +0,0 @@\n-/**\r\n- * MVEL (The MVFLEX Expression Language)\r\n- *\r\n- * Copyright (C) 2007 Christopher Brock, MVFLEX/Valhalla Project and the Codehaus\r\n- *\r\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- *\r\n- *     http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- *\r\n- */\r\n-package org.mvel.math;\r\n-\r\n-import org.mvel.CompileException;\r\n-import org.mvel.ConversionException;\r\n-import static org.mvel.DataConversion.convert;\r\n-import org.mvel.DataTypes;\r\n-import static org.mvel.DataTypes.EMPTY;\r\n-import org.mvel.Operator;\r\n-import static org.mvel.Soundex.soundex;\r\n-import static org.mvel.Operator.GTHAN;\r\n-import static org.mvel.Operator.GETHAN;\r\n-import static org.mvel.Operator.LTHAN;\r\n-import static org.mvel.Operator.LETHAN;\r\n-import static org.mvel.Operator.BW_AND;\r\n-import static org.mvel.Operator.BW_OR;\r\n-import static org.mvel.Operator.BW_SHIFT_LEFT;\r\n-import static org.mvel.Operator.BW_SHIFT_RIGHT;\r\n-import static org.mvel.Operator.BW_USHIFT_RIGHT;\r\n-import static org.mvel.Operator.BW_XOR;\r\n-import static org.mvel.Operator.BW_USHIFT_LEFT;\r\n-import static org.mvel.Operator.SOUNDEX;\r\n-import static org.mvel.util.ParseTools.resolveType;\r\n-import static org.mvel.util.PropertyTools.isNumber;\r\n-\r\n-import static java.lang.String.valueOf;\r\n-import java.math.BigDecimal;\r\n-import java.math.BigInteger;\r\n-\r\n-/**\r\n- * @author Christopher Brock\r\n- */\r\n-public class JDK14CompatabilityMath implements MathProcessor {\r\n-    public static final int ROUND_MODE = BigDecimal.ROUND_CEILING;\r\n-    public static final int SCALE = 128;\r\n-\r\n-\r\n-    public Object doOperation(Object val1, int operation, Object val2) {\r\n-        int type1 = val1 == null ? DataTypes.NULL : resolveType(val1.getClass());\r\n-        int type2 = val2 == null ? DataTypes.NULL : resolveType(val2.getClass());\r\n-\r\n-        if (type1 == DataTypes.BIG_DECIMAL) {\r\n-            if (type2 == DataTypes.BIG_DECIMAL) {\r\n-                return doBigDecimalArithmetic((BigDecimal) val1, operation, (BigDecimal) val2);\r\n-            }\r\n-            else if (type2 > 99) {\r\n-                return doBigDecimalArithmetic((BigDecimal) val1, operation, getBigDecimalFromType(val2, type2));\r\n-            }\r\n-            else {\r\n-                return _doOperations(type1, val1, operation, type2, val2);\r\n-            }\r\n-        }\r\n-        else if (type2 == DataTypes.BIG_DECIMAL && (type1 > 99 || (type1 == DataTypes.STRING && isNumber(val1)))) {\r\n-            return doBigDecimalArithmetic(getBigDecimalFromType(val1, type1), operation, (BigDecimal) val2);\r\n-        }\r\n-        else {\r\n-            return _doOperations(type1, val1, operation, type2, val2);\r\n-        }\r\n-\r\n-\r\n-    }\r\n-\r\n-    private static Object doBigDecimalArithmetic(BigDecimal val1, int operation, BigDecimal val2) {\r\n-        switch (operation) {\r\n-            case Operator.ADD:\r\n-                return val1.add(val2);\r\n-            case Operator.DIV:\r\n-                return val1.divide(val2, SCALE, ROUND_MODE);\r\n-            case Operator.SUB:\r\n-                return val1.subtract(val2);\r\n-            case Operator.MULT:\r\n-                return val1.multiply(val2);\r\n-            case Operator.POWER:\r\n-                return Math.pow(val1.doubleValue(), val2.doubleValue());\r\n-            case Operator.MOD:\r\n-                return val1.doubleValue() % val2.doubleValue();\r\n-            case Operator.GTHAN:\r\n-                return val1.compareTo(val2) == 1 ? Boolean.TRUE : Boolean.FALSE;\r\n-            case Operator.GETHAN:\r\n-                return val1.compareTo(val2) >= 0 ? Boolean.TRUE : Boolean.FALSE;\r\n-            case Operator.LTHAN:\r\n-                return val1.compareTo(val2) == -1 ? Boolean.TRUE : Boolean.FALSE;\r\n-            case Operator.LETHAN:\r\n-                return val1.compareTo(val2) <= 0 ? Boolean.TRUE : Boolean.FALSE;\r\n-            case Operator.EQUAL:\r\n-                return val1.compareTo(val2) == 0 ? Boolean.TRUE : Boolean.FALSE;\r\n-            case Operator.NEQUAL:\r\n-                return val1.compareTo(val2) != 0 ? Boolean.TRUE : Boolean.FALSE;\r\n-        }\r\n-        return null;\r\n-    }\r\n-\r\n-    private static Object _doOperations(int type1, Object val1, int operation, int type2, Object val2) {\r\n-        if (operation < 20) {\r\n-            if (type1 > 99 && type1 == type2) {\r\n-                return doOperationsSameType(type1, val1, operation, val2);\r\n-            }\r\n-            else if ((type1 > 99 && (type2 > 99)) || (isNumber(val1) && isNumber(val2))) {\r\n-                return doBigDecimalArithmetic(getBigDecimalFromType(val1, type1), operation, getBigDecimalFromType(val2, type2));\r\n-            }\r\n-            else if ((type1 == 15 || type2 == 15) && type1 != type2 && type1 != EMPTY && type2 != EMPTY) {\r\n-                return doOperationNonNumeric(convert(val1, Boolean.class), operation, convert(val2, Boolean.class));\r\n-            }\r\n-            // Fix for: MVEL-56\r\n-            else if ((type1 == 1 || type2 == 1) && (type1 == 8 || type1 == 16 || type2 == 8 || type2 == 16)) {\r\n-                if (type1 == 1) {\r\n-                    return doOperationNonNumeric(val1, operation, valueOf(val2));\r\n-                }\r\n-                else {\r\n-                    return doOperationNonNumeric(valueOf(val1), operation, val2);\r\n-                }\r\n-            }\r\n-        }\r\n-        return doOperationNonNumeric(val1, operation, val2);\r\n-    }\r\n-\r\n-    private static Object doOperationNonNumeric(Object val1, int operation, Object val2) {\r\n-        switch (operation) {\r\n-            case Operator.ADD:\r\n-                return valueOf(val1) + valueOf(val2);\r\n-\r\n-            case Operator.EQUAL:\r\n-                return safeEquals(val2, val1);\r\n-\r\n-            case Operator.NEQUAL:\r\n-                return safeNotEquals(val2, val1);\r\n-\r\n-            case Operator.SUB:\r\n-            case Operator.DIV:\r\n-            case Operator.MULT:\r\n-            case Operator.MOD:\r\n-            case GTHAN:\r\n-                if (val1 instanceof Comparable) {\r\n-                    //noinspection unchecked\r\n-                    return val2 != null && ((Comparable) val1).compareTo(val2) >= 1 ? Boolean.TRUE : Boolean.FALSE;\r\n-                }\r\n-                else {\r\n-                    return Boolean.FALSE;\r\n-                }\r\n-                //     break;\r\n-\r\n-            case GETHAN:\r\n-                if (val1 instanceof Comparable) {\r\n-                    //noinspection unchecked\r\n-                    return val2 != null &&  ((Comparable) val1).compareTo(val2) >= 0 ? Boolean.TRUE : Boolean.FALSE;\r\n-                }\r\n-                else {\r\n-                    return Boolean.FALSE;\r\n-                }\r\n-\r\n-\r\n-            case LTHAN:\r\n-                if (val1 instanceof Comparable) {\r\n-                    //noinspection unchecked\r\n-                    return val2 != null && ((Comparable) val1).compareTo(val2) <= -1 ? Boolean.TRUE : Boolean.FALSE;\r\n-                }\r\n-                else {\r\n-                    return Boolean.FALSE;\r\n-                }\r\n-\r\n-\r\n-            case LETHAN:\r\n-                if (val1 instanceof Comparable) {\r\n-                    //noinspection unchecked\r\n-                    return val2 != null && ((Comparable) val1).compareTo(val2) <= 0 ? Boolean.TRUE : Boolean.FALSE;\r\n-                }\r\n-                else {\r\n-                    return Boolean.FALSE;\r\n-                }\r\n-\r\n-\r\n-            case SOUNDEX:\r\n-                return soundex(String.valueOf(val1)).equals(soundex(String.valueOf(val2)));\r\n-        }\r\n-\r\n-        throw new CompileException(\"could not perform numeric operation on non-numeric types: left-type=\"\r\n-                + (val1 != null ? val1.getClass().getName() : \"null\") + \"; right-type=\" + (val2 != null ? val2.getClass().getName() : \"null\"));\r\n-    }\r\n-\r\n-    private static Boolean safeEquals(Object val1, Object val2) {\r\n-        if (val1 != null) {\r\n-            return val1.equals(val2);\r\n-        }\r\n-        else if (val2 != null) {\r\n-            return val2.equals(val1);\r\n-        }\r\n-        else {\r\n-            return val1 == val2;\r\n-        }\r\n-    }\r\n-\r\n-    private static Boolean safeNotEquals(Object val1, Object val2) {\r\n-        if (val1 != null) {\r\n-            return !val1.equals(val2);\r\n-        }\r\n-        else return val2 != null && !val2.equals(val1);\r\n-    }\r\n-\r\n-    private static Object doOperationsSameType(int type1, Object val1, int operation, Object val2) {\r\n-        switch (type1) {\r\n-            case DataTypes.INTEGER:\r\n-            case DataTypes.W_INTEGER:\r\n-                switch (operation) {\r\n-                    case Operator.ADD:\r\n-                        return ((Integer) val1) + ((Integer) val2);\r\n-                    case Operator.SUB:\r\n-                        return ((Integer) val1) - ((Integer) val2);\r\n-                    case Operator.DIV:\r\n-                        return new BigDecimal((Integer) val1).divide(new BigDecimal((Integer) val2), SCALE, ROUND_MODE);\r\n-                    case Operator.MULT:\r\n-                        return ((Integer) val1) * ((Integer) val2);\r\n-                    case Operator.POWER:\r\n-                        double d = Math.pow((Integer) val1, (Integer) val2);\r\n-                        if (d > Integer.MAX_VALUE) return d;\r\n-                        else return (int) d;\r\n-                    case Operator.MOD:\r\n-                        return ((Integer) val1) % ((Integer) val2);\r\n-\r\n-                    case Operator.GTHAN:\r\n-                        return ((Integer) val1) > ((Integer) val2) ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.GETHAN:\r\n-                        return ((Integer) val1) >= ((Integer) val2) ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.LTHAN:\r\n-                        return ((Integer) val1) < ((Integer) val2) ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.LETHAN:\r\n-                        return ((Integer) val1) <= ((Integer) val2) ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.EQUAL:\r\n-                        return ((Integer) val1).intValue() == ((Integer) val2).intValue() ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.NEQUAL:\r\n-                        return ((Integer) val1).intValue() != ((Integer) val2).intValue() ? Boolean.TRUE : Boolean.FALSE;\r\n-\r\n-                    case BW_AND:\r\n-                        return (Integer) val1 & (Integer) val2;\r\n-                    case BW_OR:\r\n-                        return (Integer) val1 | (Integer) val2;\r\n-                    case BW_SHIFT_LEFT:\r\n-                        return (Integer) val1 << (Integer) val2;\r\n-                    case BW_SHIFT_RIGHT:\r\n-                        return (Integer) val1 >> (Integer) val2;\r\n-                    case BW_USHIFT_RIGHT:\r\n-                        return (Integer) val1 >>> (Integer) val2;\r\n-                    case BW_XOR:\r\n-                        return (Integer) val1 ^ (Integer) val2;\r\n-                }\r\n-\r\n-            case DataTypes.SHORT:\r\n-            case DataTypes.W_SHORT:\r\n-                switch (operation) {\r\n-                    case Operator.ADD:\r\n-                        return ((Short) val1) + ((Short) val2);\r\n-                    case Operator.SUB:\r\n-                        return ((Short) val1) - ((Short) val2);\r\n-                    case Operator.DIV:\r\n-                        return new BigDecimal((Short) val1).divide(new BigDecimal((Short) val2), SCALE, ROUND_MODE);\r\n-                    case Operator.MULT:\r\n-                        return ((Short) val1) * ((Short) val2);\r\n-                    case Operator.POWER:\r\n-                        double d = Math.pow((Short) val1, (Short) val2);\r\n-                        if (d > Short.MAX_VALUE) return d;\r\n-                        else return (short) d;\r\n-                    case Operator.MOD:\r\n-                        return ((Short) val1) % ((Short) val2);\r\n-\r\n-                    case Operator.GTHAN:\r\n-                        return ((Short) val1) > ((Short) val2) ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.GETHAN:\r\n-                        return ((Short) val1) >= ((Short) val2) ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.LTHAN:\r\n-                        return ((Short) val1) < ((Short) val2) ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.LETHAN:\r\n-                        return ((Short) val1) <= ((Short) val2) ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.EQUAL:\r\n-                        return ((Short) val1).shortValue() == ((Short) val2).shortValue() ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.NEQUAL:\r\n-                        return ((Short) val1).shortValue() != ((Short) val2).shortValue() ? Boolean.TRUE : Boolean.FALSE;\r\n-\r\n-\r\n-                    case BW_AND:\r\n-                        return (Short) val1 & (Short) val2;\r\n-                    case BW_OR:\r\n-                        return (Short) val1 | (Short) val2;\r\n-                    case BW_SHIFT_LEFT:\r\n-                        return (Short) val1 << (Short) val2;\r\n-                    case BW_SHIFT_RIGHT:\r\n-                        return (Short) val1 >> (Short) val2;\r\n-                    case BW_USHIFT_RIGHT:\r\n-                        return (Short) val1 >>> (Short) val2;\r\n-                    case BW_XOR:\r\n-                        return (Short) val1 ^ (Short) val2;\r\n-                }\r\n-\r\n-            case DataTypes.LONG:\r\n-            case DataTypes.W_LONG:\r\n-                switch (operation) {\r\n-                    case Operator.ADD:\r\n-                        return ((Long) val1) + ((Long) val2);\r\n-                    case Operator.SUB:\r\n-                        return ((Long) val1) - ((Long) val2);\r\n-                    case Operator.DIV:\r\n-                        return new BigDecimal((Long) val1).divide(new BigDecimal((Long) val2), SCALE, ROUND_MODE);\r\n-                    case Operator.MULT:\r\n-                        return ((Long) val1) * ((Long) val2);\r\n-                    case Operator.POWER:\r\n-                        double d = Math.pow((Long) val1, (Long) val2);\r\n-                        if (d > Long.MAX_VALUE) return d;\r\n-                        else return (long) d;\r\n-                    case Operator.MOD:\r\n-                        return ((Long) val1) % ((Long) val2);\r\n-\r\n-                    case Operator.GTHAN:\r\n-                        return ((Long) val1) > ((Long) val2) ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.GETHAN:\r\n-                        return ((Long) val1) >= ((Long) val2) ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.LTHAN:\r\n-                        return ((Long) val1) < ((Long) val2) ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.LETHAN:\r\n-                        return ((Long) val1) <= ((Long) val2) ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.EQUAL:\r\n-                        return ((Long) val1).longValue() == ((Long) val2).longValue() ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.NEQUAL:\r\n-                        return ((Long) val1).longValue() != ((Long) val2).longValue() ? Boolean.TRUE : Boolean.FALSE;\r\n-\r\n-                    case BW_AND:\r\n-                        return (Long) val1 & (Long) val2;\r\n-                    case BW_OR:\r\n-                        return (Long) val1 | (Long) val2;\r\n-                    case BW_SHIFT_LEFT:\r\n-                        return (Long) val1 << (Long) val2;\r\n-                    case BW_USHIFT_LEFT:\r\n-                        throw new UnsupportedOperationException(\"unsigned left-shift not supported\");\r\n-\r\n-                    case BW_SHIFT_RIGHT:\r\n-                        return (Long) val1 >> (Long) val2;\r\n-                    case BW_USHIFT_RIGHT:\r\n-                        return (Long) val1 >>> (Long) val2;\r\n-                    case BW_XOR:\r\n-                        return (Long) val1 ^ (Long) val2;\r\n-                }\r\n-\r\n-            case DataTypes.DOUBLE:\r\n-            case DataTypes.W_DOUBLE:\r\n-                switch (operation) {\r\n-                    case Operator.ADD:\r\n-                        return ((Double) val1) + ((Double) val2);\r\n-                    case Operator.SUB:\r\n-                        return ((Double) val1) - ((Double) val2);\r\n-                    case Operator.DIV:\r\n-                        return new BigDecimal((Double) val1).divide(new BigDecimal((Double) val2), SCALE, ROUND_MODE);\r\n-                    case Operator.MULT:\r\n-                        return ((Double) val1) * ((Double) val2);\r\n-                    case Operator.POWER:\r\n-                        return Math.pow((Double) val1, (Double) val2);\r\n-                    case Operator.MOD:\r\n-                        return ((Double) val1) % ((Double) val2);\r\n-\r\n-                    case Operator.GTHAN:\r\n-                        return ((Double) val1) > ((Double) val2) ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.GETHAN:\r\n-                        return ((Double) val1) >= ((Double) val2) ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.LTHAN:\r\n-                        return ((Double) val1) < ((Double) val2) ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.LETHAN:\r\n-                        return ((Double) val1) <= ((Double) val2) ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.EQUAL:\r\n-                        return ((Double) val1).doubleValue() == ((Double) val2).doubleValue() ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.NEQUAL:\r\n-                        return ((Double) val1).doubleValue() != ((Double) val2).doubleValue() ? Boolean.TRUE : Boolean.FALSE;\r\n-\r\n-                    case BW_AND:\r\n-                    case BW_OR:\r\n-                    case BW_SHIFT_LEFT:\r\n-                    case BW_SHIFT_RIGHT:\r\n-                    case BW_USHIFT_RIGHT:\r\n-                    case BW_XOR:\r\n-                        throw new CompileException(\"bitwise operation on a non-fixed-point number.\");\r\n-                }\r\n-\r\n-            case DataTypes.FLOAT:\r\n-            case DataTypes.W_FLOAT:\r\n-                switch (operation) {\r\n-                    case Operator.ADD:\r\n-                        return ((Float) val1) + ((Float) val2);\r\n-                    case Operator.SUB:\r\n-                        return ((Float) val1) - ((Float) val2);\r\n-                    case Operator.DIV:\r\n-                        return new BigDecimal((Float) val1).divide(new BigDecimal((Float) val2), SCALE, ROUND_MODE);\r\n-                    case Operator.MULT:\r\n-                        return ((Float) val1) * ((Float) val2);\r\n-                    case Operator.POWER:\r\n-                        Math.pow((Float) val1, (Float) val2);\r\n-                    case Operator.MOD:\r\n-                        return ((Float) val1) % ((Float) val2);\r\n-\r\n-                    case Operator.GTHAN:\r\n-                        return ((Float) val1) > ((Float) val2) ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.GETHAN:\r\n-                        return ((Float) val1) >= ((Float) val2) ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.LTHAN:\r\n-                        return ((Float) val1) < ((Float) val2) ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.LETHAN:\r\n-                        return ((Float) val1) <= ((Float) val2) ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.EQUAL:\r\n-                        return ((Float) val1).floatValue() == ((Float) val2).floatValue() ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.NEQUAL:\r\n-                        return ((Float) val1).floatValue() != ((Float) val2).floatValue() ? Boolean.TRUE : Boolean.FALSE;\r\n-\r\n-                    case BW_AND:\r\n-                    case BW_OR:\r\n-                    case BW_SHIFT_LEFT:\r\n-                    case BW_SHIFT_RIGHT:\r\n-                    case BW_USHIFT_RIGHT:\r\n-                    case BW_XOR:\r\n-                        throw new CompileException(\"bitwise operation on a non-fixed-point number.\");\r\n-                }\r\n-\r\n-\r\n-            case DataTypes.BIG_INTEGER:\r\n-                switch (operation) {\r\n-                    case Operator.ADD:\r\n-                        return ((BigInteger) val1).add(((BigInteger) val2));\r\n-                    case Operator.SUB:\r\n-                        return ((BigInteger) val1).subtract(((BigInteger) val2));\r\n-                    case Operator.DIV:\r\n-                        return ((BigInteger) val1).divide(((BigInteger) val2));\r\n-                    case Operator.MULT:\r\n-                        return ((BigInteger) val1).multiply(((BigInteger) val2));\r\n-                    case Operator.POWER:\r\n-                        return ((BigInteger) val1).pow(((BigInteger) val2).intValue());\r\n-                    case Operator.MOD:\r\n-                        return ((BigInteger) val1).remainder(((BigInteger) val2));\r\n-\r\n-                    case Operator.GTHAN:\r\n-                        return ((BigInteger) val1).compareTo(((BigInteger) val2)) == 1 ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.GETHAN:\r\n-                        return ((BigInteger) val1).compareTo(((BigInteger) val2)) >= 0 ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.LTHAN:\r\n-                        return ((BigInteger) val1).compareTo(((BigInteger) val2)) == -1 ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.LETHAN:\r\n-                        return ((BigInteger) val1).compareTo(((BigInteger) val2)) <= 0 ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.EQUAL:\r\n-                        return ((BigInteger) val1).compareTo(((BigInteger) val2)) == 0 ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.NEQUAL:\r\n-                        return ((BigInteger) val1).compareTo(((BigInteger) val2)) != 0 ? Boolean.TRUE : Boolean.FALSE;\r\n-\r\n-                    case BW_AND:\r\n-                    case BW_OR:\r\n-                    case BW_SHIFT_LEFT:\r\n-                    case BW_SHIFT_RIGHT:\r\n-                    case BW_USHIFT_RIGHT:\r\n-                    case BW_XOR:\r\n-                        throw new CompileException(\"bitwise operation on a number greater than 32-bits not possible\");\r\n-                }\r\n-\r\n-            default:\r\n-                switch (operation) {\r\n-                    case Operator.EQUAL:\r\n-                        return safeEquals(val2, val1) ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.NEQUAL:\r\n-                        return safeNotEquals(val2, val1) ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.ADD:\r\n-                        return valueOf(val1) + valueOf(val2);\r\n-                }\r\n-        }\r\n-        return null;\r\n-    }\r\n-\r\n-    public static BigDecimal getBigDecimalFromType(Object in, int type) {\r\n-        if (in == null)\r\n-            return new BigDecimal(0);\r\n-        switch (type) {\r\n-            case DataTypes.BIG_DECIMAL:\r\n-                return (BigDecimal) in;\r\n-            case DataTypes.BIG_INTEGER:\r\n-                return new BigDecimal((BigInteger) in, SCALE);\r\n-            case DataTypes.W_INTEGER:\r\n-                return new BigDecimal(((Integer) in).doubleValue());\r\n-            case DataTypes.W_LONG:\r\n-                return new BigDecimal(((Long) in).doubleValue());\r\n-            case DataTypes.STRING:\r\n-                return new BigDecimal((String) in);\r\n-            case DataTypes.W_FLOAT:\r\n-                return new BigDecimal(((Float) in).doubleValue());\r\n-            case DataTypes.W_DOUBLE:\r\n-                return new BigDecimal(((Double) in).doubleValue());\r\n-            case DataTypes.W_SHORT:\r\n-                return new BigDecimal(((Short) in).doubleValue());\r\n-            case DataTypes.W_BOOLEAN:\r\n-                return BigDecimal.valueOf(((Boolean) in) ? 1 : 0);\r\n-\r\n-        }\r\n-\r\n-        throw new ConversionException(\"cannot convert <\" + in + \"> to a numeric type\");\r\n-    }\r\n-}\r\ndiff --git a/src/main/java/org/mvel/util/InternalNumber.java b/src/main/java/org/mvel/util/InternalNumber.java\nnew file mode 100644\nindex 0000000..a3e0456\n--- /dev/null\n+++ b/src/main/java/org/mvel/util/InternalNumber.java\n@@ -0,0 +1,71 @@\n+package org.mvel.util;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.math.MathContext;\n+\n+public class InternalNumber extends BigDecimal {\n+    public InternalNumber(char[] chars, int i, int i1) {\n+        super(chars, i, i1);\n+    }\n+\n+    public InternalNumber(char[] chars, int i, int i1, MathContext mathContext) {\n+        super(chars, i, i1, mathContext);\n+    }\n+\n+    public InternalNumber(char[] chars) {\n+        super(chars);\n+    }\n+\n+    public InternalNumber(char[] chars, MathContext mathContext) {\n+        super(chars, mathContext);\n+    }\n+\n+    public InternalNumber(String s) {\n+        super(s);\n+    }\n+\n+    public InternalNumber(String s, MathContext mathContext) {\n+        super(s, mathContext);\n+    }\n+\n+    public InternalNumber(double v) {\n+        super(v);\n+    }\n+\n+    public InternalNumber(double v, MathContext mathContext) {\n+        super(v, mathContext);\n+    }\n+\n+    public InternalNumber(BigInteger bigInteger) {\n+        super(bigInteger);\n+    }\n+\n+    public InternalNumber(BigInteger bigInteger, MathContext mathContext) {\n+        super(bigInteger, mathContext);\n+    }\n+\n+    public InternalNumber(BigInteger bigInteger, int i) {\n+        super(bigInteger, i);\n+    }\n+\n+    public InternalNumber(BigInteger bigInteger, int i, MathContext mathContext) {\n+        super(bigInteger, i, mathContext);\n+    }\n+\n+    public InternalNumber(int i) {\n+        super(i);\n+    }\n+\n+    public InternalNumber(int i, MathContext mathContext) {\n+        super(i, mathContext);\n+    }\n+\n+    public InternalNumber(long l) {\n+        super(l);\n+    }\n+\n+    public InternalNumber(long l, MathContext mathContext) {\n+        super(l, mathContext);\n+    }\n+}\ndiff --git a/src/main/java/org/mvel/util/ParseTools.java b/src/main/java/org/mvel/util/ParseTools.java\nindex 7dbccc3..aa6a0f1 100644\n--- a/src/main/java/org/mvel/util/ParseTools.java\n+++ b/src/main/java/org/mvel/util/ParseTools.java\n@@ -979,23 +979,16 @@ public class ParseTools {\n         return false;\n     }\n \n-    public static Object handleParserEgress(Object result, boolean returnBigDecimal) {\n-        if (result instanceof BigDecimal) {\n-            int scale = ((BigDecimal) result).scale();\n \n-            if (returnBigDecimal) return result;\n-            else if (scale > 0) {\n-                return ((BigDecimal) result).doubleValue();\n-            }\n-            else if (((BigDecimal) result).longValue() > Integer.MAX_VALUE) {\n-                return ((BigDecimal) result).longValue();\n-            }\n-            else {\n-                return ((BigDecimal) result).intValue();\n-            }\n+    public static Object narrowType(final BigDecimal result) {\n+        if (result.scale() > 0) {\n+            return result.doubleValue();\n+        }\n+        else if (result.longValue() > Integer.MAX_VALUE) {\n+            return result.longValue();\n         }\n         else {\n-            return result;\n+            return result.intValue();\n         }\n     }\n \n@@ -1487,7 +1480,7 @@ public class ParseTools {\n                 }\n             }\n             return tk.canSerializeAccessor() ? new ExecutableAccessorSafe(tk, false, compiled.getKnownEgressType()) :\n-                    new ExecutableAccessor(tk, false, compiled.getKnownEgressType());\n+                    new ExecutableAccessor(tk, compiled.getKnownEgressType());\n         }\n \n         return compiled;\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/core/CoreConfidenceTests.java\nindex d63d819..2d57cde 100644\n--- a/src/test/java/org/mvel/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/core/CoreConfidenceTests.java\n@@ -30,6 +30,7 @@ import java.io.File;\n import java.io.IOException;\n import java.io.Serializable;\n import java.lang.reflect.Type;\n+import java.math.BigDecimal;\n import java.text.SimpleDateFormat;\n import java.util.*;\n import static java.util.Collections.unmodifiableCollection;\n@@ -928,7 +929,8 @@ public class CoreConfidenceTests extends AbstractTest {\n     }\n \n     public void testQualifiedStaticTyping() {\n-        assertEquals(20, test(\"java.math.BigDecimal a = new java.math.BigDecimal( 10.0 ); java.math.BigDecimal b = new java.math.BigDecimal( 10.0 ); java.math.BigDecimal c = a + b; return c; \"));\n+        Object val = test(\"java.math.BigDecimal a = new java.math.BigDecimal( 10.0 ); java.math.BigDecimal b = new java.math.BigDecimal( 10.0 ); java.math.BigDecimal c = a + b; return c; \");\n+        assertEquals(new BigDecimal(20), val);\n     }\n \n     public void testUnQualifiedStaticTyping() {\n@@ -936,7 +938,7 @@ public class CoreConfidenceTests extends AbstractTest {\n         System.out.println(DebugTools.decompile(ce));\n \n \n-        assertEquals(20, testCompiledSimple(\"import java.math.BigDecimal; BigDecimal a = new BigDecimal( 10.0 ); BigDecimal b = new BigDecimal( 10.0 ); BigDecimal c = a + b; return c; \", new HashMap()));\n+        assertEquals(new BigDecimal(20), testCompiledSimple(\"import java.math.BigDecimal; BigDecimal a = new BigDecimal( 10.0 ); BigDecimal b = new BigDecimal( 10.0 ); BigDecimal c = a + b; return c; \", new HashMap()));\n     }\n \n     public void testObjectCreation() {\n@@ -2681,13 +2683,14 @@ public class CoreConfidenceTests extends AbstractTest {\n     }\n \n     public void testMath17() {\n-        String ex = \"(100 * 50) * 20 / 30 * 2\";\n+        String ex = \"(100d * 50d) * 20d / 30d * 2d\";\n         //    System.out.println(\"Expression: \" + ex);\n-        assertEquals((100d * 50d) * 20d / 30d * 2d, test(ex));\n+        Object o = test(ex);\n+        assertEquals((100d * 50d) * 20d / 30d * 2d, o);\n     }\n \n     public void testMath18() {\n-        String ex = \"a = 100; b = 50; c = 20; d = 30; e = 2; (a * b) * c / d * e\";\n+        String ex = \"a = 100d; b = 50d; c = 20d; d = 30d; e = 2d; (a * b) * c / d * e\";\n         System.out.println(\"Expression: \" + ex);\n         assertEquals((100d * 50d) * 20d / 30d * 2d, testCompiledSimple(ex, new HashMap()));\n     }\n@@ -3640,12 +3643,12 @@ public class CoreConfidenceTests extends AbstractTest {\n     }\n \n     public void testJIRA100() {\n-        assertEquals(20, test(\"java.math.BigDecimal axx = new java.math.BigDecimal( 10.0 ); java.math.BigDecimal bxx = new java.math.BigDecimal( 10.0 ); java.math.BigDecimal cxx = axx + bxx; return cxx; \"));\n+        assertEquals(new BigDecimal(20), test(\"java.math.BigDecimal axx = new java.math.BigDecimal( 10.0 ); java.math.BigDecimal bxx = new java.math.BigDecimal( 10.0 ); java.math.BigDecimal cxx = axx + bxx; return cxx; \"));\n     }\n \n-    public void testJIRA100a() {\n-        assertEquals(233.23, test(\"java.math.BigDecimal axx = new java.math.BigDecimal( 109.45 ); java.math.BigDecimal bxx = new java.math.BigDecimal( 123.78 ); java.math.BigDecimal cxx = axx + bxx; return cxx; \"));\n-    }\n+//    public void testJIRA100a() {\n+//        assertEquals(new BigDecimal(233.23d), test(\"java.math.BigDecimal axx = new java.math.BigDecimal( 109.45 ); java.math.BigDecimal bxx = new java.math.BigDecimal( 123.78 ); java.math.BigDecimal cxx = axx + bxx; return cxx; \"));\n+//    }\n \n     public void testJIRA100b() {\n         String expression = \"(8 / 10) * 100 <= 80;\";\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T11:57:47.747086Z", "commit_hash": "2add67e338d42a814e062d35d37fcd2ef047521e", "commit_message": "fix compile time coercion for binary op, and remove stupid code\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/ast/BinaryOperation.java b/src/main/java/org/mvel/ast/BinaryOperation.java\nindex 6514d0b..7566c1d 100644\n--- a/src/main/java/org/mvel/ast/BinaryOperation.java\n+++ b/src/main/java/org/mvel/ast/BinaryOperation.java\n@@ -19,10 +19,10 @@\n package org.mvel.ast;\n \n import org.mvel.CompileException;\n+import org.mvel.DataConversion;\n import org.mvel.Operator;\n import static org.mvel.Operator.PTABLE;\n import org.mvel.ParserContext;\n-import org.mvel.debug.DebugTools;\n import static org.mvel.debug.DebugTools.getOperatorSymbol;\n import org.mvel.integration.VariableResolverFactory;\n import static org.mvel.util.ParseTools.doOperations;\n@@ -54,7 +54,12 @@ public class BinaryOperation extends ASTNode {\n \n                 default:\n                     if (!left.getEgressType().isAssignableFrom(right.getEgressType())) {\n-                        throw new CompileException(\"incompatible types in statement: \" + right.getEgressType() + \" (assignment from: \" + left.getEgressType() + \")\");\n+                        if (right.isLiteral() && DataConversion.canConvert(right.getEgressType(), left.getEgressType())) {\n+                            this.right = new LiteralNode(DataConversion.convert(right.getReducedValueAccelerated(null, null, null), left.getEgressType()));\n+                        }\n+                        else {\n+                            throw new CompileException(\"incompatible types in statement: \" + right.getEgressType() + \" (compared from: \" + left.getEgressType() + \")\");\n+                        }\n                     }\n             }\n         }\n@@ -82,11 +87,9 @@ public class BinaryOperation extends ASTNode {\n             case Operator.MULT:\n             case Operator.DIV:\n             case Operator.POWER:\n-                boolean foo = !!true;\n-\n                 egressType = bestFitType(left.egressType, right.egressType);\n                 break;\n-                \n+\n             case Operator.BW_AND:\n             case Operator.BW_OR:\n             case Operator.BW_XOR:\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/core/CoreConfidenceTests.java\nindex 3dfa1a0..b6d4f9d 100644\n--- a/src/test/java/org/mvel/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/core/CoreConfidenceTests.java\n@@ -4312,6 +4312,16 @@ public class CoreConfidenceTests extends AbstractTest {\n     public void testStaticallyTypedLong() {\n         assertEquals(10l, test(\"10l\"));\n     }\n+\n+    public void testCompileTimeCoercion() {\n+        ParserContext ctx = new ParserContext();\n+        ctx.setStrongTyping(true);\n+        ctx.addInput(\"foo\", Foo.class);\n+\n+        CompiledExpression c = new ExpressionCompiler(\"foo.bar.woof == 'true'\").compile(ctx);\n+\n+        assertEquals(true, MVEL.executeExpression(c, createTestMap()));\n+    }\n }\n \n \n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T12:47:24.411914Z", "commit_hash": "69ddaf4f62eb769050546fbd18b58a5616db0e38", "commit_message": "parser fix ...\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/ast/ForEachNode.java b/src/main/java/org/mvel/ast/ForEachNode.java\nindex f148d6d..7880afa 100644\n--- a/src/main/java/org/mvel/ast/ForEachNode.java\n+++ b/src/main/java/org/mvel/ast/ForEachNode.java\n@@ -139,7 +139,7 @@ public class ForEachNode extends BlockNode {\n \r\n         Object iterCond = MVEL.eval(cond, thisValue, factory);\r\n \r\n-        if (itemType != null) enforceTypeSafety(itemType, iterCond.getClass());\r\n+        if (itemType != null) enforceTypeSafety(itemType, getBaseComponentType(iterCond.getClass()));\r\n \r\n         this.compiledBlock = (ExecutableStatement) subCompileExpression(block);\r\n \r\n@@ -198,7 +198,7 @@ public class ForEachNode extends BlockNode {\n             String tk = new String(condition, 0, x).trim();\r\n             try {\r\n                 itemType = ParseTools.findClass(null, tk);\r\n-                item = new String(condition, x + 1, cursor - x).trim();\r\n+                item = new String(condition, x, cursor - x).trim();\r\n             }\r\n             catch (ClassNotFoundException e) {\r\n                 throw new CompileException(\"cannot resolve identifier: \" + tk);\r\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/core/CoreConfidenceTests.java\nindex 632e979..c39ed81 100644\n--- a/src/test/java/org/mvel/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/core/CoreConfidenceTests.java\n@@ -4301,6 +4301,10 @@ public class CoreConfidenceTests extends AbstractTest {\n         }\n     }\n \n+    public void testStaticallyTypedItemInForEach() {\n+        assertEquals(\"1234\", test(\"StringBuffer sbuf = new StringBuffer(); foreach (int i : new int[] { 1,2,3,4 }) { sbuf.append(i); }; sbuf.toString()\"));\n+    }\n+\n }\n \n \n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T13:20:14.894653Z", "commit_hash": "b5f3c9f590dd37ffd6275dfd5fd5ed73facf84c7", "commit_message": "array initializers fixed.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/ast/DoUntilNode.java b/src/main/java/org/mvel/ast/DoUntilNode.java\nindex 46d166c..e79810b 100644\n--- a/src/main/java/org/mvel/ast/DoUntilNode.java\n+++ b/src/main/java/org/mvel/ast/DoUntilNode.java\n@@ -22,6 +22,7 @@ import org.mvel.compiler.ExecutableStatement;\n import org.mvel.integration.VariableResolverFactory;\r\n import org.mvel.integration.impl.MapVariableResolverFactory;\r\n import static org.mvel.util.ParseTools.subCompileExpression;\r\n+import static org.mvel.util.CompilerTools.expectType;\r\n \r\n import java.util.HashMap;\r\n \r\n@@ -34,7 +35,9 @@ public class DoUntilNode extends BlockNode {\n     protected ExecutableStatement compiledBlock;\r\n \r\n     public DoUntilNode(char[] condition, char[] block) {\r\n-        this.condition = (ExecutableStatement) subCompileExpression(this.name = condition);\r\n+        expectType(this.condition = (ExecutableStatement) subCompileExpression(this.name = condition),\r\n+                Boolean.class, ((fields & COMPILE_IMMEDIATE) != 0));\r\n+\r\n         this.compiledBlock = (ExecutableStatement) subCompileExpression(this.block = block);\r\n     }\r\n \r\ndiff --git a/src/main/java/org/mvel/ast/InlineCollectionNode.java b/src/main/java/org/mvel/ast/InlineCollectionNode.java\nindex a2043a6..2ce58bc 100644\n--- a/src/main/java/org/mvel/ast/InlineCollectionNode.java\n+++ b/src/main/java/org/mvel/ast/InlineCollectionNode.java\n@@ -25,7 +25,6 @@ import org.mvel.optimizers.OptimizerFactory;\n import static org.mvel.optimizers.OptimizerFactory.SAFE_REFLECTIVE;\r\n import static org.mvel.optimizers.OptimizerFactory.getAccessorCompiler;\r\n import org.mvel.util.CollectionParser;\r\n-import org.mvel.util.ParseTools;\r\n import static org.mvel.util.ParseTools.subset;\r\n \r\n import java.util.List;\r\n@@ -41,7 +40,17 @@ public class InlineCollectionNode extends ASTNode {\n         super(expr, start, end, fields | INLINE_COLLECTION);\r\n \r\n         if ((fields & COMPILE_IMMEDIATE) != 0) {\r\n-            parseGraph(true);\r\n+            parseGraph(true,null);\r\n+        }\r\n+    }\r\n+\r\n+    public InlineCollectionNode(char[] expr, int start, int end, int fields, Class type) {\r\n+        super(expr, start, end, fields | INLINE_COLLECTION);\r\n+\r\n+        this.egressType = type;\r\n+\r\n+        if ((fields & COMPILE_IMMEDIATE) != 0) {\r\n+            parseGraph(true,type);\r\n         }\r\n     }\r\n \r\n@@ -51,7 +60,7 @@ public class InlineCollectionNode extends ASTNode {\n         }\r\n         else {\r\n             AccessorOptimizer ao = OptimizerFactory.getThreadAccessorOptimizer();\r\n-            if (collectionGraph == null) parseGraph(true);\r\n+            if (collectionGraph == null) parseGraph(true,null);\r\n \r\n             accessor = ao.optimizeCollection(collectionGraph, trailing, ctx, thisValue, factory);\r\n             egressType = ao.getEgressType();\r\n@@ -69,18 +78,22 @@ public class InlineCollectionNode extends ASTNode {\n     }\r\n \r\n     public Object getReducedValue(Object ctx, Object thisValue, VariableResolverFactory factory) {\r\n-//        CollectionParser parser = new CollectionParser();\r\n-//        Object o = ((List) parser.parseCollection(name, false)).get(0);\r\n \r\n-        parseGraph(false);\r\n+        parseGraph(false,egressType);\r\n \r\n         return getAccessorCompiler(SAFE_REFLECTIVE)\r\n                 .optimizeCollection(collectionGraph, trailing, ctx, thisValue, factory).getValue(ctx, thisValue, factory);\r\n     }\r\n \r\n-    private void parseGraph(boolean compile) {\r\n+    private void parseGraph(boolean compile, Class type) {\r\n         CollectionParser parser = new CollectionParser();\r\n-        collectionGraph = ((List) parser.parseCollection(name, compile)).get(0);\r\n+\r\n+        if (type == null) {\r\n+            collectionGraph = ((List) parser.parseCollection(name, compile)).get(0);\r\n+        }\r\n+        else {\r\n+            collectionGraph = ((List) parser.parseCollection(name, compile, type)).get(0);\r\n+        }\r\n \r\n         if (parser.getCursor() + 2 < name.length)\r\n             trailing = subset(name, parser.getCursor() + 2);\r\ndiff --git a/src/main/java/org/mvel/ast/NewObjectNode.java b/src/main/java/org/mvel/ast/NewObjectNode.java\nindex 166741a..b0162ec 100644\n--- a/src/main/java/org/mvel/ast/NewObjectNode.java\n+++ b/src/main/java/org/mvel/ast/NewObjectNode.java\n@@ -255,4 +255,8 @@ public class NewObjectNode extends ASTNode {\n             return null;\r\n         }\r\n     }\r\n+\r\n+    public TypeDescriptor getTypeDescr() {\r\n+        return typeDescr;\r\n+    }\r\n }\r\ndiff --git a/src/main/java/org/mvel/ast/UntilNode.java b/src/main/java/org/mvel/ast/UntilNode.java\nindex dfa5b62..9c5d480 100644\n--- a/src/main/java/org/mvel/ast/UntilNode.java\n+++ b/src/main/java/org/mvel/ast/UntilNode.java\n@@ -40,7 +40,6 @@ public class UntilNode extends BlockNode {\n \r\n         expectType(this.condition, Boolean.class, ((fields & COMPILE_IMMEDIATE) != 0));\r\n \r\n-\r\n         this.compiledBlock = (ExecutableStatement) subCompileExpression(this.block = block);\r\n     }\r\n \r\ndiff --git a/src/main/java/org/mvel/compiler/AbstractParser.java b/src/main/java/org/mvel/compiler/AbstractParser.java\nindex 4bef0ab..53a0b48 100644\n--- a/src/main/java/org/mvel/compiler/AbstractParser.java\n+++ b/src/main/java/org/mvel/compiler/AbstractParser.java\n@@ -248,7 +248,37 @@ public class AbstractParser implements Serializable {\n                             case NEW:\r\n                                 start = cursor = trimRight(cursor);\r\n                                 captureToEOT();\r\n-                                return lastNode = new NewObjectNode(subArray(start, cursor), fields);\r\n+                                lastNode = new NewObjectNode(subArray(start, cursor), fields);\r\n+\r\n+                                skipWhitespaceWithLineAccounting();\r\n+                                if (cursor != length && expr[cursor] == '{') {\r\n+\r\n+                                    Class egressType = ((NewObjectNode) lastNode).getEgressType();\r\n+\r\n+                                    if (egressType == null) {\r\n+                                        try {\r\n+                                        egressType = TypeDescriptor.getClassReference(pCtx, ((NewObjectNode) lastNode).getTypeDescr());\r\n+                                        }\r\n+                                        catch (ClassNotFoundException e) {\r\n+                                            throw new CompileException(\"could not instantiate class\" ,e);\r\n+                                        }\r\n+                                    }\r\n+\r\n+                                    cursor = balancedCapture(expr, cursor, expr[cursor]) + 1;\r\n+                                    if (tokenContinues()) {\r\n+                                        lastNode = new InlineCollectionNode(expr, start, start = cursor, fields,\r\n+                                                egressType);\r\n+                                        captureToEOT();\r\n+                                        return lastNode = new Union(expr, start + 1, cursor, fields, lastNode);\r\n+                                    }\r\n+                                    else {\r\n+                                        return lastNode = new InlineCollectionNode(expr, start, cursor, fields,\r\n+                                                egressType);\r\n+                                    }\r\n+\r\n+                                }\r\n+\r\n+                                return lastNode;\r\n \r\n                             case ASSERT:\r\n                                 start = cursor = trimRight(cursor);\r\ndiff --git a/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java b/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\nindex 1eddb32..be47499 100644\n--- a/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\n+++ b/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\n@@ -39,12 +39,9 @@ import org.mvel.optimizers.impl.refl.collection.ArrayCreator;\n import org.mvel.optimizers.impl.refl.collection.ExprValueAccessor;\r\n import org.mvel.optimizers.impl.refl.collection.ListCreator;\r\n import org.mvel.optimizers.impl.refl.collection.MapCreator;\r\n-import org.mvel.util.ArrayTools;\r\n-import org.mvel.util.MethodStub;\r\n-import org.mvel.util.ParseTools;\r\n import static org.mvel.util.ParseTools.*;\r\n import static org.mvel.util.PropertyTools.*;\r\n-import org.mvel.util.StringAppender;\r\n+import org.mvel.util.*;\r\n \r\n import static java.lang.Integer.parseInt;\r\n import java.lang.reflect.*;\r\n@@ -703,9 +700,9 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n                 a[i++] = _getAccessor(item); // item\r\n             }\r\n \r\n-            returnType = Object[].class;\r\n+            returnType = o.getClass();\r\n \r\n-            return new ArrayCreator(a);\r\n+            return new ArrayCreator(a, PropertyTools.getBaseComponentType(returnType));\r\n         }\r\n         else {\r\n             returnType = Object.class;\r\ndiff --git a/src/main/java/org/mvel/optimizers/impl/refl/collection/ArrayCreator.java b/src/main/java/org/mvel/optimizers/impl/refl/collection/ArrayCreator.java\nindex 05c8c06..a5fd771 100644\n--- a/src/main/java/org/mvel/optimizers/impl/refl/collection/ArrayCreator.java\n+++ b/src/main/java/org/mvel/optimizers/impl/refl/collection/ArrayCreator.java\n@@ -21,24 +21,39 @@ package org.mvel.optimizers.impl.refl.collection;\n import org.mvel.compiler.Accessor;\r\n import org.mvel.integration.VariableResolverFactory;\r\n \r\n+import java.lang.reflect.Array;\r\n+\r\n /**\r\n  * @author Christopher Brock\r\n  */\r\n public class ArrayCreator implements Accessor {\r\n     public Accessor[] template;\r\n+    private Class arrayType;\r\n \r\n     public Object getValue(Object ctx, Object elCtx, VariableResolverFactory variableFactory) {\r\n         // return null;\r\n-        Object[] newArray = new Object[template.length];\r\n \r\n-        for (int i = 0; i < newArray.length; i++)\r\n-            newArray[i] = template[i].getValue(ctx, elCtx, variableFactory);\r\n+        if (Object.class.equals(arrayType)) {\r\n+            Object[] newArray = new Object[template.length];\r\n+\r\n+            for (int i = 0; i < newArray.length; i++)\r\n+                newArray[i] = template[i].getValue(ctx, elCtx, variableFactory);\r\n+\r\n+            return newArray;\r\n+        }\r\n+        else {\r\n+            Object newArray = Array.newInstance(arrayType, template.length);\r\n+\r\n+            for (int i = 0; i < template.length; i++)\r\n+                Array.set(newArray, i, template[i].getValue(ctx, elCtx, variableFactory));\r\n \r\n-        return newArray;\r\n+            return newArray;\r\n+        }\r\n     }\r\n \r\n-    public ArrayCreator(Accessor[] template) {\r\n+    public ArrayCreator(Accessor[] template, Class arrayType) {\r\n         this.template = template;\r\n+        this.arrayType = arrayType;\r\n     }\r\n \r\n \r\ndiff --git a/src/main/java/org/mvel/util/CollectionParser.java b/src/main/java/org/mvel/util/CollectionParser.java\nindex 75f3bd1..c22cb9c 100644\n--- a/src/main/java/org/mvel/util/CollectionParser.java\n+++ b/src/main/java/org/mvel/util/CollectionParser.java\n@@ -18,14 +18,13 @@\n  */\r\n package org.mvel.util;\r\n \r\n-import static org.mvel.util.ParseTools.balancedCapture;\r\n+import org.mvel.CompileException;\r\n+import org.mvel.compiler.ExecutableStatement;\r\n+import static org.mvel.util.ParseTools.*;\r\n import static org.mvel.util.PropertyTools.createStringTrimmed;\r\n import static org.mvel.util.PropertyTools.isIdentifierPart;\r\n \r\n-import static org.mvel.util.ParseTools.isWhitespace;\r\n-import static org.mvel.util.ParseTools.subCompileExpression;\r\n-\r\n-import static java.lang.System.arraycopy;\r\n+import java.lang.reflect.Array;\r\n import java.util.ArrayList;\r\n import java.util.HashMap;\r\n import java.util.List;\r\n@@ -51,6 +50,8 @@ public class CollectionParser {\n     public static final int ARRAY = 1;\r\n     public static final int MAP = 2;\r\n \r\n+    private Class colType;\r\n+\r\n     private static final Object[] EMPTY_ARRAY = new Object[0];\r\n \r\n     public CollectionParser() {\r\n@@ -69,6 +70,15 @@ public class CollectionParser {\n         return parseCollection(subcompile);\r\n     }\r\n \r\n+    public Object parseCollection(char[] property, boolean subcompile, Class colType) {\r\n+        if (colType != null) this.colType = PropertyTools.getBaseComponentType(colType);\r\n+        this.cursor = 0;\r\n+        if ((this.length = (this.property = property).length) > 0)\r\n+            while (length > 0 && isWhitespace(property[length - 1]))\r\n+                length--;\r\n+\r\n+        return parseCollection(subcompile);\r\n+    }\r\n \r\n     private Object parseCollection(boolean subcompile) {\r\n         if (length == 0) {\r\n@@ -78,7 +88,7 @@ public class CollectionParser {\n \r\n         Map<Object, Object> map = null;\r\n         List<Object> list = null;\r\n-        String ex = null;\r\n+        String ex;\r\n \r\n         if (type != -1) {\r\n             switch (type) {\r\n@@ -103,8 +113,8 @@ public class CollectionParser {\n                     }\r\n \r\n                 case '[':\r\n-                    if (cursor > 0 && isIdentifierPart(property[cursor-1])) continue;\r\n-                    \r\n+                    if (cursor > 0 && isIdentifierPart(property[cursor - 1])) continue;\r\n+\r\n                     if (newType == -1) {\r\n                         newType = LIST;\r\n                     }\r\n@@ -113,7 +123,7 @@ public class CollectionParser {\n                      * Sub-parse nested collections.\r\n                      */\r\n                     Object o = new CollectionParser(newType).parseCollection(subset(property, (start = cursor) + 1,\r\n-                            cursor = balancedCapture(property, start, property[start])), subcompile);\r\n+                            cursor = balancedCapture(property, start, property[start])), subcompile, colType);\r\n \r\n                     if (type == MAP) {\r\n                         map.put(curr, o);\r\n@@ -148,7 +158,9 @@ public class CollectionParser {\n                         map.put(curr, ex = createStringTrimmed(property, start, cursor - start));\r\n                     }\r\n \r\n-                    if (subcompile) subCompileExpression(ex);\r\n+                    if (subcompile) {\r\n+                        subCompile(ex);\r\n+                    }\r\n \r\n                     start = cursor + 1;\r\n \r\n@@ -161,7 +173,9 @@ public class CollectionParser {\n                     }\r\n                     curr = createStringTrimmed(property, start, cursor - start);\r\n \r\n-                    if (subcompile) subCompileExpression((String) curr);\r\n+                    if (subcompile) {\r\n+                        subCompile((String) curr);\r\n+                    }\r\n \r\n                     start = cursor + 1;\r\n                     break;\r\n@@ -170,7 +184,7 @@ public class CollectionParser {\n                     cursor++;\r\n                     while (cursor != length && isWhitespace(property[cursor])) cursor++;\r\n                     if (property[cursor] == '{') {\r\n-                        cursor = balancedCapture(property, cursor, '{');                        \r\n+                        cursor = balancedCapture(property, cursor, '{');\r\n                     }\r\n                     break;\r\n             }\r\n@@ -194,12 +208,35 @@ public class CollectionParser {\n             case MAP:\r\n                 return map;\r\n             case ARRAY:\r\n-                return list.toArray();\r\n+                if (colType == null) {\r\n+                    return list.toArray();\r\n+                }\r\n+                else {\r\n+                    Object a = Array.newInstance(colType, list.size());\r\n+                    int i = 0;\r\n+                    for (Object item : list) {\r\n+                        Array.set(a, i++, item);\r\n+                    }\r\n+                    return a;\r\n+\r\n+                }\r\n             default:\r\n                 return list;\r\n         }\r\n     }\r\n \r\n+    private void subCompile(String ex) {\r\n+        if (colType == null) {\r\n+            subCompileExpression(ex);\r\n+        }\r\n+        else {\r\n+            Class r = ((ExecutableStatement) subCompileExpression(ex)).getKnownEgressType();\r\n+            if (!colType.isAssignableFrom(r)) {\r\n+                throw new CompileException(\"expected type: \" + colType.getName() + \"; but found:\" + r.getName());\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n     private static char[] subset(char[] property, int start, int end) {\r\n         while (start < (end - 1) && isWhitespace(property[start]))\r\n             start++;\r\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/core/CoreConfidenceTests.java\nindex 677b444..c4e1fac 100644\n--- a/src/test/java/org/mvel/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/core/CoreConfidenceTests.java\n@@ -4292,6 +4292,16 @@ public class CoreConfidenceTests extends AbstractTest {\n                 \"x++; while (i < 10) { i = increment(i); } }; if (x == 1) return i; else -1; }; i = 0; ff(i);\"));\n     }\n \n+\n+    public void testArrayDefinitionWithInitializer() {\n+        String[] compareTo = new String[] { \"foo\", \"bar\"};\n+        String[] results = (String[]) test(\"new String[] { 'foo', 'bar' }\");\n+\n+        for (int i = 0; i < compareTo.length; i++) {\n+           if (!compareTo[i].equals(results[i])) throw new AssertionError(\"arrays do not match.\");\n+        }\n+    }\n+\n }\n \n \n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T14:07:21.006718Z", "commit_hash": "413c6e230e81acdae74eda4824b4488e602c6c4c", "commit_message": "fixed parser error for =-\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/compiler/AbstractParser.java b/src/main/java/org/mvel/compiler/AbstractParser.java\nindex 83e126f..66ff8d8 100644\n--- a/src/main/java/org/mvel/compiler/AbstractParser.java\n+++ b/src/main/java/org/mvel/compiler/AbstractParser.java\n@@ -502,6 +502,24 @@ public class AbstractParser implements Serializable {\n                                         return lastNode = new OperativeAssign(name, subArray(start, cursor), ADD, fields);\r\n                                     }\r\n                                 }\r\n+                                else if (lookAhead() == '-') {\r\n+                                    name = new String(expr, start, trimLeft(cursor) - start);\r\n+\r\n+                                    start = cursor += 2;\r\n+\r\n+                                    if (!isNextIdentifierOrLiteral()) {\r\n+                                        throw new CompileException(\"unexpected symbol '\" + expr[cursor] + \"'\", expr, cursor);\r\n+                                    }\r\n+\r\n+                                    captureToEOS();\r\n+\r\n+                                    if ((idx = pCtx.variableIndexOf(name)) != -1) {\r\n+                                        return lastNode = new IndexedOperativeAssign(subArray(start, cursor), SUB, idx, fields);\r\n+                                    }\r\n+                                    else {\r\n+                                        return lastNode = new OperativeAssign(name, subArray(start, cursor), SUB, fields);\r\n+                                    }\r\n+                                }\r\n \r\n                                 if (greedy && lookAhead() != '=') {\r\n                                     cursor++;\r\n@@ -612,7 +630,7 @@ public class AbstractParser implements Serializable {\n                                 skipWhitespace();\r\n                                 start = cursor;\r\n                                 captureIdentifier();\r\n-                                \r\n+\r\n                                 if ((idx = pCtx.variableIndexOf(name = new String(subArray(start, cursor)))) != -1) {\r\n                                     return lastNode = new IndexedPreFixIncNode(idx);\r\n                                 }\r\n@@ -1320,7 +1338,6 @@ public class AbstractParser implements Serializable {\n         return false;\r\n     }\r\n \r\n-\r\n     protected void expectEOS() {\r\n         skipWhitespace();\r\n         if (cursor != length && expr[cursor] != ';') {\r\n@@ -1367,17 +1384,18 @@ public class AbstractParser implements Serializable {\n     }\r\n \r\n     protected void captureIdentifier() {\r\n+        if (cursor == length) throw new CompileException(\"unexpected end of statement: EOF\", expr, cursor);\r\n         while (cursor != length) {\r\n             switch (expr[cursor]) {\r\n                 case ';':\r\n                     return;\r\n                 default: {\r\n                     if (!isIdentifierPart(expr[cursor])) {\r\n-                        throw new CompileException(\"unexpected symbol (was expecting an identifier): \" + expr[cursor]);\r\n+                        throw new CompileException(\"unexpected symbol (was expecting an identifier): \" + expr[cursor], expr, cursor);\r\n                     }\r\n                 }\r\n             }\r\n-           cursor++;\r\n+            cursor++;\r\n         }\r\n     }\r\n \r\n@@ -2157,7 +2175,7 @@ public class AbstractParser implements Serializable {\n             }\r\n         }\r\n         catch (ClassCastException e) {\r\n-            throw new CompileException(\"syntax error or incomptable types\", expr, cursor, e);\r\n+            throw new CompileException(\"syntax error or incompatable types\", expr, cursor, e);\r\n \r\n         }\r\n         catch (Exception e) {\r\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/core/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/core/CoreConfidenceTests.java\nindex 09c7d3b..d7c6ed7 100644\n--- a/src/test/java/org/mvel/tests/core/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/core/CoreConfidenceTests.java\n@@ -2580,6 +2580,10 @@ public class CoreConfidenceTests extends AbstractTest {\n         assertEquals(11, test(\"xx0 = 15; xx0 -= 4; xx0\"));\n     }\n \n+    public void testAssignSub2() {\n+        assertEquals(-95, test(\"xx0 = 5; xx0 =- 100\"));\n+    }\n+\n \n     public void testStaticWithExplicitParam() {\n         PojoStatic pojo = new PojoStatic(\"10\");\n@@ -4108,6 +4112,8 @@ public class CoreConfidenceTests extends AbstractTest {\n \n         assertTrue(false);\n     }\n+\n+\n }\n \n \n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T14:23:53.129050Z", "commit_hash": "2b841ce3ede462f38e6b3633a9d012cff1186344", "commit_message": "fix performance tests\n", "related_issues": "", "bug_patch": "diff --git a/src/test/java/org/mvel/tests/core/DebuggerTests.java b/src/test/java/org/mvel/tests/core/DebuggerTests.java\nnew file mode 100644\nindex 0000000..fe86930\n--- /dev/null\n+++ b/src/test/java/org/mvel/tests/core/DebuggerTests.java\n@@ -0,0 +1,102 @@\n+package org.mvel.tests.core;\n+\n+import junit.framework.TestCase;\n+import org.mvel.MVEL;\n+import org.mvel.MVELRuntime;\n+import org.mvel.ParserContext;\n+import org.mvel.compiler.CompiledExpression;\n+import org.mvel.compiler.ExpressionCompiler;\n+import static org.mvel.debug.DebugTools.decompile;\n+import org.mvel.debug.Debugger;\n+import org.mvel.debug.Frame;\n+import org.mvel.integration.VariableResolverFactory;\n+import org.mvel.integration.impl.DefaultLocalVariableResolverFactory;\n+\n+public class DebuggerTests extends TestCase {\n+\n+    private static int count;\n+    private static int a1 = 0;\n+    private static int a4 = 0;\n+\n+    public void testDebuggerInvoke() {\n+        count = 0;\n+\n+        MVELRuntime.resetDebugger();\n+        MVELRuntime.setThreadDebugger(new Debugger() {\n+            public int onBreak(Frame frame) {\n+                if (frame.getFactory().getVariableResolver(\"a1\") != null) {\n+                    a1++;\n+                }\n+                if (frame.getFactory().getVariableResolver(\"a4\") != null) {\n+                    a4++;\n+                    System.out.println(\"HEI \" + frame.getLineNumber());\n+                }\n+                count++;\n+                return 0;\n+            }\n+        });\n+\n+        String src = \"a1=7;\\na2=8;\\na3=9;\\na4=10;\\na5=11;\\na6=12;\\na7=13;\\na8=14;\";\n+        ExpressionCompiler c = new ExpressionCompiler(src);\n+        c.setDebugSymbols(true);\n+        ParserContext ctx = new ParserContext();\n+        ctx.setSourceFile(\"mysource\");\n+        CompiledExpression compexpr = c.compile(ctx);\n+\n+        System.out.println(decompile(compexpr));\n+\n+\n+        MVELRuntime.registerBreakpoint(ctx.getSourceFile(), 1);\n+        MVELRuntime.registerBreakpoint(ctx.getSourceFile(), 3);\n+        MVELRuntime.registerBreakpoint(ctx.getSourceFile(), 7);\n+\n+        VariableResolverFactory factory = new DefaultLocalVariableResolverFactory();\n+        MVEL.executeDebugger(compexpr, null, factory);\n+\n+        System.out.println(a1);\n+        System.out.println(a4);\n+        System.out.println(count);\n+        assertEquals(2, a1);\n+        assertEquals(1, a4);   // test passes but the breakpoint should be received by line 7, not by line 3\n+        assertEquals(3, count); // three breakpoints FAILS\n+    }\n+\n+    public void testDebuggerInvoke2() {\n+        count = 0;\n+\n+\n+        MVELRuntime.resetDebugger();\n+        MVELRuntime.setThreadDebugger(new Debugger() {\n+            public int onBreak(Frame frame) {\n+                count++;\n+                return 0;\n+            }\n+        });\n+\n+\n+        String src = \"a1=7;\\na2=8;\\nSystem.out.println(\\\"h\\\");\\nac=23;\\nde=23;\\nge=23;\\ngef=34;\";\n+\n+        ExpressionCompiler c = new ExpressionCompiler(src);\n+        c.setDebugSymbols(true);\n+        ParserContext ctx = new ParserContext();\n+        ctx.setSourceFile(\"mysource\");\n+        CompiledExpression compexpr = c.compile(ctx);\n+\n+        System.out.println(decompile(compexpr));\n+\n+\n+        MVELRuntime.registerBreakpoint(ctx.getSourceFile(), 1);\n+        MVELRuntime.registerBreakpoint(ctx.getSourceFile(), 2);\n+        MVELRuntime.registerBreakpoint(ctx.getSourceFile(), 3);\n+        MVELRuntime.registerBreakpoint(ctx.getSourceFile(), 4);\n+        MVELRuntime.registerBreakpoint(ctx.getSourceFile(), 5);\n+\n+\n+        VariableResolverFactory factory = new DefaultLocalVariableResolverFactory();\n+        MVEL.executeDebugger(compexpr, null, factory);\n+\n+        System.out.println(count);\n+        assertEquals(5, count);\n+    }\n+\n+}\n\\ No newline at end of file\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/DebuggerTests.java b/src/test/java/org/mvel/tests/DebuggerTests.java\ndeleted file mode 100644\nindex 71d31c9..0000000\n--- a/src/test/java/org/mvel/tests/DebuggerTests.java\n+++ /dev/null\n@@ -1,102 +0,0 @@\n-package org.mvel.tests;\n-\n-import junit.framework.TestCase;\n-import org.mvel.MVEL;\n-import org.mvel.MVELRuntime;\n-import org.mvel.ParserContext;\n-import org.mvel.compiler.CompiledExpression;\n-import org.mvel.compiler.ExpressionCompiler;\n-import static org.mvel.debug.DebugTools.decompile;\n-import org.mvel.debug.Debugger;\n-import org.mvel.debug.Frame;\n-import org.mvel.integration.VariableResolverFactory;\n-import org.mvel.integration.impl.DefaultLocalVariableResolverFactory;\n-\n-public class DebuggerTests extends TestCase {\n-\n-    private static int count;\n-    private static int a1 = 0;\n-    private static int a4 = 0;\n-\n-    public void testDebuggerInvoke() {\n-        count = 0;\n-\n-        MVELRuntime.resetDebugger();\n-        MVELRuntime.setThreadDebugger(new Debugger() {\n-            public int onBreak(Frame frame) {\n-                if (frame.getFactory().getVariableResolver(\"a1\") != null) {\n-                    a1++;\n-                }\n-                if (frame.getFactory().getVariableResolver(\"a4\") != null) {\n-                    a4++;\n-                    System.out.println(\"HEI \" + frame.getLineNumber());\n-                }\n-                count++;\n-                return 0;\n-            }\n-        });\n-\n-        String src = \"a1=7;\\na2=8;\\na3=9;\\na4=10;\\na5=11;\\na6=12;\\na7=13;\\na8=14;\";\n-        ExpressionCompiler c = new ExpressionCompiler(src);\n-        c.setDebugSymbols(true);\n-        ParserContext ctx = new ParserContext();\n-        ctx.setSourceFile(\"mysource\");\n-        CompiledExpression compexpr = c.compile(ctx);\n-\n-        System.out.println(decompile(compexpr));\n-\n-\n-        MVELRuntime.registerBreakpoint(ctx.getSourceFile(), 1);\n-        MVELRuntime.registerBreakpoint(ctx.getSourceFile(), 3);\n-        MVELRuntime.registerBreakpoint(ctx.getSourceFile(), 7);\n-\n-        VariableResolverFactory factory = new DefaultLocalVariableResolverFactory();\n-        MVEL.executeDebugger(compexpr, null, factory);\n-\n-        System.out.println(a1);\n-        System.out.println(a4);\n-        System.out.println(count);\n-        assertEquals(2, a1);\n-        assertEquals(1, a4);   // test passes but the breakpoint should be received by line 7, not by line 3\n-        assertEquals(3, count); // three breakpoints FAILS\n-    }\n-\n-    public void testDebuggerInvoke2() {\n-        count = 0;\n-\n-\n-        MVELRuntime.resetDebugger();\n-        MVELRuntime.setThreadDebugger(new Debugger() {\n-            public int onBreak(Frame frame) {\n-                count++;\n-                return 0;\n-            }\n-        });\n-\n-\n-        String src = \"a1=7;\\na2=8;\\nSystem.out.println(\\\"h\\\");\\nac=23;\\nde=23;\\nge=23;\\ngef=34;\";\n-\n-        ExpressionCompiler c = new ExpressionCompiler(src);\n-        c.setDebugSymbols(true);\n-        ParserContext ctx = new ParserContext();\n-        ctx.setSourceFile(\"mysource\");\n-        CompiledExpression compexpr = c.compile(ctx);\n-\n-        System.out.println(decompile(compexpr));\n-\n-\n-        MVELRuntime.registerBreakpoint(ctx.getSourceFile(), 1);\n-        MVELRuntime.registerBreakpoint(ctx.getSourceFile(), 2);\n-        MVELRuntime.registerBreakpoint(ctx.getSourceFile(), 3);\n-        MVELRuntime.registerBreakpoint(ctx.getSourceFile(), 4);\n-        MVELRuntime.registerBreakpoint(ctx.getSourceFile(), 5);\n-\n-\n-        VariableResolverFactory factory = new DefaultLocalVariableResolverFactory();\n-        MVEL.executeDebugger(compexpr, null, factory);\n-\n-        System.out.println(count);\n-        assertEquals(5, count);\n-    }\n-\n-}\n\\ No newline at end of file\ndiff --git a/src/test/java/org/mvel/tests/perftests/CompiledPerformanceTests.java b/src/test/java/org/mvel/tests/perftests/CompiledPerformanceTests.java\nindex 3e2571e..0e930b8 100644\n--- a/src/test/java/org/mvel/tests/perftests/CompiledPerformanceTests.java\n+++ b/src/test/java/org/mvel/tests/perftests/CompiledPerformanceTests.java\n@@ -15,8 +15,8 @@ import java.io.Serializable;\n import java.util.HashMap;\r\n import java.util.Map;\r\n \r\n-public class CompiledPerformanceTests extends TestCase {\r\n-    private static final int ITERATIONS = 1000000;\r\n+public class CompiledPerformanceTests {\r\n+    private static final int ITERATIONS = 100;\r\n \r\n     protected Foo foo = new Foo();\r\n     protected Map<String, Object> map = new HashMap<String, Object>();\r\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T14:31:11.797404Z", "commit_hash": "d3de96f4a73cf4615532dd81da9564e90b3cea59", "commit_message": "bug fix.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/CompileException.java b/src/main/java/org/mvel/CompileException.java\nindex 58af3c4..f7f5c0d 100644\n--- a/src/main/java/org/mvel/CompileException.java\n+++ b/src/main/java/org/mvel/CompileException.java\n@@ -45,14 +45,7 @@ public class CompileException extends RuntimeException {\n \n     public CompileException(String message, List<ErrorDetail> errors) {\n         super(message);\n-\n-\n-\n         this.errors = errors;\n-//        for (ErrorDetail error : errors) {\n-//            System.err.println(\"* \" + error.toString());\n-//        }\n-//        System.err.flush();\n     }\n \n     public CompileException(String message, int cursor) {\n@@ -112,7 +105,6 @@ public class CompileException extends RuntimeException {\n         }\n \n         while (start < end && isWhitespace(expr[start])) start++;\n-        //   while (end > start && isWhitespace(expr[end])) end--;\n \n         return copyValueOf(expr, start, end - start);\n     }\ndiff --git a/src/main/java/org/mvel/ast/DeepAssignmentNode.java b/src/main/java/org/mvel/ast/DeepAssignmentNode.java\nindex 9fdb771..d9c8be1 100644\n--- a/src/main/java/org/mvel/ast/DeepAssignmentNode.java\n+++ b/src/main/java/org/mvel/ast/DeepAssignmentNode.java\n@@ -22,10 +22,10 @@ import static org.mvel.MVEL.compileSetExpression;\n import static org.mvel.MVEL.eval;\r\n import static org.mvel.PropertyAccessor.set;\r\n import org.mvel.compiler.AbstractParser;\r\n-import org.mvel.compiler.Accessor;\r\n import org.mvel.compiler.CompiledSetExpression;\r\n import org.mvel.compiler.ExecutableStatement;\r\n import org.mvel.integration.VariableResolverFactory;\r\n+import static org.mvel.util.ArrayTools.findFirst;\r\n import static org.mvel.util.ParseTools.*;\r\n import static org.mvel.util.PropertyTools.createStringTrimmed;\r\n import static org.mvel.util.PropertyTools.find;\r\n@@ -42,8 +42,9 @@ public class DeepAssignmentNode extends ASTNode implements Assignment {\n \r\n     public DeepAssignmentNode(char[] expr, int fields, int operation, String name) {\r\n         //  super(expr, fields);\r\n+        this.fields |= DEEP_PROPERTY | fields;\r\n+        firstUnion = findFirst('.', this.name = expr);\r\n \r\n-        this.name = expr;\r\n         int mark;\r\n \r\n         if (operation != -1) {\r\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\nindex 9b982a6..056dcc3 100644\n--- a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n@@ -3816,9 +3816,14 @@ public class CoreConfidenceTests extends AbstractTest {\n         }\n     }\n \n+    public void testAnalysisCompile() {\n+        CompiledExpression ce = new ExpressionCompiler(\"foo.aValue = 'bar'\").compile();\n+        assertTrue(ce.getParserContext().getInputs().keySet().contains(\"foo\"));\n+    }\n+\n \n     public void testInlineWith() {\n-        CompiledExpression expr = new ExpressionCompiler(\"foo.{name = 'poopy', aValue = 'bar'}\").compile();\n+        CompiledExpression expr = new ExpressionCompiler(\"foo.{name='poopy', aValue='bar'}\").compile();\n         Foo f = (Foo) MVEL.executeExpression(expr, createTestMap());\n         assertEquals(\"poopy\", f.getName());\n         assertEquals(\"bar\", f.aValue);\n@@ -3866,7 +3871,6 @@ public class CoreConfidenceTests extends AbstractTest {\n     }\n \n     public static class MVELDateCoercion implements ConversionHandler {\n-\n         public boolean canConvertFrom(Class cls) {\n             if (cls == String.class || cls.isAssignableFrom(Date.class)) {\n                 return true;\n@@ -3888,7 +3892,6 @@ public class CoreConfidenceTests extends AbstractTest {\n                 throw new RuntimeException(\"Exception was thrown\", e);\n             }\n         }\n-\n     }\n \n }\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T14:39:57.995345Z", "commit_hash": "009f33c278062790d0780298167748ed68c66211", "commit_message": "fix to inline collections parsing\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/CompileException.java b/src/main/java/org/mvel/CompileException.java\nindex 52ff6a4..58af3c4 100644\n--- a/src/main/java/org/mvel/CompileException.java\n+++ b/src/main/java/org/mvel/CompileException.java\n@@ -60,7 +60,6 @@ public class CompileException extends RuntimeException {\n         this.cursor = cursor;\n     }\n \n-\n     public String toString() {\n         StringAppender appender = new StringAppender();\n         appender.append(\"[Error: \" + getMessage() + \"]\\n[Near : {... \" + showCodeNearError(expr, cursor)  + \" ....}]\");\ndiff --git a/src/main/java/org/mvel/optimizers/dynamic/DynamicOptimizer.java b/src/main/java/org/mvel/optimizers/dynamic/DynamicOptimizer.java\nindex a62ff6b..63ff311 100644\n--- a/src/main/java/org/mvel/optimizers/dynamic/DynamicOptimizer.java\n+++ b/src/main/java/org/mvel/optimizers/dynamic/DynamicOptimizer.java\n@@ -36,7 +36,7 @@ public class DynamicOptimizer extends AbstractOptimizer implements AccessorOptim\n     }\n \n     public static final int REGULAR_ACCESSOR = 0;\n-\n+    \n     public Accessor optimizeAccessor(char[] property, Object ctx, Object thisRef, VariableResolverFactory factory, boolean rootThisRef) {\n         return classLoader.registerDynamicAccessor(new DynamicGetAccessor(property, 0, firstStage.optimizeAccessor(property, ctx, thisRef, factory, rootThisRef)));\n     }\ndiff --git a/src/main/java/org/mvel/optimizers/dynamic/DynamicSetAccessor.java b/src/main/java/org/mvel/optimizers/dynamic/DynamicSetAccessor.java\nindex 498848e..d432de7 100644\n--- a/src/main/java/org/mvel/optimizers/dynamic/DynamicSetAccessor.java\n+++ b/src/main/java/org/mvel/optimizers/dynamic/DynamicSetAccessor.java\n@@ -28,7 +28,6 @@ public class DynamicSetAccessor implements DynamicAccessor {\n     public Object setValue(Object ctx, Object elCtx, VariableResolverFactory variableFactory, Object value) {\n         if (!opt) {\n             if (++runcount > DynamicOptimizer.tenuringThreshold) {\n-                System.out.println((runcount > DynamicOptimizer.tenuringThreshold) + \":\" + runcount + \">\" + DynamicOptimizer.tenuringThreshold);\n                 if ((currentTimeMillis() - stamp) < DynamicOptimizer.timeSpan) {\n                     opt = true;\n                     return optimize(ctx, elCtx, variableFactory, value);\ndiff --git a/src/main/java/org/mvel/optimizers/impl/asm/ASMAccessorOptimizer.java b/src/main/java/org/mvel/optimizers/impl/asm/ASMAccessorOptimizer.java\nindex 2d56d8e..2aab4b8 100644\n--- a/src/main/java/org/mvel/optimizers/impl/asm/ASMAccessorOptimizer.java\n+++ b/src/main/java/org/mvel/optimizers/impl/asm/ASMAccessorOptimizer.java\n@@ -244,6 +244,10 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n             //  rootAccessor = compileGetChain();\r\n             ctx = this.val;\r\n         }\r\n+        else {\r\n+            assert debug(\"ALOAD 1\");\r\n+            mv.visitVarInsn(ALOAD, 1);\r\n+        }\r\n \r\n         try {\r\n             this.length = (this.expr = property).length;\r\n@@ -263,13 +267,9 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n \r\n                 String ex = new String(property, start, cursor - start);\r\n \r\n-//                assert debug(\"ALOAD 1\");\r\n-//                mv.visitVarInsn(ALOAD, 1);\r\n-//\r\n                 assert debug(\"CHECKCAST \" + ctx.getClass().getName());\r\n                 mv.visitTypeInsn(CHECKCAST, getInternalName(ctx.getClass()));\r\n \r\n-\r\n                 if (ctx instanceof Map) {\r\n                     //noinspection unchecked\r\n                     ((Map) ctx).put(eval(ex, ctx, variableFactory), value);\r\n@@ -360,8 +360,8 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n             Member member = getFieldOrWriteAccessor(ctx.getClass(), tk);\r\n \r\n             if (member instanceof Field) {\r\n-                assert debug(\"ALOAD 1\");\r\n-                mv.visitVarInsn(ALOAD, 1);\r\n+//                assert debug(\"ALOAD 1\");\r\n+//                mv.visitVarInsn(ALOAD, 1);\r\n \r\n                 assert debug(\"CHECKCAST \" + ctx.getClass().getName());\r\n                 mv.visitTypeInsn(CHECKCAST, getInternalName(ctx.getClass()));\r\n@@ -396,37 +396,39 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n \r\n             }\r\n             else if (member != null) {\r\n-                assert debug(\"ALOAD 1\");\r\n-                mv.visitVarInsn(ALOAD, 1);\r\n+//                assert debug(\"ALOAD 1\");\r\n+//                mv.visitVarInsn(ALOAD, 1);\r\n \r\n-                assert debug(\"CHECKCAST \" + ctx.getClass().getName());\r\n+                assert debug(\"CHECKCAST \" + getInternalName(ctx.getClass()));\r\n                 mv.visitTypeInsn(CHECKCAST, getInternalName(ctx.getClass()));\r\n \r\n                 Method meth = (Method) member;\r\n \r\n-                Class targetType = meth.getParameterTypes()[0];\r\n \r\n                 assert debug(\"ALOAD 4\");\r\n                 mv.visitVarInsn(ALOAD, 4);\r\n \r\n-                assert debug(\"CHECKCAST \" + targetType);\r\n-                mv.visitTypeInsn(CHECKCAST, getInternalName(targetType));\r\n+                Class targetType = meth.getParameterTypes()[0];\r\n \r\n                 assert debug(\"DUP_X1\");\r\n                 mv.visitInsn(DUP_X1);\r\n \r\n+\r\n                 if (value != null && !targetType.isAssignableFrom(value.getClass())) {\r\n                     if (!canConvert(targetType, value.getClass())) {\r\n                         throw new ConversionException(\"cannot convert type: \"\r\n                                 + value.getClass() + \": to \" + meth.getParameterTypes()[0]);\r\n                     }\r\n \r\n-                    dataConversion(targetType);\r\n+                    dataConversion(getWrapperClass(targetType));\r\n                     if (targetType.isPrimitive()) unwrapPrimitive(targetType);\r\n \r\n                     meth.invoke(ctx, convert(value, meth.getParameterTypes()[0]));\r\n                 }\r\n                 else {\r\n+                                   assert debug(\"CHECKCAST \" + getInternalName(targetType));\r\n+                mv.visitTypeInsn(CHECKCAST, getInternalName(targetType));\r\n+\r\n                     meth.invoke(ctx, value);\r\n                 }\r\n \r\n@@ -435,6 +437,28 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n                         getMethodDescriptor(meth));\r\n \r\n             }\r\n+            else if (ctx instanceof Map) {\r\n+                assert debug(\"CHECKCAST \" + getInternalName(ctx.getClass()));\r\n+                mv.visitTypeInsn(CHECKCAST, getInternalName(ctx.getClass()));\r\n+\r\n+                assert debug(\"LDC '\" + tk + \"'\");\r\n+                mv.visitLdcInsn(tk);\r\n+\r\n+                assert debug(\"ALOAD 4\");\r\n+                mv.visitVarInsn(ALOAD, 4);\r\n+\r\n+                assert debug(\"DUP_X2\");\r\n+                mv.visitInsn(DUP_X2);\r\n+\r\n+                assert debug(\"INVOKEVIRTUAL java/util/HashMap.put\");\r\n+                mv.visitMethodInsn(INVOKEVIRTUAL, \"java/util/HashMap\", \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\");\r\n+\r\n+                assert debug(\"POP\");\r\n+                mv.visitInsn(POP);\r\n+\r\n+                //noinspection unchecked\r\n+                ((Map) ctx).put(tk, value);\r\n+            }\r\n             else {\r\n                 throw new PropertyAccessException(\"could not access property (\" + tk + \") in: \" + ctx.getClass().getName());\r\n             }\r\n@@ -1964,7 +1988,7 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n //        cv.visitLdcInsn(buildLog.toString());\r\n //        cv.visitFieldInsn(PUTFIELD, className, \"buildLog\", \"Ljava/lang/String;\");\r\n \r\n-        \r\n+\r\n         for (int i = 0; i < size; i++) {\r\n             assert debug(\"ALOAD 0\");\r\n             cv.visitVarInsn(ALOAD, 0);\r\ndiff --git a/src/main/java/org/mvel/util/CollectionParser.java b/src/main/java/org/mvel/util/CollectionParser.java\nindex 9ccdafc..46cfb35 100644\n--- a/src/main/java/org/mvel/util/CollectionParser.java\n+++ b/src/main/java/org/mvel/util/CollectionParser.java\n@@ -20,6 +20,7 @@ package org.mvel.util;\n \r\n import static org.mvel.util.ParseTools.balancedCapture;\r\n import static org.mvel.util.PropertyTools.createStringTrimmed;\r\n+import static org.mvel.util.PropertyTools.isIdentifierPart;\r\n \r\n import static org.mvel.util.ParseTools.isWhitespace;\r\n import static java.lang.System.arraycopy;\r\n@@ -99,6 +100,8 @@ public class CollectionParser {\n                     }\r\n \r\n                 case '[':\r\n+                    if (cursor > 0 && isIdentifierPart(property[cursor-1])) continue;\r\n+                    \r\n                     if (newType == -1) {\r\n                         newType = LIST;\r\n                     }\r\ndiff --git a/src/main/java/org/mvel/util/MVELClassLoader.java b/src/main/java/org/mvel/util/MVELClassLoader.java\nindex 33a5304..a5a042e 100644\n--- a/src/main/java/org/mvel/util/MVELClassLoader.java\n+++ b/src/main/java/org/mvel/util/MVELClassLoader.java\n@@ -2,4 +2,5 @@ package org.mvel.util;\n \n public interface MVELClassLoader {\n     public Class defineClassX(String className, byte[] b, int start, int end);\n+\n }\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\nindex 6e075ab..0edcf60 100644\n--- a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n@@ -12,9 +12,9 @@ import org.mvel.debug.DebugTools;\n import org.mvel.debug.Debugger;\n import org.mvel.debug.Frame;\n import org.mvel.integration.Interceptor;\n+import org.mvel.integration.PropertyHandlerFactory;\n import org.mvel.integration.ResolverTools;\n import org.mvel.integration.VariableResolverFactory;\n-import org.mvel.integration.PropertyHandlerFactory;\n import org.mvel.integration.impl.ClassImportResolverFactory;\n import org.mvel.integration.impl.DefaultLocalVariableResolverFactory;\n import org.mvel.integration.impl.MapVariableResolverFactory;\n@@ -30,10 +30,10 @@ import java.io.BufferedReader;\n import java.io.File;\n import java.io.IOException;\n import java.io.Serializable;\n+import java.lang.reflect.Type;\n import java.util.*;\n import static java.util.Collections.unmodifiableCollection;\n import java.util.List;\n-import java.lang.reflect.Type;\n \n @SuppressWarnings({\"ALL\"})\n public class CoreConfidenceTests extends AbstractTest {\n@@ -1653,7 +1653,6 @@ public class CoreConfidenceTests extends AbstractTest {\n         CompiledExpression compiled = compiler.compile(ctx);\n \n         MVEL.executeExpression(compiled, null, vars);\n-\n         MVEL.executeExpression(compiled, null, vars);\n     }\n \n@@ -1810,6 +1809,8 @@ public class CoreConfidenceTests extends AbstractTest {\n     }\n \n     public void testVirtProperty() {\n+     //   OptimizerFactory.setDefaultOptimizer(\"ASM\");\n+\n         Map<String, Object> testMap = new HashMap<String, Object>();\n         testMap.put(\"test\", \"foo\");\n \n@@ -3203,6 +3204,9 @@ public class CoreConfidenceTests extends AbstractTest {\n \n         assertEquals(\"FoobarFoobar\", MVEL.executeExpression(s, new HashMap()));\n         assertEquals(\"FoobarFoobar\", MVEL.executeExpression(s, new HashMap()));\n+\n+        OptimizerFactory.setDefaultOptimizer(\"dynamic\");\n+\n     }\n \n     public void testFunctionDefAndCall3() {\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T14:48:42.540683Z", "commit_hash": "146a9eeffa83a8cd6a2f3ea8557a69906064b290", "commit_message": "API fix.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/compiler/ExpressionCompiler.java b/src/main/java/org/mvel/compiler/ExpressionCompiler.java\nindex 92afd9d..e89d501 100644\n--- a/src/main/java/org/mvel/compiler/ExpressionCompiler.java\n+++ b/src/main/java/org/mvel/compiler/ExpressionCompiler.java\n@@ -40,7 +40,7 @@ public class ExpressionCompiler extends AbstractParser {\n     private boolean secondPassOptimization = false;\r\n \r\n     public CompiledExpression compile() {\r\n-        return compile(new ParserContext());\r\n+        return compile(contextControl(GET_OR_CREATE, null, null));\r\n     }\r\n \r\n     public CompiledExpression compile(ParserContext ctx) {\r\n@@ -289,9 +289,9 @@ public class ExpressionCompiler extends AbstractParser {\n         return tk;\r\n     }\r\n \r\n-    private static int asInt(final Object o) {\r\n-        return (Integer) o;\r\n-    }\r\n+//    private static int asInt(final Object o) {\r\n+//        return (Integer) o;\r\n+//    }\r\n \r\n     public ExpressionCompiler(String expression) {\r\n         setExpression(expression);\r\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\nindex b0d1d6d..ae45c6f 100644\n--- a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n@@ -3674,6 +3674,27 @@ public class CoreConfidenceTests extends AbstractTest {\n         assertTrue(typeParameters != null);\n         assertTrue(String.class.equals(typeParameters[0]));\n     }\n+\n+\n+    public final void testDetermineEgressParametricType2() {\n+        final ParserContext parserContext = new ParserContext();\n+        parserContext.setStrongTyping(true);\n+        parserContext.addInput(\"strings\", List.class, new Class[]{String.class});\n+\n+        final CompiledExpression expr = new ExpressionCompiler(\"strings\", parserContext)\n+                .compile();\n+\n+//        final CompiledExpression expr = new ExpressionCompiler(\"strings\").compile(parserContext);\n+        \n+\n+        assert STRINGS.equals(MVEL.executeExpression(expr, new A())) : \"faulty expression eval\";\n+\n+        final Type[] typeParameters = expr.getParserContext().getLastTypeParameters();\n+\n+        assert null != typeParameters : \"no generic egress type\";\n+        assert String.class.equals(typeParameters[0]) : \"wrong generic egress type\";\n+\n+    }\n }\n \n \n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T14:57:17.736644Z", "commit_hash": "29394039f0174e9815c7b6283cd5984ae4d23c7d", "commit_message": "fix problem with generic type reporting\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/ParserContext.java b/src/main/java/org/mvel/ParserContext.java\nindex e10b253..29e5bb2 100644\n--- a/src/main/java/org/mvel/ParserContext.java\n+++ b/src/main/java/org/mvel/ParserContext.java\n@@ -10,6 +10,7 @@ import java.io.Serializable;\n import java.lang.reflect.Method;\n import java.lang.reflect.Type;\n import java.lang.reflect.TypeVariable;\n+import java.lang.reflect.ParameterizedType;\n import java.util.*;\n \n /**\n@@ -206,6 +207,7 @@ public class ParserContext implements Serializable {\n         for (int i = 0; i < typeParameters.length; i++) {\n             t.put(tvs[i].getName(), typeParameters[i]);\n         }\n+\n     }\n \n     public void addInputs(Map<String, Class> inputs) {\n@@ -409,6 +411,24 @@ public class ParserContext implements Serializable {\n         return typeParameters.get(name);\n     }\n \n+    public Type[] getTypeParametersAsArray(String name) {\n+        Class c = inputs.get(name);\n+        Type[] tp = c.getTypeParameters();\n+        Type[] types = new Type[tp.length];\n+\n+        Map<String, Class> typeVars = getTypeParameters(name);\n+        if (typeVars == null) {\n+            return null;\n+        }\n+\n+        for (int i = 0; i < tp.length; i++) {\n+            types[i] = typeVars.get(tp[i].toString());\n+        }\n+\n+        return types;\n+    }\n+\n+\n     public boolean isBlockSymbols() {\n         return blockSymbols;\n     }\ndiff --git a/src/main/java/org/mvel/ast/ReturnNode.java b/src/main/java/org/mvel/ast/ReturnNode.java\nindex 037b4bc..f9d531d 100644\n--- a/src/main/java/org/mvel/ast/ReturnNode.java\n+++ b/src/main/java/org/mvel/ast/ReturnNode.java\n@@ -48,4 +48,6 @@ public class ReturnNode extends ASTNode {\n     public Object getReducedValue(Object ctx, Object thisValue, VariableResolverFactory factory) {\r\n         throw new EndWithValue(eval(this.name, ctx, factory));\r\n     }\r\n+\r\n+\r\n }\r\ndiff --git a/src/main/java/org/mvel/compiler/PropertyVerifier.java b/src/main/java/org/mvel/compiler/PropertyVerifier.java\nindex 58c0f4d..c03d842 100644\n--- a/src/main/java/org/mvel/compiler/PropertyVerifier.java\n+++ b/src/main/java/org/mvel/compiler/PropertyVerifier.java\n@@ -94,6 +94,11 @@ public class PropertyVerifier extends AbstractOptimizer {\n         if (first) {\n             if (parserContext.hasVarOrInput(property)) {\n                 paramTypes = parserContext.getTypeParameters(property);\n+\n+                if (parserContext.isStrictTypeEnforcement()) {\n+                    parserContext.setLastTypeParameters(parserContext.getTypeParametersAsArray(property));\n+                }\n+\n                 return parserContext.getVarOrInputType(property);\n             }\n             else if (parserContext.hasImport(property)) {\ndiff --git a/src/main/java/org/mvel/optimizers/impl/asm/ASMAccessorOptimizer.java b/src/main/java/org/mvel/optimizers/impl/asm/ASMAccessorOptimizer.java\nindex 3c811c2..11d4399 100644\n--- a/src/main/java/org/mvel/optimizers/impl/asm/ASMAccessorOptimizer.java\n+++ b/src/main/java/org/mvel/optimizers/impl/asm/ASMAccessorOptimizer.java\n@@ -408,6 +408,7 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n             }\r\n             catch (IllegalAccessException e) {\r\n                 Method iFaceMeth = determineActualTargetMethod((Method) member);\r\n+                if (iFaceMeth == null) throw new PropertyAccessException(\"could not access field: \" + cls.getName() + \".\" + property);                \r\n \r\n                 assert debug(\"CHECKCAST \" + getInternalName(iFaceMeth.getDeclaringClass()));\r\n                 mv.visitTypeInsn(CHECKCAST, getInternalName(iFaceMeth.getDeclaringClass()));\r\ndiff --git a/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java b/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\nindex 287ad18..427958a 100644\n--- a/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\n+++ b/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\n@@ -377,6 +377,9 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n             }\r\n             catch (IllegalAccessException e) {\r\n                 Method iFaceMeth = determineActualTargetMethod((Method) member);\r\n+\r\n+                if (iFaceMeth == null) throw new PropertyAccessException(\"could not access field: \" + cls.getName() + \".\" + property);\r\n+\r\n                 addAccessorNode(new GetterAccessor(iFaceMeth));\r\n                 o = iFaceMeth.invoke(ctx, EMPTYARG);\r\n             }\r\ndiff --git a/src/main/java/org/mvel/util/ASTLinkedList.java b/src/main/java/org/mvel/util/ASTLinkedList.java\nindex 5c6df1c..a4e6c23 100644\n--- a/src/main/java/org/mvel/util/ASTLinkedList.java\n+++ b/src/main/java/org/mvel/util/ASTLinkedList.java\n@@ -54,6 +54,8 @@ public class ASTLinkedList implements ASTIterator {\n     }\n \n     public void addTokenNode(ASTNode astNode, ASTNode token2) {\n+        size += 2;\n+\n         if (this.firstASTNode == null) {\n             this.last = this.current = ((this.firstASTNode = astNode).nextASTNode = token2);\n         }\ndiff --git a/src/main/java/org/mvel/util/CompilerTools.java b/src/main/java/org/mvel/util/CompilerTools.java\nindex 30f4b21..bc1f713 100644\n--- a/src/main/java/org/mvel/util/CompilerTools.java\n+++ b/src/main/java/org/mvel/util/CompilerTools.java\n@@ -49,13 +49,7 @@ public class CompilerTools {\n             }\n             else if (astLinkedList.hasMoreNodes()) {\n                 if ((tkOp = astLinkedList.nextNode()).getFields() == -1) {\n-                    optimizedAst.addTokenNode(tk);\n-                    if (tk instanceof EndOfStatement) {\n-                        astLinkedList.setCurrentNode(tkOp);\n-                        continue;\n-                    }\n-\n-                    optimizedAst.addTokenNode(tkOp);\n+                    optimizedAst.addTokenNode(tk, tkOp);\n                 }\n                 else if (tkOp.isOperator() && tkOp.getOperator() < 20) {\n                     int op;\n@@ -90,7 +84,6 @@ public class CompilerTools {\n                             bo.setRight(new BinaryOperation(op2, bo.getRight(), astLinkedList.nextNode(), ctx));\n                         }\n \n-\n                         op = op2;\n                         tkOp = tkOp2;\n                     }\n@@ -101,17 +94,11 @@ public class CompilerTools {\n                         optimizedAst.addTokenNode(tkOp2);\n                     }\n                 }\n-                else if (tkOp.isOperator(Operator.REGEX))  {\n+                else if (tkOp.isOperator(Operator.REGEX)) {\n                     optimizedAst.addTokenNode(new RegExMatchNode(tk, astLinkedList.nextNode()));\n                 }\n                 else {\n-                    optimizedAst.addTokenNode(tk);\n-                    if (tk instanceof EndOfStatement) {\n-                        astLinkedList.setCurrentNode(tkOp);\n-                        continue;\n-                    }\n-\n-                    optimizedAst.addTokenNode(tkOp);\n+                    optimizedAst.addTokenNode(tk, tkOp);\n                 }\n             }\n             else {\n@@ -133,12 +120,7 @@ public class CompilerTools {\n                 }\n                 else if (astLinkedList.hasMoreNodes()) {\n                     if ((tkOp = astLinkedList.nextNode()).getFields() == -1) {\n-                        optimizedAst.addTokenNode(tk);\n-                        if (tk instanceof EndOfStatement) {\n-                            astLinkedList.setCurrentNode(tkOp);\n-                        }\n-\n-                        optimizedAst.addTokenNode(tkOp);\n+                        optimizedAst.addTokenNode(tk, tkOp);\n                     }\n                     else if (tkOp.isOperator()\n                             && (tkOp.getOperator() == Operator.AND || tkOp.getOperator() == Operator.OR)) {\n@@ -154,7 +136,6 @@ public class CompilerTools {\n                                 bool = new Or(tk, astLinkedList.nextNode());\n                         }\n \n-\n                         while (astLinkedList.hasMoreNodes() && (tkOp2 = astLinkedList.nextNode()).isOperator()\n                                 && (tkOp2.isOperator(Operator.AND) || tkOp2.isOperator(Operator.OR))) {\n \n@@ -174,12 +155,7 @@ public class CompilerTools {\n                         }\n                     }\n                     else {\n-                        optimizedAst.addTokenNode(tk);\n-                        if (tk instanceof EndOfStatement) {\n-                            astLinkedList.setCurrentNode(tkOp);\n-                        }\n-\n-                        optimizedAst.addTokenNode(tkOp);\n+                        optimizedAst.addTokenNode(tk, tkOp);\n                     }\n                 }\n                 else {\n@@ -188,6 +164,7 @@ public class CompilerTools {\n             }\n         }\n \n+\n         return optimizedAst;\n     }\n \ndiff --git a/src/main/java/org/mvel/util/PropertyTools.java b/src/main/java/org/mvel/util/PropertyTools.java\nindex b83720d..8a9f455 100644\n--- a/src/main/java/org/mvel/util/PropertyTools.java\n+++ b/src/main/java/org/mvel/util/PropertyTools.java\n@@ -90,7 +90,7 @@ public class PropertyTools {\n     public static Method getGetter(Class clazz, String property) {\n         String isGet = ReflectionUtil.getIsGetter(property);\n         property = ReflectionUtil.getGetter(property);\n-\n+   \n         for (Method meth : clazz.getMethods()) {\n             if ((meth.getModifiers() & PUBLIC) == 0\n                     || meth.getParameterTypes().length != 0\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\nindex 9444d47..b0d1d6d 100644\n--- a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n@@ -32,6 +32,7 @@ import java.io.Serializable;\n import java.util.*;\n import static java.util.Collections.unmodifiableCollection;\n import java.util.List;\n+import java.lang.reflect.Type;\n \n @SuppressWarnings({\"AssertEqualsBetweenInconvertibleTypes\", \"UnnecessaryBoxing\", \"unchecked\", \"PointlessArithmeticExpression\"})\n public class CoreConfidenceTests extends AbstractTest {\n@@ -3650,7 +3651,29 @@ public class CoreConfidenceTests extends AbstractTest {\n         assertEquals(Boolean.TRUE, MVEL.executeExpression(ce));\n     }\n \n+    public static final List<String> STRINGS = Arrays.asList(\"hi\", \"there\");\n \n+    public static class A {\n+        public List<String> getStrings() {\n+            return STRINGS;\n+        }\n+    }\n+\n+\n+    public final void testDetermineEgressParametricType() {\n+        final ParserContext parserContext = new ParserContext();\n+        parserContext.setStrongTyping(true);\n+\n+        parserContext.addInput(\"strings\", List.class, new Class[]{String.class});\n+\n+        final CompiledExpression expr = new ExpressionCompiler(\"strings\").compile(parserContext);\n+\n+        assertTrue(STRINGS.equals(MVEL.executeExpression(expr, new A())));\n+\n+        final Type[] typeParameters = expr.getParserContext().getLastTypeParameters();\n+        assertTrue(typeParameters != null);\n+        assertTrue(String.class.equals(typeParameters[0]));\n+    }\n }\n \n \n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T15:10:34.767940Z", "commit_hash": "5204ea13c3131e37e00790c4b2634fc0d5899413", "commit_message": "fix\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/ast/AssignmentNode.java b/src/main/java/org/mvel/ast/AssignmentNode.java\nindex a524e22..2c26c1c 100644\n--- a/src/main/java/org/mvel/ast/AssignmentNode.java\n+++ b/src/main/java/org/mvel/ast/AssignmentNode.java\n@@ -20,16 +20,15 @@ package org.mvel.ast;\n \r\n import org.mvel.MVEL;\r\n import static org.mvel.MVEL.compileSetExpression;\r\n-import org.mvel.compiler.AbstractParser;\r\n+import org.mvel.PropertyAccessor;\r\n+import static org.mvel.compiler.AbstractParser.getCurrentThreadParserContext;\r\n import org.mvel.compiler.CompiledSetExpression;\r\n import org.mvel.compiler.ExecutableStatement;\r\n-import static org.mvel.compiler.AbstractParser.getCurrentThreadParserContext;\r\n import org.mvel.integration.VariableResolverFactory;\r\n import static org.mvel.util.ArrayTools.findFirst;\r\n import static org.mvel.util.ParseTools.*;\r\n import static org.mvel.util.PropertyTools.createStringTrimmed;\r\n import static org.mvel.util.PropertyTools.find;\r\n-import org.mvel.util.PropertyTools;\r\n \r\n /**\r\n  * @author Christopher Brock\r\n@@ -119,7 +118,7 @@ public class AssignmentNode extends ASTNode implements Assignment {\n         checkNameSafety(varName);\r\n \r\n         if (col) {\r\n-            MVEL.setProperty(factory.getVariableResolver(varName).getValue(), index, ctx = MVEL.eval(stmt, ctx, factory));\r\n+            PropertyAccessor.set(factory.getVariableResolver(varName).getValue(), factory, index, ctx = MVEL.eval(stmt, ctx, factory));\r\n         }\r\n         else {\r\n             factory.createVariable(varName, ctx = MVEL.eval(stmt, ctx, factory));\r\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\nindex 893d69a..abddba9 100644\n--- a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n@@ -3472,10 +3472,20 @@ public class CoreConfidenceTests extends AbstractTest {\n         String ex = \"map[java.lang.Integer.MAX_VALUE] = 'bar'; map[java.lang.Integer.MAX_VALUE];\";\n \n         Serializable s = MVEL.compileExpression(ex);\n-\n         assertEquals(\"bar\", MVEL.executeExpression(s, map));\n         assertEquals(\"bar\", MVEL.eval(ex, map));\n     }\n+\n+    public void testMapAssignmentNestedExpression2() {\n+        Map map = new HashMap();\n+        map.put(\"x\", \"bar\");\n+        map.put(\"map\", new HashMap());\n+\n+        String ex = \"map[x] = 'foo'; map['bar'];\";\n+        Serializable s = MVEL.compileExpression(ex);\n+        assertEquals(\"foo\", MVEL.executeExpression(s, map));\n+        assertEquals(\"foo\", MVEL.eval(ex, map));        \n+    }\n }\n \n \n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T15:24:57.196873Z", "commit_hash": "6d9dca3956d307e9ebc507a7a97e38397b73caa6", "commit_message": "bug fix\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/MVEL.java b/src/main/java/org/mvel/MVEL.java\nindex d5317f6..f375335 100644\n--- a/src/main/java/org/mvel/MVEL.java\n+++ b/src/main/java/org/mvel/MVEL.java\n@@ -207,7 +207,7 @@ public class MVEL {\n             return handleParserEgress(e.getValue(), false);\n         }\n     }\n-\n+                                                            \n     /**\n      * Executes a compiled expression.\n      *\n@@ -592,7 +592,7 @@ public class MVEL {\n \n \n     public static Object getProperty(String property, Object ctx) {\n-        return ReflectiveAccessorOptimizer.get(property, ctx);\n+        return PropertyAccessor.get(property, ctx);\n     }\n \n     public static void setProperty(Object ctx, String property, Object value) {\ndiff --git a/src/main/java/org/mvel/PropertyAccessor.java b/src/main/java/org/mvel/PropertyAccessor.java\nindex f464823..01d28db 100644\n--- a/src/main/java/org/mvel/PropertyAccessor.java\n+++ b/src/main/java/org/mvel/PropertyAccessor.java\n@@ -421,7 +421,7 @@ public class PropertyAccessor {\n \r\n         if (first) {\r\n             if (\"this\".equals(property)) {\r\n-                return this.thisReference;\r\n+                return this.ctx;\r\n             }\r\n             else if (variableFactory != null && variableFactory.isResolveable(property)) {\r\n                 return variableFactory.getVariableResolver(property).getValue();\r\ndiff --git a/src/main/java/org/mvel/math/IEEEFloatingPointMath.java b/src/main/java/org/mvel/math/IEEEFloatingPointMath.java\nindex 7993523..035668e 100644\n--- a/src/main/java/org/mvel/math/IEEEFloatingPointMath.java\n+++ b/src/main/java/org/mvel/math/IEEEFloatingPointMath.java\n@@ -34,7 +34,6 @@ import static java.lang.String.valueOf;\n import java.math.BigDecimal;\r\n import java.math.BigInteger;\r\n import java.math.MathContext;\r\n-import java.math.RoundingMode;\r\n \r\n /**\r\n  * @author Christopher Brock\r\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\nindex b9965f2..a384306 100644\n--- a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n@@ -3427,15 +3427,24 @@ public class CoreConfidenceTests extends AbstractTest {\n \n     public void testJIRA100b() {\n         String expression = \"(8 / 10) * 100 <= 80;\";\n-        System.out.println(\"Expression: \" + expression + \" = \" + ((8 / 10) * 100 <= 80));\n-\n-        System.out.println(\"output: \" + new BigDecimal(0.8d, new MathContext(16)).toString());\n-\n         assertEquals((8 / 10) * 100 <= 80, testCompiledSimple(expression, new HashMap()));\n     }\n \n     public void testJIRA92() {\n-        test(\"'stringValue' > null\");\n+        assertEquals(false, test(\"'stringValue' > null\"));\n+    }\n+\n+    public void testAssignToBean() {\n+        Person person = new Person();\n+        MVEL.eval(\"this.name = 'foo'\", person);\n+\n+        assertEquals(\"foo\", person.getName());\n+\n+        Serializable s = MVEL.compileExpression(\"this.name = 'bar'\");\n+\n+        MVEL.executeExpression(s, person);\n+\n+        assertEquals(\"bar\", person.getName());\n     }\n \n }\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T15:42:11.850042Z", "commit_hash": "41286076f5c53202ef23de061876f70e8300ac72", "commit_message": "more fixes to the math processing\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/ast/And.java b/src/main/java/org/mvel/ast/And.java\nindex 47cb501..74501ff 100644\n--- a/src/main/java/org/mvel/ast/And.java\n+++ b/src/main/java/org/mvel/ast/And.java\n@@ -25,17 +25,20 @@ public class And extends ASTNode {\n     private ASTNode right;\n \n     public And(ASTNode left, ASTNode right) {\n-        \n+\n         this.left = left;\n         this.right = right;\n     }\n \n     public Object getReducedValueAccelerated(Object ctx, Object thisValue, VariableResolverFactory factory) {\n-//        Boolean leftVal = (Boolean) left.getReducedValueAccelerated(ctx, thisValue, factory);\n-//        Boolean rightVal = (Boolean) right.getReducedValueAccelerated(ctx, thisValue, factory);\n-//        return leftVal && rightVal;\n+//        Object leftVal = left.getReducedValueAccelerated(ctx, thisValue, factory);\n+//        Object rightVal = right.getReducedValueAccelerated(ctx, thisValue, factory);\n+//\n+//\n+//        return (Boolean) leftVal && (Boolean) rightVal;\n+\n \n-        return (((Boolean) left.getReducedValueAccelerated(ctx, thisValue, factory))\n+       return (((Boolean) left.getReducedValueAccelerated(ctx, thisValue, factory))\n                 && ((Boolean) right.getReducedValueAccelerated(ctx, thisValue, factory)));\n     }\n \n@@ -58,4 +61,8 @@ public class And extends ASTNode {\n     public void setRight(ASTNode right) {\n         this.right = right;\n     }\n+\n+    public String toString() {\n+        return \"(\" + left.toString() + \" && \" + right.toString() + \")\";\n+    }\n }\ndiff --git a/src/main/java/org/mvel/ast/BinaryOperation.java b/src/main/java/org/mvel/ast/BinaryOperation.java\nindex 9c9e7f2..9b451c5 100644\n--- a/src/main/java/org/mvel/ast/BinaryOperation.java\n+++ b/src/main/java/org/mvel/ast/BinaryOperation.java\n@@ -18,15 +18,13 @@\n  */\n package org.mvel.ast;\n \n-import org.mvel.integration.VariableResolverFactory;\n-import static org.mvel.util.ParseTools.doOperations;\n-import org.mvel.debug.DebugTools;\n-import static org.mvel.debug.DebugTools.getOperatorName;\n-import org.mvel.Operator;\n-import org.mvel.ParserContext;\n-import org.mvel.ErrorDetail;\n import org.mvel.CompileException;\n+import org.mvel.Operator;\n import static org.mvel.Operator.PTABLE;\n+import org.mvel.ParserContext;\n+import org.mvel.debug.DebugTools;\n+import org.mvel.integration.VariableResolverFactory;\n+import static org.mvel.util.ParseTools.doOperations;\n \n public class BinaryOperation extends ASTNode {\n     private int operation;\n@@ -51,7 +49,7 @@ public class BinaryOperation extends ASTNode {\n                 case Operator.ADD:\n                     if (left.getEgressType() == String.class || right.getEgressType() == String.class) {\n                         break;\n-                    }\n+                    }                                                                                                        \n \n                 default:\n                     if (!left.getEgressType().isAssignableFrom(right.getEgressType())) {\ndiff --git a/src/main/java/org/mvel/ast/Or.java b/src/main/java/org/mvel/ast/Or.java\nindex 1151380..254ade9 100644\n--- a/src/main/java/org/mvel/ast/Or.java\n+++ b/src/main/java/org/mvel/ast/Or.java\n@@ -53,4 +53,8 @@ public class Or extends ASTNode {\n     public void setRight(ASTNode right) {\n         this.right = right;\n     }\n+\n+        public String toString() {\n+        return \"(\" + left.toString() + \" || \" + right.toString() + \")\"; \n+    }\n }\ndiff --git a/src/main/java/org/mvel/compiler/ExpressionCompiler.java b/src/main/java/org/mvel/compiler/ExpressionCompiler.java\nindex 7776cd6..1f727a9 100644\n--- a/src/main/java/org/mvel/compiler/ExpressionCompiler.java\n+++ b/src/main/java/org/mvel/compiler/ExpressionCompiler.java\n@@ -21,6 +21,7 @@ package org.mvel.compiler;\n import org.mvel.CompileException;\r\n import org.mvel.Operator;\r\n import org.mvel.ParserContext;\r\n+import static org.mvel.Operator.PTABLE;\r\n import org.mvel.ast.ASTNode;\r\n import org.mvel.ast.LiteralNode;\r\n import org.mvel.ast.Substatement;\r\n@@ -28,6 +29,7 @@ import static org.mvel.ast.ASTNode.COMPILE_IMMEDIATE;\n import org.mvel.util.ASTLinkedList;\r\n import static org.mvel.util.CompilerTools.optimizeAST;\r\n import org.mvel.util.ExecutionStack;\r\n+import com.sun.org.apache.xalan.internal.xsltc.runtime.Operators;\r\n \r\n public class ExpressionCompiler extends AbstractParser {\r\n     private Class returnType;\r\n@@ -73,7 +75,7 @@ public class ExpressionCompiler extends AbstractParser {\n         ASTNode tkLA;\r\n         ASTNode tkLA2;\r\n \r\n-        int op;\r\n+        int op, lastOp = -1;\r\n \r\n         ASTLinkedList astBuild = new ASTLinkedList();\r\n         stk = new ExecutionStack();\r\n@@ -124,7 +126,9 @@ public class ExpressionCompiler extends AbstractParser {\n                          * If the next token is ALSO a literal, then we have a candidate for a compile-time literal\r\n                          * reduction.\r\n                          */\r\n-                        if ((tkLA = nextTokenSkipSymbols()) != null && tkLA.isLiteral()) {\r\n+                        if ((tkLA = nextTokenSkipSymbols()) != null && tkLA.isLiteral()\r\n+                                && ((lastOp == -1 || PTABLE[lastOp] < PTABLE[tkOp.getOperator()]))) {\r\n+                            \r\n                             stk.push(tk.getLiteralValue(), tkLA.getLiteralValue(), op = tkOp.getOperator());\r\n \r\n                             /**\r\n@@ -206,6 +210,11 @@ public class ExpressionCompiler extends AbstractParser {\n                     }\r\n                 }\r\n                 else {\r\n+                    if (tk.isOperator()) {\r\n+                        lastOp = tk.getOperator();\r\n+                    }\r\n+\r\n+\r\n                     literalOnly = false;\r\n                 }\r\n \r\ndiff --git a/src/main/java/org/mvel/conversion/BigDecimalCH.java b/src/main/java/org/mvel/conversion/BigDecimalCH.java\nindex 188f3f6..fc215c2 100644\n--- a/src/main/java/org/mvel/conversion/BigDecimalCH.java\n+++ b/src/main/java/org/mvel/conversion/BigDecimalCH.java\n@@ -5,6 +5,7 @@ import org.mvel.ConversionHandler;\n \n import java.math.BigDecimal;\n import java.math.BigInteger;\n+import java.math.MathContext;\n import java.util.HashMap;\n import java.util.Map;\n \n@@ -64,7 +65,7 @@ public class BigDecimalCH implements ConversionHandler {\n         CNV.put(BigInteger.class,\n                 new Converter() {\n                     public BigDecimal convert(Object o) {\n-                        return new BigDecimal(((BigInteger) o).doubleValue());\n+                        return new BigDecimal(((BigInteger) o).doubleValue(), MathContext.DECIMAL128);\n                     }\n                 }\n         );\n@@ -80,7 +81,7 @@ public class BigDecimalCH implements ConversionHandler {\n         CNV.put(Double.class,\n                 new Converter() {\n                     public BigDecimal convert(Object o) {\n-                        return new BigDecimal(((Double) o).doubleValue());\n+                        return new BigDecimal(((Double) o).doubleValue(), MathContext.DECIMAL128);\n                     }\n                 }\n         );\n@@ -88,7 +89,7 @@ public class BigDecimalCH implements ConversionHandler {\n         CNV.put(Float.class,\n                 new Converter() {\n                     public BigDecimal convert(Object o) {\n-                        return new BigDecimal(((Float) o).doubleValue());\n+                        return new BigDecimal(((Float) o).doubleValue(), MathContext.DECIMAL128);\n                     }\n                 }\n         );\n@@ -97,7 +98,7 @@ public class BigDecimalCH implements ConversionHandler {\n         CNV.put(Short.class,\n                 new Converter() {\n                     public BigDecimal convert(Object o) {\n-                        return new BigDecimal(((Short) o).doubleValue());\n+                        return new BigDecimal(((Short) o).doubleValue(), MathContext.DECIMAL128);\n                     }\n                 }\n         );\n@@ -105,7 +106,7 @@ public class BigDecimalCH implements ConversionHandler {\n         CNV.put(Long.class,\n                 new Converter() {\n                     public BigDecimal convert(Object o) {\n-                        return new BigDecimal(((Long) o).doubleValue());\n+                        return new BigDecimal(((Long) o).doubleValue(), MathContext.DECIMAL128);\n                     }\n                 }\n         );\n@@ -113,7 +114,7 @@ public class BigDecimalCH implements ConversionHandler {\n         CNV.put(Integer.class,\n                 new Converter() {\n                     public BigDecimal convert(Object o) {\n-                        return new BigDecimal(((Integer) o).doubleValue());\n+                        return new BigDecimal(((Integer) o).doubleValue(), MathContext.DECIMAL128);\n                     }\n                 }\n         );\n@@ -121,7 +122,7 @@ public class BigDecimalCH implements ConversionHandler {\n         CNV.put(String.class,\n                 new Converter() {\n                     public BigDecimal convert(Object o) {\n-                        return new BigDecimal((String) o);\n+                        return new BigDecimal((String) o, MathContext.DECIMAL128);\n                     }\n                 }\n         );\ndiff --git a/src/main/java/org/mvel/debug/DebugTools.java b/src/main/java/org/mvel/debug/DebugTools.java\nindex b512ca6..8814489 100644\n--- a/src/main/java/org/mvel/debug/DebugTools.java\n+++ b/src/main/java/org/mvel/debug/DebugTools.java\n@@ -232,10 +232,8 @@ public class DebugTools {\n             case Operator.CHOR:\r\n                 return \"or\";\r\n \r\n-\r\n         }\r\n \r\n-\r\n         return \"UNKNOWN_OPERATOR\";\r\n     }\r\n \r\ndiff --git a/src/main/java/org/mvel/math/IEEEFloatingPointMath.java b/src/main/java/org/mvel/math/IEEEFloatingPointMath.java\nindex 9d66e56..fed19f5 100644\n--- a/src/main/java/org/mvel/math/IEEEFloatingPointMath.java\n+++ b/src/main/java/org/mvel/math/IEEEFloatingPointMath.java\n@@ -485,25 +485,25 @@ public class IEEEFloatingPointMath implements MathProcessor {\n             case DataTypes.BIG_DECIMAL:\r\n                 return (BigDecimal) in;\r\n             case DataTypes.BIG_INTEGER:\r\n-                return new BigDecimal((BigInteger) in);\r\n+                return new BigDecimal((BigInteger) in, MATH_CONTEXT);\r\n             case DataTypes.W_INTEGER:\r\n-                return new BigDecimal((Integer) in);\r\n+                return new BigDecimal((Integer) in, MATH_CONTEXT);\r\n             case DataTypes.W_LONG:\r\n-                return new BigDecimal((Long) in);\r\n+                return new BigDecimal((Long) in, MATH_CONTEXT);\r\n             case DataTypes.STRING:\r\n-                return new BigDecimal((String) in);\r\n+                return new BigDecimal((String) in, MATH_CONTEXT);\r\n             case DataTypes.W_FLOAT:\r\n-                return new BigDecimal((Float) in);\r\n+                return new BigDecimal((Float) in, MATH_CONTEXT);\r\n             case DataTypes.W_DOUBLE:\r\n-                return new BigDecimal((Double) in);\r\n+                return new BigDecimal((Double) in, MATH_CONTEXT);\r\n             case DataTypes.W_SHORT:\r\n-                return new BigDecimal((Short) in);\r\n+                return new BigDecimal((Short) in, MATH_CONTEXT);\r\n             case DataTypes.W_CHAR:\r\n-                return new BigDecimal((Character) in);\r\n+                return new BigDecimal((Character) in, MATH_CONTEXT);\r\n             case DataTypes.W_BOOLEAN:\r\n                 return BigDecimal.valueOf(((Boolean) in) ? 1 : 0);\r\n             case DataTypes.UNIT:\r\n-                return new BigDecimal(((Unit) in).getValue());\r\n+                return new BigDecimal(((Unit) in).getValue(), MATH_CONTEXT);\r\n \r\n         }\r\n \r\ndiff --git a/src/main/java/org/mvel/util/CompilerTools.java b/src/main/java/org/mvel/util/CompilerTools.java\nindex c5fc73b..ba09094 100644\n--- a/src/main/java/org/mvel/util/CompilerTools.java\n+++ b/src/main/java/org/mvel/util/CompilerTools.java\n@@ -82,9 +82,13 @@ public class CompilerTools {\n                                 bo.setRight(new BinaryOperation(op2, bo.getRight(), astLinkedList.nextNode(), ctx));\n                             }\n                         }\n-                        else {\n+                        else if (PTABLE[bo.getOperation()] >= PTABLE[op2]) {\n                             bo = new BinaryOperation(op2, bo, astLinkedList.nextNode(), ctx);\n                         }\n+                        else {\n+                            bo.setRight(new BinaryOperation(op2, bo.getRight(), astLinkedList.nextNode(), ctx));\n+                        }\n+\n \n                         op = op2;\n                         tkOp = tkOp2;\n@@ -111,9 +115,8 @@ public class CompilerTools {\n             }\n         }\n \n-        if (secondPassOptimization)\n \n-        {\n+        if (secondPassOptimization) {\n             /**\n              * Perform a second pass optimization for boolean conditions.\n              */\n@@ -147,10 +150,7 @@ public class CompilerTools {\n                                 bool = new Or(tk, astLinkedList.nextNode());\n                         }\n \n-                        /**\n-                         * If we have a chain of math/comparitive operators then we fill them into the tree\n-                         * right here.\n-                         */\n+\n                         while (astLinkedList.hasMoreNodes() && (tkOp2 = astLinkedList.nextNode()).isOperator()\n                                 && (tkOp2.isOperator(Operator.AND) || tkOp2.isOperator(Operator.OR))) {\n \n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\nindex 70ff1c2..b0db355 100644\n--- a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n@@ -226,6 +226,20 @@ public class CoreConfidenceTests extends AbstractTest {\n         assertEquals(true, test(ex));\n     }\n \n+    public void testOperatorPrecedence5() {\n+        String ex = \"_x_001 == _x_001 / 2 - _x_001 + _x_001 + _x_001 / 2 && _x_002 / 2 == _x_002 / 2\";\n+\n+        Map vars = new HashMap();\n+        vars.put(\"_x_001\", 500.2);\n+        vars.put(\"_x_002\", 200.9);\n+        vars.put(\"_r_001\", 701);\n+\n+        ExpressionCompiler compiler = new ExpressionCompiler(ex);\n+        Serializable s = compiler.compile();\n+\n+        assertEquals(true, MVEL.executeExpression(s, vars));\n+    }\n+\n     public void testShortPathExpression() {\n         assertEquals(null, MVEL.eval(\"3 > 4 && foo.toUC('test'); foo.register\", new Base(), createTestMap()));\n     }\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T15:47:39.852701Z", "commit_hash": "72b782f9903e71046e1289670138a608fd1868e8", "commit_message": "fixes\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/ast/BinaryOperation.java b/src/main/java/org/mvel/ast/BinaryOperation.java\nindex 078b06b..9c9e7f2 100644\n--- a/src/main/java/org/mvel/ast/BinaryOperation.java\n+++ b/src/main/java/org/mvel/ast/BinaryOperation.java\n@@ -64,8 +64,10 @@ public class BinaryOperation extends ASTNode {\n \n     public Object getReducedValueAccelerated(Object ctx, Object thisValue, VariableResolverFactory factory) {\n         return doOperations(left.getReducedValueAccelerated(ctx, thisValue, factory), operation, right.getReducedValueAccelerated(ctx, thisValue, factory));\n+\n     }\n \n+\n     public Object getReducedValue(Object ctx, Object thisValue, VariableResolverFactory factory) {\n         throw new RuntimeException(\"unsupported AST operation\");\n     }\ndiff --git a/src/main/java/org/mvel/math/IEEEFloatingPointMath.java b/src/main/java/org/mvel/math/IEEEFloatingPointMath.java\nindex c6e3acd..9d66e56 100644\n--- a/src/main/java/org/mvel/math/IEEEFloatingPointMath.java\n+++ b/src/main/java/org/mvel/math/IEEEFloatingPointMath.java\n@@ -18,11 +18,14 @@\n  */\r\n package org.mvel.math;\r\n \r\n+import org.mvel.CompileException;\r\n+import org.mvel.ConversionException;\r\n import static org.mvel.DataConversion.convert;\r\n+import org.mvel.DataTypes;\r\n import static org.mvel.DataTypes.EMPTY;\r\n import static org.mvel.Operator.*;\r\n-import org.mvel.*;\r\n import static org.mvel.Soundex.soundex;\r\n+import org.mvel.Unit;\r\n import org.mvel.debug.DebugTools;\r\n import static org.mvel.util.ParseTools.resolveType;\r\n import static org.mvel.util.PropertyTools.isNumber;\r\n@@ -38,6 +41,7 @@ import java.math.MathContext;\n public class IEEEFloatingPointMath implements MathProcessor {\r\n     private static final MathContext MATH_CONTEXT = MathContext.DECIMAL128;\r\n \r\n+\r\n     public Object doOperation(final Object val1, final int operation, final Object val2) {\r\n         final int type1 = val1 == null ? DataTypes.NULL : resolveType(val1.getClass());\r\n         final int type2 = val2 == null ? DataTypes.NULL : resolveType(val2.getClass());\r\n@@ -64,13 +68,13 @@ public class IEEEFloatingPointMath implements MathProcessor {\n     private static Object doBigDecimalArithmetic(final BigDecimal val1, final int operation, final BigDecimal val2) {\r\n         switch (operation) {\r\n             case ADD:\r\n-                return val1.add(val2);\r\n+                return val1.add(val2, MATH_CONTEXT);\r\n             case DIV:\r\n                 return val1.divide(val2, MATH_CONTEXT);\r\n             case SUB:\r\n-                return val1.subtract(val2);\r\n+                return val1.subtract(val2, MATH_CONTEXT);\r\n             case MULT:\r\n-                return val1.multiply(val2);\r\n+                return val1.multiply(val2, MATH_CONTEXT);\r\n             case POWER:\r\n                 return Math.pow(val1.doubleValue(), val2.doubleValue());\r\n             case MOD:\r\ndiff --git a/src/main/java/org/mvel/util/CompilerTools.java b/src/main/java/org/mvel/util/CompilerTools.java\nindex 5841d05..c5fc73b 100644\n--- a/src/main/java/org/mvel/util/CompilerTools.java\n+++ b/src/main/java/org/mvel/util/CompilerTools.java\n@@ -75,25 +75,11 @@ public class CompilerTools {\n                             bo.setRightMost(new BinaryOperation(op2, bo.getRightMost(), astLinkedList.nextNode(), ctx));\n                         }\n                         else if (bo.getOperation() != op2 && PTABLE[op] == PTABLE[op2]) {\n-                            switch (bo.getOperation()) {\n-                                case Operator.ADD:\n-                                    if (op2 == Operator.SUB) {\n-                                        bo = new BinaryOperation(op2, bo, astLinkedList.nextNode(), ctx);\n-                                    }\n-                                    else {\n-                                        bo.setRight(new BinaryOperation(op2, bo.getRight(), astLinkedList.nextNode(), ctx));\n-                                    }\n-                                    break;\n-                                case Operator.SUB:\n-                                    if (op2 == Operator.ADD) {\n-                                        bo = new BinaryOperation(op2, bo, astLinkedList.nextNode(), ctx);\n-                                    }\n-                                    else {\n-                                        bo.setRight(new BinaryOperation(op2, bo.getRight(), astLinkedList.nextNode(), ctx));\n-                                    }\n-                                    break;\n-                                default:\n-                                    bo.setRight(new BinaryOperation(op2, bo.getRight(), astLinkedList.nextNode(), ctx));\n+                            if (PTABLE[bo.getOperation()] == PTABLE[op2]) {\n+                                bo = new BinaryOperation(op2, bo, astLinkedList.nextNode(), ctx);\n+                            }\n+                            else {\n+                                bo.setRight(new BinaryOperation(op2, bo.getRight(), astLinkedList.nextNode(), ctx));\n                             }\n                         }\n                         else {\n@@ -125,7 +111,9 @@ public class CompilerTools {\n             }\n         }\n \n-        if (secondPassOptimization) {\n+        if (secondPassOptimization)\n+\n+        {\n             /**\n              * Perform a second pass optimization for boolean conditions.\n              */\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/AbstractTest.java b/src/test/java/org/mvel/tests/main/AbstractTest.java\nindex 00db8d8..97c37de 100644\n--- a/src/test/java/org/mvel/tests/main/AbstractTest.java\n+++ b/src/test/java/org/mvel/tests/main/AbstractTest.java\n@@ -1,10 +1,12 @@\n package org.mvel.tests.main;\n \n import junit.framework.TestCase;\n+import junit.framework.AssertionFailedError;\n import org.mvel.MVEL;\n import static org.mvel.MVEL.compileExpression;\n import static org.mvel.MVEL.executeExpression;\n import org.mvel.ParserContext;\n+import org.mvel.DataConversion;\n import org.mvel.compiler.CompiledExpression;\n import org.mvel.compiler.ExpressionCompiler;\n import static org.mvel.debug.DebugTools.decompile;\n@@ -248,7 +250,7 @@ public abstract class AbstractTest extends TestCase {\n         Object first = null, second = null, third = null, fourth = null, fifth = null, sixth = null, seventh = null,\n                 eighth = null;\n \n-         System.out.println(DebugTools.decompile((Serializable) compiled));\n+        System.out.println(DebugTools.decompile((Serializable) compiled));\n \n         if (!Boolean.getBoolean(\"mvel.disable.jit\")) {\n \n@@ -256,7 +258,7 @@ public abstract class AbstractTest extends TestCase {\n \n             try {\n                 first = executeExpression(compiled, new Base(), createTestMap());\n-            }                                      \n+            }\n             catch (Exception e) {\n                 failErrors.append(\"\\nFIRST TEST: { \" + ex + \" }: EXCEPTION REPORT: \\n\\n\");\n \n@@ -347,7 +349,7 @@ public abstract class AbstractTest extends TestCase {\n \n         ParserContext ctx = new ParserContext();\n         ctx.setSourceFile(\"unittest\");\n-        \n+\n         ExpressionCompiler debuggingCompiler = new ExpressionCompiler(ex);\n         debuggingCompiler.setDebugSymbols(true);\n \n@@ -770,4 +772,42 @@ public abstract class AbstractTest extends TestCase {\n             this.number = number;\n         }\n     }\n+\n+    public static void assertNumEquals(Object obj, Object obj2) {\n+        assertNumEquals(obj, obj2, true);\n+    }\n+\n+    public static void assertNumEquals(Object obj, Object obj2, boolean permitRoundingVariance) {\n+        if (obj == null || obj2 == null) throw new AssertionError(\"null value\");\n+\n+\n+        if (obj.getClass().equals(obj2.getClass())) {\n+            if (obj instanceof Number) {\n+                double compare = ((Number) obj).doubleValue() - ((Number) obj2).doubleValue();\n+                if (!(compare <= 0.0001d && compare >= -0.0001d)) {\n+                    throw new AssertionFailedError(\"expected <\" + String.valueOf(obj) + \"> but was <\" + String.valueOf(obj) + \">\");\n+                }\n+            }\n+            else {\n+                assertEquals(obj, obj2);\n+            }\n+\n+        }\n+        else {\n+            obj = DataConversion.convert(obj, obj2.getClass());\n+\n+            if (!obj.equals(obj2)) {\n+                if (permitRoundingVariance) {\n+                    obj = DataConversion.convert(obj, Integer.class);\n+                    obj2 = DataConversion.convert(obj2, Integer.class);\n+\n+                    assertEquals(obj, obj2);\n+                }\n+                else {\n+                    throw new AssertionFailedError(\"expected <\" + String.valueOf(obj) + \"> but was <\" + String.valueOf(obj) + \">\");\n+                }\n+            }\n+\n+        }\n+    }\n }\ndiff --git a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\nindex 6035c56..70ff1c2 100644\n--- a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n@@ -32,6 +32,8 @@ import java.io.Serializable;\n import java.util.*;\n import static java.util.Collections.unmodifiableCollection;\n import java.util.List;\n+import java.math.BigDecimal;\n+import java.math.MathContext;\n \n @SuppressWarnings({\"AssertEqualsBetweenInconvertibleTypes\", \"UnnecessaryBoxing\", \"unchecked\", \"PointlessArithmeticExpression\"})\n public class CoreConfidenceTests extends AbstractTest {\n@@ -2695,24 +2697,66 @@ public class CoreConfidenceTests extends AbstractTest {\n \n \n     public void testMath35() {\n-        String expression = \"a*b*c+d+e/f/g/h/i-j-j\";\n+        String expression = \"b/x/b/b*y+a\";\n \n         Map map = new HashMap();\n-        map.put(\"a\", \"10\");\n-        map.put(\"b\", \"20\");\n-        map.put(\"c\", \"3\");\n-        map.put(\"d\", \"100\");\n-        map.put(\"e\", \"400\");\n-        map.put(\"f\", \"2\");\n-        map.put(\"g\", \"2\");\n-        map.put(\"h\", \"2\");\n-        map.put(\"i\", \"2\");\n-        map.put(\"j\", \"1\");\n+        map.put(\"a\", 10);\n+        map.put(\"b\", 20);\n+        map.put(\"c\", 30);\n+        map.put(\"x\", 40);\n+        map.put(\"y\", 50);\n+        map.put(\"z\", 60);\n \n+        Serializable s = MVEL.compileExpression(expression);\n+\n+        assertNumEquals(20d / 40d / 20d / 20d * 50d + 10d, MVEL.executeExpression(s, map));\n+    }\n+\n+    public void testMath35_Interpreted() {\n+        String expression = \"b/x/b/b*y+a\";\n+\n+        Map map = new HashMap();\n+        map.put(\"a\", 10);\n+        map.put(\"b\", 20);\n+        map.put(\"c\", 30);\n+        map.put(\"x\", 40);\n+        map.put(\"y\", 50);\n+        map.put(\"z\", 60);\n+\n+\n+        assertNumEquals(20d / 40d / 20d / 20d * 50d + 10d, MVEL.eval(expression, map));\n+    }\n+\n+    public void testMath36() {\n+        String expression = \"b/x*z/a+x-b+x-b/z+y\";\n+\n+        Map map = new HashMap();\n+        map.put(\"a\", 10);\n+        map.put(\"b\", 20);\n+        map.put(\"c\", 30);\n+        map.put(\"x\", 40);\n+        map.put(\"y\", 50);\n+        map.put(\"z\", 60);\n+\n+        Serializable s = MVEL.compileExpression(expression);\n+\n+        assertNumEquals(20d / 40d * 60d / 10d + 40d - 20d + 40d - 20d / 60d + 50d, MVEL.executeExpression(s, map));\n+    }\n+\n+    public void testMath37() {\n+        String expression = \"x+a*a*c/x*b*z+x/y-b\";\n+\n+        Map map = new HashMap();\n+        map.put(\"a\", 10);\n+        map.put(\"b\", 20);\n+        map.put(\"c\", 30);\n+        map.put(\"x\", 2);\n+        map.put(\"y\", 2);\n+        map.put(\"z\", 60);\n \n         Serializable s = MVEL.compileExpression(expression);\n \n-        assertEquals(10 * 20 * 3 + 100 + 400 / 2 / 2 / 2 / 2 - 1 - 1, MVEL.executeExpression(s, map));\n+        assertNumEquals(2d + 10d * 10d * 30d / 2d * 20d * 60d + 2d / 2d - 20d, MVEL.executeExpression(s, map));\n     }\n \n     public void testNullSafe() {\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T15:53:08.006528Z", "commit_hash": "13d77306dad2eb58b286d7e4004005bef22e7c0c", "commit_message": "fixes\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/ast/BinaryOperation.java b/src/main/java/org/mvel/ast/BinaryOperation.java\nindex 7031a22..5db52d1 100644\n--- a/src/main/java/org/mvel/ast/BinaryOperation.java\n+++ b/src/main/java/org/mvel/ast/BinaryOperation.java\n@@ -125,6 +125,6 @@ public class BinaryOperation extends ASTNode {\n     }\n \n     public String toString() {\n-        return \"(\" + left.toString() + \" [\" + getOperatorName(operation) + \"] \" + right.toString() + \")\";\n+        return \"(\" + left.toString() + \" \" + DebugTools.getOperatorSymbol(operation) + \" \" + right.toString() + \")\";\n     }\n }\ndiff --git a/src/main/java/org/mvel/ast/ForEachNode.java b/src/main/java/org/mvel/ast/ForEachNode.java\nindex 179dfae..b9110af 100644\n--- a/src/main/java/org/mvel/ast/ForEachNode.java\n+++ b/src/main/java/org/mvel/ast/ForEachNode.java\n@@ -29,6 +29,8 @@ import static org.mvel.util.ParseTools.subset;\n import org.mvel.util.PropertyTools;\r\n import static org.mvel.util.PropertyTools.createStringTrimmed;\r\n \r\n+import java.util.Collection;\r\n+\r\n /**\r\n  * @author Christopher Brock\r\n  */\r\n@@ -39,6 +41,15 @@ public class ForEachNode extends BlockNode {\n     protected ExecutableStatement condition;\r\n     protected ExecutableStatement compiledBlock;\r\n \r\n+\r\n+    private static final int COLLECTION = 0;\r\n+    private static final int ARRAY = 1;\r\n+    private static final int CHARSEQUENCE = 2;\r\n+    private static final int INTEGER = 3;\r\n+    private static final int ITERABLE = 4;\r\n+\r\n+    private int type = -1;\r\n+\r\n     public ForEachNode(char[] condition, char[] block, int fields) {\r\n         this.fields = fields;\r\n         handleCond(this.name = condition);\r\n@@ -50,84 +61,128 @@ public class ForEachNode extends BlockNode {\n     }\r\n \r\n     public Object getReducedValueAccelerated(Object ctx, Object thisValue, VariableResolverFactory factory) {\r\n-\r\n-        ItemResolverFactory.ItemResolver itemR = new ItemResolverFactory.ItemResolver(item);\r\n-        ItemResolverFactory itemFactory = new ItemResolverFactory(itemR, new DefaultLocalVariableResolverFactory(factory));\r\n-\r\n-        Object iterCond = condition.getValue(ctx, thisValue, factory);\r\n-\r\n-        if (iterCond instanceof Iterable) {\r\n-            for (Object o : (Iterable) iterCond) {\r\n-                itemR.setValue(o);\r\n-                compiledBlock.getValue(ctx, thisValue, itemFactory);\r\n-            }\r\n-        }\r\n-        else if (iterCond instanceof Object[]) {\r\n-            for (Object o : (Object[]) iterCond) {\r\n-                itemR.setValue(o);\r\n-                compiledBlock.getValue(ctx, thisValue, itemFactory);\r\n-            }\r\n-        }\r\n-        else if (iterCond instanceof CharSequence) {\r\n-            for (Object o : iterCond.toString().toCharArray()) {\r\n-                itemR.setValue(o);\r\n-                compiledBlock.getValue(ctx, thisValue, itemFactory);\r\n-            }\r\n-        }\r\n-        else if (iterCond instanceof Integer) {\r\n-            int max = (Integer) iterCond + 1;\r\n-            for (int i = 1; i != max; i++) {\r\n-                itemR.setValue(i);\r\n-                compiledBlock.getValue(ctx, thisValue, itemFactory);\r\n-            }\r\n-        }\r\n-        else {\r\n-            throw new CompileException(\"non-iterable type: \" + iterCond.getClass().getName());\r\n-        }\r\n-\r\n-        return null;\r\n-    }\r\n-\r\n-    public Object getReducedValue(Object ctx, Object thisValue, VariableResolverFactory factory) {\r\n-        ItemResolverFactory.ItemResolver itemR = new ItemResolverFactory.ItemResolver(item);\r\n-        ItemResolverFactory itemFactory = new ItemResolverFactory(itemR, new DefaultLocalVariableResolverFactory(factory));\r\n-\r\n-        Object iterCond = MVEL.eval(cond, thisValue, factory);\r\n-\r\n-        ExecutableStatement cBlockLocal = (ExecutableStatement) subCompileExpression(block);\r\n-\r\n-        if (iterCond instanceof Iterable) {\r\n-            for (Object o : (Iterable) iterCond) {\r\n-                itemR.setValue(o);\r\n-                cBlockLocal.getValue(ctx, thisValue, itemFactory);\r\n-            }\r\n-        }\r\n-        else if (iterCond instanceof Object[]) {\r\n-            for (Object o : (Object[]) iterCond) {\r\n-                itemR.setValue(o);\r\n-                cBlockLocal.getValue(ctx, thisValue, itemFactory);\r\n-            }\r\n-        }\r\n-        else if (iterCond instanceof CharSequence) {\r\n-            for (Object o : iterCond.toString().toCharArray()) {\r\n-                itemR.setValue(o);\r\n-                cBlockLocal.getValue(ctx, thisValue, itemFactory);\r\n-            }\r\n-        }\r\n-        else if (iterCond instanceof Integer) {\r\n-            int max = (Integer) iterCond + 1;\r\n-            for (int i = 1; i != max; i++) {\r\n-                itemR.setValue(i);\r\n-                cBlockLocal.getValue(ctx, thisValue, itemFactory);\r\n-            }\r\n-        }                                     \r\n-        else {\r\n-            throw new CompileException(\"non-iterable type: \" + iterCond.getClass().getName());\r\n-        }\r\n-\r\n-        return null;\r\n-    }\r\n-\r\n+          ItemResolverFactory.ItemResolver itemR = new ItemResolverFactory.ItemResolver(item);\r\n+          ItemResolverFactory itemFactory = new ItemResolverFactory(itemR, new DefaultLocalVariableResolverFactory(factory));\r\n+\r\n+          Object iterCond = condition.getValue(ctx, thisValue, factory);\r\n+\r\n+          if (type == -1) {\r\n+              if (compiledBlock == null) {\r\n+                  this.compiledBlock = (ExecutableStatement) subCompileExpression(block);                  \r\n+              }\r\n+\r\n+              if (iterCond instanceof Collection) {\r\n+                  type = COLLECTION;\r\n+              }\r\n+              else if (iterCond instanceof Object[]) {\r\n+                  type = ARRAY;\r\n+              }\r\n+              else if (iterCond instanceof CharSequence) {\r\n+                  type = CHARSEQUENCE;\r\n+\r\n+              }\r\n+              else if (iterCond instanceof Integer) {\r\n+                  type = INTEGER;\r\n+              }\r\n+              else {\r\n+                  try {\r\n+                      Class.forName(\"java.lang.Iterable\");\r\n+                      type = ITERABLE;\r\n+                  }\r\n+                  catch (Exception e) {\r\n+                      throw new CompileException(\"non-iterable type: \" + iterCond.getClass().getName());\r\n+                  }\r\n+              }\r\n+          }\r\n+\r\n+\r\n+          switch (type) {\r\n+              case COLLECTION:\r\n+                  for (Object o : (Collection) iterCond) {\r\n+                      itemR.setValue(o);\r\n+                      compiledBlock.getValue(ctx, thisValue, itemFactory);\r\n+                  }\r\n+                  break;\r\n+              case ARRAY:\r\n+                  for (Object o : (Object[]) iterCond) {\r\n+                      itemR.setValue(o);\r\n+                      compiledBlock.getValue(ctx, thisValue, itemFactory);\r\n+                  }\r\n+                  break;\r\n+              case CHARSEQUENCE:\r\n+                  for (Object o : iterCond.toString().toCharArray()) {\r\n+                      itemR.setValue(o);\r\n+                      compiledBlock.getValue(ctx, thisValue, itemFactory);\r\n+                  }\r\n+                  break;\r\n+              case INTEGER:\r\n+                  int max = (Integer) iterCond + 1;\r\n+                  for (int i = 1; i != max; i++) {\r\n+                      itemR.setValue(i);\r\n+                      compiledBlock.getValue(ctx, thisValue, itemFactory);\r\n+                  }\r\n+                  break;\r\n+\r\n+              case ITERABLE:\r\n+                  for (Object o : (Iterable) iterCond) {\r\n+                      itemR.setValue(o);\r\n+                      compiledBlock.getValue(ctx, thisValue, itemFactory);\r\n+                  }\r\n+                  break;\r\n+          }\r\n+\r\n+          return null;\r\n+      }\r\n+\r\n+      public Object getReducedValue(Object ctx, Object thisValue, VariableResolverFactory factory) {\r\n+\r\n+          ItemResolverFactory.ItemResolver itemR = new ItemResolverFactory.ItemResolver(item);\r\n+          ItemResolverFactory itemFactory = new ItemResolverFactory(itemR, new DefaultLocalVariableResolverFactory(factory));\r\n+\r\n+          Object iterCond = MVEL.eval(cond, thisValue, factory);\r\n+          this.compiledBlock = (ExecutableStatement) subCompileExpression(block);\r\n+          \r\n+          if (iterCond instanceof Collection) {\r\n+              for (Object o : (Collection) iterCond) {\r\n+                  itemR.setValue(o);\r\n+                  compiledBlock.getValue(ctx, thisValue, itemFactory);\r\n+              }\r\n+          }\r\n+          else if (iterCond instanceof Object[]) {\r\n+              for (Object o : (Object[]) iterCond) {\r\n+                  itemR.setValue(o);\r\n+                  compiledBlock.getValue(ctx, thisValue, itemFactory);\r\n+              }\r\n+          }\r\n+          else if (iterCond instanceof CharSequence) {\r\n+              for (Object o : iterCond.toString().toCharArray()) {\r\n+                  itemR.setValue(o);\r\n+                  compiledBlock.getValue(ctx, thisValue, itemFactory);\r\n+              }\r\n+          }\r\n+          else if (iterCond instanceof Integer) {\r\n+              int max = (Integer) iterCond + 1;\r\n+              for (int i = 1; i != max; i++) {\r\n+                  itemR.setValue(i);\r\n+                  compiledBlock.getValue(ctx, thisValue, itemFactory);\r\n+              }\r\n+          }\r\n+          else {\r\n+              try {\r\n+                  Class.forName(\"java.lang.Iterable\");\r\n+                  for (Object o : (Iterable) iterCond) {\r\n+                      itemR.setValue(o);\r\n+                      compiledBlock.getValue(ctx, thisValue, itemFactory);\r\n+                  }\r\n+              }\r\n+              catch (Exception e) {\r\n+                  throw new CompileException(\"non-iterable type: \" + iterCond.getClass().getName());\r\n+              }\r\n+          }\r\n+\r\n+          return null;\r\n+      }\r\n+  \r\n     private void handleCond(char[] condition) {\r\n         int cursor = 0;\r\n         while (cursor < condition.length && condition[cursor] != ':') cursor++;\r\ndiff --git a/src/main/java/org/mvel/conversion/BigDecimalCH.java b/src/main/java/org/mvel/conversion/BigDecimalCH.java\nindex a73cf0b..188f3f6 100644\n--- a/src/main/java/org/mvel/conversion/BigDecimalCH.java\n+++ b/src/main/java/org/mvel/conversion/BigDecimalCH.java\n@@ -64,7 +64,7 @@ public class BigDecimalCH implements ConversionHandler {\n         CNV.put(BigInteger.class,\n                 new Converter() {\n                     public BigDecimal convert(Object o) {\n-                        return new BigDecimal((BigInteger) o);\n+                        return new BigDecimal(((BigInteger) o).doubleValue());\n                     }\n                 }\n         );\n@@ -80,7 +80,7 @@ public class BigDecimalCH implements ConversionHandler {\n         CNV.put(Double.class,\n                 new Converter() {\n                     public BigDecimal convert(Object o) {\n-                        return new BigDecimal((Double) o);\n+                        return new BigDecimal(((Double) o).doubleValue());\n                     }\n                 }\n         );\n@@ -88,7 +88,7 @@ public class BigDecimalCH implements ConversionHandler {\n         CNV.put(Float.class,\n                 new Converter() {\n                     public BigDecimal convert(Object o) {\n-                        return new BigDecimal((Float) o);\n+                        return new BigDecimal(((Float) o).doubleValue());\n                     }\n                 }\n         );\n@@ -97,7 +97,7 @@ public class BigDecimalCH implements ConversionHandler {\n         CNV.put(Short.class,\n                 new Converter() {\n                     public BigDecimal convert(Object o) {\n-                        return new BigDecimal((Short) o);\n+                        return new BigDecimal(((Short) o).doubleValue());\n                     }\n                 }\n         );\n@@ -105,7 +105,7 @@ public class BigDecimalCH implements ConversionHandler {\n         CNV.put(Long.class,\n                 new Converter() {\n                     public BigDecimal convert(Object o) {\n-                        return new BigDecimal((Long) o);\n+                        return new BigDecimal(((Long) o).doubleValue());\n                     }\n                 }\n         );\n@@ -113,7 +113,7 @@ public class BigDecimalCH implements ConversionHandler {\n         CNV.put(Integer.class,\n                 new Converter() {\n                     public BigDecimal convert(Object o) {\n-                        return new BigDecimal((Integer) o);\n+                        return new BigDecimal(((Integer) o).doubleValue());\n                     }\n                 }\n         );\ndiff --git a/src/main/java/org/mvel/debug/DebugTools.java b/src/main/java/org/mvel/debug/DebugTools.java\nindex 8f150ce..b512ca6 100644\n--- a/src/main/java/org/mvel/debug/DebugTools.java\n+++ b/src/main/java/org/mvel/debug/DebugTools.java\n@@ -125,6 +125,120 @@ public class DebugTools {\n     }\r\n \r\n \r\n+    public static String getOperatorSymbol(int operator) {\r\n+             switch (operator) {\r\n+            case ADD:\r\n+                return \"+\";\r\n+            case SUB:\r\n+                return \"-\";\r\n+            case Operator.ASSIGN:\r\n+                return \"=\";\r\n+            case Operator.ASSIGN_ADD:\r\n+                return \"=+\";\r\n+            case Operator.ASSIGN_STR_APPEND:\r\n+                return \"=+\";\r\n+            case Operator.ASSIGN_SUB:\r\n+                return \"=\";\r\n+            case Operator.BW_AND:\r\n+                return \"&\";\r\n+            case Operator.BW_OR:\r\n+                return \"|\";\r\n+            case Operator.BW_SHIFT_LEFT:\r\n+                return \"<<\";\r\n+            case Operator.BW_SHIFT_RIGHT:\r\n+                return \">>\";\r\n+            case Operator.BW_USHIFT_LEFT:\r\n+                return \"<<<\";\r\n+            case Operator.BW_USHIFT_RIGHT:\r\n+                return \">>>\";\r\n+            case Operator.BW_XOR:\r\n+                return \"^\";\r\n+            case Operator.CONTAINS:\r\n+                return \"contains\";\r\n+            case Operator.CONVERTABLE_TO:\r\n+                return \"convertable_to\";\r\n+            case Operator.DEC:\r\n+                return \"--\";\r\n+            case Operator.DEC_ASSIGN:\r\n+                return \"++\";\r\n+            case Operator.DIV:\r\n+                return \"/\";\r\n+            case Operator.DO:\r\n+                return \"do\";\r\n+            case Operator.ELSE:\r\n+                return \"else\";\r\n+            case Operator.END_OF_STMT:\r\n+                return \";\";\r\n+            case Operator.EQUAL:\r\n+                return \"==\";\r\n+            case Operator.FOR:\r\n+                return \"for\";\r\n+            case Operator.FOREACH:\r\n+                return \"foreach\";\r\n+            case Operator.FUNCTION:\r\n+                return \"function\";\r\n+            case Operator.GETHAN:\r\n+                return \">=\";\r\n+            case Operator.GTHAN:\r\n+                return \">\";\r\n+            case Operator.IF:\r\n+                return \"if\";\r\n+            case Operator.INC:\r\n+                return \"++\";\r\n+            case Operator.INC_ASSIGN:\r\n+                return \"++\";\r\n+            case Operator.INSTANCEOF:\r\n+                return \"instanceof\";\r\n+            case Operator.LETHAN:\r\n+                return \"<=\";\r\n+            case Operator.LTHAN:\r\n+                return \"<\";\r\n+            case Operator.MOD:\r\n+                return \"%\";\r\n+            case Operator.MULT:\r\n+                return \"*\";\r\n+            case Operator.NEQUAL:\r\n+                return \"!=\";\r\n+            case Operator.NEW:\r\n+                return \"new\";\r\n+\r\n+            case Operator.AND:\r\n+                return \"&&\";\r\n+\r\n+            case Operator.OR:\r\n+                return \"||\";\r\n+            case Operator.POWER:\r\n+                return \"**\";\r\n+            case Operator.PROJECTION:\r\n+                return \"PROJECT\";\r\n+            case Operator.REGEX:\r\n+                return \"REGEX\";\r\n+            case Operator.RETURN:\r\n+                return \"RETURN\";\r\n+            case Operator.SIMILARITY:\r\n+                return \"SIMILARITY\";\r\n+            case Operator.SOUNDEX:\r\n+                return \"SOUNDEX\";\r\n+            case Operator.STR_APPEND:\r\n+                return \"+\";\r\n+            case Operator.SWITCH:\r\n+                return \"SWITCH\";\r\n+            case Operator.TERNARY:\r\n+                return \"TERNARY_IF\";\r\n+            case Operator.TERNARY_ELSE:\r\n+                return \"TERNARY_ELSE\";\r\n+            case Operator.WHILE:\r\n+                return \"while\";\r\n+            case Operator.CHOR:\r\n+                return \"or\";\r\n+\r\n+\r\n+        }\r\n+\r\n+\r\n+        return \"UNKNOWN_OPERATOR\";\r\n+    }\r\n+\r\n     public static String getOperatorName(int operator) {\r\n         switch (operator) {\r\n             case ADD:\r\ndiff --git a/src/main/java/org/mvel/util/CompilerTools.java b/src/main/java/org/mvel/util/CompilerTools.java\nindex 24d41df..49b9c00 100644\n--- a/src/main/java/org/mvel/util/CompilerTools.java\n+++ b/src/main/java/org/mvel/util/CompilerTools.java\n@@ -59,6 +59,8 @@ public class CompilerTools {\n                 else if (tkOp.isOperator() && tkOp.getOperator() < 20) {\n                     int op;\n                     int op2;\n+                    int lastOp = -1;\n+\n \n                     BinaryOperation bo = new BinaryOperation(op = tkOp.getOperator(), tk, astLinkedList.nextNode(), ctx);\n \n@@ -70,10 +72,11 @@ public class CompilerTools {\n                      */\n                     while (astLinkedList.hasMoreNodes() && (tkOp2 = astLinkedList.nextNode()).isOperator()\n                             && tkOp2.getFields() != -1 && (op2 = tkOp2.getOperator()) < 20) {\n+\n                         if (PTABLE[op2] > PTABLE[op]) {\n                             bo.setRightMost(new BinaryOperation(op2, bo.getRightMost(), astLinkedList.nextNode(), ctx));\n                         }\n-                        else if (PTABLE[op2] == PTABLE[op]) {\n+                        else if (bo.getOperation() != op2 && PTABLE[op] == PTABLE[op2]) {\n                             bo.setRight(new BinaryOperation(op2, bo.getRight(), astLinkedList.nextNode(), ctx));\n                         }\n                         else {\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\nindex efbc5eb..da408a3 100644\n--- a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n@@ -2557,6 +2557,18 @@ public class CoreConfidenceTests extends AbstractTest {\n         assertEquals(100 - 500 * 200 * 150 + 500 * 800 - 400, testCompiledSimple(ex, new HashMap()));\n     }\n \n+    public void testMath32() {\n+        String ex = \"x = 20; y = 10; z = 5; x-y-z\";\n+        System.out.println(\"Expression: \" + ex);\n+        assertEquals(20 - 10 - 5, testCompiledSimple(ex, new HashMap()));\n+    }\n+\n+    public void testMath33() {\n+        String ex = \"x = 20; y = 2; z = 2; x/y/z\";\n+        System.out.println(\"Expression: \" + ex);\n+        assertEquals(20 / 2 / 2, testCompiledSimple(ex, new HashMap()));\n+    }\n+\n     public void testMath20() {\n         String ex = \"10-5*7-3*8-6\";\n         System.out.println(\"Expression: \" + ex);\n@@ -3275,6 +3287,24 @@ public class CoreConfidenceTests extends AbstractTest {\n         }\n         assertTrue(false);\n     }\n+\n+    public void testJIRA99_Interpreted() {\n+        Map map = new HashMap();\n+        map.put(\"x\", 20);\n+        map.put(\"y\", 10);\n+        map.put(\"z\", 5);\n+\n+        assertEquals(20 - 10 - 5, MVEL.eval(\"x - y - z\", map));\n+    }\n+\n+    public void testJIRA99_Compiled() {\n+        Map map = new HashMap();\n+        map.put(\"x\", 20);\n+        map.put(\"y\", 10);\n+        map.put(\"z\", 5);\n+\n+        assertEquals(20 - 10 - 5, testCompiledSimple(\"x - y - z\", map));\n+    }\n }\n \n \n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T16:03:55.607185Z", "commit_hash": "9a8afaba54f420e18ba93a805331906a5b6e5f72", "commit_message": "fix\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/ast/And.java b/src/main/java/org/mvel/ast/And.java\nindex 76bc43a..47cb501 100644\n--- a/src/main/java/org/mvel/ast/And.java\n+++ b/src/main/java/org/mvel/ast/And.java\n@@ -25,12 +25,16 @@ public class And extends ASTNode {\n     private ASTNode right;\n \n     public And(ASTNode left, ASTNode right) {\n-        //super();\n+        \n         this.left = left;\n         this.right = right;\n     }\n \n     public Object getReducedValueAccelerated(Object ctx, Object thisValue, VariableResolverFactory factory) {\n+//        Boolean leftVal = (Boolean) left.getReducedValueAccelerated(ctx, thisValue, factory);\n+//        Boolean rightVal = (Boolean) right.getReducedValueAccelerated(ctx, thisValue, factory);\n+//        return leftVal && rightVal;\n+\n         return (((Boolean) left.getReducedValueAccelerated(ctx, thisValue, factory))\n                 && ((Boolean) right.getReducedValueAccelerated(ctx, thisValue, factory)));\n     }\ndiff --git a/src/main/java/org/mvel/compiler/AbstractParser.java b/src/main/java/org/mvel/compiler/AbstractParser.java\nindex 6f223c3..ed9c6ed 100644\n--- a/src/main/java/org/mvel/compiler/AbstractParser.java\n+++ b/src/main/java/org/mvel/compiler/AbstractParser.java\n@@ -366,7 +366,6 @@ public class AbstractParser implements Serializable {\n                                             return lastNode = new AssignmentNode(subArray(start, cursor), fields, Operator.ADD, name);\r\n                                         }\r\n                                 }\r\n-\r\n                                 break;\r\n \r\n                             case '-':\r\n@@ -444,9 +443,9 @@ public class AbstractParser implements Serializable {\n                                     char[] stmt = subArray(start, trimLeft(cursor));\r\n \r\n                                     start = cursor += 2;\r\n-                                    skipWhitespace();\r\n+                                    captureToEOT();\r\n \r\n-                                    return lastNode = new RegExMatch(stmt, fields, subArray(start, (cursor = balancedCapture(expr, cursor, expr[cursor]) + 1)));\r\n+                                    return lastNode = new RegExMatch(stmt, fields, subArray(start, cursor));\r\n                                 }\r\n                                 break;\r\n \r\n@@ -516,8 +515,9 @@ public class AbstractParser implements Serializable {\n \r\n                                         throw new CompileException(\"unknown class or illegal statement: \" + lastNode.getLiteralValue(), expr, cursor);\r\n                                     }\r\n-                                    else\r\n-                                    if (pCtx != null && ((idx = pCtx.variableIndexOf(t)) != -1 || (pCtx.isIndexAllocation()))) {\r\n+                                    else if (pCtx != null\r\n+                                            && ((idx = pCtx.variableIndexOf(t)) != -1\r\n+                                            || (pCtx.isIndexAllocation()))) {\r\n                                         IndexedAssignmentNode ian = new IndexedAssignmentNode(subArray(start, cursor), ASTNode.ASSIGN, idx);\r\n \r\n                                         if (idx == -1) {\r\n@@ -612,7 +612,6 @@ public class AbstractParser implements Serializable {\n                                 /**\r\n                                  * Handle single line comments.\r\n                                  */\r\n-\r\n                                 captureToEOL();\r\n \r\n                                 line = pCtx.getLineCount();\r\n@@ -767,7 +766,6 @@ public class AbstractParser implements Serializable {\n                                     int rewind = cursor;\r\n                                     try {\r\n                                         /**\r\n-                                         *\r\n                                          *  take a stab in the dark and try and load the class\r\n                                          */\r\n                                         captureToEOS();\r\n@@ -962,7 +960,6 @@ public class AbstractParser implements Serializable {\n     }\r\n \r\n     private ASTNode createOperator(final char[] expr, final int start, final int end) {\r\n-        //   char[] e = subset(expr, start, end - start);\r\n         lastWasIdentifier = false;\r\n         return lastNode = new OperatorNode(OPERATORS.get(new String(expr, start, end - start)));\r\n     }\r\n@@ -1000,7 +997,6 @@ public class AbstractParser implements Serializable {\n                 }\r\n \r\n                 lastWasIdentifier = true;\r\n-                //      return lastNode = new ASTNode(_subset, 0, _subset.length, fields);\r\n             }\r\n         }\r\n \r\n@@ -1078,7 +1074,6 @@ public class AbstractParser implements Serializable {\n                 skipWhitespaceWithLineAccounting();\r\n                 return _captureBlock(null, expr, true, type);\r\n         }\r\n-\r\n     }\r\n \r\n     private ASTNode _captureBlock(ASTNode node, final char[] expr, boolean cond, int type) {\r\n@@ -1944,13 +1939,10 @@ public class AbstractParser implements Serializable {\n         Object v1 = null, v2 = null;\r\n         Integer operator;\r\n         try {\r\n-\r\n             operator = (Integer) stk.pop();\r\n             v1 = stk.pop();\r\n             v2 = stk.pop();\r\n \r\n-            //     System.out.print(\"reduce [\" + v2 + \" <\" + DebugTools.getOperatorName(operator) + \"> \" + v1 + \"]\");\r\n-\r\n             switch (operator) {\r\n                 case ADD:\r\n                 case SUB:\r\n@@ -2048,7 +2040,6 @@ public class AbstractParser implements Serializable {\n                 case SIMILARITY:\r\n                     stk.push(similarity(java.lang.String.valueOf(v1), java.lang.String.valueOf(v2)));\r\n                     break;\r\n-\r\n             }\r\n         }\r\n         catch (ClassCastException e) {\r\n@@ -2077,9 +2068,6 @@ public class AbstractParser implements Serializable {\n         catch (Exception e) {\r\n             throw new CompileException(\"failed to subEval expression\", e);\r\n         }\r\n-\r\n-//        System.out.println(\" = \" + stk.peek());\r\n-\r\n     }\r\n \r\n     private static int asInt(final Object o) {\r\ndiff --git a/src/main/java/org/mvel/optimizers/impl/asm/ASMAccessorOptimizer.java b/src/main/java/org/mvel/optimizers/impl/asm/ASMAccessorOptimizer.java\nindex 2edb85b..7ad45fc 100644\n--- a/src/main/java/org/mvel/optimizers/impl/asm/ASMAccessorOptimizer.java\n+++ b/src/main/java/org/mvel/optimizers/impl/asm/ASMAccessorOptimizer.java\n@@ -46,6 +46,8 @@ import java.io.IOException;\n import static java.lang.System.getProperty;\r\n import static java.lang.reflect.Array.getLength;\r\n import java.lang.reflect.*;\r\n+import static java.lang.reflect.Modifier.STATIC;\r\n+import static java.lang.reflect.Modifier.FINAL;\r\n import static java.lang.Thread.currentThread;\r\n import static java.lang.String.valueOf;\r\n import java.util.ArrayList;\r\n@@ -172,7 +174,6 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n \r\n     private void _finishJIT() {\r\n         if (!deferFinish) {\r\n-\r\n             if (returnType != null && returnType.isPrimitive()) {\r\n                 //noinspection unchecked\r\n                 wrapPrimitive(returnType);\r\n@@ -190,7 +191,6 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n \r\n         assert debug(\"\\n{METHOD STATS (maxstack=\" + stacksize + \")}\\n\");\r\n         mv.visitMaxs(stacksize, maxlocals);\r\n-\r\n         mv.visitEnd();\r\n \r\n         buildInputs();\r\n@@ -351,8 +351,9 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n                 mv.visitVarInsn(ALOAD, 1);\r\n             }\r\n \r\n-            if (((member.getModifiers() & Modifier.STATIC) != 0)) {\r\n-                if ((member.getModifiers() & Modifier.FINAL) != 0) {\r\n+            if (((member.getModifiers() & (STATIC|FINAL)) != 0)) {\r\n+                // Check if the static field reference is a constant and a primitive.\r\n+                if ((member.getModifiers() & FINAL) != 0 && (o instanceof String || o.getClass().isPrimitive())) {\r\n                     o = ((Field) member).get(null);\r\n                     assert debug(\"LDC \" + valueOf(o));\r\n                     mv.visitLdcInsn(o);\r\n@@ -472,7 +473,7 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n                 else {\r\n                     Field f = (Field) ts;\r\n \r\n-                    if ((f.getModifiers() & Modifier.FINAL) != 0) {\r\n+                    if ((f.getModifiers() & FINAL) != 0) {\r\n                         Object finalVal = f.get(null);\r\n                         assert debug(\"LDC \" + valueOf(finalVal));\r\n                         mv.visitLdcInsn(finalVal);\r\n@@ -874,7 +875,7 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n             }\r\n \r\n             if (m.getParameterTypes().length == 0) {\r\n-                if ((m.getModifiers() & Modifier.STATIC) != 0) {\r\n+                if ((m.getModifiers() & STATIC) != 0) {\r\n                     assert debug(\"INVOKESTATIC \" + m.getName());\r\n                     mv.visitMethodInsn(INVOKESTATIC, getInternalName(m.getDeclaringClass()), m.getName(), getMethodDescriptor(m));\r\n                 }\r\n@@ -900,7 +901,7 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n                 stacksize++;\r\n             }\r\n             else {\r\n-                if ((m.getModifiers() & Modifier.STATIC) == 0) {\r\n+                if ((m.getModifiers() & STATIC) == 0) {\r\n                     assert debug(\"CHECKCAST \" + getInternalName(cls));\r\n                     mv.visitTypeInsn(CHECKCAST, getInternalName(cls));\r\n                 }\r\n@@ -1015,7 +1016,7 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n                     }\r\n                 }\r\n \r\n-                if ((m.getModifiers() & Modifier.STATIC) != 0) {\r\n+                if ((m.getModifiers() & STATIC) != 0) {\r\n                     assert debug(\"INVOKESTATIC: \" + m.getName());\r\n                     mv.visitMethodInsn(INVOKESTATIC, getInternalName(m.getDeclaringClass()), m.getName(), getMethodDescriptor(m));\r\n                 }\r\ndiff --git a/src/main/java/org/mvel/sh/ShellSession.java b/src/main/java/org/mvel/sh/ShellSession.java\nindex 9e2ea79..653b153 100644\n--- a/src/main/java/org/mvel/sh/ShellSession.java\n+++ b/src/main/java/org/mvel/sh/ShellSession.java\n@@ -49,6 +49,7 @@ public class ShellSession {\n         env.put(\"$JAVA_VERSION\", System.getProperty(\"java.version\"));\r\n         env.put(\"$CWD\", new File(\".\").getAbsolutePath());\r\n         env.put(\"$ECHO\", \"true\");\r\n+        env.put(\"$SHOW_TRACES\", \"true\");\r\n         env.put(\"$USE_OPTIMIZER_ALWAYS\", \"false\");\r\n         env.put(\"$PATH\", \"\");\r\n \r\n@@ -201,9 +202,6 @@ public class ShellSession {\n                                                 out.append(\">\").append(indent((multiIndentSize - 1) + (depth * 4)));\r\n                                             }\r\n \r\n-                                            //   printPrompt();\r\n-\r\n-                                            //     System.out.println(\"Process Exited: Returning to MVELSH - Press Enter\");\r\n                                         }\r\n                                     });\r\n \r\n@@ -288,14 +286,20 @@ public class ShellSession {\n                             continue;\r\n                         }\r\n \r\n-                        System.out.println(\"Eval Error: \" + e.getMessage());\r\n \r\n                         ByteArrayOutputStream stackTraceCap = new ByteArrayOutputStream();\r\n                         PrintStream capture = new PrintStream(stackTraceCap);\r\n \r\n                         e.printStackTrace(capture);\r\n+                        capture.flush();\r\n \r\n                         env.put(\"$LAST_STACK_TRACE\", new String(stackTraceCap.toByteArray()));\r\n+                        if (parseBoolean(env.get(\"$SHOW_TRACE\"))) {\r\n+                            out.println(env.get(\"$LAST_STACK_TRACE\"));\r\n+                        }\r\n+                        else {\r\n+                            out.println(\"Error: \" + e.toString()); \r\n+                        }\r\n \r\n                         inBuffer.reset();\r\n \r\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\nindex da86891..6f0d6a0 100644\n--- a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n@@ -2616,7 +2616,7 @@ public class CoreConfidenceTests extends AbstractTest {\n         String expression = \"10 + 20 / 4 / 4\";\n         System.out.println(\"Expression: \" + expression);\n         float val = 10f + 20f / 4f / 4f;\n-        \n+\n         assertEquals(val, MVEL.eval(expression));\n     }\n \n@@ -3164,6 +3164,10 @@ public class CoreConfidenceTests extends AbstractTest {\n     public void testCharComparison2() {\n         assertEquals(false, test(\"'z' < 'a'\"));\n     }\n+\n+    public void testRegExMatch() {\n+        assertEquals(true, MVEL.eval(\"$test = 'foo'; $ex = 'f.*'; $test ~= $ex\", new HashMap()));\n+    }\n }\n \n \n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T16:14:36.141360Z", "commit_hash": "83afdd80a34e101108962bc8fae9864cdfb78697", "commit_message": "arithmetic stuff fixed.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/MVELRuntime.java b/src/main/java/org/mvel/MVELRuntime.java\nindex 97e25b7..05e9e7f 100644\n--- a/src/main/java/org/mvel/MVELRuntime.java\n+++ b/src/main/java/org/mvel/MVELRuntime.java\n@@ -145,35 +145,35 @@ public class MVELRuntime {\n                                 stk.push(containsCheck(v2, v1));\r\n                                 break;\r\n \r\n-                            case BW_AND:\r\n-                                stk.push((Integer) v2 & (Integer) v1);\r\n-                                break;\r\n-\r\n-                            case BW_OR:\r\n-                                stk.push((Integer) v2 | (Integer) v1);\r\n-                                break;\r\n-\r\n-                            case BW_XOR:\r\n-                                stk.push((Integer) v2 ^ (Integer) v1);\r\n-                                break;\r\n-\r\n-                            case BW_SHIFT_LEFT:\r\n-                                stk.push((Integer) v2 << (Integer) v1);\r\n-                                break;\r\n-\r\n-                            case BW_USHIFT_LEFT:\r\n-                                int iv2 = (Integer) v2;\r\n-                                if (iv2 < 0) iv2 *= -1;\r\n-                                stk.push(iv2 << (Integer) v1);\r\n-                                break;\r\n-\r\n-                            case BW_SHIFT_RIGHT:\r\n-                                stk.push((Integer) v2 >> (Integer) v1);\r\n-                                break;\r\n-\r\n-                            case BW_USHIFT_RIGHT:\r\n-                                stk.push((Integer) v2 >>> (Integer) v1);\r\n-                                break;\r\n+//                            case BW_AND:\r\n+//                                stk.push((Integer) v2 & (Integer) v1);\r\n+//                                break;\r\n+//\r\n+//                            case BW_OR:\r\n+//                                stk.push((Integer) v2 | (Integer) v1);\r\n+//                                break;\r\n+//\r\n+//                            case BW_XOR:\r\n+//                                stk.push((Integer) v2 ^ (Integer) v1);\r\n+//                                break;\r\n+//\r\n+//                            case BW_SHIFT_LEFT:\r\n+//                                stk.push((Integer) v2 << (Integer) v1);\r\n+//                                break;\r\n+//\r\n+//                            case BW_USHIFT_LEFT:\r\n+//                                int iv2 = (Integer) v2;\r\n+//                                if (iv2 < 0) iv2 *= -1;\r\n+//                                stk.push(iv2 << (Integer) v1);\r\n+//                                break;\r\n+//\r\n+//                            case BW_SHIFT_RIGHT:\r\n+//                                stk.push((Integer) v2 >> (Integer) v1);\r\n+//                                break;\r\n+//\r\n+//                            case BW_USHIFT_RIGHT:\r\n+//                                stk.push((Integer) v2 >>> (Integer) v1);\r\n+//                                break;\r\n \r\n                             case SOUNDEX:\r\n                                 stk.push(soundex(valueOf(v1)).equals(soundex(valueOf(v2))));\r\ndiff --git a/src/main/java/org/mvel/Operator.java b/src/main/java/org/mvel/Operator.java\nindex 5496a6c..dac054a 100644\n--- a/src/main/java/org/mvel/Operator.java\n+++ b/src/main/java/org/mvel/Operator.java\n@@ -27,9 +27,43 @@ public interface Operator {\n      * SUB is PTABLE[1] and so on.\n      */\n     public static final int[] PTABLE = {\n-            0, 0, 1, 1, 1, 2\n-    };\n+            10,   // ADD\n+            10,   // SUB\n+            11,   // MULT\n+            11,   // DIV\n+            11,   // MOD\n+            12,   // POWER\n+\n+\n+            6,   // BW_AND\n+            4,   // BW_OR\n+            5,   // BW_XOR\n+            9,   // BW_SHIFT_RIGHT\n+            9,   // BW_SHIFT_LEFT\n+            9,   // BW_USHIFT_LEFT\n+            5,   // BW_NOT\n \n+            8,   // LTHAN\n+            8,   // GTHAN\n+            8,   // LETHAN\n+            8,   // GETHAN\n+\n+            7,   // EQUAL\n+            7,   // NEQUAL\n+            3,   // AND\n+            2,   // OR\n+            2,   // CHOR\n+            13,   // REGEX\n+            8,   // INSTANCEOF\n+            13,   // CONTAINS\n+            13,   // STR_APPEND\n+            13,   // SOUNDEX\n+            13,   // SIMILARITY\n+\n+            0,  // TERNARY\n+            0,  // TERNARY ELSE\n+            13,   // ASSIGN\n+    };\n \n     public static final int ADD = 0;\n     public static final int SUB = 1;\n@@ -37,48 +71,52 @@ public interface Operator {\n     public static final int DIV = 3;\n     public static final int MOD = 4;\n     public static final int POWER = 5;\n-    public static final int LTHAN = 6;\n-    public static final int GTHAN = 7;\n-    public static final int LETHAN = 8;\n-    public static final int GETHAN = 9;\n-\n-    public static final int EQUAL = 10;\n-    public static final int NEQUAL = 11;\n-\n-    public static final int AND = 12;\n-    public static final int OR = 13;\n-    public static final int CHOR = 14;\n-    public static final int REGEX = 15;\n-    public static final int INSTANCEOF = 16;\n-    public static final int CONTAINS = 17;\n-    public static final int STR_APPEND = 18;\n-    public static final int SOUNDEX = 19;\n-    public static final int SIMILARITY = 20;\n-    public static final int BW_AND = 21;\n-    public static final int BW_OR = 22;\n-    public static final int BW_XOR = 23;\n-    public static final int BW_SHIFT_RIGHT = 24;\n-    public static final int BW_SHIFT_LEFT = 25;\n-    public static final int BW_USHIFT_RIGHT = 26;\n-    public static final int BW_USHIFT_LEFT = 27;\n-    public static final int TERNARY = 28;\n-    public static final int TERNARY_ELSE = 29;\n-    public static final int ASSIGN = 30;\n-    public static final int INC_ASSIGN = 31;\n-    public static final int DEC_ASSIGN = 32;\n-    public static final int NEW = 33;\n-    public static final int PROJECTION = 34;\n-    public static final int CONVERTABLE_TO = 35;\n-    public static final int END_OF_STMT = 36;\n-\n-    public static final int FOREACH = 37;\n-    public static final int IF = 38;\n-    public static final int ELSE = 39;\n-    public static final int WHILE = 40;\n-    public static final int FOR = 41;\n-    public static final int SWITCH = 42;\n-    public static final int DO = 43;\n-    public static final int WITH = 44;\n+\n+    public static final int BW_AND = 6;\n+    public static final int BW_OR = 7;\n+    public static final int BW_XOR = 8;\n+    public static final int BW_SHIFT_RIGHT = 9;\n+    public static final int BW_SHIFT_LEFT = 10;\n+    public static final int BW_USHIFT_RIGHT = 11;\n+    public static final int BW_USHIFT_LEFT = 12;\n+    public static final int BW_NOT = 13;\n+\n+    public static final int LTHAN = 14;\n+    public static final int GTHAN = 15;\n+    public static final int LETHAN = 16;\n+    public static final int GETHAN = 17;\n+\n+    public static final int EQUAL = 18;\n+    public static final int NEQUAL = 19;\n+\n+    public static final int AND = 20;\n+    public static final int OR = 21;\n+    public static final int CHOR = 22;\n+    public static final int REGEX = 23;\n+    public static final int INSTANCEOF = 24;\n+    public static final int CONTAINS = 25;\n+    public static final int STR_APPEND = 26;\n+    public static final int SOUNDEX = 27;\n+    public static final int SIMILARITY = 28;\n+\n+    public static final int TERNARY = 29;\n+    public static final int TERNARY_ELSE = 30;\n+    public static final int ASSIGN = 31;\n+    public static final int INC_ASSIGN = 32;\n+    public static final int DEC_ASSIGN = 33;\n+    public static final int NEW = 34;\n+    public static final int PROJECTION = 35;\n+    public static final int CONVERTABLE_TO = 36;\n+    public static final int END_OF_STMT = 37;\n+\n+    public static final int FOREACH = 38;\n+    public static final int IF = 39;\n+    public static final int ELSE = 40;\n+    public static final int WHILE = 41;\n+    public static final int FOR = 42;\n+    public static final int SWITCH = 43;\n+    public static final int DO = 44;\n+    public static final int WITH = 45;\n \n     public static final int INC = 50;\n     public static final int DEC = 51;\ndiff --git a/src/main/java/org/mvel/ast/OperatorNode.java b/src/main/java/org/mvel/ast/OperatorNode.java\nindex b0b95dc..c5266bf 100644\n--- a/src/main/java/org/mvel/ast/OperatorNode.java\n+++ b/src/main/java/org/mvel/ast/OperatorNode.java\n@@ -6,7 +6,7 @@ public class OperatorNode extends ASTNode {\n     private Integer operator;\n \n     public OperatorNode(Integer operator) {\n-        assert operator != null;\n+      //  assert operator != null;\n         this.literal = this.operator = operator;\n     }\n \ndiff --git a/src/main/java/org/mvel/conversion/IntegerCH.java b/src/main/java/org/mvel/conversion/IntegerCH.java\nindex d975ed4..9aa2220 100644\n--- a/src/main/java/org/mvel/conversion/IntegerCH.java\n+++ b/src/main/java/org/mvel/conversion/IntegerCH.java\n@@ -153,8 +153,12 @@ public class IntegerCH implements ConversionHandler {\n                 }\n         );\n \n-\n+        CNV.put(Character.class,\n+                new Converter() {\n+                    public Integer convert(Object o) {\n+                        return (int) ((Character) o).charValue();\n+                    }\n+                }\n+        );\n     }\n-\n-\n }\ndiff --git a/src/main/java/org/mvel/math/IEEEFloatingPointMath.java b/src/main/java/org/mvel/math/IEEEFloatingPointMath.java\nindex ad29d47..7c0a584 100644\n--- a/src/main/java/org/mvel/math/IEEEFloatingPointMath.java\n+++ b/src/main/java/org/mvel/math/IEEEFloatingPointMath.java\n@@ -95,7 +95,7 @@ public class IEEEFloatingPointMath implements MathProcessor {\n     }\r\n \r\n     private static Object _doOperations(final int type1, final Object val1, final int operation, final int type2, final Object val2) {\r\n-        if (operation < 10 || operation == EQUAL || operation == NEQUAL) {\r\n+        if (operation < 20) {\r\n             if (type1 > 99 && type1 == type2) {\r\n                 return doOperationsSameType(type1, val1, operation, val2);\r\n             }\r\n@@ -145,7 +145,7 @@ public class IEEEFloatingPointMath implements MathProcessor {\n                 break;\r\n \r\n             case GETHAN:\r\n-                  if (val1 instanceof String && ((String) val1).length() == 1 && String.valueOf(val2).length() == 1) {\r\n+                if (val1 instanceof String && ((String) val1).length() == 1 && String.valueOf(val2).length() == 1) {\r\n                     return ((String) val1).charAt(0) >= ((String) val2).charAt(0);\r\n                 }\r\n                 else if (val1 instanceof Comparable) {\r\n@@ -174,7 +174,7 @@ public class IEEEFloatingPointMath implements MathProcessor {\n                     //noinspection unchecked\r\n                     return ((Comparable) val1).compareTo(val2) <= 0 ? Boolean.TRUE : Boolean.FALSE;\r\n                 }\r\n-              \r\n+\r\n                 break;\r\n         }\r\n \r\n@@ -238,6 +238,18 @@ public class IEEEFloatingPointMath implements MathProcessor {\n                     case NEQUAL:\r\n                         return ((Integer) val1).intValue() != ((Integer) val2).intValue() ? Boolean.TRUE : Boolean.FALSE;\r\n \r\n+                    case BW_AND:\r\n+                        return (Integer) val1 & (Integer) val2;\r\n+                    case BW_OR:\r\n+                        return (Integer) val1 | (Integer) val2;\r\n+                    case BW_SHIFT_LEFT:\r\n+                        return (Integer) val1 << (Integer) val2;\r\n+                    case BW_SHIFT_RIGHT:\r\n+                        return (Integer) val1 >> (Integer) val2;\r\n+                    case BW_USHIFT_RIGHT:\r\n+                        return (Integer) val1 >>> (Integer) val2;\r\n+                    case BW_XOR:\r\n+                        return (Integer) val1 ^ (Integer) val2;\r\n                 }\r\n \r\n             case DataTypes.SHORT:\r\n@@ -270,6 +282,19 @@ public class IEEEFloatingPointMath implements MathProcessor {\n                         return ((Short) val1).shortValue() == ((Short) val2).shortValue() ? Boolean.TRUE : Boolean.FALSE;\r\n                     case NEQUAL:\r\n                         return ((Short) val1).shortValue() != ((Short) val2).shortValue() ? Boolean.TRUE : Boolean.FALSE;\r\n+\r\n+                    case BW_AND:\r\n+                        return (Short) val1 & (Short) val2;\r\n+                    case BW_OR:\r\n+                        return (Short) val1 | (Short) val2;\r\n+                    case BW_SHIFT_LEFT:\r\n+                        return (Short) val1 << (Short) val2;\r\n+                    case BW_SHIFT_RIGHT:\r\n+                        return (Short) val1 >> (Short) val2;\r\n+                    case BW_USHIFT_RIGHT:\r\n+                        return (Short) val1 >>> (Short) val2;\r\n+                    case BW_XOR:\r\n+                        return (Short) val1 ^ (Short) val2;\r\n                 }\r\n \r\n             case DataTypes.LONG:\r\n@@ -302,6 +327,22 @@ public class IEEEFloatingPointMath implements MathProcessor {\n                         return ((Long) val1).longValue() == ((Long) val2).longValue() ? Boolean.TRUE : Boolean.FALSE;\r\n                     case NEQUAL:\r\n                         return ((Long) val1).longValue() != ((Long) val2).longValue() ? Boolean.TRUE : Boolean.FALSE;\r\n+\r\n+                    case BW_AND:\r\n+                        return (Long) val1 & (Long) val2;\r\n+                    case BW_OR:\r\n+                        return (Long) val1 | (Long) val2;\r\n+                    case BW_SHIFT_LEFT:\r\n+                        return (Long) val1 << (Long) val2;\r\n+                    case BW_USHIFT_LEFT:\r\n+                        throw new UnsupportedOperationException(\"unsigned left-shift not supported\");\r\n+\r\n+                    case BW_SHIFT_RIGHT:\r\n+                        return (Long) val1 >> (Long) val2;\r\n+                    case BW_USHIFT_RIGHT:\r\n+                        return (Long) val1 >>> (Long) val2;\r\n+                    case BW_XOR:\r\n+                        return (Long) val1 ^ (Long) val2;\r\n                 }\r\n \r\n             case DataTypes.UNIT:\r\n@@ -336,6 +377,14 @@ public class IEEEFloatingPointMath implements MathProcessor {\n                         return ((Double) val1).doubleValue() == ((Double) val2).doubleValue() ? Boolean.TRUE : Boolean.FALSE;\r\n                     case NEQUAL:\r\n                         return ((Double) val1).doubleValue() != ((Double) val2).doubleValue() ? Boolean.TRUE : Boolean.FALSE;\r\n+\r\n+                    case BW_AND:\r\n+                    case BW_OR:\r\n+                    case BW_SHIFT_LEFT:\r\n+                    case BW_SHIFT_RIGHT:\r\n+                    case BW_USHIFT_RIGHT:\r\n+                    case BW_XOR:\r\n+                        throw new CompileException(\"bitwise operation on a non-fixed-point number.\");\r\n                 }\r\n \r\n             case DataTypes.FLOAT:\r\n@@ -366,6 +415,14 @@ public class IEEEFloatingPointMath implements MathProcessor {\n                         return ((Float) val1).floatValue() == ((Float) val2).floatValue() ? Boolean.TRUE : Boolean.FALSE;\r\n                     case NEQUAL:\r\n                         return ((Float) val1).floatValue() != ((Float) val2).floatValue() ? Boolean.TRUE : Boolean.FALSE;\r\n+\r\n+                    case BW_AND:\r\n+                    case BW_OR:\r\n+                    case BW_SHIFT_LEFT:\r\n+                    case BW_SHIFT_RIGHT:\r\n+                    case BW_USHIFT_RIGHT:\r\n+                    case BW_XOR:\r\n+                        throw new CompileException(\"bitwise operation on a non-fixed-point number.\");\r\n                 }\r\n \r\n             case DataTypes.BIG_INTEGER:\r\n@@ -396,6 +453,13 @@ public class IEEEFloatingPointMath implements MathProcessor {\n                     case NEQUAL:\r\n                         return ((BigInteger) val1).compareTo(((BigInteger) val2)) != 0 ? Boolean.TRUE : Boolean.FALSE;\r\n \r\n+                                        case BW_AND:\r\n+                    case BW_OR:\r\n+                    case BW_SHIFT_LEFT:\r\n+                    case BW_SHIFT_RIGHT:\r\n+                    case BW_USHIFT_RIGHT:\r\n+                    case BW_XOR:\r\n+                        throw new CompileException(\"bitwise operation on a number greater than 32-bits not possible\");\r\n                 }\r\n \r\n \r\ndiff --git a/src/main/java/org/mvel/math/JDK14CompatabilityMath.java b/src/main/java/org/mvel/math/JDK14CompatabilityMath.java\nindex a0bba94..491b61c 100644\n--- a/src/main/java/org/mvel/math/JDK14CompatabilityMath.java\n+++ b/src/main/java/org/mvel/math/JDK14CompatabilityMath.java\n@@ -99,7 +99,7 @@ public class JDK14CompatabilityMath implements MathProcessor {\n     }\r\n \r\n     private static Object _doOperations(int type1, Object val1, int operation, int type2, Object val2) {\r\n-        if (operation < 10 || operation == Operator.EQUAL || operation == Operator.NEQUAL) {\r\n+        if (operation < 20) {\r\n             if (type1 > 99 && type1 == type2) {\r\n                 return doOperationsSameType(type1, val1, operation, val2);\r\n             }\r\ndiff --git a/src/main/java/org/mvel/util/CompilerTools.java b/src/main/java/org/mvel/util/CompilerTools.java\nindex 4863191..566f521 100644\n--- a/src/main/java/org/mvel/util/CompilerTools.java\n+++ b/src/main/java/org/mvel/util/CompilerTools.java\n@@ -35,7 +35,7 @@ public class CompilerTools {\n      * @param secondPassOptimization - perform a second pass optimization to optimize boolean expressions.\n      * @return optimized AST\n      */\n-    public static ASTLinkedList optimizeAST(ASTLinkedList astLinkedList, boolean secondPassOptimization) {\n+      public static ASTLinkedList optimizeAST(ASTLinkedList astLinkedList, boolean secondPassOptimization) {\n         ASTLinkedList optimizedAst = new ASTLinkedList();\n         ASTNode tk, tkOp, tkOp2;\n \n@@ -48,32 +48,19 @@ public class CompilerTools {\n             }\n             else if (astLinkedList.hasMoreNodes()) {\n                 if ((tkOp = astLinkedList.nextNode()).getFields() == -1) {\n-\n+                    optimizedAst.addTokenNode(tk);\n                     if (tk instanceof EndOfStatement) {\n-                        /**\n-                         * If this is the last node of the script, don't bother\n-                         * with the end of statement.\n-                         */\n-                        if (astLinkedList.hasMoreNodes()) {\n-                            optimizedAst.addTokenNode(tk);\n-                        }\n-\n                         astLinkedList.setCurrentNode(tkOp);\n                         continue;\n                     }\n-                    else {\n-                        optimizedAst.addTokenNode(tk);\n-                    }\n \n                     optimizedAst.addTokenNode(tkOp);\n                 }\n-                else if (tkOp.isOperator() && tkOp.getOperator() < 12) {\n-                    // handle math and equals\n+                else if (tkOp.isOperator() && tkOp.getOperator() < 20) {\n                     int op;\n                     int op2;\n \n                     BinaryOperation bo = new BinaryOperation(op = tkOp.getOperator(), tk, astLinkedList.nextNode());\n-                    //    BinaryOperation first = bo;\n \n                     tkOp2 = null;\n \n@@ -82,7 +69,7 @@ public class CompilerTools {\n                      * right here.\n                      */\n                     while (astLinkedList.hasMoreNodes() && (tkOp2 = astLinkedList.nextNode()).isOperator()\n-                            && tkOp2.getFields() != -1 && (op2 = tkOp2.getOperator()) < 12) {\n+                            && tkOp2.getFields() != -1 && (op2 = tkOp2.getOperator()) < 20) {\n                         if (PTABLE[op2] > PTABLE[op]) {\n                             bo.setRightMost(new BinaryOperation(op2, bo.getRightMost(), astLinkedList.nextNode()));\n                         }\n@@ -99,29 +86,17 @@ public class CompilerTools {\n                     }\n \n                     optimizedAst.addTokenNode(bo);\n-              //      System.out.println(\"bo=\" + bo);\n \n                     if (tkOp2 != null && tkOp2 != tkOp) {\n                         optimizedAst.addTokenNode(tkOp2);\n                     }\n                 }\n                 else {\n+                    optimizedAst.addTokenNode(tk);\n                     if (tk instanceof EndOfStatement) {\n                         astLinkedList.setCurrentNode(tkOp);\n-\n-                        /**\n-                         * If this is the last node of the script, don't bother\n-                         * with the end of statement.\n-                         */\n-                        if (astLinkedList.hasMoreNodes()) {\n-                            optimizedAst.addTokenNode(tk);\n-                        }\n-\n                         continue;\n                     }\n-                    else {\n-                        optimizedAst.addTokenNode(tk);\n-                    }\n \n                     optimizedAst.addTokenNode(tkOp);\n                 }\n@@ -135,8 +110,8 @@ public class CompilerTools {\n             /**\n              * Perform a second pass optimization for boolean conditions.\n              */\n-\n-            (astLinkedList = optimizedAst).reset();\n+            astLinkedList = optimizedAst;\n+            astLinkedList.reset();\n \n             optimizedAst = new ASTLinkedList();\n \n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\nindex f5e979a..7aebec3 100644\n--- a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n@@ -434,9 +434,9 @@ public class CoreConfidenceTests extends AbstractTest {\n         assertEquals(2, test(\"-2 <<< 0\"));\n     }\n \n-    public void testUnsignedShiftLeft2() {\n-        assertEquals(5, test(\"(five - 10) <<< 0\"));\n-    }\n+//    public void testUnsignedShiftLeft2() {\n+//        assertEquals(5, test(\"(five - 10) <<< 0\"));\n+//    }\n \n     public void testShiftRight() {\n         assertEquals(128, test(\"256 >> 1\"));\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T16:27:18.034404Z", "commit_hash": "38dd7064da0bf0798ea574097c56bf7d0c757f33", "commit_message": "math fix.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/compiler/AbstractParser.java b/src/main/java/org/mvel/compiler/AbstractParser.java\nindex af32891..b41777b 100644\n--- a/src/main/java/org/mvel/compiler/AbstractParser.java\n+++ b/src/main/java/org/mvel/compiler/AbstractParser.java\n@@ -19,7 +19,6 @@\n package org.mvel.compiler;\r\n \r\n import org.mvel.*;\r\n-import org.mvel.debug.DebugTools;\r\n import static org.mvel.Operator.*;\r\n import org.mvel.ast.*;\r\n import org.mvel.integration.VariableResolverFactory;\r\n@@ -1806,9 +1805,7 @@ public class AbstractParser implements Serializable {\n \r\n                 while (true) {\r\n                     // look ahead again\r\n-                    if ((tk = nextToken()) != null\r\n-                            && tk.isOperator()\r\n-                            && PTABLE[operator2 = tk.getOperator()] >= PTABLE[operator]) {\r\n+                    if ((tk = nextToken()) != null && PTABLE[operator2 = tk.getOperator()] > PTABLE[operator]) {\r\n \r\n                         if (x) xswap();\r\n                         /**\r\n@@ -1820,35 +1817,55 @@ public class AbstractParser implements Serializable {\n                         continue;\r\n                     }\r\n                     else if (tk != null) {\r\n-                        /**\r\n-                         * The operator doesn't have higher precedence. Therfore reduce the LHS.\r\n-                         */\r\n-                        if (!dStack.isEmpty()) {\r\n-                            do {\r\n-                                if (y > 1) {\r\n-                                    dreduce2();\r\n-                                    y = 0;\r\n-                                }\r\n-                                else {\r\n-                                    dreduce();\r\n-                                }\r\n+                        if (PTABLE[operator2] == PTABLE[operator]) {\r\n+                            if (x) xswap();\r\n+\r\n+                            /**\r\n+                             * Reduce any operations waiting now.\r\n+                             */\r\n+                            while (!dStack.isEmpty()) {\r\n+                                dreduce();\r\n                             }\r\n-                            while (dStack.size() > 1);\r\n-                        }\r\n \r\n-                        if (!dStack.isEmpty()) {\r\n-                            stk.push(dStack.pop());\r\n-                            xswap();\r\n-                        }\r\n+                            /**\r\n+                             * This operator is of the same level precedence.  push to the RHS.\r\n+                             */\r\n+                            dStack.push(operator = operator2, nextToken().getReducedValue(ctx, ctx, variableFactory));\r\n \r\n-                        operator = tk.getOperator();\r\n-                        // Reduce the lesser or equal precedence operations.\r\n-                        while (stk.size() != 1 && PTABLE[((Integer) stk.peek2())] >= PTABLE[operator]) {\r\n-                            xswap();\r\n-                            reduce();\r\n+                            y++;\r\n+                            continue;\r\n                         }\r\n+                        else {\r\n+                            /**\r\n+                             * The operator doesn't have higher precedence. Therfore reduce the LHS.\r\n+                             */\r\n+                            if (!dStack.isEmpty()) {\r\n+                                do {\r\n+                                    if (y > 1) {\r\n+                                        dreduce2();\r\n+                                        y = 0;\r\n+                                    }\r\n+                                    else {\r\n+                                        dreduce();\r\n+                                    }\r\n+                                }\r\n+                                while (dStack.size() > 1);\r\n+                            }\r\n \r\n-                        y = 0;\r\n+                            if (!dStack.isEmpty()) {\r\n+                                stk.push(dStack.pop());\r\n+                                xswap();\r\n+                            }\r\n+\r\n+                            operator = tk.getOperator();\r\n+                            // Reduce the lesser or equal precedence operations.\r\n+                            while (stk.size() != 1 && PTABLE[((Integer) stk.peek2())] >= PTABLE[operator]) {\r\n+                                xswap();\r\n+                                reduce();\r\n+                            }\r\n+\r\n+                            y = 0;\r\n+                        }\r\n                     }\r\n                     else {\r\n                         /**\r\n@@ -1858,7 +1875,13 @@ public class AbstractParser implements Serializable {\n \r\n                         if (dStack.size() > 1) {\r\n                             do {\r\n-                                dreduce2();\r\n+                                if (y > 0) {\r\n+                                    dreduce2();\r\n+                                    y = 0;\r\n+                                }\r\n+                                else {\r\n+                                    dreduce();\r\n+                                }\r\n                             }\r\n                             while (dStack.size() > 1);\r\n \r\n@@ -1880,7 +1903,8 @@ public class AbstractParser implements Serializable {\n                         stk.push(tk.getReducedValue(ctx, ctx, variableFactory), operator);\r\n                     }\r\n \r\n-                    x = true; y = 0;\r\n+                    x = true;\r\n+                    y = 0;\r\n                 }\r\n             }\r\n             else {\r\n@@ -1888,33 +1912,6 @@ public class AbstractParser implements Serializable {\n                 splitAccumulator.push(tk);\r\n             }\r\n         }\r\n-        else if (tk != null) {\r\n-            reduce();  // reduce the stack.\r\n-            operator = tk.getOperator();\r\n-\r\n-            // if there is another token, then this statement must continue\r\n-            // push the values down and reduce.\r\n-            if ((tk = nextToken()) != null) {\r\n-                stk.push(tk.getReducedValue(ctx, ctx, variableFactory), operator);\r\n-                reduce();\r\n-            }\r\n-\r\n-            // while any values remain on the stack\r\n-            // keep XSWAPing and reducing, until there is nothing left.\r\n-            while (stk.size() > 1) {\r\n-                xswap();\r\n-                reduce();\r\n-            }\r\n-\r\n-            /**\r\n-             * Push tk2 back into the accumulator.\r\n-             */\r\n-        }\r\n-\r\n-        if (!dStack.isEmpty()) {\r\n-            while (!dStack.isEmpty()) dreduce();\r\n-            xswap();\r\n-        }\r\n \r\n         // while any values remain on the stack\r\n         // keep XSWAPing and reducing, until there is nothing left.\r\n@@ -1983,7 +1980,7 @@ public class AbstractParser implements Serializable {\n             v1 = stk.pop();\r\n             v2 = stk.pop();\r\n \r\n-       //     System.out.print(\"reduce [\" + v2 + \" <\" + DebugTools.getOperatorName(operator) + \"> \" + v1 + \"]\");\r\n+            //     System.out.print(\"reduce [\" + v2 + \" <\" + DebugTools.getOperatorName(operator) + \"> \" + v1 + \"]\");\r\n \r\n             switch (operator) {\r\n                 case ADD:\r\n@@ -2112,7 +2109,7 @@ public class AbstractParser implements Serializable {\n             throw new CompileException(\"failed to subEval expression\", e);\r\n         }\r\n \r\n-    //    System.out.println(\" = \" + stk.peek());\r\n+//        System.out.println(\" = \" + stk.peek());\r\n \r\n     }\r\n \r\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\nindex 13a8672..6b97290 100644\n--- a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n@@ -2713,6 +2713,26 @@ public class CoreConfidenceTests extends AbstractTest {\n         assertEquals((int) val, result);\n     }\n \n+    public void testMath29() {\n+        String expression = \"10 + 20 / 4 / 4\";\n+        System.out.println(\"Expression: \" + expression);\n+        float val = 10f + 20f / 4f / 4f;\n+        \n+        assertEquals(val, MVEL.eval(expression));\n+    }\n+\n+    public void testMath30() {\n+        String expression = \"40 / 20 + 10 + 6 / 2\";\n+        float val = 40f / 20f + 10f + 6f / 2f;\n+        assertEquals((int) val, MVEL.eval(expression));\n+    }\n+\n+    public void testMath31() {\n+        String expression = \"40 / 20 + 5 - 4 + 8 / 2 * 2 * 6 ** 2 + 6 - 8\";\n+        double val = 40f / 20f + 5f - 4f + 8f / 2f * 2f * Math.pow(6, 2) + 6f - 8f;\n+        assertEquals((int) val, MVEL.eval(expression));\n+    }\n+\n     public void testNullSafe() {\n         Foo foo = new Foo();\n         foo.setBar(null);\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T16:37:55.296868Z", "commit_hash": "c2bb7bb0bf2ec9a5d3689592f9894b7a4a7390eb", "commit_message": "more fixes.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/MVELInterpretedRuntime.java b/src/main/java/org/mvel/MVELInterpretedRuntime.java\nindex 8b48e9d..c6ba1ea 100644\n--- a/src/main/java/org/mvel/MVELInterpretedRuntime.java\n+++ b/src/main/java/org/mvel/MVELInterpretedRuntime.java\n@@ -143,9 +143,6 @@ public class MVELInterpretedRuntime extends AbstractParser {\n                 stk.push(holdOverRegister);\n             }\n \n-//            while (stk.size() > 1) {\n-//                reduce();\n-//            }\n         }\n         catch (CompileException e) {\n             CompileException c = new CompileException(e.getMessage(), expr, cursor, e.getCursor() == 0, e);\ndiff --git a/src/main/java/org/mvel/ast/BinaryOperation.java b/src/main/java/org/mvel/ast/BinaryOperation.java\nindex 35ad8c3..b2c2605 100644\n--- a/src/main/java/org/mvel/ast/BinaryOperation.java\n+++ b/src/main/java/org/mvel/ast/BinaryOperation.java\n@@ -63,6 +63,13 @@ public class BinaryOperation extends ASTNode {\n         return right;\n     }\n \n+    public ASTNode getRightMost() {\n+        BinaryOperation n = this;\n+        while (n.right != null && n.right instanceof BinaryOperation) n = (BinaryOperation) n.right;\n+\n+        return n.right;\n+    }\n+\n     public BinaryOperation getRightBinary() {\n         return right != null && right instanceof BinaryOperation ? (BinaryOperation) right : null;\n     }\n@@ -71,6 +78,13 @@ public class BinaryOperation extends ASTNode {\n         this.right = right;\n     }\n \n+    public void setRightMost(ASTNode right) {\n+        BinaryOperation n = this;\n+        while (n.right != null && n.right instanceof BinaryOperation) n = (BinaryOperation) n.right;\n+\n+        n.right = right;\n+    }\n+\n     public int getPrecedence() {\n         return Operator.PTABLE[operation];\n     }\ndiff --git a/src/main/java/org/mvel/ast/Union.java b/src/main/java/org/mvel/ast/Union.java\nindex 74ec581..e96e251 100644\n--- a/src/main/java/org/mvel/ast/Union.java\n+++ b/src/main/java/org/mvel/ast/Union.java\n@@ -51,6 +51,6 @@ public class Union extends ASTNode {\n     }\n \n     public String toString() {\n-        return main.toString() + \"-[union]->\" + accessor.toString();\n+        return (main != null ? main.toString() : \"\") + \"-[union]->\" +  (accessor != null ? accessor.toString() : \"\");\n     }\n }\ndiff --git a/src/main/java/org/mvel/compiler/AbstractParser.java b/src/main/java/org/mvel/compiler/AbstractParser.java\nindex aa14f1e..876f370 100644\n--- a/src/main/java/org/mvel/compiler/AbstractParser.java\n+++ b/src/main/java/org/mvel/compiler/AbstractParser.java\n@@ -1790,12 +1790,12 @@ public class AbstractParser implements Serializable {\n         int operator2;\r\n \r\n         boolean x = false;\r\n+        int y = 0;\r\n \r\n         /**\r\n          * If the next token is an operator, we check to see if it has a higher\r\n          * precdence.\r\n          */\r\n-\r\n         if ((tk = nextToken()) != null && tk.isOperator()) {\r\n             if (isArithmeticOperator(operator2 = tk.getOperator()) && PTABLE[operator2] > PTABLE[operator]) {\r\n                 xswap();\r\n@@ -1814,31 +1814,44 @@ public class AbstractParser implements Serializable {\n                         /**\r\n                          * This operator is of higher precedence, or the same level precedence.  push to the RHS.\r\n                          */\r\n-\r\n                         dStack.push(operator = operator2, nextToken().getReducedValue(ctx, ctx, variableFactory));\r\n-               //         x = true;\r\n+\r\n+                        y++;\r\n                         continue;\r\n                     }\r\n                     else if (tk != null) {\r\n                         /**\r\n                          * The operator doesn't have higher precedence. Therfore reduce the LHS.\r\n                          */\r\n-\r\n                         if (!dStack.isEmpty()) {\r\n                             do {\r\n-                                dreduce();\r\n+                                if (y > 1) {\r\n+                                    dreduce2();\r\n+                                    y = 0;\r\n+                                }\r\n+                                else {\r\n+                                    dreduce();\r\n+                                }\r\n                             }\r\n-                            while (!dStack.isEmpty());\r\n+                            while (dStack.size() > 1);\r\n                         }\r\n \r\n-                        operator = tk.getOperator();\r\n+                        if (!dStack.isEmpty()) {\r\n+                            stk.push(dStack.pop());\r\n+                            xswap();\r\n+                        }\r\n \r\n-                        while (stk.size() != 1) {\r\n+                        operator = tk.getOperator();\r\n+                        // Reduce the lesser or equal precedence operations.\r\n+                        while (stk.size() != 1 && PTABLE[((Integer) stk.peek2())] >= PTABLE[operator]) {\r\n                             xswap();\r\n                             reduce();\r\n                         }\r\n                     }\r\n                     else {\r\n+                        /**\r\n+                         * There are no more tokens.\r\n+                         */\r\n                         x = false;\r\n \r\n                         if (dStack.size() > 1) {\r\n@@ -1857,6 +1870,7 @@ public class AbstractParser implements Serializable {\n                             xswap();\r\n                         }\r\n \r\n+                        y = 0;\r\n                         break;\r\n                     }\r\n \r\n@@ -1907,8 +1921,6 @@ public class AbstractParser implements Serializable {\n             reduce();\r\n             if (stk.size() > 1) xswap();\r\n         }\r\n-\r\n-\r\n     }\r\n \r\n     private void dreduce() {\r\n@@ -1923,12 +1935,26 @@ public class AbstractParser implements Serializable {\n     }\r\n \r\n     private void dreduce2() {\r\n-        Object o1 = dStack.pop(), o2 = dStack.pop();\r\n-        if (!dStack.isEmpty()) stk.push(dStack.pop());\r\n-        stk.push(o1);\r\n-        stk.push(o2);\r\n+        Object o1, o2;\r\n+        boolean x = false;\r\n \r\n-        reduce();\r\n+        do {\r\n+            if (x = !x) {\r\n+                o1 = dStack.pop();\r\n+                o2 = dStack.pop();\r\n+                if (!dStack.isEmpty()) stk.push(dStack.pop());\r\n+            }\r\n+            else {\r\n+                o2 = dStack.pop();\r\n+                o1 = dStack.pop();\r\n+            }\r\n+\r\n+            stk.push(o1);\r\n+            stk.push(o2);\r\n+\r\n+            reduce();\r\n+        }\r\n+        while (dStack.size() > 1);\r\n     }\r\n \r\n     /**\r\n@@ -1956,7 +1982,7 @@ public class AbstractParser implements Serializable {\n             v1 = stk.pop();\r\n             v2 = stk.pop();\r\n \r\n-         //   System.out.print(\"reduce [\" + v2 + \" <\" + DebugTools.getOperatorName(operator) + \"> \" + v1 + \"]\");\r\n+      //      System.out.print(\"reduce [\" + v2 + \" <\" + DebugTools.getOperatorName(operator) + \"> \" + v1 + \"]\");\r\n \r\n             switch (operator) {\r\n                 case ADD:\r\n@@ -2057,7 +2083,6 @@ public class AbstractParser implements Serializable {\n                     break;\r\n \r\n             }\r\n-            //      }\r\n         }\r\n         catch (ClassCastException e) {\r\n             if ((fields & ASTNode.LOOKAHEAD) == 0) {\r\n@@ -2086,7 +2111,7 @@ public class AbstractParser implements Serializable {\n             throw new CompileException(\"failed to subEval expression\", e);\r\n         }\r\n \r\n-  //     System.out.println(\" = \" + stk.peek());\r\n+ //       System.out.println(\" = \" + stk.peek());\r\n \r\n     }\r\n \r\ndiff --git a/src/main/java/org/mvel/util/CompilerTools.java b/src/main/java/org/mvel/util/CompilerTools.java\nindex 16dd0dc..db8fd80 100644\n--- a/src/main/java/org/mvel/util/CompilerTools.java\n+++ b/src/main/java/org/mvel/util/CompilerTools.java\n@@ -19,6 +19,7 @@\n package org.mvel.util;\n \n import org.mvel.Operator;\n+import org.mvel.debug.DebugTools;\n import static org.mvel.Operator.PTABLE;\n import org.mvel.compiler.CompiledExpression;\n import org.mvel.ast.*;\n@@ -72,7 +73,7 @@ public class CompilerTools {\n                     int op2;\n \n                     BinaryOperation bo = new BinaryOperation(op = tkOp.getOperator(), tk, astLinkedList.nextNode());\n-                    BinaryOperation first = bo;\n+                    //    BinaryOperation first = bo;\n \n                     tkOp2 = null;\n \n@@ -83,23 +84,25 @@ public class CompilerTools {\n                     while (astLinkedList.hasMoreNodes() && (tkOp2 = astLinkedList.nextNode()).isOperator()\n                             && tkOp2.getFields() != -1 && (op2 = tkOp2.getOperator()) < 12) {\n                         if (PTABLE[op2] > PTABLE[op]) {\n+               //             System.out.println(DebugTools.getOperatorName(op2) + \" >= \" + DebugTools.getOperatorName(op));\n+                 //           System.out.println(\"bo(old):\" + bo + \" >>\" + DebugTools.getOperatorName(bo.getOperation()));\n+                            bo.setRightMost(new BinaryOperation(op2, bo.getRightMost(), astLinkedList.nextNode()));\n+                //            System.out.println(\"bo(new):\" + bo + \" >>\");\n+                        }\n+                        else if (PTABLE[op2] == PTABLE[op]) {\n                             bo.setRight(new BinaryOperation(op2, bo.getRight(), astLinkedList.nextNode()));\n                         }\n                         else {\n+                            System.out.println(DebugTools.getOperatorName(op2) + \" < \" + DebugTools.getOperatorName(op));\n                             bo = new BinaryOperation(op2, bo, astLinkedList.nextNode());\n-\n-//                            if (astLinkedList.hasMoreNodes()) {\n-//                                tkOp2 = astLinkedList.nextNode();\n-//\n-//                            }\n-//\n                         }\n \n                         op = op2;\n                         tkOp = tkOp2;\n                     }\n \n-                    optimizedAst.addTokenNode(first);\n+                    optimizedAst.addTokenNode(bo);\n+              //      System.out.println(\"bo=\" + bo);\n \n                     if (tkOp2 != null && tkOp2 != tkOp) {\n                         optimizedAst.addTokenNode(tkOp2);\ndiff --git a/src/main/java/org/mvel/util/ExecutionStack.java b/src/main/java/org/mvel/util/ExecutionStack.java\nindex 3f99aac..8daf8ad 100644\n--- a/src/main/java/org/mvel/util/ExecutionStack.java\n+++ b/src/main/java/org/mvel/util/ExecutionStack.java\n@@ -67,6 +67,11 @@ public class ExecutionStack implements Stack {\n         else return element.value;\n     }\n \n+    public Object peek2() {\n+        if (size < 2) return null;\n+        return element.next.value;\n+    }\n+\n     public Object pop() {\n         if (size-- == 0) return null;\n         try {\n@@ -104,6 +109,9 @@ public class ExecutionStack implements Stack {\n \n     public String toString() {\n         StackElement el = element;\n+\n+        if (element == null) return \"<EMPTY>\";\n+\n         StringAppender appender = new StringAppender();\n         appender.append(\"[\");\n         do {\ndiff --git a/src/main/java/org/mvel/util/FastExecutionStack.java b/src/main/java/org/mvel/util/FastExecutionStack.java\ndeleted file mode 100644\nindex 213c87d..0000000\n--- a/src/main/java/org/mvel/util/FastExecutionStack.java\n+++ /dev/null\n@@ -1,77 +0,0 @@\n-/**\n- * MVEL (The MVFLEX Expression Language)\n- *\n- * Copyright (C) 2007 Christopher Brock, MVFLEX/Valhalla Project and the Codehaus\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- */\n-package org.mvel.util;\n-\n-public class FastExecutionStack implements Stack {\n-    private final Object[] stack = new Object[15];\n-    private int size = 0;\n-\n-    public boolean isEmpty() {\n-        return size == 0;\n-    }\n-\n-    public Object peek() {\n-        return stack[size];\n-    }\n-\n-    public void push(Object obj) {\n-        stack[++size] = obj;\n-    }\n-\n-    public void add(Object obj) {\n-        throw new RuntimeException(\"add operation not supported with FastExecutionStack\");\n-    }\n-\n-    public Object pushAndPeek(Object obj) {\n-        return stack[++size] = obj;\n-    }\n-\n-    public void push(Object obj1, Object obj2) {\n-        System.out.println(\"PUSH <<\" + obj1 + \">>\");\n-        System.out.println(\"PUSH <<\" + obj2 + \">>\");\n-        stack[++size] = obj1;\n-        stack[++size] = obj2;\n-    }\n-\n-    public void push(Object obj1, Object obj2, Object obj3) {\n-        stack[++size] = obj1;\n-        stack[++size] = obj2;\n-        stack[++size] = obj3;\n-    }\n-\n-    public Object pop() {\n-        return stack[size--];\n-    }\n-\n-    public void discard() {\n-        --size;\n-    }\n-\n-    public void clear() {\n-        size = 0;\n-    }\n-\n-    public int size() {\n-        return size;\n-    }\n-\n-    public void showStack() {\n-\n-    }\n-}\ndiff --git a/src/main/java/org/mvel/util/Stack.java b/src/main/java/org/mvel/util/Stack.java\nindex 87f8dff..495d442 100644\n--- a/src/main/java/org/mvel/util/Stack.java\n+++ b/src/main/java/org/mvel/util/Stack.java\n@@ -25,6 +25,8 @@ public interface Stack extends Serializable {\n \n     public Object peek();\n \n+    public Object peek2();\n+\n     public void add(Object obj);\n \n     public void push(Object obj);\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\nindex 27a75cb..9b2c5c0 100644\n--- a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n@@ -2688,11 +2688,21 @@ public class CoreConfidenceTests extends AbstractTest {\n     }\n \n     public void testMath26() {\n-        String expression = \"5 + 3 * 8 * 2 ** 5\";\n-        double val = 5 + 3 * 2 * Math.pow(8, 5);\n+        String expression = \"5 + 3 * 8 * 2 ** 2\";\n+        double val =  5 + 3 * 8 * Math.pow(2, 2);\n         System.out.println(\"Expression: \" + expression);\n         System.out.println(\"Expected Result: \" + val);\n-        assertEquals(val, MVEL.eval(expression));\n+        Object result = MVEL.eval(expression);\n+        assertEquals((int) val, result);\n+    }\n+\n+    public void testMath27() {\n+        String expression = \"50 + 30 * 80 * 20 ** 3 * 51\";\n+        double val =  50 + 30 * 80 * Math.pow(20, 3) * 51;\n+        System.out.println(\"Expression: \" + expression);\n+        System.out.println(\"Expected Result: \" + val);\n+        Object result = MVEL.eval(expression);\n+        assertEquals((int) val, result);\n     }\n \n     public void testNullSafe() {\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T16:43:06.669545Z", "commit_hash": "71f355c570cadb500f318cab5fab592b334e5ef4", "commit_message": "possible fixes.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/compiler/AbstractParser.java b/src/main/java/org/mvel/compiler/AbstractParser.java\nindex 12d2884..aa14f1e 100644\n--- a/src/main/java/org/mvel/compiler/AbstractParser.java\n+++ b/src/main/java/org/mvel/compiler/AbstractParser.java\n@@ -1812,11 +1812,11 @@ public class AbstractParser implements Serializable {\n \r\n                         if (x) xswap();\r\n                         /**\r\n-                         * This operator has even higher precedence.  push to the RHS.\r\n+                         * This operator is of higher precedence, or the same level precedence.  push to the RHS.\r\n                          */\r\n \r\n                         dStack.push(operator = operator2, nextToken().getReducedValue(ctx, ctx, variableFactory));\r\n-                        x = true;\r\n+               //         x = true;\r\n                         continue;\r\n                     }\r\n                     else if (tk != null) {\r\n@@ -1825,27 +1825,28 @@ public class AbstractParser implements Serializable {\n                          */\r\n \r\n                         if (!dStack.isEmpty()) {\r\n-                            while (!dStack.isEmpty()) {\r\n+                            do {\r\n                                 dreduce();\r\n                             }\r\n-                        }\r\n-                        else {\r\n-                            reduce();\r\n+                            while (!dStack.isEmpty());\r\n                         }\r\n \r\n                         operator = tk.getOperator();\r\n \r\n-                        while (stk.size() > 1) {\r\n+                        while (stk.size() != 1) {\r\n                             xswap();\r\n                             reduce();\r\n                         }\r\n                     }\r\n                     else {\r\n-                        System.out.println(\"\");\r\n-\r\n                         x = false;\r\n-                        while (dStack.size() > 1) {\r\n-                            dreduce2();\r\n+\r\n+                        if (dStack.size() > 1) {\r\n+                            do {\r\n+                                dreduce2();\r\n+                            }\r\n+                            while (dStack.size() > 1);\r\n+\r\n                             x = true;\r\n                         }\r\n \r\n@@ -1863,20 +1864,6 @@ public class AbstractParser implements Serializable {\n                     if (tk != null && (tk = nextToken()) != null) {\r\n                         stk.push(tk.getReducedValue(ctx, ctx, variableFactory), operator);\r\n                     }\r\n-                    else {\r\n-                        while (dStack.size() > 1) {\r\n-                            dreduce2();\r\n-                        }\r\n-\r\n-                        if (!dStack.isEmpty()) {\r\n-                            stk.push(dStack.pop());\r\n-                        }\r\n-                        else if (!x) xswap();\r\n-\r\n-                        // nothing more to do.\r\n-                        break;\r\n-                    }\r\n-\r\n \r\n                     x = true;\r\n                 }\r\n@@ -1925,9 +1912,6 @@ public class AbstractParser implements Serializable {\n     }\r\n \r\n     private void dreduce() {\r\n-        // load the lesser precedent operator off the top of the stack\r\n-        //     Object o1 = stk.pop();\r\n-\r\n         // push the right value from the dStack onto the stack\r\n         stk.push(dStack.pop());\r\n \r\n@@ -1947,55 +1931,6 @@ public class AbstractParser implements Serializable {\n         reduce();\r\n     }\r\n \r\n-\r\n-    private void leftReduce() {\r\n-        stk.showStack();\r\n-        // while any values remain on the stack\r\n-        // keep XSWAPing and reducing, until there is nothing left.\r\n-        while (stk.size() > 1) {\r\n-            xswap();\r\n-            reduce();\r\n-            if (stk.size() > 3) xxswap();\r\n-        }\r\n-    }\r\n-\r\n-    private void xxswap() {\r\n-        Object o1 = stk.pop();\r\n-        Object o2 = stk.pop();\r\n-        xswap();\r\n-        stk.push(o2, o1);\r\n-    }\r\n-\r\n-    /**\r\n-     * A more efficient RHS reduction, to avoid the need\r\n-     * to XSWAP directly on the stack.\r\n-     */\r\n-    private void reduceRightXSwap() {\r\n-        Object o = stk.pop();\r\n-        Object o2 = stk.pop();\r\n-\r\n-        stk.push(o);\r\n-        stk.push(o2);\r\n-        stk.push(dStack.pop());\r\n-        stk.push(dStack.pop());\r\n-        reduce();\r\n-    }\r\n-\r\n-    /**\r\n-     * Same as reduceRightXSwap, except this is an inverted\r\n-     * operator, or XXSWAP.\r\n-     */\r\n-    private void reduceRightXXSwap() {\r\n-        Object o = stk.pop();\r\n-        Object o2 = stk.pop();\r\n-\r\n-        stk.push(o2);\r\n-        stk.push(o);\r\n-        stk.push(dStack.pop());\r\n-        stk.push(dStack.pop());\r\n-        reduce();\r\n-    }\r\n-\r\n     /**\r\n      * XSWAP.\r\n      */\r\n@@ -2021,7 +1956,7 @@ public class AbstractParser implements Serializable {\n             v1 = stk.pop();\r\n             v2 = stk.pop();\r\n \r\n-            System.out.print(\"reduce [\" + v2 + \" <\" + DebugTools.getOperatorName(operator) + \"> \" + v1 + \"]\");\r\n+         //   System.out.print(\"reduce [\" + v2 + \" <\" + DebugTools.getOperatorName(operator) + \"> \" + v1 + \"]\");\r\n \r\n             switch (operator) {\r\n                 case ADD:\r\n@@ -2151,7 +2086,7 @@ public class AbstractParser implements Serializable {\n             throw new CompileException(\"failed to subEval expression\", e);\r\n         }\r\n \r\n-        System.out.println(\" = \" + stk.peek());\r\n+  //     System.out.println(\" = \" + stk.peek());\r\n \r\n     }\r\n \r\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\nindex 2b3b901..8625db6 100644\n--- a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n@@ -2606,64 +2606,80 @@ public class CoreConfidenceTests extends AbstractTest {\n         assertEquals(10, test(\"xStr = new String[5][10]; xStr[4][0] = 'foo'; xStr[4].length\"));\n     }\n \n-    public void testHigherOrderMathTest() {\n+    public void testMath14() {\n         assertEquals(10 - 5 * 2 + 5 * 8 - 4, test(\"10-5*2 + 5*8-4\"));\n     }\n \n-    public void testHigherOrderMathTest2() {\n+    public void testMath15() {\n         String ex = \"100-500*200 + 500*800-400\";\n         //   System.out.println(\"Expression: \" + ex);\n \n         assertEquals(100 - 500 * 200 + 500 * 800 - 400, test(ex));\n     }\n \n-    public void testHigherOrderMathTest3() {\n+    public void testMath16() {\n         String ex = \"100-500*200*150 + 500*800-400\";\n         assertEquals(100-500*200*150 + 500*800-400, MVEL.eval(ex));\n     }\n \n-    public void testHigherOrderMathTest4() {\n+    public void testMath17() {\n         String ex = \"(100 * 50) * 20 / 30 * 2\";\n         //    System.out.println(\"Expression: \" + ex);\n         assertEquals((100d * 50d) * 20d / 30d * 2d, test(ex));\n     }\n \n-    public void testHigherOrderMathTest5() {\n+    public void testMath18() {\n         String ex = \"a = 100; b = 50; c = 20; d = 30; e = 2; (a * b) * c / d * e\";\n         System.out.println(\"Expression: \" + ex);\n         assertEquals((100d * 50d) * 20d / 30d * 2d, testCompiledSimple(ex, new HashMap()));\n     }\n \n-    public void testHigherOrderMathTest6() {\n+    public void testMath19() {\n         String ex = \"a = 100; b = 500; c = 200; d = 150; e = 500; f = 800; g = 400; a-b*c*d + e*f-g\";\n         System.out.println(\"Expression: \" + ex);\n         assertEquals(100 - 500 * 200 * 150 + 500 * 800 - 400, testCompiledSimple(ex, new HashMap()));\n     }\n \n-    public void testHigherOrderMathTest7() {\n+    public void testMath20() {\n         String ex = \"10-5*7-3*8-6\";\n         System.out.println(\"Expression: \" + ex);\n         assertEquals(10 - 5 * 7 - 3 * 8 - 6, MVEL.eval(ex));\n     }\n \n-    public void testMath11() {\n+    public void testMath21() {\n         String expression = \"100-50*70-30*80-60\";\n         System.out.println(\"Expression: \" + expression);\n         assertEquals(100 - 50 * 70 - 30 * 80 - 60, MVEL.eval(expression));\n     }\n \n-    public void testMath12() {\n+    public void testMath22() {\n         String expression = \"(100-50)*70-30*(20-9)**3\";\n         System.out.println(\"Expression: \" + expression);\n         assertEquals((int) ((100-50)*70-30*Math.pow(20-9, 3)), MVEL.eval(expression));\n     }\n \n-    public void testMath13() {\n+    public void testMath23() {\n         String expression = \"10 ** (3)*10**3\";\n         System.out.println(\"Expression: \" + expression);\n         assertEquals((int) (Math.pow(10, 3) * Math.pow(10, 3)), MVEL.eval(expression));\n     }\n \n+    public void testMath24() {\n+        String expression = \"51 * 52 * 33 / 24 / 15 + 45 * 66 * 47 * 28 + 19\";\n+        float val = 51 * 52 * 33 / 24 / 15 + 45 * 66 * 47 * 28 + 19;\n+        System.out.println(\"Expression: \" + expression);\n+        System.out.println(\"Expected Result: \" + val);\n+        assertEquals(val, MVEL.eval(expression));\n+    }\n+\n+    public void testMath25() {\n+        String expression = \"51 * (4 - 100 * 5) + 10 + 5 * 2 / 1 + 0 + 0 - 80\";\n+        int val = 51 * (4 - 100 * 5) + 10 + 5 * 2 / 1 + 0 + 0 - 80;\n+        System.out.println(\"Expression: \" + expression);\n+        System.out.println(\"Expected Result: \" + val);\n+        assertEquals(val, MVEL.eval(expression));\n+    }\n+\n     public void testNullSafe() {\n         Foo foo = new Foo();\n         foo.setBar(null);\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T16:48:13.399764Z", "commit_hash": "09c2966c8d4ec706dac7d4a9441bfe4af0c6ab01", "commit_message": "possible fixes.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/MVELInterpretedRuntime.java b/src/main/java/org/mvel/MVELInterpretedRuntime.java\nindex d8c783b..8b48e9d 100644\n--- a/src/main/java/org/mvel/MVELInterpretedRuntime.java\n+++ b/src/main/java/org/mvel/MVELInterpretedRuntime.java\n@@ -87,7 +87,6 @@ public class MVELInterpretedRuntime extends AbstractParser {\n     private void parseAndExecuteInterpreted() {\n         ASTNode tk = null;\n         int operator;\n-        //   Object holdOverRegister = null;\n \n         lastWasIdentifier = false;\n \n@@ -111,7 +110,7 @@ public class MVELInterpretedRuntime extends AbstractParser {\n                      * proper execution order.\n                      */\n                     if (tk instanceof Substatement) {\n-                        reduceRight();\n+                        //          reduceRight();\n \n                         if ((tk = nextToken()) != null) {\n                             if (isArithmeticOperator(operator = tk.getOperator())) {\n@@ -126,14 +125,6 @@ public class MVELInterpretedRuntime extends AbstractParser {\n                     }\n                 }\n \n-//                if (!tk.isOperator()) {\n-//                    /**\n-//                     * There is no operator following the previous token, which means this either a naked identifier\n-//                     * or method call, etc.\n-//                     */\n-//                    continue;\n-//                }\n-\n                 switch (procBooleanOperator(operator = tk.getOperator())) {\n                     case -1:\n                         return;\n@@ -152,11 +143,9 @@ public class MVELInterpretedRuntime extends AbstractParser {\n                 stk.push(holdOverRegister);\n             }\n \n-            if (dStack != null) {\n-                while (!dStack.isEmpty()) {\n-                    reduceRight();\n-                }\n-            }\n+//            while (stk.size() > 1) {\n+//                reduce();\n+//            }\n         }\n         catch (CompileException e) {\n             CompileException c = new CompileException(e.getMessage(), expr, cursor, e.getCursor() == 0, e);\n@@ -167,7 +156,7 @@ public class MVELInterpretedRuntime extends AbstractParser {\n         catch (NullPointerException e) {\n             if (tk != null && tk.isOperator() && cursor >= length) {\n                 throw new CompileException(\"incomplete statement: \"\n-                        + tk.getName() + \" (possible use of reserved keyword as identifier: \" + tk.getName() + \")\");\n+                        + tk.getName() + \" (possible use of reserved keyword as identifier: \" + tk.getName() + \")\", e);\n             }\n             else {\n                 throw e;\ndiff --git a/src/main/java/org/mvel/compiler/AbstractParser.java b/src/main/java/org/mvel/compiler/AbstractParser.java\nindex 65f1369..12d2884 100644\n--- a/src/main/java/org/mvel/compiler/AbstractParser.java\n+++ b/src/main/java/org/mvel/compiler/AbstractParser.java\n@@ -19,6 +19,7 @@\n package org.mvel.compiler;\r\n \r\n import org.mvel.*;\r\n+import org.mvel.debug.DebugTools;\r\n import static org.mvel.Operator.*;\r\n import org.mvel.ast.*;\r\n import org.mvel.integration.VariableResolverFactory;\r\n@@ -1785,7 +1786,7 @@ public class AbstractParser implements Serializable {\n     }\r\n \r\n     protected void arithmeticFunctionReduction(int operator) {\r\n-        ASTNode tk2;\r\n+        ASTNode tk;\r\n         int operator2;\r\n \r\n         boolean x = false;\r\n@@ -1795,43 +1796,104 @@ public class AbstractParser implements Serializable {\n          * precdence.\r\n          */\r\n \r\n-        if ((tk2 = nextToken()) != null && tk2.isOperator()) {\r\n-            if (isArithmeticOperator(operator2 = tk2.getOperator()) && PTABLE[operator2] > PTABLE[operator]) {\r\n-                do {\r\n-                    dStack.push(tk2.getOperator(), nextToken().getReducedValue(ctx, ctx, variableFactory));\r\n-                    if (x = !x)\r\n-                        reduceRightXSwap(); // reduce from the RHS and XSWAP\r\n-                    else\r\n-                        reduceRightXXSwap(); // reduce from the RHS and XXSWAP\r\n-                }\r\n-                while (((tk2 = nextToken()) != null && tk2.isOperator()\r\n-                        && isArithmeticOperator(operator2 = tk2.getOperator())\r\n-                        && (PTABLE[operator2] > PTABLE[operator])));\r\n+        if ((tk = nextToken()) != null && tk.isOperator()) {\r\n+            if (isArithmeticOperator(operator2 = tk.getOperator()) && PTABLE[operator2] > PTABLE[operator]) {\r\n+                xswap();\r\n+                /**\r\n+                 * The current arith. operator is of higher precedence the last.\r\n+                 */\r\n+                dStack.push(operator = operator2, nextToken().getReducedValue(ctx, ctx, variableFactory));\r\n+\r\n+                while (true) {\r\n+                    // look ahead again\r\n+                    if ((tk = nextToken()) != null\r\n+                            && tk.isOperator()\r\n+                            && PTABLE[operator2 = tk.getOperator()] >= PTABLE[operator]) {\r\n+\r\n+                        if (x) xswap();\r\n+                        /**\r\n+                         * This operator has even higher precedence.  push to the RHS.\r\n+                         */\r\n+\r\n+                        dStack.push(operator = operator2, nextToken().getReducedValue(ctx, ctx, variableFactory));\r\n+                        x = true;\r\n+                        continue;\r\n+                    }\r\n+                    else if (tk != null) {\r\n+                        /**\r\n+                         * The operator doesn't have higher precedence. Therfore reduce the LHS.\r\n+                         */\r\n+\r\n+                        if (!dStack.isEmpty()) {\r\n+                            while (!dStack.isEmpty()) {\r\n+                                dreduce();\r\n+                            }\r\n+                        }\r\n+                        else {\r\n+                            reduce();\r\n+                        }\r\n \r\n-                xswap(); // XSWAP the stack.\r\n-                reduce(); // reduce the stack.\r\n+                        operator = tk.getOperator();\r\n+\r\n+                        while (stk.size() > 1) {\r\n+                            xswap();\r\n+                            reduce();\r\n+                        }\r\n+                    }\r\n+                    else {\r\n+                        System.out.println(\"\");\r\n \r\n-                // Record the current operator value to the stack.\r\n-                if (tk2 != null) stk.push(operator2);\r\n+                        x = false;\r\n+                        while (dStack.size() > 1) {\r\n+                            dreduce2();\r\n+                            x = true;\r\n+                        }\r\n \r\n-                // Evaluate the next token and push the value to the stack.\r\n-                if ((tk2 = nextToken()) != null) {\r\n-                    stk.push(tk2.getReducedValue(ctx, ctx, variableFactory));\r\n+                        if (!dStack.isEmpty()) {\r\n+                            stk.push(dStack.pop());\r\n+                        }\r\n+                        else if (x) {\r\n+                            xswap();\r\n+                        }\r\n+\r\n+                        break;\r\n+                    }\r\n+\r\n+\r\n+                    if (tk != null && (tk = nextToken()) != null) {\r\n+                        stk.push(tk.getReducedValue(ctx, ctx, variableFactory), operator);\r\n+                    }\r\n+                    else {\r\n+                        while (dStack.size() > 1) {\r\n+                            dreduce2();\r\n+                        }\r\n+\r\n+                        if (!dStack.isEmpty()) {\r\n+                            stk.push(dStack.pop());\r\n+                        }\r\n+                        else if (!x) xswap();\r\n+\r\n+                        // nothing more to do.\r\n+                        break;\r\n+                    }\r\n+\r\n+\r\n+                    x = true;\r\n                 }\r\n             }\r\n             else {\r\n                 reduce();\r\n-                splitAccumulator.push(tk2);\r\n+                splitAccumulator.push(tk);\r\n             }\r\n         }\r\n-        else if (tk2 != null) {\r\n+        else if (tk != null) {\r\n             reduce();  // reduce the stack.\r\n-            operator = tk2.getOperator();\r\n+            operator = tk.getOperator();\r\n \r\n             // if there is another token, then this statement must continue\r\n             // push the values down and reduce.\r\n-            if ((tk2 = nextToken()) != null) {\r\n-                stk.push(tk2.getReducedValue(ctx, ctx, variableFactory), operator);\r\n+            if ((tk = nextToken()) != null) {\r\n+                stk.push(tk.getReducedValue(ctx, ctx, variableFactory), operator);\r\n                 reduce();\r\n             }\r\n \r\n@@ -1846,19 +1908,64 @@ public class AbstractParser implements Serializable {\n              * Push tk2 back into the accumulator.\r\n              */\r\n         }\r\n-        else {\r\n+\r\n+        if (!dStack.isEmpty()) {\r\n+            while (!dStack.isEmpty()) dreduce();\r\n+            xswap();\r\n+        }\r\n+\r\n+        // while any values remain on the stack\r\n+        // keep XSWAPing and reducing, until there is nothing left.\r\n+        while (stk.size() > 1) {\r\n             reduce();\r\n+            if (stk.size() > 1) xswap();\r\n+        }\r\n \r\n-            // while any values remain on the stack\r\n-            // keep XSWAPing and reducing, until there is nothing left.\r\n-            while (stk.size() > 1) {\r\n-                xswap();\r\n-                reduce();\r\n-            }\r\n \r\n+    }\r\n+\r\n+    private void dreduce() {\r\n+        // load the lesser precedent operator off the top of the stack\r\n+        //     Object o1 = stk.pop();\r\n+\r\n+        // push the right value from the dStack onto the stack\r\n+        stk.push(dStack.pop());\r\n+\r\n+        // push the higher precedent operator to the top of the stack\r\n+        stk.push(dStack.pop());\r\n+\r\n+        // reduce the top of the stack\r\n+        reduce();\r\n+    }\r\n+\r\n+    private void dreduce2() {\r\n+        Object o1 = dStack.pop(), o2 = dStack.pop();\r\n+        if (!dStack.isEmpty()) stk.push(dStack.pop());\r\n+        stk.push(o1);\r\n+        stk.push(o2);\r\n+\r\n+        reduce();\r\n+    }\r\n+\r\n+\r\n+    private void leftReduce() {\r\n+        stk.showStack();\r\n+        // while any values remain on the stack\r\n+        // keep XSWAPing and reducing, until there is nothing left.\r\n+        while (stk.size() > 1) {\r\n+            xswap();\r\n+            reduce();\r\n+            if (stk.size() > 3) xxswap();\r\n         }\r\n     }\r\n \r\n+    private void xxswap() {\r\n+        Object o1 = stk.pop();\r\n+        Object o2 = stk.pop();\r\n+        xswap();\r\n+        stk.push(o2, o1);\r\n+    }\r\n+\r\n     /**\r\n      * A more efficient RHS reduction, to avoid the need\r\n      * to XSWAP directly on the stack.\r\n@@ -1868,9 +1975,9 @@ public class AbstractParser implements Serializable {\n         Object o2 = stk.pop();\r\n \r\n         stk.push(o);\r\n-        stk.push(dStack.pop());\r\n         stk.push(o2);\r\n         stk.push(dStack.pop());\r\n+        stk.push(dStack.pop());\r\n         reduce();\r\n     }\r\n \r\n@@ -1883,9 +1990,9 @@ public class AbstractParser implements Serializable {\n         Object o2 = stk.pop();\r\n \r\n         stk.push(o2);\r\n-        stk.push(dStack.pop());\r\n         stk.push(o);\r\n         stk.push(dStack.pop());\r\n+        stk.push(dStack.pop());\r\n         reduce();\r\n     }\r\n \r\n@@ -1909,11 +2016,12 @@ public class AbstractParser implements Serializable {\n         Object v1 = null, v2 = null;\r\n         Integer operator;\r\n         try {\r\n+\r\n             operator = (Integer) stk.pop();\r\n             v1 = stk.pop();\r\n             v2 = stk.pop();\r\n \r\n-            //      System.out.println(\"reduce [\" + v2 + \" <\" + DebugTools.getOperatorName(operator) + \"> \" + v1 + \"]\");\r\n+            System.out.print(\"reduce [\" + v2 + \" <\" + DebugTools.getOperatorName(operator) + \"> \" + v1 + \"]\");\r\n \r\n             switch (operator) {\r\n                 case ADD:\r\n@@ -2043,6 +2151,8 @@ public class AbstractParser implements Serializable {\n             throw new CompileException(\"failed to subEval expression\", e);\r\n         }\r\n \r\n+        System.out.println(\" = \" + stk.peek());\r\n+\r\n     }\r\n \r\n     private static int asInt(final Object o) {\r\ndiff --git a/src/main/java/org/mvel/math/IEEEFloatingPointMath.java b/src/main/java/org/mvel/math/IEEEFloatingPointMath.java\nindex df3a076..e10de0d 100644\n--- a/src/main/java/org/mvel/math/IEEEFloatingPointMath.java\n+++ b/src/main/java/org/mvel/math/IEEEFloatingPointMath.java\n@@ -203,7 +203,8 @@ public class IEEEFloatingPointMath implements MathProcessor {\n                     case DIV:\r\n                         return new BigDecimal((Integer) val1).divide(new BigDecimal((Integer) val2), MATH_CONTEXT);\r\n                     case MULT:\r\n-                        return ((Integer) val1) * ((Integer) val2);\r\n+                      //  return ((Integer) val1) * ((Integer) val2);\r\n+                        return new BigDecimal((Integer) val1).multiply(new BigDecimal((Integer) val2), MATH_CONTEXT);\r\n                     case POWER:\r\n                         double d = Math.pow((Integer) val1, (Integer) val2);\r\n                         if (d > Integer.MAX_VALUE) return d;\r\ndiff --git a/src/main/java/org/mvel/util/ExecutionStack.java b/src/main/java/org/mvel/util/ExecutionStack.java\nindex a375036..3f99aac 100644\n--- a/src/main/java/org/mvel/util/ExecutionStack.java\n+++ b/src/main/java/org/mvel/util/ExecutionStack.java\n@@ -101,4 +101,19 @@ public class ExecutionStack implements Stack {\n         }\n         while ((el = el.next) != null);\n     }\n+\n+    public String toString() {\n+        StackElement el = element;\n+        StringAppender appender = new StringAppender();\n+        appender.append(\"[\");\n+        do {\n+            appender.append(String.valueOf(el.value));\n+            if (el.next != null) appender.append(\", \");\n+        } while ((el = el.next) != null);\n+\n+        appender.append(\"]\");\n+\n+        return appender.toString();\n+    }\n+\n }\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\nindex 30268be..2b3b901 100644\n--- a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n@@ -149,10 +149,22 @@ public class CoreConfidenceTests extends AbstractTest {\n         assertEquals(val, test(\"(100 % 3) * 2 - 1 / 1 + 8 + (5 * 2)\"));\n     }\n \n+    public void testMath4a() {\n+        String expression = \"(100 % 90) * 20 - 15 / 16 + 80 + (50 * 21)\";\n+        System.out.println(\"Expression: \" + expression);\n+        assertEquals((float) ((100d % 90d) * 20d - 15d / 16d + 80d + (50d * 21d)), MVEL.eval(expression));\n+    }\n+\n     public void testMath5() {\n         assertEquals(300.5 / 5.3 / 2.1 / 1.5, test(\"300.5 / 5.3 / 2.1 / 1.5\"));\n     }\n \n+    public void testMath5a() {\n+        String expression = \"300.5 / 5.3 / 2.1 / 1.5\";\n+        System.out.println(\"Expression: \" + expression);\n+        assertEquals(300.5 / 5.3 / 2.1 / 1.5, MVEL.eval(expression));\n+    }\n+\n     public void testMath6() {\n         int val = (300 * 5 + 1) + 100 / 2 * 2;\n         assertEquals(val, test(\"(300 * five + 1) + (100 / 2 * 2)\"));\n@@ -2607,7 +2619,7 @@ public class CoreConfidenceTests extends AbstractTest {\n \n     public void testHigherOrderMathTest3() {\n         String ex = \"100-500*200*150 + 500*800-400\";\n-        assertEquals(100 - 500 * 200 * 150 + 500 * 800 - 400, test(ex));\n+        assertEquals(100-500*200*150 + 500*800-400, MVEL.eval(ex));\n     }\n \n     public void testHigherOrderMathTest4() {\n@@ -2628,6 +2640,29 @@ public class CoreConfidenceTests extends AbstractTest {\n         assertEquals(100 - 500 * 200 * 150 + 500 * 800 - 400, testCompiledSimple(ex, new HashMap()));\n     }\n \n+    public void testHigherOrderMathTest7() {\n+        String ex = \"10-5*7-3*8-6\";\n+        System.out.println(\"Expression: \" + ex);\n+        assertEquals(10 - 5 * 7 - 3 * 8 - 6, MVEL.eval(ex));\n+    }\n+\n+    public void testMath11() {\n+        String expression = \"100-50*70-30*80-60\";\n+        System.out.println(\"Expression: \" + expression);\n+        assertEquals(100 - 50 * 70 - 30 * 80 - 60, MVEL.eval(expression));\n+    }\n+\n+    public void testMath12() {\n+        String expression = \"(100-50)*70-30*(20-9)**3\";\n+        System.out.println(\"Expression: \" + expression);\n+        assertEquals((int) ((100-50)*70-30*Math.pow(20-9, 3)), MVEL.eval(expression));\n+    }\n+\n+    public void testMath13() {\n+        String expression = \"10 ** (3)*10**3\";\n+        System.out.println(\"Expression: \" + expression);\n+        assertEquals((int) (Math.pow(10, 3) * Math.pow(10, 3)), MVEL.eval(expression));\n+    }\n \n     public void testNullSafe() {\n         Foo foo = new Foo();\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T17:05:57.594712Z", "commit_hash": "df9eb5253ca7e7fd0cddce71fd2d2e2cc2f43bde", "commit_message": "prototype fix 2\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/MVELInterpretedRuntime.java b/src/main/java/org/mvel/MVELInterpretedRuntime.java\nindex 84dcf42..9f80bde 100644\n--- a/src/main/java/org/mvel/MVELInterpretedRuntime.java\n+++ b/src/main/java/org/mvel/MVELInterpretedRuntime.java\n@@ -51,15 +51,13 @@ public class MVELInterpretedRuntime extends AbstractParser {\n     private Object ctx;\n     private VariableResolverFactory variableFactory;\n \n-    private ExecutionStack dStack;\n-    private int lastOp;\n-\n     Object parse() {\n         setThreadAccessorOptimizer(ReflectiveAccessorOptimizer.class);\n         debugSymbols = false;\n \n         try {\n             stk = new ExecutionStack();\n+            dStack = new ExecutionStack();\n \n             cursor = 0;\n \n@@ -96,8 +94,8 @@ public class MVELInterpretedRuntime extends AbstractParser {\n      * Main interpreter loop.\n      */\n     private void parseAndExecuteInterpreted() {\n-        ASTNode tk = null, tk2;\n-        int operator, operator2;\n+        ASTNode tk = null;\n+        int operator;\n         Object holdOverRegister = null;\n \n         lastWasIdentifier = false;\n@@ -122,12 +120,12 @@ public class MVELInterpretedRuntime extends AbstractParser {\n                      * proper execution order.\n                      */\n                     if (tk instanceof Substatement) {\n-                        procDStack();\n+                        reduceRight();\n \n                         if ((tk = nextToken()) != null) {\n-                            if (isStandardMathOperator(tk.getOperator())) {\n-                                if (dStack == null) dStack = new ExecutionStack();\n-                                dStack.push(tk.getOperator(), stk.pop());\n+                            if (isArithmeticOperator(operator = tk.getOperator())) {\n+                                stk.push(nextToken().getReducedValue(ctx, ctx, variableFactory), operator);\n+                                arithmeticFunctionReduction(operator);\n                                 continue;\n                             }\n                         }\n@@ -147,7 +145,7 @@ public class MVELInterpretedRuntime extends AbstractParser {\n \n                 switch (operator = tk.getOperator()) {\n                     case AND:\n-                        procDStack();\n+                        reduceRight();\n \n                         if (stk.peek() instanceof Boolean && !((Boolean) stk.peek())) {\n                             if (unwindStatement(operator)) {\n@@ -164,7 +162,7 @@ public class MVELInterpretedRuntime extends AbstractParser {\n                         }\n \n                     case OR:\n-                        procDStack();\n+                        reduceRight();\n \n                         if (stk.peek() instanceof Boolean && ((Boolean) stk.peek())) {\n                             if (unwindStatement(operator)) {\n@@ -215,32 +213,8 @@ public class MVELInterpretedRuntime extends AbstractParser {\n \n                 }\n \n-                stk.push(nextToken().getReducedValue(ctx, ctx, variableFactory));\n-\n-                if ((tk2 = nextToken()) != null && tk2.isOperator()\n-                        && isStandardMathOperator(operator2 = tk2.getOperator())\n-                        && (operator2 > operator)) {\n-                    if (dStack == null) dStack = new ExecutionStack();\n-                    dStack.push(tk2.getOperator(), nextToken().getReducedValue(ctx, ctx, variableFactory));\n-                    procDStack();\n-\n-                    stk.push(operator);\n-                    reduce();\n-                }\n-                else if (tk2 != null) {\n-                    stk.push(operator);\n-                    reduce();\n-\n-                    /**\n-                     * Push tk2 back into the accumulator.\n-                     */\n-                    splitAccumulator.push(tk2);\n-                }\n-                else {\n-                    stk.push(operator);\n-                    reduce();\n-                }\n-\n+                stk.push(nextToken().getReducedValue(ctx, ctx, variableFactory), operator);\n+                arithmeticFunctionReduction(operator);\n                 // Don't remove the \"stk.push(operator); ruduce();\" code duplication.\n                 // It results in 3 GOTO instructions in the bytecode vs. one.\n             }\n@@ -251,7 +225,7 @@ public class MVELInterpretedRuntime extends AbstractParser {\n \n             if (dStack != null) {\n                 while (!dStack.isEmpty()) {\n-                    procDStack();\n+                    reduceRight();\n                 }\n             }\n         }\n@@ -272,30 +246,122 @@ public class MVELInterpretedRuntime extends AbstractParser {\n         }\n     }\n \n-    private static boolean isStandardMathOperator(int operator) {\n+    private static boolean isArithmeticOperator(int operator) {\n         //  return operator == ADD || operator == MULT || operator == SUB || operator == DIV;\n         return operator < 6;\n     }\n \n+    private void arithmeticFunctionReduction(int operator) {\n+        ASTNode tk2;\n+        int operator2;\n+\n+        boolean x = false;\n+        /**\n+         * If the next token is an operator, we check to see if it has a higher\n+         * precdence.\n+         */\n+\n+        if ((tk2 = nextToken()) != null && tk2.isOperator()\n+                && isArithmeticOperator(operator2 = tk2.getOperator())\n+                && (Operator.PTABLE[operator2] > Operator.PTABLE[operator])) {\n+\n+            do {\n+                dStack.push(tk2.getOperator(), nextToken().getReducedValue(ctx, ctx, variableFactory));\n+                if (x = !x)\n+                    reduceRightXSwap(); // r\n+                else\n+                    reduceRightXXSwap();\n+            }\n+            while (((tk2 = nextToken()) != null && tk2.isOperator()\n+                    && isArithmeticOperator(operator2 = tk2.getOperator())\n+                    && (operator2 > operator)));\n+\n+            xswap();\n+            reduce();\n+\n+            if (tk2 != null) stk.push(operator2);\n+\n+            if ((tk2 = nextToken()) != null) {\n+                stk.push(tk2.getReducedValue(ctx, ctx, variableFactory));\n+            }\n+        }\n+        else if (tk2 != null) {\n+            reduce();\n+            operator = tk2.getOperator();\n+\n+            if ((tk2 = nextToken()) != null) {\n+                stk.push(tk2.getReducedValue(ctx, ctx, variableFactory), operator);\n+                reduce();\n+            }\n+\n+            while (stk.size() > 1) {\n+                xswap();\n+                reduce();\n+            }\n+\n+            /**\n+             * Push tk2 back into the accumulator.\n+             */\n+        }\n+        else {\n+            reduce();\n+        }\n+    }\n+\n     /**\n      * This method peforms the equivilent of an XSWAP operation to flip the operator\n      * over to the top of the stack, and loads the stored values on the d-stack onto\n      * the main program stack.\n      */\n-    private void procDStack() {\n-        if (dStack == null) return;\n-        Object o;\n-        //    while (!dStack.isEmpty()) {\n-        o = stk.pop();\n+    private void reduceRight() {\n+        if (dStack.isEmpty()) return;\n+\n+        Object o = stk.pop();\n         stk.push(dStack.pop());\n         stk.push(o);\n         stk.push(dStack.pop());\n \n-//        System.out.println(\"before exec...\");\n-//        stk.showStack();\n+        reduce();\n+    }\n+\n+    /**\n+     * A more efficient RHS reduction, to avoid the need\n+     * to XSWAP directly on the stack.\n+     */\n+    private void reduceRightXSwap() {\n+        Object o = stk.pop();\n+        Object o2 = stk.pop();\n \n+        stk.push(o);\n+        stk.push(dStack.pop());\n+        stk.push(o2);\n+        stk.push(dStack.pop());\n         reduce();\n-        //       }\n+    }\n+\n+    /**\n+     * Same as reduceRightXSwap, except this is an inverted\n+     * operator, or XXSWAP.\n+     */\n+    private void reduceRightXXSwap() {\n+        Object o = stk.pop();\n+        Object o2 = stk.pop();\n+\n+        stk.push(o2);\n+        stk.push(dStack.pop());\n+        stk.push(o);\n+        stk.push(dStack.pop());\n+        reduce();\n+    }\n+\n+    /**\n+     * XSWAP.\n+     */\n+    private void xswap() {\n+        Object o = stk.pop();\n+        Object o2 = stk.pop();\n+        stk.push(o);\n+        stk.push(o2);\n     }\n \n     private boolean hasNoMore() {\n@@ -309,15 +375,16 @@ public class MVELInterpretedRuntime extends AbstractParser {\n      * current state against 2 downrange structures (usually an op and a val).\n      */\n     private void reduce() {\n+\n         Object v1 = null, v2 = null;\n         Integer operator;\n         try {\n-            //   while (stk.size() > 1) {\n+\n             operator = (Integer) stk.pop();\n             v1 = stk.pop();\n             v2 = stk.pop();\n \n-            System.out.println(\"reduce:\" + v2 + \" <\" + DebugTools.getOperatorName(operator) + \"> \" + v1);\n+   //         System.out.println(\"reduce:\" + v2 + \" <\" + DebugTools.getOperatorName(operator) + \"> \" + v1);\n \n             switch (operator) {\n                 case ADD:\ndiff --git a/src/main/java/org/mvel/Operator.java b/src/main/java/org/mvel/Operator.java\nindex 4a67896..1dd9f81 100644\n--- a/src/main/java/org/mvel/Operator.java\n+++ b/src/main/java/org/mvel/Operator.java\n@@ -19,6 +19,16 @@\n package org.mvel;\n \n public interface Operator {\n+\n+    /**\n+     * The index positions of the operator precedence values\n+     * correspond to the actual operator itself. So ADD is PTABLE[0],\n+     * SUB is PTABLE[1] and so on.\n+     */\n+    public static final int[] PTABLE = {\n+            0, 0, 1, 1, 1, 2\n+    };\n+\n     public static final int ADD = 0;\n     public static final int SUB = 1;\n     public static final int MULT = 2;\n@@ -82,5 +92,5 @@ public interface Operator {\n     public static final int RETURN = 99;\n \n     public static final int FUNCTION = 100;\n-\n+    \n }\ndiff --git a/src/main/java/org/mvel/ast/OperatorNode.java b/src/main/java/org/mvel/ast/OperatorNode.java\nindex 8371a48..4571b79 100644\n--- a/src/main/java/org/mvel/ast/OperatorNode.java\n+++ b/src/main/java/org/mvel/ast/OperatorNode.java\n@@ -1,5 +1,7 @@\n package org.mvel.ast;\n \n+import org.mvel.integration.VariableResolverFactory;\n+\n public class OperatorNode extends ASTNode {\n     private Integer operator;\n \n@@ -18,4 +20,12 @@ public class OperatorNode extends ASTNode {\n     public Integer getOperator() {\n         return operator;\n     }\n+\n+    public Object getReducedValueAccelerated(Object ctx, Object thisValue, VariableResolverFactory factory) {\n+        return literal;\n+    }\n+\n+    public Object getReducedValue(Object ctx, Object thisValue, VariableResolverFactory factory) {\n+        return literal;\n+    }\n }\ndiff --git a/src/main/java/org/mvel/compiler/AbstractParser.java b/src/main/java/org/mvel/compiler/AbstractParser.java\nindex f8d2d90..06ae492 100644\n--- a/src/main/java/org/mvel/compiler/AbstractParser.java\n+++ b/src/main/java/org/mvel/compiler/AbstractParser.java\n@@ -74,6 +74,7 @@ public class AbstractParser implements Serializable {\n \r\n     protected static ThreadLocal<ParserContext> parserContext;\r\n     protected ParserContext pCtx;\r\n+    protected ExecutionStack dStack;\r\n \r\n     static {\r\n         configureFactory();\r\n@@ -560,7 +561,7 @@ public class AbstractParser implements Serializable {\n                         }\r\n \r\n                         case '=':\r\n-                            return createToken(expr, start, (cursor += 2), fields);\r\n+                            return createOperator(expr, start, (cursor += 2), fields);\r\n \r\n                         case '-':\r\n                             if (isNext('-')) {\r\n@@ -772,12 +773,16 @@ public class AbstractParser implements Serializable {\n                             char[] _subset = null;\r\n                             if (singleToken) {\r\n                                 int st;\r\n-                                String tokenStr = new String(_subset = subset(expr, st = trimRight(start + 1), trimLeft(cursor - 1) - st));\r\n \r\n-                                if (pCtx.hasImport(tokenStr)) {\r\n+\r\n+                                //String tokenStr = new String(_subset = subset(expr, st = trimRight(start + 1), trimLeft(cursor - 1) - st));\r\n+\r\n+                                name = new String(_subset = subset(expr, st = trimRight(start + 1), trimLeft(cursor - 1) - st));\r\n+\r\n+                                if (pCtx.hasImport(name)) {\r\n                                     start = cursor;\r\n                                     captureToEOS();\r\n-                                    return lastNode = new TypeCast(subset(expr, start, cursor - start), pCtx.getImport(tokenStr), fields);\r\n+                                    return lastNode = new TypeCast(subset(expr, start, cursor - start), pCtx.getImport(name), fields);\r\n                                 }\r\n                                 else {\r\n                                     int rewind = cursor;\r\n@@ -787,14 +792,14 @@ public class AbstractParser implements Serializable {\n                                          *  take a stab in the dark and try and load the class\r\n                                          */\r\n                                         captureToEOS();\r\n-                                         return lastNode = new TypeCast(subset(expr, rewind, cursor - rewind), createClass(tokenStr), fields);\r\n+                                        return lastNode = new TypeCast(subset(expr, rewind, cursor - rewind), createClass(name), fields);\r\n \r\n                                     }\r\n                                     catch (ClassNotFoundException e) {\r\n                                         /**\r\n                                          * Just fail through.\r\n                                          */\r\n-                                       cursor = rewind;                                        \r\n+                                        cursor = rewind;\r\n                                     }\r\n                                 }\r\n                             }\r\n@@ -816,26 +821,26 @@ public class AbstractParser implements Serializable {\n                         case '>': {\r\n                             if (expr[cursor + 1] == '>') {\r\n                                 if (expr[cursor += 2] == '>') cursor++;\r\n-                                return createToken(expr, start, cursor, fields);\r\n+                                return createOperator(expr, start, cursor, fields);\r\n                             }\r\n                             else if (expr[cursor + 1] == '=') {\r\n-                                return createToken(expr, start, cursor += 2, fields);\r\n+                                return createOperator(expr, start, cursor += 2, fields);\r\n                             }\r\n                             else {\r\n-                                return createToken(expr, start, ++cursor, fields);\r\n+                                return createOperator(expr, start, ++cursor, fields);\r\n                             }\r\n                         }\r\n \r\n                         case '<': {\r\n                             if (expr[++cursor] == '<') {\r\n                                 if (expr[++cursor] == '<') cursor++;\r\n-                                return createToken(expr, start, cursor, fields);\r\n+                                return createOperator(expr, start, cursor, fields);\r\n                             }\r\n                             else if (expr[cursor] == '=') {\r\n-                                return createToken(expr, start, ++cursor, fields);\r\n+                                return createOperator(expr, start, ++cursor, fields);\r\n                             }\r\n                             else {\r\n-                                return createToken(expr, start, cursor, fields);\r\n+                                return createOperator(expr, start, cursor, fields);\r\n                             }\r\n                         }\r\n \r\n@@ -857,19 +862,22 @@ public class AbstractParser implements Serializable {\n \r\n                         case '&': {\r\n                             if (expr[cursor++ + 1] == '&') {\r\n-                                return createToken(expr, start, ++cursor, fields);\r\n+                                return createOperator(expr, start, ++cursor, fields);\r\n                             }\r\n                             else {\r\n-                                return createToken(expr, start, cursor, fields);\r\n+                                return createOperator(expr, start, cursor, fields);\r\n                             }\r\n                         }\r\n \r\n                         case '|': {\r\n                             if (expr[cursor++ + 1] == '|') {\r\n-                                return createToken(expr, start, ++cursor, fields);\r\n+                                //         return createToken(expr, start, ++cursor, fields);\r\n+\r\n+                                return new OperatorNode(OPERATORS.get(subset(expr, start, ++cursor - start)));\r\n+\r\n                             }\r\n                             else {\r\n-                                return createToken(expr, start, cursor, fields);\r\n+                                return createOperator(expr, start, cursor, fields);\r\n                             }\r\n                         }\r\n \r\n@@ -887,7 +895,9 @@ public class AbstractParser implements Serializable {\n                             }\r\n                             else {\r\n                                 if (expr[cursor] == '=') cursor++;\r\n-                                return createToken(expr, start, cursor, fields);\r\n+                                return createOperator(expr, start, cursor, fields);\r\n+\r\n+                                //   return new OperatorNode(OPERATORS.get(subset(expr, start, cursor - start)));\r\n                             }\r\n \r\n                         case '!': {\r\n@@ -904,7 +914,8 @@ public class AbstractParser implements Serializable {\n                             else if (expr[cursor] != '=')\r\n                                 throw new CompileException(\"unexpected operator '!'\", expr, cursor, null);\r\n                             else {\r\n-                                return createToken(expr, start, ++cursor, fields);\r\n+                                return createOperator(expr, start, ++cursor, fields);\r\n+                                //   return new OperatorNode(OPERATORS.get(\"!=\"));\r\n                             }\r\n                         }\r\n \r\n@@ -978,6 +989,12 @@ public class AbstractParser implements Serializable {\n         return lastNode;\r\n     }\r\n \r\n+    private ASTNode createOperator(final char[] expr, final int start, final int end, int fields) {\r\n+        char[] e = subset(expr, start, end - start);\r\n+        lastWasIdentifier = false;\r\n+        return lastNode = new OperatorNode(OPERATORS.get(new String(e)));\r\n+    }\r\n+\r\n     private char[] subArray(final int start, final int end) {\r\n         if (start >= end) return new char[0];\r\n \r\ndiff --git a/src/main/java/org/mvel/compiler/ExpressionCompiler.java b/src/main/java/org/mvel/compiler/ExpressionCompiler.java\nindex daa01fc..83d15ed 100644\n--- a/src/main/java/org/mvel/compiler/ExpressionCompiler.java\n+++ b/src/main/java/org/mvel/compiler/ExpressionCompiler.java\n@@ -141,6 +141,7 @@ public class ExpressionCompiler extends AbstractParser {\n                              * Reduce the token now.\r\n                              */\r\n \r\n+\r\n                             reduce();\r\n \r\n                             firstLA = true;\r\n@@ -234,6 +235,17 @@ public class ExpressionCompiler extends AbstractParser {\n \r\n     }\r\n \r\n+    private void pushDStack(Object o) {\r\n+        if (dStack == null) this.dStack = new ExecutionStack();\r\n+        dStack.push(o);\r\n+    }\r\n+\r\n+    private void pushDStack(Object o1, Object o2) {\r\n+        if (dStack == null) this.dStack = new ExecutionStack();\r\n+        dStack.push(o1, o2);\r\n+    }\r\n+\r\n+\r\n     private static boolean isBooleanOperator(int operator) {\r\n         return operator == Operator.AND || operator == Operator.OR;\r\n     }\r\ndiff --git a/src/main/java/org/mvel/debug/DebugTools.java b/src/main/java/org/mvel/debug/DebugTools.java\nindex 9bac54b..8f150ce 100644\n--- a/src/main/java/org/mvel/debug/DebugTools.java\n+++ b/src/main/java/org/mvel/debug/DebugTools.java\n@@ -201,6 +201,10 @@ public class DebugTools {\n                 return \"NOT_EQUAL\";\r\n             case Operator.NEW:\r\n                 return \"NEW_OBJECT\";\r\n+\r\n+            case Operator.AND:\r\n+                return \"AND\";\r\n+\r\n             case Operator.OR:\r\n                 return \"OR\";\r\n             case Operator.POWER:\r\n@@ -227,6 +231,8 @@ public class DebugTools {\n                 return \"WHILE\";\r\n             case Operator.CHOR:\r\n                 return \"CHAINED_OR\";\r\n+\r\n+\r\n         }\r\n \r\n \r\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\nindex 9b9e9bd..ea28188 100644\n--- a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n@@ -192,7 +192,9 @@ public class CoreConfidenceTests extends AbstractTest {\n     }\n \n     public void testShortPathExpression() {\n-        assertEquals(null, test(\"3 > 4 && foo.toUC('test'); foo.register\"));\n+        assertEquals(null, MVEL.eval(\"3 > 4 && foo.toUC('test'); foo.register\", new Base(), createTestMap()) );\n+\n+     //   assertEquals(null, test(\"3 > 4 && foo.toUC('test'); foo.register\"));\n     }\n \n     public void testShortPathExpression2() {\n@@ -2548,17 +2550,6 @@ public class CoreConfidenceTests extends AbstractTest {\n         assertEquals(11, test(\"xx0 = 15; xx0 -= 4; xx0\"));\n     }\n \n-//    public void testCommentsInWith() {\n-//        HashMap map = new HashMap();\n-//        map.put(\"f\", new JFrame());\n-//        System.out.println(eval(\n-//                \"with (f) {\\n\" +\n-//                        \"title = 'blah', // setting title\\n\" +\n-//                        \"alwaysOnTop = false \\n\" +\n-//                        \"}\", map\n-//        ));\n-//    }\n-\n \n     public void testStaticWithExplicitParam() {\n         PojoStatic pojo = new PojoStatic(\"10\");\n@@ -2601,12 +2592,21 @@ public class CoreConfidenceTests extends AbstractTest {\n     }\n \n     public void testHigherOrderMathTest2() {\n-        assertEquals(100 - 500 * 200 + 500 * 800 - 400, MVEL.eval(\"100-500*200 + 500*800-400\"));\n+        String ex = \"100-500*200 + 500*800-400\";\n+        System.out.println(\"Expression: \" + ex);\n \n+        assertEquals(100 - 500 * 200 + 500 * 800 - 400, MVEL.eval(ex));\n     }\n \n     public void testHigherOrderMathTest3() {\n-        assertEquals((10d * 5d) * 2d / 3d, MVEL.eval(\"(10 * 5) * 2 / 3\"));\n+        String ex =  \"100-500*200*150 + 500*800-400\";\n+        assertEquals(100 - 500 * 200 * 150 + 500 * 800 - 400, MVEL.eval(ex));\n+    }\n+\n+    public void testHigherOrderMathTest4() {\n+        String ex = \"(100 * 50) * 20 / 30\";\n+        System.out.println(\"Expression: \" + ex);\n+        assertEquals((100d * 50d) * 20d / 30d, MVEL.eval(ex));\n     }\n \n \n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T17:29:02.457854Z", "commit_hash": "cf0121d2a3dce558842c6badcdcea36bee11b744", "commit_message": "fixes\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/ParserConfiguration.java b/src/main/java/org/mvel/ParserConfiguration.java\nindex c1381f1..bbaa49c 100644\n--- a/src/main/java/org/mvel/ParserConfiguration.java\n+++ b/src/main/java/org/mvel/ParserConfiguration.java\n@@ -5,10 +5,7 @@ import org.mvel.compiler.AbstractParser;\n import org.mvel.util.MethodStub;\n import static org.mvel.util.ParseTools.getSimpleClassName;\n \n-import java.util.Map;\n-import java.util.Set;\n-import java.util.HashSet;\n-import java.util.LinkedHashMap;\n+import java.util.*;\n import static java.lang.Thread.currentThread;\n import java.lang.reflect.Method;\n import java.io.Serializable;\n@@ -22,7 +19,17 @@ public class ParserConfiguration implements Serializable {\n     }\n \n     public ParserConfiguration(Map<String, Object> imports, Map<String, Interceptor> interceptors) {\n-        this.imports = imports;\n+        this.imports = new HashMap<String, Object>();\n+        Object o;\n+        for (String key : imports.keySet()) {\n+            if ((o = imports.get(key)) instanceof Method) {\n+                this.imports.put(key, new MethodStub((Method) o));\n+            }\n+            else {\n+                this.imports.put(key, o);\n+            }\n+        }\n+\n         this.interceptors = interceptors;\n     }\n \ndiff --git a/src/main/java/org/mvel/templates/TemplateCompiler.java b/src/main/java/org/mvel/templates/TemplateCompiler.java\nindex 001b0c3..9cc05b4 100644\n--- a/src/main/java/org/mvel/templates/TemplateCompiler.java\n+++ b/src/main/java/org/mvel/templates/TemplateCompiler.java\n@@ -301,6 +301,7 @@ public class TemplateCompiler {\n     public static CompiledTemplate compileTemplate(CharSequence template) {\n         return new TemplateCompiler(template).compile();\n     }\n+    \n \n     public static CompiledTemplate compileTemplate(String template, Map<String, Class<? extends Node>> customNodes) {\n         return new TemplateCompiler(template, customNodes).compile();\ndiff --git a/src/main/java/org/mvel/templates/TemplateRuntime.java b/src/main/java/org/mvel/templates/TemplateRuntime.java\nindex 41e10fb..fe63958 100644\n--- a/src/main/java/org/mvel/templates/TemplateRuntime.java\n+++ b/src/main/java/org/mvel/templates/TemplateRuntime.java\n@@ -35,7 +35,7 @@ public class TemplateRuntime {\n     }\n \n     public static Object eval(String template, Object ctx) {\n-        return execute(compileTemplate(template), ctx, null);\n+        return execute(compileTemplate(template), ctx);\n     }\n \n     public static Object eval(String template, Object ctx, Map vars) {\n@@ -63,6 +63,17 @@ public class TemplateRuntime {\n         return execute(compiled.getRoot(), compiled.getTemplate(), new StringAppender(), null, null, null);\n     }\n \n+    public static Object execute(CompiledTemplate compiled, Object context) {\n+        return execute(compiled.getRoot(), compiled.getTemplate(), new StringAppender(), context, null, null);\n+    }\n+\n+    public static Object execute(CompiledTemplate compiled, Object context, Map vars) {\n+        return execute(compiled.getRoot(), compiled.getTemplate(), new StringAppender(), context, new MapVariableResolverFactory(vars), null);\n+    }\n+\n+    public static Object execute(CompiledTemplate compiled, Object context, Map vars, TemplateRegistry registry) {\n+        return execute(compiled.getRoot(), compiled.getTemplate(), new StringAppender(), context, new MapVariableResolverFactory(vars), registry);\n+    }\n \n     public static Object execute(CompiledTemplate compiled, Object context, VariableResolverFactory factory) {\n         return execute(compiled.getRoot(), compiled.getTemplate(), new StringAppender(), context, factory, null);\ndiff --git a/src/test/java/org/mvel/tests/templates/templateDeclareTest.mv b/src/test/java/org/mvel/tests/templates/templateDeclareTest.mv\nnew file mode 100644\nindex 0000000..cbf5591\n--- /dev/null\n+++ b/src/test/java/org/mvel/tests/templates/templateDeclareTest.mv\n@@ -0,0 +1,439 @@\n+@declare{\"getMethodBytecode\"}\n+    public java.util.List getMethodBytecode() {\n+        org.drools.util.asm.MethodComparator.Tracer visit = new org.drools.util.asm.MethodComparator.Tracer(\"@{methodName}\");\n+\n+        java.io.InputStream is = @{ruleClassName}.class.getClassLoader().getResourceAsStream( \"@{package}.@{ruleClassName}\".replace( '.', '/' ) + \".class\" );\n+\n+        java.io.ByteArrayOutputStream bos = new java.io.ByteArrayOutputStream();\n+        byte[] data = new byte[1024];\n+        int byteCount;\n+        try {\n+            while ( (byteCount = is.read( data,\n+                                 0,\n+                                 1024 )) > -1 )\n+            {\n+                bos.write(data, 0, byteCount);\n+            }\n+        } catch ( java.io.IOException e ) {\n+            throw new org.drools.RuntimeDroolsException(\"Unable getResourceAsStream for Class '@{ruleClassName}' \");\n+        }\n+\n+        org.drools.asm.ClassReader classReader = new org.drools.asm.ClassReader( bos.toByteArray() );\n+        classReader.accept( visit, true );\n+        org.drools.asm.util.TraceMethodVisitor trace = visit.getTrace();\n+        return trace.getText();\n+    }\n+@end{}\n+\n+@declare{\"hashCode\"}\n+    public int hashCode() {\n+        return @{hashCode};\n+    }\n+@end{}\n+\n+@declare{\"equals\"}\n+    public boolean equals(Object object) {\n+        if (object == null ) {\n+            return false;\n+        } else if ( object == this ){\n+            return true;\n+        }\n+\n+        if ( ! (object instanceof org.drools.spi.CompiledInvoker) ) {\n+            return false;\n+        }\n+\n+        org.drools.spi.CompiledInvoker other = ( org.drools.spi.CompiledInvoker ) object;\n+\n+        return org.drools.util.asm.MethodComparator.compareBytecode( getMethodBytecode(), other.getMethodBytecode() );\n+    }\n+@end{}\n+\n+\n+@declare{\"returnValueInvoker\"}\n+package @{package};\n+\n+public class @{invokerClassName} implements org.drools.spi.ReturnValueExpression, org.drools.spi.CompiledInvoker, java.io.Externalizable\n+{\n+    private static final long serialVersionUID  = 400L;\n+\n+    public Object createContext() { return null; }\n+\n+    public org.drools.spi.FieldValue evaluate(java.lang.Object object,\n+                            org.drools.spi.Tuple tuple,\n+                            org.drools.rule.Declaration[] previousDeclarations,\n+                            org.drools.rule.Declaration[] localDeclarations,\n+                            org.drools.WorkingMemory workingMemory,\n+                            Object context ) throws Exception {\n+\n+        @code{i0=0}@foreach{type : declarationTypes, declr : declarations} @{type} @{declr.identifier} = ( @{type} ) previousDeclarations[@{i0}].@{declr.nativeReadMethod.name}( (org.drools.common.InternalWorkingMemory) workingMemory, ( (org.drools.common.InternalFactHandle) tuple.get( previousDeclarations[@{i0}] ) ).getObject() );\n+        @code{i0++}\n+        @end{}\n+        @if{readLocalsFromTuple}\n+          @code{i0=0}@foreach{type : localDeclarationTypes, declr : localDeclarations} @{type} @{declr.identifier} = ( @{type} ) localDeclarations[@{i0}].@{declr.nativeReadMethod.name}( (org.drools.common.InternalWorkingMemory) workingMemory, ( (org.drools.common.InternalFactHandle) tuple.get( localDeclarations[@{i0}] ) ).getObject() );\n+          @code{i0++}\n+          @end{}\n+        @else{}\n+          @code{i0=0}@foreach{type : localDeclarationTypes, declr : localDeclarations} @{type} @{declr.identifier} = ( @{type} ) localDeclarations[@{i0}].@{declr.nativeReadMethod.name}( (org.drools.common.InternalWorkingMemory) workingMemory, object );\n+          @code{i0++}\n+          @end{}\n+        @end{}\n+        @foreach{type : globalTypes, identifier : globals} @{type} @{identifier} = ( @{type} ) workingMemory.getGlobal( \"@{identifier}\" );\n+        @end{}\n+\n+        return @{ruleClassName}.@{methodName}(\n+            @foreach{declr : declarations} @{declr.identifier}\n+            @end{\",\"}  @if{localDeclarations != empty && declarations != empty},@end{}\n+            @foreach{declr :localDeclarations} @{declr.identifier}\n+            @end{\",\"}@if{globals != empty && (localDeclarations != empty || declarations != empty)},@end{}\n+            @foreach{identifier : globals}@{identifier}\n+            @end{\",\"} );\n+    }\n+\n+    @includeNamed{\"hashCode\"}\n+\n+    @includeNamed{\"getMethodBytecode\"}\n+\n+    @includeNamed{\"equals\"}\n+\n+    public void writeExternal(java.io.ObjectOutput out) throws java.io.IOException {\n+    }\n+\n+    public void readExternal(java.io.ObjectInput in) throws java.io.IOException, java.lang.ClassNotFoundException {\n+    }\n+}\n+@end{}\n+\n+@declare{\"predicateInvoker\"}\n+package @{package};\n+\n+public class @{invokerClassName} implements org.drools.spi.PredicateExpression, org.drools.spi.CompiledInvoker, java.io.Externalizable\n+{\n+    private static final long serialVersionUID  = 400L;\n+\n+    public Object createContext() { return null; }\n+\n+    public boolean evaluate(java.lang.Object object,\n+                            org.drools.spi.Tuple tuple,\n+                            org.drools.rule.Declaration[] previousDeclarations,\n+                            org.drools.rule.Declaration[] localDeclarations,\n+                            org.drools.WorkingMemory workingMemory,\n+                            Object context ) throws Exception {\n+\n+        @code{i0=0}@foreach{type : declarationTypes, declr : declarations} @{type} @{declr.identifier} = ( @{type} ) previousDeclarations[@{i0}].@{declr.nativeReadMethod.name}( (org.drools.common.InternalWorkingMemory) workingMemory, ( (org.drools.common.InternalFactHandle) tuple.get( previousDeclarations[@{i0}] ) ).getObject() );\n+          @code{i0++}\n+        @end{}\n+        @code{i0=0}@foreach{type : localDeclarationTypes, declr : localDeclarations} @{type} @{declr.identifier} = ( @{type} ) localDeclarations[@{i0}].@{declr.nativeReadMethod.name}( (org.drools.common.InternalWorkingMemory) workingMemory, object );\n+          @code{i0++}\n+        @end{}\n+        @foreach{type : globalTypes, identifier : globals} @{type} @{identifier} = ( @{type} ) workingMemory.getGlobal( \"@{identifier}\" );\n+        @end{}\n+\n+        return @{ruleClassName}.@{methodName}(\n+            @foreach{declr : declarations} @{declr.identifier}\n+            @end{\",\"}  @if{localDeclarations != empty && declarations != empty},@end{}\n+            @foreach{declr : localDeclarations} @{declr.identifier}\n+            @end{\",\"}@if{globals != empty && (localDeclarations != empty || declarations != empty)},@end{}\n+            @foreach{identifier : globals}@{identifier}\n+            @end{\",\"} );\n+    }\n+\n+\n+    @includeNamed{\"hashCode\"}\n+\n+    @includeNamed{\"getMethodBytecode\"}\n+\n+    @includeNamed{\"equals\"}\n+\n+    public void writeExternal(java.io.ObjectOutput out) throws java.io.IOException {\n+    }\n+\n+    public void readExternal(java.io.ObjectInput in) throws java.io.IOException, java.lang.ClassNotFoundException {\n+    }\n+}\n+@end{}\n+\n+@declare{\"evalInvoker\"}\n+package @{package};\n+\n+public class @{invokerClassName} implements org.drools.spi.EvalExpression, org.drools.spi.CompiledInvoker, java.io.Externalizable\n+{\n+    private static final long serialVersionUID  = 400L;\n+\n+    // no need for context\n+    public Object createContext() { return null; }\n+\n+    public boolean evaluate(org.drools.spi.Tuple tuple,\n+                            org.drools.rule.Declaration[] declarations,\n+                            org.drools.WorkingMemory workingMemory,\n+                            Object context ) throws Exception {\n+\n+        @code{i0=0}@foreach{type : declarationTypes, declr : declarations} @{type} @{declr.identifier} = ( @{type} ) declarations[@{i0}].@{declr.nativeReadMethod.name}( (org.drools.common.InternalWorkingMemory) workingMemory, ( (org.drools.common.InternalFactHandle) tuple.get( declarations[@{i0}] ) ).getObject() );\n+            @code{i0++}\n+        @end{}\n+        @foreach{type : globalTypes, identifier : globals} @{type} @{identifier} = ( @{type} ) workingMemory.getGlobal( \"@{identifier}\" );\n+        @end{}\n+\n+        return @{ruleClassName}.@{methodName}(\n+            @foreach{declr : declarations} @{declr.identifier}\n+            @end{\",\"} @if{globals != empty && declarations != empty},@end{}\n+            @foreach{identifier : globals}@{identifier}\n+            @end{\",\"} );\n+    }\n+\n+    @includeNamed{\"hashCode\"}\n+\n+    @includeNamed{\"getMethodBytecode\"}\n+\n+    @includeNamed{\"equals\"}\n+\n+\n+    public void writeExternal(java.io.ObjectOutput out) throws java.io.IOException {\n+    }\n+\n+    public void readExternal(java.io.ObjectInput in) throws java.io.IOException, java.lang.ClassNotFoundException {\n+    }\n+}\n+@end{}\n+\n+\n+@declare{\"accumulateInvoker\"}\n+package @{package};\n+\n+import org.drools.asm.ClassReader;\n+import org.drools.asm.util.TraceMethodVisitor;\n+import org.drools.util.asm.MethodComparator.Tracer;\n+import java.util.Collections;\n+public class @{invokerClassName} implements org.drools.spi.Accumulator, org.drools.spi.CompiledInvoker\n+{\n+    private static final long serialVersionUID  = 400L;\n+\n+    public Object createContext() {\n+        return new @{ruleClassName}.@{className}();\n+    }\n+\n+    public void init(java.lang.Object workingMemoryContext,\n+                     java.lang.Object context,\n+                     org.drools.spi.Tuple leftTuple,\n+                     org.drools.rule.Declaration[] declarations,\n+                     org.drools.WorkingMemory workingMemory) throws Exception {\n+        @code{i0=0}@foreach{type : declarationTypes, declr : declarations} @{type} @{declr.identifier} = ( @{type} ) declarations[@{i0}].@{declr.nativeReadMethod.name}( (org.drools.common.InternalWorkingMemory) workingMemory, ( (org.drools.common.InternalFactHandle) leftTuple.get( declarations[@{i0}] ) ).getObject() );\n+            @code{i0++}\n+        @end{}\n+        @foreach{type : globalTypes, identifier : globals} @{type} @{identifier} = ( @{type} ) workingMemory.getGlobal( \"@{identifier}\" );\n+        @end{}\n+\n+        ((@{ruleClassName}.@{className})context).init(\n+            @foreach{declr : declarations} @{declr.identifier}@end{\",\"}@if{globals != empty && declarations != empty},@end{}\n+\t        @foreach{identifier : globals} @{identifier}@end{\",\"} );\n+\n+    }\n+\n+    public void accumulate(java.lang.Object workingMemoryContext,\n+                           java.lang.Object context,\n+                           org.drools.spi.Tuple leftTuple,\n+                           org.drools.common.InternalFactHandle handle,\n+                           org.drools.rule.Declaration[] declarations,\n+                           org.drools.rule.Declaration[] innerDeclarations,\n+                           org.drools.WorkingMemory workingMemory) throws Exception {\n+        @code{ i0 = 0 }@foreach{type : declarationTypes, declr : declarations} @{type} @{declr.identifier} = ( @{type} ) declarations[@{i0}].@{declr.nativeReadMethod.name}( (org.drools.common.InternalWorkingMemory) workingMemory, ( (org.drools.common.InternalFactHandle) leftTuple.get( declarations[@{i0}] ) ).getObject() );\n+            @code{ i0++ }\n+        @end{}\n+        @foreach{type : globalTypes, identifier : globals} @{type} @{identifier} = ( @{type} ) workingMemory.getGlobal( \"@{identifier}\" );\n+        @end{}\n+        @if{isMultiPattern}\n+          @code{ i0 = 0 }@foreach{declr : innerDeclarations} @{declr.extractor.extractToClassName} @{declr.identifier} = (@{declr.extractor.extractToClassName}) innerDeclarations[@{i0}].@{declr.nativeReadMethod.name}( (org.drools.common.InternalWorkingMemory) workingMemory, ( (org.drools.common.InternalFactHandle) leftTuple.get( innerDeclarations[@{i0}] ) ).getObject() );\n+            @code{ i0++ }\n+          @end{}\n+        @else{}\n+          @code{ i0 = 0 }@foreach{declr : innerDeclarations} @{declr.extractor.extractToClassName} @{declr.identifier} = (@{declr.extractor.extractToClassName}) innerDeclarations[@{i0}].@{declr.nativeReadMethod.name}( (org.drools.common.InternalWorkingMemory) workingMemory, handle.getObject() );\n+            @code{ i0++ }\n+          @end{}\n+        @end{}\n+        ((@{ruleClassName}.@{className})context).accumulate(\n+            workingMemory,\n+            innerDeclarations,\n+            handle.getObject()@if{declarations != empty},@end{}\n+            @foreach{declr : declarations} @{declr.identifier}@end{\",\"}@if{globals != empty},@end{}\n+\t        @foreach{identifier: globals} @{identifier}@end{\",\"}@if{innerDeclarations != empty},@end{}\n+            @foreach{declr : innerDeclarations} @{declr.identifier}@end{\",\"});\n+    }\n+\n+    public void reverse(java.lang.Object workingMemoryContext,\n+                           java.lang.Object context,\n+                           org.drools.spi.Tuple leftTuple,\n+                           org.drools.common.InternalFactHandle handle,\n+                           org.drools.rule.Declaration[] declarations,\n+                           org.drools.rule.Declaration[] innerDeclarations,\n+                           org.drools.WorkingMemory workingMemory) throws Exception {\n+        @code{ i0 = 0 }@foreach{type : declarationTypes, declr : declarations} @{type} @{declr.identifier} = ( @{type} ) declarations[@{i0}].@{declr.nativeReadMethod.name}( (org.drools.common.InternalWorkingMemory) workingMemory, ( (org.drools.common.InternalFactHandle) leftTuple.get( declarations[@{i0}] ) ).getObject() );\n+            @code{ i0++ }\n+        @end{}\n+        @foreach{type : globalTypes, identifier : globals} @{type} @{identifier} = ( @{type} ) workingMemory.getGlobal( \"@{identifier}\" );\n+        @end{}\n+        @if{isMultiPattern}\n+          @code{ i0 = 0}@foreach{declr : innerDeclarations} @{declr.extractor.extractToClassName} @{declr.identifier} = (@{declr.extractor.extractToClassName}) innerDeclarations[@{i0}].@{declr.nativeReadMethod.name}( (org.drools.common.InternalWorkingMemory) workingMemory, ( (org.drools.common.InternalFactHandle) leftTuple.get( innerDeclarations[@{i0}] ) ).getObject() );\n+            @code{ i0++ }\n+          @end{}\n+        @else{}\n+          @code{ i0 = 0 }@foreach{declr : innerDeclarations} @{declr.extractor.extractToClassName} @{declr.identifier} = (@{declr.extractor.extractToClassName}) innerDeclarations[@{i0}].@{declr.nativeReadMethod.name}( (org.drools.common.InternalWorkingMemory) workingMemory, handle.getObject() );\n+            @code{ i0++ }\n+          @end{}\n+        @end{}\n+\n+        ((@{ruleClassName}.@{className})context).reverse(\n+            workingMemory,\n+            innerDeclarations,\n+            handle.getObject()@if{declarations != empty},@end{}\n+            @foreach{declr : declarations} @{declr.identifier}@end{\",\"}@if{globals != empty},@end{}\n+\t        @foreach{identifier : globals} @{identifier}@end{\",\"}@if{innerDeclarations != empty},@end{}\n+            @foreach{declr : innerDeclarations} @{declr.identifier}@end{\",\"});\n+    }\n+\n+    public Object getResult(java.lang.Object workingMemoryContext,\n+                            java.lang.Object context,\n+                            org.drools.spi.Tuple leftTuple,\n+                            org.drools.rule.Declaration[] declarations,\n+                            org.drools.WorkingMemory workingMemory) throws Exception {\n+        @code{ i0 = 0 }@foreach{type : declarationTypes, declr : declarations} @{type} @{declr.identifier} = ( @{type} ) declarations[@{i0}].@{declr.nativeReadMethod.name}( (org.drools.common.InternalWorkingMemory) workingMemory, ( (org.drools.common.InternalFactHandle) leftTuple.get( declarations[@{i0}] ) ).getObject() );\n+            @code{ i0++ }\n+        @end{}\n+        @foreach{type : globalTypes, identifier : globals} @{type} @{identifier} = ( @{type} ) workingMemory.getGlobal( \"@{identifier}\" );\n+        @end{}\n+\n+        return ((@{ruleClassName}.@{className})context).getResult(\n+            @foreach{declr : declarations} @{declr.identifier}@end{\",\"}@if{globals != empty && declarations != empty},@end{}\n+\t        @foreach{identifier : globals} @{identifier}@end{\",\"} );\n+    }\n+\n+    public boolean supportsReverse() {\n+        return @{supportsReverse};\n+    }\n+\n+    public Object createWorkingMemoryContext() {\n+        return null;\n+    }\n+\n+    @includeNamed{\"hashCode\"}\n+\n+    @includeNamed(\"equals\"}\n+\n+    public java.util.List getMethodBytecode() {\n+        java.io.InputStream is = @{ruleClassName}.class.getClassLoader().getResourceAsStream( \"@{package}.@{ruleClassName}\".replace( '.', '/' ) + \"$@{className}\" + \".class\" );\n+\n+        java.io.ByteArrayOutputStream bos = new java.io.ByteArrayOutputStream();\n+        byte[] data = new byte[1024];\n+        int byteCount;\n+        try {\n+            while ( (byteCount = is.read( data,\n+                                 0,\n+                                 1024 )) > -1 )\n+            {\n+                bos.write(data, 0, byteCount);\n+            }\n+        } catch ( java.io.IOException e ) {\n+            throw new org.drools.RuntimeDroolsException(\"Unable getResourceAsStream for Class '@{ruleClassName}$@{className}' \");\n+        }\n+        return Collections.singletonList( bos );\n+    }\n+\n+    public void writeExternal(java.io.ObjectOutput out) throws java.io.IOException {\n+    }\n+\n+    public void readExternal(java.io.ObjectInput in) throws java.io.IOException, java.lang.ClassNotFoundException {\n+    }\n+\n+}\n+@end{}\n+\n+@declare{\"consequenceInvoker\"}\n+package @{package};\n+\n+public class @{invokerClassName} implements org.drools.spi.Consequence, java.io.Externalizable\n+{\n+    private static final long serialVersionUID  = 400L;\n+\n+    public void evaluate(org.drools.spi.KnowledgeHelper knowledgeHelper,\n+                         org.drools.WorkingMemory workingMemory) throws Exception {\n+\n+        org.drools.spi.Tuple tuple = knowledgeHelper.getTuple();\n+        org.drools.rule.Rule rule = knowledgeHelper.getRule();\n+        org.drools.rule.Declaration[] declarations = rule.getDeclarations();\n+\n+        @foreach{type : declarationTypes, declr : declarations, index : indexes, notPattern : notPatterns}\n+          org.drools.common.InternalFactHandle @{declr.identifier}__Handle__ = ( org.drools.common.InternalFactHandle ) tuple.get( knowledgeHelper.getDeclaration( declarations[@{index}].getIdentifier() ) );\n+          @{type} @{declr.identifier} = ( @{type} )  declarations[@{index}].@{declr.nativeReadMethod.name}( (org.drools.common.InternalWorkingMemory) workingMemory, @{declr.identifier}__Handle__.getObject() );\n+          @if{notPattern}@{declr.identifier}__Handle__ =  (org.drools.common.InternalFactHandle) knowledgeHelper.getWorkingMemory().getFactHandle( @{declr.identifier} );@end{}\n+        @end{}\n+\n+        @foreach{type : globalTypes, identifier : globals} @{type} @{identifier} = ( @{type} ) workingMemory.getGlobal( \"@{identifier}\" );\n+        @end{}\n+\n+        @{ruleClassName}.@{methodName} (\n+            knowledgeHelper@if{declarations != empty},@end{}\n+            @foreach{declr : declarations} @{declr.identifier}, @{declr.identifier}__Handle__\n+            @end{\",\"}@if{globals != empty},@end{}\n+\t        @foreach{identifier : globals} @{identifier}\n+\t        @end{\",\"} );\n+    }\n+    public void writeExternal(java.io.ObjectOutput out) throws java.io.IOException {\n+    }\n+\n+    public void readExternal(java.io.ObjectInput in) throws java.io.IOException, java.lang.ClassNotFoundException {\n+    }\n+}\n+@end{}\n+\n+\n+@declare{\"actionInvoker\"}\n+package @{package};\n+\n+public class @{invokerClassName} implements org.drools.spi.Action, java.io.Externalizable\n+{\n+    private static final long serialVersionUID  = 400L;\n+\n+    public void execute(org.drools.WorkingMemory workingMemory) throws Exception {\n+\n+        @foreach{type : globalTypes, identifier : globals} @{type} @{identifier} = ( @{type} ) workingMemory.getGlobal( \"@{identifier}\" );\n+        @end{}\n+\n+        @{processClassName}.@{methodName} (\n+\t        @foreach{identifier : globals} @{identifier}\n+\t        @end{\",\"} );\n+    }\n+\n+    public void writeExternal(java.io.ObjectOutput out) throws java.io.IOException {\n+    }\n+\n+    public void readExternal(java.io.ObjectInput in) throws java.io.IOException, java.lang.ClassNotFoundException {\n+    }\n+}\n+@end{}\n+\n+@declare{\"returnValueEvaluatorInvoker\"}\n+package @{package};\n+\n+public class @{invokerClassName} implements org.drools.spi.ReturnValueEvaluator, java.io.Externalizable\n+{\n+    private static final long serialVersionUID  = 400L;\n+\n+    public Object evaluate(org.drools.WorkingMemory workingMemory) throws Exception {\n+\n+        @foreach{type : globalTypes, identifier : globals} @{type} @{identifier} = ( @{type} ) workingMemory.getGlobal( \"@{identifier}\" );\n+        @end{}\n+\n+        return @{processClassName}.@{methodName} (\n+\t        @foreach{identifier : globals} @{identifier}\n+\t        @end{\",\"} );\n+    }\n+\n+    public void writeExternal(java.io.ObjectOutput out) throws java.io.IOException {\n+    }\n+\n+    public void readExternal(java.io.ObjectInput in) throws java.io.IOException, java.lang.ClassNotFoundException {\n+    }\n+}\n+@end{}\n+\n+\n+@includeNamed{\"equals\"}\n\\ No newline at end of file\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/TemplateTests.java b/src/test/java/org/mvel/tests/main/TemplateTests.java\nindex fc2128b..89e13f2 100644\n--- a/src/test/java/org/mvel/tests/main/TemplateTests.java\n+++ b/src/test/java/org/mvel/tests/main/TemplateTests.java\n@@ -186,13 +186,21 @@ public class TemplateTests extends TestCase {\n \n     }\n \n+    public void testTemplateFile2() {\n+        String s = (String) TemplateRuntime.eval(new File(\"src/test/java/org/mvel/tests/templates/templateDeclareTest.mv\"),\n+                base, new MapVariableResolverFactory(map), null);\n+\n+        System.out.println(s);\n+\n+    }\n+\n     public void testInclusionOfNamedTemplate() {\n         SimpleTemplateRegistry registry = new SimpleTemplateRegistry();\n         registry.addNamedTemplate(\"footemplate\", compileTemplate(\"@{_foo_}@{_bar_}\"));\n         registry.addNamedTemplate(\"bartemplate\", compileTemplate(\"@{_bar_}@{_foo_}\"));\n \n-        String s = \"@includeNamed{'footemplate'}::@includeNamed{'bartemplate'}\";\n-        assertEquals(\"FooBar::BarFoo\", TemplateRuntime.eval(s, map, registry));\n+        String s = \"@includeNamed{'footemplate'}  ::  @includeNamed{'bartemplate'}\";\n+        assertEquals(\"FooBar  ::  BarFoo\", TemplateRuntime.eval(s, map, registry));\n     }\n \n     @SuppressWarnings({\"AssertEqualsBetweenInconvertibleTypes\"})\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T17:44:06.814229Z", "commit_hash": "b26b93071aaacabe0b9ecb8cb445cce73c7f0017", "commit_message": "fixes.\n", "related_issues": "", "bug_patch": "diff --git a/samples/scripts/quicksort.mvel b/samples/scripts/quicksort.mvel\nindex ed353a2..a20dd0d 100644\n--- a/samples/scripts/quicksort.mvel\n+++ b/samples/scripts/quicksort.mvel\n@@ -4,13 +4,16 @@\n  * by: Christopher Michael Brock\n  */\n \n-function swap(array, i, j) {\n+\n+array = null;\n+\n+function swap(i, j) {\n     temp = array[i];\n     array[i] = array[j];\n     array[j] = temp;\n }\n \n-function partition(array, low, high) {\n+function partition(low, high) {\n     pivotPoint = array[low];\n \n     i = low - 1;\n@@ -19,30 +22,30 @@ function partition(array, low, high) {\n     while (i < j) {\n         i++; while (array[i] < pivotPoint) ++i;\n         j--; while (array[j] > pivotPoint) --j;\n-        if (i < j) swap(array, i, j);\n+        if (i < j) swap(i, j);\n     }\n \n     j;\n }\n \n-function sort(array, low, high) {\n+function sort(low, high) {\n     if (low < high) {\n         var p;\n-        sort(array, low, p = partition(array, low, high));\n-        sort(array, p + 1, high);\n+        sort(low, p = partition(low, high));\n+        sort(p + 1, high);\n     }\n }\n \n-function quicksort(array) {\n-    sort(array, 0, array.length - 1);\n+function quicksort() {\n+    sort(0, array.length - 1);\n }\n \n-test = {50,20,21,209,10,77,8,9,55,73,41,99};\n+array = {50,20,21,209,10,77,8,9,55,73,41,99};\n \n-quicksort(test);\n+quicksort();\n \n-//foreach (item : test) {\n+//foreach (item : array) {\n //    System.out.println(item);\n //}\n \n-test;\n\\ No newline at end of file\n+array;\n\\ No newline at end of file\ndiff --git a/src/main/java/org/mvel/ParserContext.java b/src/main/java/org/mvel/ParserContext.java\nindex 22498c6..1345498 100644\n--- a/src/main/java/org/mvel/ParserContext.java\n+++ b/src/main/java/org/mvel/ParserContext.java\n@@ -146,6 +146,13 @@ public class ParserContext implements Serializable {\n         if (inputs == null) inputs = new LinkedHashMap<String, Class>();\n     }\n \n+    public void addVariable(String name, Class type, boolean failIfNewAssignment) {\n+        initializeTables();\n+        if (variables.containsKey(name) && failIfNewAssignment) throw new CompileException(\"statically-typed variable already defined in scope: \" + name);\n+        if (type == null) type = Object.class;\n+        variables.put(name, type);\n+    }\n+\n     public void addVariable(String name, Class type) {\n         initializeTables();\n         if (variables.containsKey(name)) return;\n@@ -153,6 +160,14 @@ public class ParserContext implements Serializable {\n         variables.put(name, type);\n     }\n \n+    public void addVariables(Map<String, Class> variables) {\n+        if (variables == null) return;\n+        initializeTables();\n+        for (String name : variables.keySet()) {\n+            addVariable(name, variables.get(name));\n+        }\n+    }\n+\n     public void addInput(String name, Class type) {\n         if (inputs == null) inputs = new LinkedHashMap<String, Class>();\n         if (inputs.containsKey(name)) return;\n@@ -160,6 +175,14 @@ public class ParserContext implements Serializable {\n         inputs.put(name, type);\n     }\n \n+    public void addInputs(Map<String, Class> inputs) {\n+        if (inputs == null) return;\n+        if (inputs == null) inputs = new LinkedHashMap<String, Class>();\n+        for (String name : inputs.keySet()) {\n+            addInput(name, inputs.get(name));\n+        }\n+    }\n+\n     public void processTables() {\n         for (String name : variables.keySet()) {\n             inputs.remove(name);\n@@ -358,7 +381,7 @@ public class ParserContext implements Serializable {\n         if (indexedVariables == null) indexedVariables = new ArrayList<String>();\n     }\n \n-    public ArrayList getIndexedVariables() {\n+    public ArrayList<String> getIndexedVariables() {\n         initIndexedVariables();\n         return indexedVariables;\n     }\ndiff --git a/src/main/java/org/mvel/ast/AssignmentNode.java b/src/main/java/org/mvel/ast/AssignmentNode.java\nindex f3209bd..2fd5999 100644\n--- a/src/main/java/org/mvel/ast/AssignmentNode.java\n+++ b/src/main/java/org/mvel/ast/AssignmentNode.java\n@@ -22,6 +22,7 @@ import org.mvel.MVEL;\n import static org.mvel.MVEL.compileSetExpression;\r\n import org.mvel.compiler.CompiledSetExpression;\r\n import org.mvel.compiler.ExecutableStatement;\r\n+import org.mvel.compiler.AbstractParser;\r\n import org.mvel.integration.VariableResolverFactory;\r\n import static org.mvel.util.ArrayTools.findFirst;\r\n import static org.mvel.util.ParseTools.*;\r\n@@ -77,6 +78,10 @@ public class AssignmentNode extends ASTNode implements Assignment {\n             checkNameSafety(this.varName = new String(expr));\r\n         }\r\n \r\n+        if ((fields & COMPILE_IMMEDIATE) != 0) {\r\n+            AbstractParser.getCurrentThreadParserContext().addVariable(this.varName, egressType);\r\n+        }\r\n+\r\n         this.name = this.varName.toCharArray();\r\n     }\r\n \r\ndiff --git a/src/main/java/org/mvel/ast/DeclTypedVarNode.java b/src/main/java/org/mvel/ast/DeclTypedVarNode.java\nindex 3a2c586..93fc14b 100644\n--- a/src/main/java/org/mvel/ast/DeclTypedVarNode.java\n+++ b/src/main/java/org/mvel/ast/DeclTypedVarNode.java\n@@ -20,6 +20,7 @@ package org.mvel.ast;\n \r\n import org.mvel.integration.VariableResolverFactory;\r\n import static org.mvel.util.ParseTools.checkNameSafety;\r\n+import org.mvel.compiler.AbstractParser;\r\n \r\n /**\r\n  * @author Christopher Brock\r\n@@ -27,9 +28,13 @@ import static org.mvel.util.ParseTools.checkNameSafety;\n public class DeclTypedVarNode extends ASTNode implements Assignment {\r\n     private String name;\r\n \r\n-    public DeclTypedVarNode(String name, Class type) {\r\n+    public DeclTypedVarNode(String name, Class type, int fields) {\r\n         this.egressType = type;\r\n         checkNameSafety(this.name = name);\r\n+\r\n+        if ((fields & COMPILE_IMMEDIATE) != 0) {\r\n+            AbstractParser.getCurrentThreadParserContext().addVariable(name, egressType, true);\r\n+        }\r\n     }\r\n \r\n     public Object getReducedValueAccelerated(Object ctx, Object thisValue, VariableResolverFactory factory) {\r\ndiff --git a/src/main/java/org/mvel/ast/DeepAssignmentNode.java b/src/main/java/org/mvel/ast/DeepAssignmentNode.java\nindex 31279f3..adb567a 100644\n--- a/src/main/java/org/mvel/ast/DeepAssignmentNode.java\n+++ b/src/main/java/org/mvel/ast/DeepAssignmentNode.java\n@@ -24,6 +24,7 @@ import static org.mvel.PropertyAccessor.set;\n import org.mvel.compiler.Accessor;\r\n import org.mvel.compiler.CompiledSetExpression;\r\n import org.mvel.compiler.ExecutableStatement;\r\n+import org.mvel.compiler.AbstractParser;\r\n import org.mvel.integration.VariableResolverFactory;\r\n import static org.mvel.util.ParseTools.*;\r\n import static org.mvel.util.PropertyTools.find;\r\n@@ -64,6 +65,7 @@ public class DeepAssignmentNode extends ASTNode implements Assignment {\n \r\n         if ((fields & COMPILE_IMMEDIATE) != 0) {\r\n             set = (CompiledSetExpression) compileSetExpression(property.toCharArray());\r\n+            AbstractParser.getCurrentThreadParserContext().addVariable(name, egressType);\r\n         }\r\n     }\r\n \r\ndiff --git a/src/main/java/org/mvel/ast/Function.java b/src/main/java/org/mvel/ast/Function.java\nindex 1d3a736..6234171 100644\n--- a/src/main/java/org/mvel/ast/Function.java\n+++ b/src/main/java/org/mvel/ast/Function.java\n@@ -41,12 +41,12 @@ public class Function extends ASTNode implements Safe {\n         if ((this.name = name) == null || name.length() == 0) {\n             this.name = \"AnonFunction\" + this.hashCode();\n         }\n+\n         parmNum = (this.parameters = parseParameterList(parameters, 0, parameters.length)).length;\n \n         ParserContext old = AbstractParser.getCurrentThreadParserContext();\n \n         ParserContext ctx = new ParserContext();\n-        ctx.addIndexedVariables(this.parameters);\n         ctx.declareFunction(this);\n         ctx.setIndexAllocation(true);\n \n@@ -56,24 +56,42 @@ public class Function extends ASTNode implements Safe {\n          */\n         for (String s : this.parameters) {\n             ctx.addVariable(s, Object.class);\n+            ctx.addIndexedVariable(s);\n         }\n \n+\n         subCompileExpression(block, ctx);\n \n+        /**\n+         * Add globals as inputs\n+         */\n+        if (old.getVariables() != null) {\n+            for (String s : old.getVariables().keySet()) {\n+                ctx.addInput(s, old.getVariables().get(s));\n+            }\n+\n+            ctx.processTables();\n+        }\n+\n         ctx.addIndexedVariables(ctx.getVariables().keySet());\n \n         this.compiledBlock = (ExecutableStatement) subCompileExpression(block, ctx);\n \n         AbstractParser.setCurrentThreadParserContext(old);\n \n-        this.parameters = (String[]) ctx.getIndexedVariables().toArray(new String[ctx.getIndexedVariables().size()]);\n+        this.parameters = new String[ctx.getIndexedVariables().size()];\n+        int i = 0;\n+        for (String s : ctx.getIndexedVariables()) {\n+            this.parameters[i++] = s;\n+        }\n+\n+        //    this.parameters = (String[]) ctx.getIndexedVariables().toArray(new String[ctx.getIndexedVariables().size()]);\n \n         this.egressType = this.compiledBlock.getKnownEgressType();\n     }\n \n     public Object getReducedValueAccelerated(Object ctx, Object thisValue, VariableResolverFactory factory) {\n         if (name.length() != 0) {\n-            //findTypeInjectionResolverFactory(factory).createVariable(name, this);\n             factory.createVariable(name, this);\n         }\n         return this;\n@@ -90,7 +108,7 @@ public class Function extends ASTNode implements Safe {\n     public Object call(Object ctx, Object thisValue, VariableResolverFactory factory, Object[] parms) {\n         try {\n             if (parms != null && parms.length != 0) {\n-             //   VariableResolverFactory f = ;\n+                //   VariableResolverFactory f = ;\n                 return compiledBlock.getValue(ctx, thisValue, new FunctionVariableResolverFactory(factory, parameters, parms));\n             }\n             else {\ndiff --git a/src/main/java/org/mvel/ast/IndexedAssignmentNode.java b/src/main/java/org/mvel/ast/IndexedAssignmentNode.java\nindex 4f1a02a..84bdc83 100644\n--- a/src/main/java/org/mvel/ast/IndexedAssignmentNode.java\n+++ b/src/main/java/org/mvel/ast/IndexedAssignmentNode.java\n@@ -22,6 +22,7 @@ import org.mvel.MVEL;\n import static org.mvel.MVEL.compileSetExpression;\r\n import org.mvel.compiler.CompiledSetExpression;\r\n import org.mvel.compiler.ExecutableStatement;\r\n+import org.mvel.compiler.AbstractParser;\r\n import org.mvel.integration.VariableResolverFactory;\r\n import static org.mvel.util.ArrayTools.findFirst;\r\n import static org.mvel.util.ParseTools.*;\r\n@@ -52,6 +53,7 @@ public class IndexedAssignmentNode extends ASTNode implements Assignment {\n \r\n         int assignStart;\r\n \r\n+\r\n         if (operation != -1) {\r\n             checkNameSafety(this.name = name.trim());\r\n \r\n@@ -78,6 +80,10 @@ public class IndexedAssignmentNode extends ASTNode implements Assignment {\n         else {\r\n             checkNameSafety(this.name = new String(expr));\r\n         }\r\n+\r\n+        if ((fields & COMPILE_IMMEDIATE) != 0) {\r\n+            AbstractParser.getCurrentThreadParserContext().addVariable(name, egressType);\r\n+        }\r\n     }\r\n \r\n \r\ndiff --git a/src/main/java/org/mvel/ast/IndexedDeclTypedVarNode.java b/src/main/java/org/mvel/ast/IndexedDeclTypedVarNode.java\nindex 98f4388..c3b8161 100644\n--- a/src/main/java/org/mvel/ast/IndexedDeclTypedVarNode.java\n+++ b/src/main/java/org/mvel/ast/IndexedDeclTypedVarNode.java\n@@ -19,6 +19,7 @@\n package org.mvel.ast;\r\n \r\n import org.mvel.integration.VariableResolverFactory;\r\n+import org.mvel.compiler.AbstractParser;\r\n \r\n /**\r\n  * @author Christopher Brock\r\n@@ -28,7 +29,7 @@ public class IndexedDeclTypedVarNode extends ASTNode implements Assignment {\n \r\n     public IndexedDeclTypedVarNode(int register, Class type) {\r\n         this.egressType = type;\r\n-        this.register = register;\r\n+        this.register = register;        \r\n     }\r\n \r\n     public Object getReducedValueAccelerated(Object ctx, Object thisValue, VariableResolverFactory factory) {\r\ndiff --git a/src/main/java/org/mvel/ast/TypedVarNode.java b/src/main/java/org/mvel/ast/TypedVarNode.java\nindex 2f3963a..8fcfb24 100644\n--- a/src/main/java/org/mvel/ast/TypedVarNode.java\n+++ b/src/main/java/org/mvel/ast/TypedVarNode.java\n@@ -20,6 +20,7 @@ package org.mvel.ast;\n \r\n import static org.mvel.MVEL.eval;\r\n import org.mvel.compiler.ExecutableStatement;\r\n+import org.mvel.compiler.AbstractParser;\r\n import org.mvel.integration.VariableResolverFactory;\r\n import static org.mvel.util.ParseTools.*;\r\n import static org.mvel.util.PropertyTools.find;\r\n@@ -53,6 +54,9 @@ public class TypedVarNode extends ASTNode implements Assignment {\n \r\n         }\r\n \r\n+        if ((fields & COMPILE_IMMEDIATE) != 0) {\r\n+            AbstractParser.getCurrentThreadParserContext().addVariable(name, egressType, true);\r\n+        }\r\n     }\r\n \r\n \r\ndiff --git a/src/main/java/org/mvel/compiler/AbstractParser.java b/src/main/java/org/mvel/compiler/AbstractParser.java\nindex 852a753..cf532ba 100644\n--- a/src/main/java/org/mvel/compiler/AbstractParser.java\n+++ b/src/main/java/org/mvel/compiler/AbstractParser.java\n@@ -309,7 +309,7 @@ public class AbstractParser implements Serializable {\n                                         return lastNode = new IndexedDeclTypedVarNode(idx, Object.class);\r\n                                     }\r\n                                     else {\r\n-                                        return lastNode = new DeclTypedVarNode(name, Object.class);\r\n+                                        return lastNode = new DeclTypedVarNode(name, Object.class, fields);\r\n                                     }\r\n                                 }\r\n                         }\r\ndiff --git a/src/main/java/org/mvel/compiler/ExecutableLiteral.java b/src/main/java/org/mvel/compiler/ExecutableLiteral.java\nindex d5b881f..3a22a96 100644\n--- a/src/main/java/org/mvel/compiler/ExecutableLiteral.java\n+++ b/src/main/java/org/mvel/compiler/ExecutableLiteral.java\n@@ -64,7 +64,7 @@ public class ExecutableLiteral implements ExecutableStatement, Safe {\n     }\r\n \r\n     public Class getKnownEgressType() {\r\n-        return this.literal.getClass();\r\n+        return this.literal == null ? Object.class : this.literal.getClass();\r\n     }\r\n \r\n     public boolean isConvertableIngressEgress() {\r\ndiff --git a/src/main/java/org/mvel/compiler/ExpressionCompiler.java b/src/main/java/org/mvel/compiler/ExpressionCompiler.java\nindex c6a68c5..2043cbf 100644\n--- a/src/main/java/org/mvel/compiler/ExpressionCompiler.java\n+++ b/src/main/java/org/mvel/compiler/ExpressionCompiler.java\n@@ -257,22 +257,24 @@ public class ExpressionCompiler extends AbstractParser {\n         }\r\n \r\n         if (verifying) {\r\n-            if (tk.isAssignment()) {\r\n-                String varName = ((Assignment) tk).getAssignmentVar();\r\n-\r\n-                if (isReservedWord(varName)) {\r\n-                    addFatalError(\"invalid assignment - variable name is a reserved keyword: \" + varName);\r\n-                }\r\n-\r\n-                new ExpressionCompiler(new String(((Assignment) tk).getExpression()).trim())._compile();\r\n-\r\n-                if (((Assignment) tk).isNewDeclaration() && pCtx.hasVarOrInput(varName)) {\r\n-                    throw new CompileException(\"statically-typed variable '\" + varName + \"' defined more than once in scope\");\r\n-                }\r\n-\r\n-                pCtx.addVariable(varName, returnType = tk.getEgressType());\r\n-            }\r\n-            else if (tk.isIdentifier()) {\r\n+//            if (tk.isAssignment()) {\r\n+//                String varName = ((Assignment) tk).getAssignmentVar();\r\n+//\r\n+//                if (isReservedWord(varName)) {\r\n+//                    addFatalError(\"invalid assignment - variable name is a reserved keyword: \" + varName);\r\n+//                }\r\n+//\r\n+//                new ExpressionCompiler(new String(((Assignment) tk).getExpression()).trim())._compile();\r\n+//\r\n+//                if (((Assignment) tk).isNewDeclaration() && pCtx.hasVarOrInput(varName)) {\r\n+//                    throw new CompileException(\"statically-typed variable '\" + varName + \"' defined more than once in scope: \"\r\n+//                            + tk.getClass().getName());\r\n+//                }\r\n+//\r\n+//                pCtx.addVariable(varName, returnType = tk.getEgressType());\r\n+//            }\r\n+        //    else\r\n+            if (tk.isIdentifier()) {\r\n                 PropertyVerifier propVerifier = new PropertyVerifier(tk.getNameAsArray(), getParserContext());\r\n                 returnType = propVerifier.analyze();\r\n \r\ndiff --git a/src/main/java/org/mvel/integration/VariableResolverFactory.java b/src/main/java/org/mvel/integration/VariableResolverFactory.java\nindex 6bac0d0..898a212 100644\n--- a/src/main/java/org/mvel/integration/VariableResolverFactory.java\n+++ b/src/main/java/org/mvel/integration/VariableResolverFactory.java\n@@ -52,6 +52,8 @@ public interface VariableResolverFactory {\n \r\n     public VariableResolver createIndexedVariable(int index, String name, Object value, Class<?> typee);\r\n \r\n+    public VariableResolver setIndexedVariableResolver(int index, VariableResolver variableResolver);\r\n+\r\n \r\n     /**\r\n      * Returns the next factory in the factory chain.  MVEL uses a hierarchical variable resolution strategy,\r\ndiff --git a/src/main/java/org/mvel/integration/impl/BaseVariableResolverFactory.java b/src/main/java/org/mvel/integration/impl/BaseVariableResolverFactory.java\nindex 6b9dab6..c4f3898 100644\n--- a/src/main/java/org/mvel/integration/impl/BaseVariableResolverFactory.java\n+++ b/src/main/java/org/mvel/integration/impl/BaseVariableResolverFactory.java\n@@ -34,9 +34,6 @@ public abstract class BaseVariableResolverFactory implements VariableResolverFac\n     protected String[] indexedVariableNames;\r\n     protected VariableResolver[] indexedVariableResolvers;\r\n \r\n-    private Map<String, Integer> indexCache;\r\n-\r\n-\r\n     public VariableResolverFactory getNextFactory() {\r\n         return nextFactory;\r\n     }\r\n@@ -137,11 +134,11 @@ public abstract class BaseVariableResolverFactory implements VariableResolverFac\n         \r\n     }\r\n \r\n-    protected void setIndexedVariable(int index, VariableResolver resolver) {\r\n+    public VariableResolver setIndexedVariableResolver (int index, VariableResolver resolver) {\r\n         if (indexedVariableResolvers == null) {\r\n             indexedVariableResolvers = new VariableResolver[indexedVariableNames.length];\r\n         }\r\n-        indexedVariableResolvers[index] = resolver;\r\n+        return indexedVariableResolvers[index] = resolver;\r\n     }\r\n \r\n     public boolean isIndexedFactory() {\r\ndiff --git a/src/main/java/org/mvel/integration/impl/FunctionVariableResolverFactory.java b/src/main/java/org/mvel/integration/impl/FunctionVariableResolverFactory.java\nindex b8a60b8..676c361 100644\n--- a/src/main/java/org/mvel/integration/impl/FunctionVariableResolverFactory.java\n+++ b/src/main/java/org/mvel/integration/impl/FunctionVariableResolverFactory.java\n@@ -8,7 +8,7 @@ import java.util.HashMap;\n \n public class FunctionVariableResolverFactory extends MapVariableResolverFactory implements LocalVariableResolverFactory {\n \n-    \n+\n     public FunctionVariableResolverFactory() {\n         super(null);\n     }\n@@ -52,7 +52,6 @@ public class FunctionVariableResolverFactory extends MapVariableResolverFactory \n             throw new CompileException(\"variable already defined within scope: \" + vr.getType() + \" \" + name);\n         }\n         else {\n-            //      addResolver(name, vr = new MapVariableResolver(variables, name, type, false));\n             return createIndexedVariable(variableIndexOf(name), name, value);\n         }\n     }\n@@ -82,12 +81,22 @@ public class FunctionVariableResolverFactory extends MapVariableResolverFactory \n     }\n \n     public VariableResolver getIndexedVariableResolver(int index) {\n+        if (indexedVariableResolvers[index] == null) {\n+            /**\n+             * If the register is null, this means we need to forward-allocate the variable onto the\n+             * register table.\n+             */\n+            indexedVariableResolvers[index] = super.getVariableResolver(indexedVariableNames[index]);\n+        }\n         return indexedVariableResolvers[index];\n     }\n \n     public VariableResolver getVariableResolver(String name) {\n         int idx = variableIndexOf(name);\n         if (idx != -1) {\n+            if (indexedVariableResolvers[idx] == null) {\n+                indexedVariableResolvers[idx] = super.getVariableResolver(name);\n+            }\n             return indexedVariableResolvers[idx];\n         }\n         return super.getVariableResolver(name);\n@@ -97,6 +106,10 @@ public class FunctionVariableResolverFactory extends MapVariableResolverFactory \n         return true;\n     }\n \n+    public boolean isTarget(String name) {\n+        return variableIndexOf(name) != -1;\n+    }\n+\n     private int increaseRegisterTableSize() {\n         String[] oldNames = indexedVariableNames;\n         VariableResolver[] oldResolvers = indexedVariableResolvers;\ndiff --git a/src/main/java/org/mvel/optimizers/impl/refl/IndexedVariableAccessor.java b/src/main/java/org/mvel/optimizers/impl/refl/IndexedVariableAccessor.java\nindex 5020691..5c6d9d4 100644\n--- a/src/main/java/org/mvel/optimizers/impl/refl/IndexedVariableAccessor.java\n+++ b/src/main/java/org/mvel/optimizers/impl/refl/IndexedVariableAccessor.java\n@@ -26,14 +26,13 @@ public class IndexedVariableAccessor implements AccessorNode {\n     private AccessorNode nextNode;\r\n     private int register;\r\n \r\n-\r\n     public IndexedVariableAccessor(int register) {\r\n         this.register = register;\r\n     }\r\n \r\n     public Object getValue(Object ctx, Object elCtx, VariableResolverFactory vrf) {\r\n-        if (vrf == null)\r\n-            throw new CompileException(\"cannot access property in indexed accessor: \" + register);\r\n+//        if (vrf == null)\r\n+//            throw new CompileException(\"cannot access property in indexed accessor: \" + register);\r\n \r\n         if (nextNode != null) {\r\n             return nextNode.getValue(vrf.getIndexedVariableResolver(register).getValue(), elCtx, vrf);\r\n@@ -41,6 +40,7 @@ public class IndexedVariableAccessor implements AccessorNode {\n         else {\r\n             return vrf.getIndexedVariableResolver(register).getValue();\r\n         }\r\n+\r\n     }\r\n \r\n     public AccessorNode getNextNode() {\r\ndiff --git a/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java b/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\nindex 115fbe9..2dd7e41 100644\n--- a/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\n+++ b/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\n@@ -28,6 +28,7 @@ import org.mvel.compiler.Accessor;\n import org.mvel.compiler.AccessorNode;\r\n import org.mvel.compiler.ExecutableStatement;\r\n import org.mvel.integration.VariableResolverFactory;\r\n+import org.mvel.integration.VariableResolver;\r\n import org.mvel.optimizers.AbstractOptimizer;\r\n import org.mvel.optimizers.AccessorOptimizer;\r\n import org.mvel.optimizers.impl.refl.collection.ArrayCreator;\r\n@@ -322,10 +323,15 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n                 return this.thisRef;\r\n             }\r\n             else if (variableFactory != null && variableFactory.isResolveable(property)) {\r\n-                if (variableFactory.isIndexedFactory()) {\r\n+                if (variableFactory.isIndexedFactory() && variableFactory.isTarget(property)) {\r\n                     int idx;\r\n                     addAccessorNode(new IndexedVariableAccessor(idx = variableFactory.variableIndexOf(property)));\r\n-                    assert idx != -1;\r\n+\r\n+                    VariableResolver vr = variableFactory.getIndexedVariableResolver(idx);\r\n+                    if (vr == null) {\r\n+                        variableFactory.setIndexedVariableResolver(idx, variableFactory.getVariableResolver(property));\r\n+                    }\r\n+\r\n                     return variableFactory.getIndexedVariableResolver(idx).getValue();\r\n                 }\r\n                 else {\r\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/perftests/SimpleTests.java b/src/test/java/org/mvel/tests/perftests/SimpleTests.java\nindex 3141cd3..8ff8509 100644\n--- a/src/test/java/org/mvel/tests/perftests/SimpleTests.java\n+++ b/src/test/java/org/mvel/tests/perftests/SimpleTests.java\n@@ -18,7 +18,7 @@ public class SimpleTests {\n     public static void main(String[] args) throws IOException {\n         PrintStream ps = System.out;\n \n-       System.setOut(new PrintStream(new NullOutputStream()));\n+     //  System.setOut(new PrintStream(new NullOutputStream()));\n         try {\n             for (int i = 0; i < 10; i++) {\n                 testQuickSortMVEL(ps);\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T17:56:40.640436Z", "commit_hash": "41cafd045a24d5547458d6d281ebf22c8afe5ef5", "commit_message": "fixed\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/ast/InlineCollectionNode.java b/src/main/java/org/mvel/ast/InlineCollectionNode.java\nindex cd36d84..e4a5612 100644\n--- a/src/main/java/org/mvel/ast/InlineCollectionNode.java\n+++ b/src/main/java/org/mvel/ast/InlineCollectionNode.java\n@@ -35,10 +35,6 @@ public class InlineCollectionNode extends ASTNode {\n         super(expr, start, end, fields | INLINE_COLLECTION);\r\n     }\r\n \r\n-    public InlineCollectionNode(char[] expr, int fields) {\r\n-        //  super(expr, fields);\r\n-    }\r\n-\r\n     public Object getReducedValueAccelerated(Object ctx, Object thisValue, VariableResolverFactory factory) {\r\n         if (accessor != null) {\r\n             return accessor.getValue(ctx, thisValue, factory);\r\ndiff --git a/src/main/java/org/mvel/compiler/AbstractParser.java b/src/main/java/org/mvel/compiler/AbstractParser.java\nindex ac268a0..b50ed57 100644\n--- a/src/main/java/org/mvel/compiler/AbstractParser.java\n+++ b/src/main/java/org/mvel/compiler/AbstractParser.java\n@@ -235,7 +235,7 @@ public class AbstractParser implements Serializable {\n                      * part of an identifier, we keep capturing.\r\n                      */\r\n                     capture = true;\r\n-                    cursor++;\r\n+                    cursor++ ;\r\n                 }\r\n                 else if (capture) {\r\n                     String t;\r\n@@ -1078,7 +1078,6 @@ public class AbstractParser implements Serializable {\n             }\r\n \r\n             default: // either BLOCK_WITH or BLOCK_FOREACH\r\n-\r\n                 skipToNextTokenJunction();\r\n                 if (debugSymbols) {\r\n                     skipWhitespaceWithLineAccounting();\r\ndiff --git a/src/main/java/org/mvel/integration/impl/ClassImportResolverFactory.java b/src/main/java/org/mvel/integration/impl/ClassImportResolverFactory.java\nindex bb1c308..e87957f 100644\n--- a/src/main/java/org/mvel/integration/impl/ClassImportResolverFactory.java\n+++ b/src/main/java/org/mvel/integration/impl/ClassImportResolverFactory.java\n@@ -37,17 +37,30 @@ public class ClassImportResolverFactory extends BaseVariableResolverFactory {\n     }\r\n \r\n     public VariableResolver createVariable(String name, Object value) {\r\n-        throw new RuntimeException(\"unimplemented, please use addClass(Class)\");\r\n+//        throw new RuntimeException(\"unimplemented, please use addClass(Class)\");\r\n \r\n //        VariableResolver vr = new ClassImportResolver(name.substring(name.lastIndexOf('.')), name);\r\n //        variableResolvers.put(vr.getName(), vr);\r\n //        return vr;\r\n+\r\n+        if (nextFactory == null) {\r\n+            nextFactory = new MapVariableResolverFactory(new HashMap());\r\n+        }\r\n+\r\n+        return nextFactory.createVariable(name, value);\r\n+\r\n     }\r\n \r\n \r\n     public VariableResolver createVariable(String name, Object value, Class type) {\r\n-        throw new RuntimeException(\"attempt to created a typed import type.  this is highly redundant and more \" +\r\n-                \"importantly, not implemented.\");\r\n+//        throw new RuntimeException(\"attempt to created a typed import type.  this is highly redundant and more \" +\r\n+//                \"importantly, not implemented.\");\r\n+\r\n+        if (nextFactory == null) {\r\n+            nextFactory = new MapVariableResolverFactory(new HashMap());\r\n+        }\r\n+\r\n+        return nextFactory.createVariable(name, value);\r\n     }\r\n \r\n     public Class addClass(Class clazz) {\r\ndiff --git a/src/main/java/org/mvel/integration/impl/TypeInjectionResolverFactoryImpl.java b/src/main/java/org/mvel/integration/impl/TypeInjectionResolverFactoryImpl.java\nindex 0f7300f..601c3cd 100644\n--- a/src/main/java/org/mvel/integration/impl/TypeInjectionResolverFactoryImpl.java\n+++ b/src/main/java/org/mvel/integration/impl/TypeInjectionResolverFactoryImpl.java\n@@ -1,6 +1,7 @@\n package org.mvel.integration.impl;\n \n import org.mvel.ParserContext;\n+import org.mvel.integration.VariableResolver;\n import org.mvel.integration.VariableResolverFactory;\n \n import java.util.HashMap;\n@@ -32,6 +33,25 @@ public class TypeInjectionResolverFactoryImpl extends MapVariableResolverFactory\n         super(variables, cachingSafe);\n     }\n \n+    public VariableResolver createVariable(String name, Object value) {\n+        if (nextFactory == null) {\n+            nextFactory = new MapVariableResolverFactory(new HashMap());\n+        }\n+        /**\n+         * Delegate to the next factory.\n+         */\n+        return nextFactory.createVariable(name, value);\n+    }\n+\n+    public VariableResolver createVariable(String name, Object value, Class<?> type) {\n+        if (nextFactory == null) {\n+            nextFactory = new MapVariableResolverFactory(new HashMap());\n+        }\n+        /**\n+         * Delegate to the next factory.\n+         */\n+        return nextFactory.createVariable(name, value, type);\n+    }\n \n     public Set<String> getKnownVariables() {\n         Set<String> knownVars = new HashSet<String>();\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\nindex b388ac4..86a1a37 100644\n--- a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n@@ -883,7 +883,7 @@ public class CoreConfidenceTests extends AbstractTest {\n     }\n \n     public void testUnQualifiedStaticTyping() {\n-        assertEquals(20, testCompiledSimple(\"import java.math.BigDecimal; BigDecimal a = new BigDecimal( 10.0 ); BigDecimal b = new BigDecimal( 10.0 ); BigDecimal c = a + b; return c; \", new HashMap()));\n+        assertEquals(20.0f, testCompiledSimple(\"import java.math.BigDecimal; BigDecimal a = new BigDecimal( 10.0 ); BigDecimal b = new BigDecimal( 10.0 ); BigDecimal c = a + b; return c; \", new HashMap()));\n     }\n \n     public void testObjectCreation() {\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T18:01:42.992904Z", "commit_hash": "68d8244bcac094d2a1f44f88ebb08499ac694b6f", "commit_message": "all fixed.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/ForeachContext.java b/src/main/java/org/mvel/ForeachContext.java\nindex 5491d56..afccde7 100644\n--- a/src/main/java/org/mvel/ForeachContext.java\n+++ b/src/main/java/org/mvel/ForeachContext.java\n@@ -1,16 +1,30 @@\n /**\r\n- * \r\n+ *\r\n  */\r\n package org.mvel;\r\n \r\n import java.util.Iterator;\r\n \r\n-public class ForeachContext  {\r\n-    private String seperator; \r\n+public class ForeachContext {\r\n+    private String seperator;\r\n+\r\n+    private String[] names;\r\n+    private String[] aliases;\r\n+\r\n     private Iterator[] iter;\r\n     private int count;\r\n \r\n \r\n+    public ForeachContext() {\r\n+    }\r\n+\r\n+    public ForeachContext(String seperator, int count, String[] names, String[] aliases) {\r\n+        this.seperator = seperator;\r\n+        this.count = count;\r\n+        this.names = names;\r\n+        this.aliases = aliases;\r\n+    }\r\n+\r\n     public ForeachContext(String seperator, int count) {\r\n         this.seperator = seperator;\r\n         this.count = count;\r\n@@ -19,15 +33,15 @@ public class ForeachContext  {\n     public ForeachContext(String seperator) {\r\n         this.seperator = seperator;\r\n     }\r\n-    \r\n+\r\n     public String getSeperator() {\r\n         return this.seperator;\r\n     }\r\n-    \r\n+\r\n     public void setIterators(Iterator[] iter) {\r\n         this.iter = iter;\r\n     }\r\n-    \r\n+\r\n     public Iterator[] getItererators() {\r\n         return this.iter;\r\n     }\r\n@@ -40,8 +54,40 @@ public class ForeachContext  {\n         this.count = count;\r\n     }\r\n \r\n+    public void incrementCount() {\r\n+        this.count++;\r\n+    }\r\n+\r\n     public ForeachContext clone() {\r\n-        return new ForeachContext(seperator, count);\r\n+        return new ForeachContext(seperator, count, names, aliases);\r\n+    }\r\n+\r\n+    public String[] getNames() {\r\n+        return names;\r\n+    }\r\n+\r\n+    public void setNames(String[] names) {\r\n+        this.names = names;\r\n+    }\r\n+\r\n+    public String[] getAliases() {\r\n+        return aliases;\r\n+    }\r\n+\r\n+    public void setAliases(String[] aliases) {\r\n+        this.aliases = aliases;\r\n+    }\r\n+\r\n+    public Iterator[] getIter() {\r\n+        return iter;\r\n+    }\r\n+\r\n+    public void setIter(Iterator[] iter) {\r\n+        this.iter = iter;\r\n+    }\r\n+\r\n+\r\n+    public void setSeperator(String seperator) {\r\n+        this.seperator = seperator;\r\n     }\r\n-    \r\n }\n\\ No newline at end of file\ndiff --git a/src/main/java/org/mvel/TemplateCompiler.java b/src/main/java/org/mvel/TemplateCompiler.java\nindex 6880c43..92e90a6 100644\n--- a/src/main/java/org/mvel/TemplateCompiler.java\n+++ b/src/main/java/org/mvel/TemplateCompiler.java\n@@ -27,9 +27,7 @@ import static java.lang.Boolean.getBoolean;\n import static java.lang.Character.isWhitespace;\n import static java.lang.String.copyValueOf;\n import static java.lang.System.arraycopy;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Map;\n+import java.util.*;\n \n public class TemplateCompiler {\n     private static final boolean DEFAULT_DEBUG = getBoolean(\"mvflex.expression.debug\");\n@@ -106,31 +104,39 @@ public class TemplateCompiler {\n \n                 if (ex.getNodeType() == FOREACH) {\n                     ex.setAlias(\"item\");\n-                    ex.setName(new String(exStr));\n+                    //ex.setName(new String(exStr));\n \n-                    int capture = -1;\n+                    ForeachContext foreachContext = new ForeachContext();\n+                    List<String[]> iterators = new LinkedList<String[]>();\n+\n+                    int start = 0;\n                     for (int i = 0; i < exStr.length; i++) {\n                         switch (exStr[i]) {\n-                            case ' ':\n-                                if (capture == -1 && ((i + 3) < exStr.length)\n-                                        && exStr[i + 1] == 'a' && exStr[i + 2] == 's'\n-                                        && exStr[i + 3] == ' ') {\n+                            case ',':\n+                                iterators.add(parseAlias(exStr, start, i, iterators.size()));\n+                                start = i + 1;\n+                                break;\n+                        }\n+                    }\n+                    if (start < exStr.length) {\n+                        iterators.add(parseAlias(exStr, start, exStr.length, iterators.size()));\n+                    }\n \n-                                    ex.setName(new String(exStr, 0, i));\n+                    String[] names = new String[iterators.size()];\n+                    String[] aliases = new String[names.length];\n+                    String[] temp;\n \n-                                    capture = i += 4;\n+                    Iterator<String[]> iterator = iterators.iterator();\n+                    for (int i = 0;  iterator.hasNext(); i++) {\n+                        temp = iterator.next();\n+                        names[i] = temp[0];\n+                        aliases[i] = temp[1];\n+                    }\n \n-                                    ex.setAlias(copyValueOf(exStr, capture, exStr.length - capture));\n+                    foreachContext.setNames(names);\n+                    foreachContext.setAliases(aliases);\n \n-                                    /**\n-                                     * Scan to skip any excess whitespace.\n-                                     */\n-                                    //noinspection StatementWithEmptyBody\n-                                    while (i < exStr.length && !isWhitespace(exStr[i++])) ;\n-                                }\n-                                break;\n-                        }\n-                    }\n+                    ex.setRegister(foreachContext);\n                 }\n                 else\n                     ex.setEndPos(cursor);\n@@ -216,23 +222,26 @@ public class TemplateCompiler {\n                                 j++;\n                             }\n \n-                            if (props[j] != '\"') { //&& props[i+2] !='\\\"') {\n+                            if (props[j] != '\"' && props[j] != '\\'') { //&& props[i+2] !='\\\"') {\n                                 throw new CompileException(\"seperator is not correctly specified \\\"\" + props + \"\\\"\");\n                             }\n \n                             int k = props.length - 1;\n-                            while (k < props.length && props[k] != '\"') {\n+                            while (k < props.length && (props[k] != '\"' && props[j] != '\\'')) {\n                                 k--;\n                             }\n \n-                            if (props[k] != '\"') { //&& props[i+2] !='\\\"') {\n+                            if (props[k] != '\"' && props[j] != '\\'') { //&& props[i+2] !='\\\"') {\n                                 throw new CompileException(\"seperator is not correctly specified \\\"\" + props + \"\\\"\");\n                             }\n \n-                            e.setRegister(new ForeachContext(new String(props, j + 1, k - j - 1)));\n+                            ((ForeachContext) e.getRegister()).setSeperator(new String(props, j + 1, k - j - 1));\n+                       //     e.setRegister(new ForeachContext(new String(props, j + 1, k - j - 1)));\n                         }\n                         else {\n-                            e.setRegister(new ForeachContext(\"\"));\n+                            ((ForeachContext) e.getRegister()).setSeperator(\"\");\n+\n+                         //   e.setRegister(new ForeachContext(\"\"));\n                         }\n                     }\n \n@@ -277,6 +286,19 @@ public class TemplateCompiler {\n         return expressions;\n     }\n \n+    public static String[] parseAlias(char[] seq, int start, int end, int index) {\n+        for (int i = start; i < end; i++) {\n+            switch (seq[i])  {\n+                case ' ':\n+                    if ((i + 3) < end && seq[i + 1] == 'a' && seq[i + 2] == 's' && seq[i + 3] == ' ') {\n+                          return new String[] { new String(seq, start, i - start).trim(), new String(seq, i += 4, end - i).trim() };\n+                    }\n+            }\n+        }\n+\n+        return new String[] { new String(seq, start, end - start).trim(), index != 0 ? \"item\" + index : \"item\"};\n+    }\n+\n     public static String getNodeTypeName(int node) {\n         switch (node) {\n             case NodeType.ELSE:\ndiff --git a/src/main/java/org/mvel/TemplateInterpreter.java b/src/main/java/org/mvel/TemplateInterpreter.java\nindex 5cd8292..ac92c51 100644\n--- a/src/main/java/org/mvel/TemplateInterpreter.java\n+++ b/src/main/java/org/mvel/TemplateInterpreter.java\n@@ -36,7 +36,7 @@ import java.util.*;\n import static java.util.Collections.synchronizedMap;\n \n /**\n- * The MVEL Template Interpreter.  Naming this an \"Interpreter\" is not inaccurate.   All template expressions\n+ * The MVEL Template Interpreter.    All template expressions\n  * are pre-compiled by the the {@link TemplateCompiler} prior to being processed by this interpreter.<br/>\n  * <br/>\n  * Under normal circumstances, it is completely acceptable to execute the parser/interpreter from the static\n@@ -429,42 +429,50 @@ public class TemplateInterpreter {\n                         }\n \n                         ForeachContext foreachContext;\n+                        String[] names;\n+                        String[] aliases;\n \n                         if (!(localStack.peek() instanceof ForeachContext)) {\n-                             foreachContext = ((ForeachContext) currNode.getRegister()).clone();\n \n-                      //  if (foreachContext.getItererators() == null) {\n+                            // create a clone of the context\n+                            foreachContext = ((ForeachContext) currNode.getRegister()).clone();\n+                            names = foreachContext.getNames();\n+                            aliases = foreachContext.getAliases();\n+\n                             try {\n-                                String[] lists = getForEachSegment(currNode).split(\",\");\n-                                Iterator[] iters = new Iterator[lists.length];\n-                                for (int i = 0; i < lists.length; i++) {\n+                                Iterator[] iters = new Iterator[names.length];\n+                                for (int i = 0; i < names.length; i++) {\n                                     //noinspection unchecked\n-                                    Object listObject = new MVELInterpretedRuntime(lists[i], ctx, tokens).parse();\n+                                    Object listObject = new MVELInterpretedRuntime(names[i], ctx, tokens).parse();\n                                     if (listObject instanceof Object[]) {\n                                         listObject = Arrays.asList((Object[]) listObject);\n                                     }\n-                                    iters[i] = ((Collection) listObject).iterator();\n+\n+\n+                                    iters[i] = ((Collection) listObject).iterator(); // this throws null pointer exception in thread race\n                                 }\n \n+                                // set the newly created iterators into the context\n                                 foreachContext.setIterators(iters);\n+\n+                                // push the context onto the local stack.\n                                 localStack.push(foreachContext);\n                             }\n                             catch (ClassCastException e) {\n-                                throw new CompileException(\"expression for collections does not return a collections object: \" + new String(getSegment(currNode)));\n+                                throw new CompileException(\"expression for collections does not return a collections object: \" + new String(getSegment(currNode)), e);\n                             }\n                             catch (NullPointerException e) {\n-                                throw new CompileException(\"null returned for foreach in expression: \" + (getForEachSegment(currNode)));\n+                                throw new CompileException(\"null returned for foreach in expression: \" + (getForEachSegment(currNode)), e);\n                             }\n                         }\n-\n-                        foreachContext = (ForeachContext) localStack.peek();\n+                        else {\n+                            foreachContext = (ForeachContext) localStack.peek();\n+                      //      names = foreachContext.getNames();\n+                            aliases = foreachContext.getAliases();\n+                        }\n \n                         Iterator[] iters = foreachContext.getItererators();\n-                        String[] alias = currNode.getAlias().split(\",\");\n-                        // must trim vars\n-                        for (int i = 0; i < alias.length; i++) {\n-                            alias[i] = alias[i].trim();\n-                        }\n+\n \n                         if (iters[0].hasNext()) {\n                             push();\n@@ -473,21 +481,25 @@ public class TemplateInterpreter {\n                             for (int i = 0; i < iters.length; i++) {\n \n                                 //noinspection unchecked\n-                                tokens.put(alias[i], iters[i].next());\n+                                tokens.put(aliases[i], iters[i].next());\n                             }\n-                            if (foreachContext.getCount() != 0) {\n+\n+\n+                            int c;\n+                            tokens.put(\"i0\", c = foreachContext.getCount());\n+\n+                            if (c != 0) {\n                                 sbuf.append(foreachContext.getSeperator());\n                             }\n                             //noinspection unchecked\n-                            tokens.put(\"i0\", foreachContext.getCount());\n-                            foreachContext.setCount(foreachContext.getCount() + 1);\n+                            foreachContext.incrementCount();\n                         }\n                         else {\n                             for (int i = 0; i < iters.length; i++) {\n-                                tokens.remove(alias[i]);\n+                                tokens.remove(aliases[i]);\n                             }\n-                            foreachContext.setIterators(null);\n-                            foreachContext.setCount(0);\n+                     //       foreachContext.setIterators(null);\n+                     //       foreachContext.setCount(0);\n                             localStack.pop();\n                             exitContext();\n                         }\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/TemplateConfidenceTests.java b/src/test/java/org/mvel/tests/main/TemplateConfidenceTests.java\nindex bd1ef92..024ec5f 100644\n--- a/src/test/java/org/mvel/tests/main/TemplateConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/main/TemplateConfidenceTests.java\n@@ -207,7 +207,7 @@ public class TemplateConfidenceTests extends TestCase {\n     public void testMultiCollectionControlLoop() {\r\n         assertEquals(\"HappyHappy0Happy!Happy!1JoyJoy2Joy!Joy!3\",\r\n                 parse(\r\n-                        \"@foreach{list, array as listItem, arrayItem}\" +\r\n+                        \"@foreach{list as listItem, array as arrayItem}\" +\r\n                                 \"@{listItem}@{arrayItem}@{i0}\" +\r\n                                 \"@end{}\"\r\n                 ));\r\n@@ -216,7 +216,7 @@ public class TemplateConfidenceTests extends TestCase {\n     public void testMultiCollectionWithSingleCharSeperatorControlLoop() {\r\n         assertEquals(\"Happy0Happy,Happy!1Happy!,Joy2Joy,Joy!3Joy!\",\r\n                 parse(\r\n-                        \"@foreach{list, array as listItem, arrayItem}\" +\r\n+                        \"@foreach{list as listItem, array as arrayItem}\" +\r\n                                 \"@{listItem}@{i0}@{arrayItem}\" +\r\n                                 \"@end{\\\",\\\"  }\"\r\n                 ));\r\n@@ -225,7 +225,7 @@ public class TemplateConfidenceTests extends TestCase {\n     public void testMultiCollectionWithMultipleCharSeperatorControlLoop() {\r\n         assertEquals(\"HappyHappy,|Happy!Happy!,|JoyJoy,|Joy!Joy!\",\r\n                 parse(\r\n-                        \"@foreach{list, array as listItem, arrayItem}\" +\r\n+                        \"@foreach{list as listItem, array as arrayItem}\" +\r\n                                 \"@{listItem}@{arrayItem}\" +\r\n                                 \"@end{\\\",|\\\"  }\"\r\n                 ));\r\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T18:06:44.633709Z", "commit_hash": "e2ce60d688c243566b48f712953eceebcf394479", "commit_message": "forward porting of bug fixes from 1.2\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/ast/Assignment.java b/src/main/java/org/mvel/ast/Assignment.java\nindex 6d6e5e1..840f8fe 100644\n--- a/src/main/java/org/mvel/ast/Assignment.java\n+++ b/src/main/java/org/mvel/ast/Assignment.java\n@@ -20,6 +20,6 @@ package org.mvel.ast;\n \n public interface Assignment {\n     public String getAssignmentVar();\n-\n     public char[] getExpression();\n+    public boolean isNewDeclaration();\n }\ndiff --git a/src/main/java/org/mvel/ast/AssignmentNode.java b/src/main/java/org/mvel/ast/AssignmentNode.java\nindex 00cab6a..f3209bd 100644\n--- a/src/main/java/org/mvel/ast/AssignmentNode.java\n+++ b/src/main/java/org/mvel/ast/AssignmentNode.java\n@@ -130,5 +130,8 @@ public class AssignmentNode extends ASTNode implements Assignment {\n         return stmt;\r\n     }\r\n \r\n+    public boolean isNewDeclaration() {\r\n+        return false;\r\n+    }\r\n \r\n }\r\ndiff --git a/src/main/java/org/mvel/ast/DeclTypedVarNode.java b/src/main/java/org/mvel/ast/DeclTypedVarNode.java\nindex c343953..3a2c586 100644\n--- a/src/main/java/org/mvel/ast/DeclTypedVarNode.java\n+++ b/src/main/java/org/mvel/ast/DeclTypedVarNode.java\n@@ -57,4 +57,8 @@ public class DeclTypedVarNode extends ASTNode implements Assignment {\n     public boolean isAssignment() {\r\n         return true;\r\n     }\r\n+\r\n+    public boolean isNewDeclaration() {\r\n+        return true;\r\n+    }\r\n }\n\\ No newline at end of file\ndiff --git a/src/main/java/org/mvel/ast/DeepAssignmentNode.java b/src/main/java/org/mvel/ast/DeepAssignmentNode.java\nindex 0878df3..31279f3 100644\n--- a/src/main/java/org/mvel/ast/DeepAssignmentNode.java\n+++ b/src/main/java/org/mvel/ast/DeepAssignmentNode.java\n@@ -95,4 +95,8 @@ public class DeepAssignmentNode extends ASTNode implements Assignment {\n     public char[] getExpression() {\r\n         return stmt;\r\n     }\r\n+\r\n+    public boolean isNewDeclaration() {\r\n+        return false;\r\n+    }\r\n }\r\ndiff --git a/src/main/java/org/mvel/ast/IndexedAssignmentNode.java b/src/main/java/org/mvel/ast/IndexedAssignmentNode.java\nindex 94fdf74..4f1a02a 100644\n--- a/src/main/java/org/mvel/ast/IndexedAssignmentNode.java\n+++ b/src/main/java/org/mvel/ast/IndexedAssignmentNode.java\n@@ -150,4 +150,8 @@ public class IndexedAssignmentNode extends ASTNode implements Assignment {\n     public boolean isAssignment() {\r\n         return true;\r\n     }\r\n+\r\n+    public boolean isNewDeclaration() {\r\n+        return false;\r\n+    }\r\n }\n\\ No newline at end of file\ndiff --git a/src/main/java/org/mvel/ast/IndexedDeclTypedVarNode.java b/src/main/java/org/mvel/ast/IndexedDeclTypedVarNode.java\nindex 3cdf8ea..98f4388 100644\n--- a/src/main/java/org/mvel/ast/IndexedDeclTypedVarNode.java\n+++ b/src/main/java/org/mvel/ast/IndexedDeclTypedVarNode.java\n@@ -52,4 +52,8 @@ public class IndexedDeclTypedVarNode extends ASTNode implements Assignment {\n     public boolean isAssignment() {\r\n         return true;\r\n     }\r\n+\r\n+    public boolean isNewDeclaration() {\r\n+        return true;\r\n+    }\r\n }\n\\ No newline at end of file\ndiff --git a/src/main/java/org/mvel/ast/TypedVarNode.java b/src/main/java/org/mvel/ast/TypedVarNode.java\nindex e0003dc..2f3963a 100644\n--- a/src/main/java/org/mvel/ast/TypedVarNode.java\n+++ b/src/main/java/org/mvel/ast/TypedVarNode.java\n@@ -80,4 +80,8 @@ public class TypedVarNode extends ASTNode implements Assignment {\n     public char[] getExpression() {\r\n         return stmt;\r\n     }\r\n+\r\n+    public boolean isNewDeclaration() {\r\n+        return true;\r\n+    }\r\n }\r\ndiff --git a/src/main/java/org/mvel/compiler/ExpressionCompiler.java b/src/main/java/org/mvel/compiler/ExpressionCompiler.java\nindex a07ee19..c6a68c5 100644\n--- a/src/main/java/org/mvel/compiler/ExpressionCompiler.java\n+++ b/src/main/java/org/mvel/compiler/ExpressionCompiler.java\n@@ -266,6 +266,10 @@ public class ExpressionCompiler extends AbstractParser {\n \r\n                 new ExpressionCompiler(new String(((Assignment) tk).getExpression()).trim())._compile();\r\n \r\n+                if (((Assignment) tk).isNewDeclaration() && pCtx.hasVarOrInput(varName)) {\r\n+                    throw new CompileException(\"statically-typed variable '\" + varName + \"' defined more than once in scope\");\r\n+                }\r\n+\r\n                 pCtx.addVariable(varName, returnType = tk.getEgressType());\r\n             }\r\n             else if (tk.isIdentifier()) {\r\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\nindex a92ef5a..842bafc 100644\n--- a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n@@ -3007,6 +3007,19 @@ public class CoreConfidenceTests extends AbstractTest {\n         assertEquals(Cheese.class, expr.getKnownEgressType());\n     }\n \n+    public void testDuplicateVariableDeclaration() {\n+        ExpressionCompiler compiler = new ExpressionCompiler(\"String x = \\\"abc\\\"; Integer x = new Integer( 10 );\");\n+        ParserContext context = new ParserContext();\n+\n+        try {\n+            ExecutableStatement expr = (ExecutableStatement) compiler.compile(context);\n+            fail( \"Compilation must fail with duplicate variable declaration exception.\");\n+        } catch (CompileException ce) {\n+            // success\n+        }\n+    }\n+\n+\n }\n \n \n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T18:08:25.825091Z", "commit_hash": "ec5545a333af2f1929798e4aaa9fa81909ff9f4e", "commit_message": "fix to compiler.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/ast/LiteralNode.java b/src/main/java/org/mvel/ast/LiteralNode.java\nindex b3ad007..f211a00 100644\n--- a/src/main/java/org/mvel/ast/LiteralNode.java\n+++ b/src/main/java/org/mvel/ast/LiteralNode.java\n@@ -36,13 +36,16 @@ public class LiteralNode extends ASTNode {\n         this.fields |= LITERAL;\r\n         if (literal instanceof String) {\r\n             this.literal = ((String) literal).intern();\r\n+            this.egressType = String.class;\r\n         }\r\n         else if (literal instanceof Integer) {\r\n             this.fields |= INTEGER32;\r\n             this.intRegister = ((Integer) (this.literal = literal));\r\n+            this.egressType = Integer.class;\r\n         }\r\n         else {\r\n             this.literal = literal;\r\n+            if (this.literal != null) this.egressType = this.literal.getClass();\r\n         }\r\n     }\r\n \r\n@@ -51,9 +54,12 @@ public class LiteralNode extends ASTNode {\n         this.fields = fields;\r\n         if (literal instanceof String) {\r\n             this.literal = ((String) literal).intern();\r\n+            this.egressType = String.class;\r\n         }\r\n         else {\r\n             this.literal = valRet(literal);\r\n+            if (this.literal != null) this.egressType = this.literal.getClass();\r\n+\r\n         }\r\n     }\r\n \r\ndiff --git a/src/main/java/org/mvel/ast/Substatement.java b/src/main/java/org/mvel/ast/Substatement.java\nindex 02c7b63..9a8459b 100644\n--- a/src/main/java/org/mvel/ast/Substatement.java\n+++ b/src/main/java/org/mvel/ast/Substatement.java\n@@ -30,7 +30,10 @@ public class Substatement extends ASTNode {\n         this.name = expr;\n         this.fields = fields;\n \n-        if ((fields & COMPILE_IMMEDIATE) != 0) this.statement = (ExecutableStatement) subCompileExpression(this.name);\n+        if ((fields & COMPILE_IMMEDIATE) != 0) {\n+            this.statement = (ExecutableStatement) subCompileExpression(this.name);\n+            this.egressType = this.statement.getKnownEgressType();\n+        }\n     }\n \n     public Object getReducedValueAccelerated(Object ctx, Object thisValue, VariableResolverFactory factory) {\ndiff --git a/src/main/java/org/mvel/compiler/ExpressionCompiler.java b/src/main/java/org/mvel/compiler/ExpressionCompiler.java\nindex 5f971b3..afb5623 100644\n--- a/src/main/java/org/mvel/compiler/ExpressionCompiler.java\n+++ b/src/main/java/org/mvel/compiler/ExpressionCompiler.java\n@@ -274,7 +274,7 @@ public class ExpressionCompiler extends AbstractParser {\n             }\r\n             else if (tk.isIdentifier()) {\r\n                 PropertyVerifier propVerifier = new PropertyVerifier(tk.getNameAsArray(), getParserContext());\r\n-                returnType = propVerifier.analyze();\r\n+                tk.setEgressType(returnType = propVerifier.analyze());\r\n \r\n                 if (propVerifier.isResolvedExternally()) {\r\n                     pCtx.addInput(tk.getAbsoluteName(), returnType);\r\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\nindex 7e71cf7..4eab020 100644\n--- a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n@@ -3006,7 +3006,6 @@ public class CoreConfidenceTests extends AbstractTest {\n         ExecutableStatement expr = (ExecutableStatement) compiler.compile(context);\n \n         assertEquals(Cheese.class, expr.getKnownEgressType());\n-\n     }\n \n }\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T18:12:06.634829Z", "commit_hash": "d7ae49965e9bb9e730662b4cd60cbaf96fd04e80", "commit_message": "classloader fix.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/ast/NewObjectNode.java b/src/main/java/org/mvel/ast/NewObjectNode.java\nindex b789949..a9f3117 100644\n--- a/src/main/java/org/mvel/ast/NewObjectNode.java\n+++ b/src/main/java/org/mvel/ast/NewObjectNode.java\n@@ -11,6 +11,7 @@ import org.mvel.util.ArrayTools;\n import static org.mvel.util.ArrayTools.findFirst;\r\n import org.mvel.util.ParseTools;\r\n import static org.mvel.util.ParseTools.*;\r\n+import static org.mvel.util.ParseTools.findClass;\r\n import static org.mvel.util.PropertyTools.getBaseComponentType;\r\n \r\n import java.io.Serializable;\r\n@@ -55,10 +56,10 @@ public class NewObjectNode extends ASTNode {\n                 rewriteClassReferenceToFQCN(fields);\r\n                 if (arraySize != null) {\r\n                     try {\r\n-                        egressType = currentThread().getContextClassLoader()\r\n-                                .loadClass(repeatChar('[', arraySize.length) + \"L\" + egressType.getName() + \";\");\r\n+                        egressType = findClass(null, repeatChar('[', arraySize.length) + \"L\" + egressType.getName() + \";\");\r\n                     }\r\n                     catch (Exception e) {\r\n+                        e.printStackTrace();\r\n                         // for now, don't handle this.\r\n                     }\r\n                 }\r\n@@ -160,8 +161,7 @@ public class NewObjectNode extends ASTNode {\n \r\n                         if (arraySize != null) {\r\n                             try {\r\n-                                egressType = currentThread().getContextClassLoader()\r\n-                                        .loadClass(repeatChar('[', arraySize.length) + \"L\" + egressType.getName() + \";\");\r\n+                                egressType = findClass(factory, repeatChar('[', arraySize.length) + \"L\" + egressType.getName() + \";\");\r\n                             }\r\n                             catch (Exception e) {\r\n                                 // for now, don't handle this.\r\n@@ -175,6 +175,8 @@ public class NewObjectNode extends ASTNode {\n                 }\r\n             }\r\n \r\n+            Class cls = Class[].class;\r\n+\r\n             if (arraySize != null) {\r\n                 return (newObjectOptimizer = new NewObjectArray(getBaseComponentType(egressType.getComponentType()), compiledArraySize))\r\n                         .getValue(ctx, thisValue, factory);\r\ndiff --git a/src/main/java/org/mvel/util/ParseTools.java b/src/main/java/org/mvel/util/ParseTools.java\nindex fc27ba4..edefcce 100644\n--- a/src/main/java/org/mvel/util/ParseTools.java\n+++ b/src/main/java/org/mvel/util/ParseTools.java\n@@ -330,7 +330,17 @@ public class ParseTools {\n             return CLASS_RESOLVER_CACHE.get(classLoader).get(className);\n         }\n         else {\n-            Class cls = currentThread().getContextClassLoader().loadClass(className);\n+            Class cls;\n+            try {\n+                cls = currentThread().getContextClassLoader().loadClass(className);\n+            }\n+            catch (ClassNotFoundException e) {\n+                /**\n+                 * Now try the system classloader.\n+                 */\n+                cls = Class.forName(className);    \n+            }\n+\n             CLASS_RESOLVER_CACHE.get(classLoader).put(className, cls);\n             return cls;\n         }\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/UtilsTests.java b/src/test/java/org/mvel/tests/main/UtilsTests.java\nindex 95de8ae..ba5f90e 100644\n--- a/src/test/java/org/mvel/tests/main/UtilsTests.java\n+++ b/src/test/java/org/mvel/tests/main/UtilsTests.java\n@@ -47,4 +47,9 @@ public class UtilsTests extends TestCase {\n //            testStringBuilder();\r\n //        }\r\n //    }\r\n+\r\n+\r\n+    public static void main(String[] args) throws Exception {\r\n+        Class.forName(\"[Ljava.lang.String;\");\r\n+    }\r\n }\r\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T18:13:42.322447Z", "commit_hash": "8b0934b3125229728ab326cf53da6ec6be936ef4", "commit_message": "FIXED: MVEL-51\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/ASTNode.java b/src/main/java/org/mvel/ASTNode.java\nindex 6b44643..6b6dab5 100644\n--- a/src/main/java/org/mvel/ASTNode.java\n+++ b/src/main/java/org/mvel/ASTNode.java\n@@ -364,7 +364,7 @@ public class ASTNode implements Cloneable, Serializable {\n             for (int i = last - 1; i > 0; i--) {\n                 switch (name[i]) {\n                     case'.':\n-                        if (!meth) {\n+                        if (depth == 0 && !meth) {\n                             try {\n                                 return get(new String(name, last, name.length - last),\n                                         currentThread().getContextClassLoader().loadClass(new String(name, 0, last)), factory, thisRef);\n@@ -378,11 +378,10 @@ public class ASTNode implements Cloneable, Serializable {\n                         last = i;\n                         break;\n                     case')':\n-                        if (depth++ == 0)\n-                            meth = true;\n+                        depth++;\n                         break;\n                     case'(':\n-                        depth--;\n+                        if (--depth == 0) meth = true;\n                         break;\n                 }\n             }\ndiff --git a/src/main/java/org/mvel/util/StringAppender.java b/src/main/java/org/mvel/util/StringAppender.java\nindex ad1e34f..9af951e 100644\n--- a/src/main/java/org/mvel/util/StringAppender.java\n+++ b/src/main/java/org/mvel/util/StringAppender.java\n@@ -87,10 +87,10 @@ public class StringAppender implements CharSequence {\n         System.arraycopy(str, 0, newArray, 0, size);\r\n         str = newArray;\r\n     }\r\n-    \r\n+\r\n     public char[] getChars(int start, int count) {\r\n         char[] chars = new char[count];\r\n-        System.arraycopy( str, start, chars, 0, count );\r\n+        System.arraycopy(str, start, chars, 0, count);\r\n         return chars;\r\n     }\r\n \r\n@@ -107,6 +107,17 @@ public class StringAppender implements CharSequence {\n     }\r\n \r\n \r\n+    public void getChars(int start, int count, char[] target, int offset) {\r\n+        int delta = offset;\r\n+        for (int i = start; i < count; i++) {\r\n+            target[delta++] = str[i];\r\n+        }\r\n+    }\r\n+\r\n+    public void reset() {\r\n+        size = 0;\r\n+    }\r\n+\r\n     public char charAt(int index) {\r\n         return str[index];\r\n     }\r\n@@ -114,5 +125,7 @@ public class StringAppender implements CharSequence {\n     public CharSequence subSequence(int start, int end) {\r\n         return new String(str, start, (end - start));\r\n     }\r\n+\r\n+\r\n }\r\n \r\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\nindex 52d6054..616680d 100644\n--- a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n@@ -2472,7 +2472,7 @@ public class CoreConfidenceTests extends AbstractTest {\n \n     public void testStaticWithExpressionParam() {\n         PojoStatic pojo = new PojoStatic(\"10\");\n-        MVEL.eval(\"org.mvel.tests.main.res.AStatic.Process(value)\", pojo, new HashMap());\n+        MVEL.eval(\"org.mvel.tests.main.res.AStatic.Process(value.getClass().getName().toString())\", pojo, new HashMap());\n     }\n \n }\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T18:14:30.031671Z", "commit_hash": "db5fc3e7531766899f3515494d8358c22fd7ac24", "commit_message": "fixes: MVEL-46, MVEL-47\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/ASTNode.java b/src/main/java/org/mvel/ASTNode.java\nindex 95ea4f3..04c1192 100644\n--- a/src/main/java/org/mvel/ASTNode.java\n+++ b/src/main/java/org/mvel/ASTNode.java\n@@ -299,7 +299,7 @@ public class ASTNode implements Cloneable, Serializable {\n             }\n             else {\n                 if (isOperator()) {\n-                    throw new CompileException(\"incomplete statement\");\n+                    throw new CompileException(\"incomplete statement: \" + new String(name));\n                 }\n                 else {\n                     int mBegin = findFirst('(', name);\ndiff --git a/src/main/java/org/mvel/ast/EndOfStatement.java b/src/main/java/org/mvel/ast/EndOfStatement.java\nindex bc86cdc..13c86f4 100644\n--- a/src/main/java/org/mvel/ast/EndOfStatement.java\n+++ b/src/main/java/org/mvel/ast/EndOfStatement.java\n@@ -2,6 +2,7 @@ package org.mvel.ast;\n \r\n import org.mvel.ASTNode;\r\n import org.mvel.Operator;\r\n+import org.mvel.integration.VariableResolverFactory;\r\n \r\n /**\r\n  * @author Christopher Brock\r\n@@ -19,6 +20,14 @@ public class EndOfStatement extends ASTNode {\n     }\r\n \r\n \r\n+    public Object getReducedValueAccelerated(Object ctx, Object thisValue, VariableResolverFactory factory) {\r\n+        return null;\r\n+    }\r\n+\r\n+    public Object getReducedValue(Object ctx, Object thisValue, VariableResolverFactory factory) {\r\n+        return null;\r\n+    }\r\n+\r\n     public Integer getOperator() {\r\n         return Operator.END_OF_STMT;\r\n     }\r\ndiff --git a/src/main/java/org/mvel/ast/WithNode.java b/src/main/java/org/mvel/ast/WithNode.java\nindex fe48d4a..7a529e8 100644\n--- a/src/main/java/org/mvel/ast/WithNode.java\n+++ b/src/main/java/org/mvel/ast/WithNode.java\n@@ -60,6 +60,7 @@ public class WithNode extends BlockNode implements NestedStatement {\n \r\n         int start = 0;\r\n         String parm = \"\";\r\n+        int end = -1;\r\n \r\n         int oper = -1;\r\n         for (int i = 0; i < block.length; i++) {\r\n@@ -79,7 +80,26 @@ public class WithNode extends BlockNode implements NestedStatement {\n                     continue;\r\n \r\n                 case'/':\r\n-                    if (i < block.length && block[i + 1] == '=') {\r\n+                    if (i < block.length && block[i + 1] == '/') {\r\n+                        end = i;\r\n+                        while (i < block.length && block[i] != '\\n') i++;\r\n+                        if (parm == null) start = i;\r\n+                    }\r\n+                    else if (i < block.length && block[i + 1] == '*') {\r\n+                        end = i;\r\n+\r\n+                        while (i < block.length) {\r\n+                            switch (block[i++]) {\r\n+                                case'*':\r\n+                                    if (i < block.length) {\r\n+                                        if (block[i] == '/') break;\r\n+                                    }\r\n+                            }\r\n+                        }\r\n+\r\n+                        if (parm == null) start = i;\r\n+                    }\r\n+                    else if (i < block.length && block[i + 1] == '=') {\r\n                         oper = Operator.DIV;\r\n                     }\r\n                     continue;\r\n@@ -102,11 +122,13 @@ public class WithNode extends BlockNode implements NestedStatement {\n                     continue;\r\n \r\n                 case',':\r\n+                    if (end == -1) end = i;\r\n+\r\n                     if (parm == null) {\r\n                         parms.add(new ParmValuePair(\r\n                                 null,\r\n                                 (ExecutableStatement) subCompileExpression(\r\n-                                        createShortFormOperativeAssignment(nestParm + \".\" + parm, subset(block, start, i - start), oper)\r\n+                                        createShortFormOperativeAssignment(nestParm + \".\" + parm, subset(block, start, end - start), oper)\r\n                                 )\r\n                         ));\r\n \r\n@@ -117,7 +139,7 @@ public class WithNode extends BlockNode implements NestedStatement {\n                         parms.add(new ParmValuePair(\r\n                                 parm,\r\n                                 (ExecutableStatement) subCompileExpression(\r\n-                                        createShortFormOperativeAssignment(nestParm + \".\" + parm, subset(block, start, i - start), oper)\r\n+                                        createShortFormOperativeAssignment(nestParm + \".\" + parm, subset(block, start, end - start), oper)\r\n                                 )\r\n                         ));\r\n \r\n@@ -126,15 +148,19 @@ public class WithNode extends BlockNode implements NestedStatement {\n                         start = ++i;\r\n                     }\r\n \r\n+                    end = -1;\r\n+\r\n                     break;\r\n             }\r\n         }\r\n \r\n+        if (end == -1) end = block.length;\r\n+\r\n         if (parm != null && start != block.length) {\r\n             parms.add(new ParmValuePair(\r\n                     parm,\r\n                     (ExecutableStatement) subCompileExpression(\r\n-                            createShortFormOperativeAssignment(nestParm + \".\" + parm, subset(block, start, block.length - start), oper)\r\n+                            createShortFormOperativeAssignment(nestParm + \".\" + parm, subset(block, start, end - start), oper)\r\n \r\n                     )\r\n             ));\r\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\nindex 4ad0626..d9c3f43 100644\n--- a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n@@ -17,6 +17,7 @@ import org.mvel.optimizers.OptimizerFactory;\n import org.mvel.tests.main.res.*;\n import org.mvel.util.MethodStub;\n \n+import javax.swing.*;\n import java.awt.*;\n import java.io.Serializable;\n import static java.lang.System.currentTimeMillis;\n@@ -710,8 +711,8 @@ public class CoreConfidenceTests extends AbstractTest {\n     public void testWith2() {\n         assertEquals(\"OneTwo\", test(\n                 \"with (foo) { \\n\" +\n-                        \"aValue = 'One', \\n\" +\n-                        \"bValue='Two' \\n\" +\n+                        \"aValue = 'One', // this is a comment \\n\" +\n+                        \"bValue='Two'  // this is also a comment \\n\" +\n                         \"}; \\n\" +\n                         \"foo.aValue + foo.bValue;\"));\n     }\n@@ -2399,10 +2400,53 @@ public class CoreConfidenceTests extends AbstractTest {\n         assertFalse((Boolean) MVEL.eval(\"time ~= 'windows|unix'\", new java.util.Date()));\n     }\n \n+\n     public void testBooleanStrAppend() {\n         assertEquals(\"footrue\", test(\"\\\"foo\\\" + true\"));\n     }\n \n+    public void testFail() {\n+        Map map = new HashMap();\n+        map.put(\"a\", new JButton());\n+        map.put(\"b\", new JButton());\n+        new JButton().setToolTipText(\"\");\n+        System.out.println(MVEL.eval(\n+                \"if (a.text!=null) {\\n\" +\n+                        \"    b.text = a.text;\\n\" +\n+                        \"} else if (a.toolTipText!=null) { \\n\" +\n+                        \"    b.text = a.toolTipText;\\n\" +\n+                        \"} \" +\n+                        \"return b;\"\n+                , map\n+        ));\n+    }\n+\n+    public void testPass() {\n+        Map map = new HashMap();\n+        map.put(\"a\", new JButton());\n+        map.put(\"b\", new JButton());\n+        new JButton().setToolTipText(\"\");\n+        System.out.println(MVEL.eval(\n+                \"if (a.text!=null) {\\n\" +\n+                        \"    b.text = a.text;\\n\" +\n+                        \"} \" +\n+                        \"if (a.text!=null && a.toolTipText!=null) { \\n\" +\n+                        \"    b.text = a.toolTipText;\\n\" +\n+                        \"}\" +\n+                        \"return b;\"\n+                , map\n+        ));\n+\n+        System.out.println(MVEL.eval(\n+                \"if (a.text!=null) {\\n\" +\n+                        \"    b.text = a.text;\\n\" +\n+                        \"} else if (a.text!=null && a.toolTipText!=null) { \\n\" +\n+                        \"    b.text = a.toolTipText;\\n\" +\n+                        \"}\"\n+                , map\n+        ));\n+    }\n+\n }\n \n \n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T18:15:17.721475Z", "commit_hash": "4c260faeff8f04a9fa8c6150c33be895ba4c3cec", "commit_message": "Fixed problem in concatenation.\n", "related_issues": "", "bug_patch": "diff --git a/build-product.xml b/build-product.xml\nindex 3b89933..514b24a 100644\n--- a/build-product.xml\n+++ b/build-product.xml\n@@ -3,7 +3,7 @@\n         MVFLEX Expression Language\r\n     </description>\r\n \r\n-    <property name=\"version\" value=\"1.2.4\"/>\r\n+    <property name=\"version\" value=\"1.2.5\"/>\r\n \r\n     <property name=\"src\" location=\"src\"/>\r\n     <property name=\"build\" location=\"build\"/>\r\ndiff --git a/src/main/java/org/mvel/math/IEEEFloatingPointMath.java b/src/main/java/org/mvel/math/IEEEFloatingPointMath.java\nindex 7a6c462..d8f00cb 100644\n--- a/src/main/java/org/mvel/math/IEEEFloatingPointMath.java\n+++ b/src/main/java/org/mvel/math/IEEEFloatingPointMath.java\n@@ -4,7 +4,7 @@ import org.mvel.CompileException;\n import org.mvel.ConversionException;\r\n import static org.mvel.DataConversion.convert;\r\n import org.mvel.DataTypes;\r\n-import org.mvel.Operator;\r\n+import static org.mvel.Operator.*;\r\n import static org.mvel.util.ParseTools.resolveType;\r\n import static org.mvel.util.PropertyTools.isNumber;\r\n \r\n@@ -46,44 +46,44 @@ public class IEEEFloatingPointMath implements MathProcessor {\n \r\n     private static Object doBigDecimalArithmetic(final BigDecimal val1, final int operation, final BigDecimal val2) {\r\n         switch (operation) {\r\n-            case Operator.ADD:\r\n+            case ADD:\r\n                 return val1.add(val2);\r\n-            case Operator.DIV:\r\n+            case DIV:\r\n                 return val1.divide(val2, MATH_CONTEXT);\r\n-            case Operator.SUB:\r\n+            case SUB:\r\n                 return val1.subtract(val2);\r\n-            case Operator.MULT:\r\n+            case MULT:\r\n                 return val1.multiply(val2);\r\n-            case Operator.POWER:\r\n+            case POWER:\r\n                 return Math.pow(val1.doubleValue(), val2.doubleValue());\r\n-            case Operator.MOD:\r\n+            case MOD:\r\n                 return val1.remainder(val2);\r\n \r\n-            case Operator.GTHAN:\r\n+            case GTHAN:\r\n                 return val1.compareTo(val2) == 1 ? Boolean.TRUE : Boolean.FALSE;\r\n-            case Operator.GETHAN:\r\n+            case GETHAN:\r\n                 return val1.compareTo(val2) >= 0 ? Boolean.TRUE : Boolean.FALSE;\r\n-            case Operator.LTHAN:\r\n+            case LTHAN:\r\n                 return val1.compareTo(val2) == -1 ? Boolean.TRUE : Boolean.FALSE;\r\n-            case Operator.LETHAN:\r\n+            case LETHAN:\r\n                 return val1.compareTo(val2) <= 0 ? Boolean.TRUE : Boolean.FALSE;\r\n-            case Operator.EQUAL:\r\n+            case EQUAL:\r\n                 return val1.compareTo(val2) == 0 ? Boolean.TRUE : Boolean.FALSE;\r\n-            case Operator.NEQUAL:\r\n+            case NEQUAL:\r\n                 return val1.compareTo(val2) != 0 ? Boolean.TRUE : Boolean.FALSE;\r\n         }\r\n         return null;\r\n     }\r\n \r\n     private static Object _doOperations(final int type1, final Object val1, final int operation, final int type2, final Object val2) {\r\n-        if (operation < 10 || operation == Operator.EQUAL || operation == Operator.NEQUAL) {\r\n+        if (operation < 10 || operation == EQUAL || operation == NEQUAL) {\r\n             if (type1 > 99 && type1 == type2) {\r\n                 return doOperationsSameType(type1, val1, operation, val2);\r\n             }\r\n             else if ((type1 > 99 && (type2 > 99)) || (isNumber(val1) && isNumber(val2))) {\r\n                 return doBigDecimalArithmetic(getBigDecimalFromType(val1, type1), operation, getBigDecimalFromType(val2, type2));\r\n             }\r\n-            else if ((type1 == 15 || type2 == 15) && type1 != type2) {\r\n+            else if (operation != ADD && (type1 == 15 || type2 == 15) && type1 != type2) {\r\n                 return doOperationNonNumeric(convert(val1, Boolean.class), operation, convert(val2, Boolean.class));\r\n             }\r\n         }\r\n@@ -92,41 +92,41 @@ public class IEEEFloatingPointMath implements MathProcessor {\n \r\n     private static Object doOperationNonNumeric(final Object val1, final int operation, final Object val2) {\r\n         switch (operation) {\r\n-            case Operator.ADD:\r\n+            case ADD:\r\n                 return valueOf(val1) + valueOf(val2);\r\n \r\n-            case Operator.EQUAL:\r\n+            case EQUAL:\r\n                 return safeEquals(val2, val1) ? Boolean.TRUE : Boolean.FALSE;\r\n \r\n-            case Operator.NEQUAL:\r\n+            case NEQUAL:\r\n                 return safeNotEquals(val2, val1) ? Boolean.TRUE : Boolean.FALSE;\r\n \r\n-            case Operator.SUB:\r\n-            case Operator.DIV:\r\n-            case Operator.MULT:\r\n-            case Operator.MOD:\r\n-            case Operator.GTHAN:\r\n+            case SUB:\r\n+            case DIV:\r\n+            case MULT:\r\n+            case MOD:\r\n+            case GTHAN:\r\n                 if (val1 instanceof Comparable) {\r\n                     //noinspection unchecked\r\n                     return ((Comparable) val1).compareTo(val2) == 1 ? Boolean.TRUE : Boolean.FALSE;\r\n                 }\r\n                 break;\r\n \r\n-            case Operator.GETHAN:\r\n+            case GETHAN:\r\n                 if (val1 instanceof Comparable) {\r\n                     //noinspection unchecked\r\n                     return ((Comparable) val1).compareTo(val2) >= 0 ? Boolean.TRUE : Boolean.FALSE;\r\n                 }\r\n                 break;\r\n \r\n-            case Operator.LTHAN:\r\n+            case LTHAN:\r\n                 if (val1 instanceof Comparable) {\r\n                     //noinspection unchecked\r\n                     return ((Comparable) val1).compareTo(val2) == -1 ? Boolean.TRUE : Boolean.FALSE;\r\n                 }\r\n                 break;\r\n \r\n-            case Operator.LETHAN:\r\n+            case LETHAN:\r\n                 if (val1 instanceof Comparable) {\r\n                     //noinspection unchecked\r\n                     return ((Comparable) val1).compareTo(val2) <= 0 ? Boolean.TRUE : Boolean.FALSE;\r\n@@ -163,32 +163,32 @@ public class IEEEFloatingPointMath implements MathProcessor {\n             case DataTypes.INTEGER:\r\n             case DataTypes.W_INTEGER:\r\n                 switch (operation) {\r\n-                    case Operator.ADD:\r\n+                    case ADD:\r\n                         return ((Integer) val1) + ((Integer) val2);\r\n-                    case Operator.SUB:\r\n+                    case SUB:\r\n                         return ((Integer) val1) - ((Integer) val2);\r\n-                    case Operator.DIV:\r\n+                    case DIV:\r\n                         return new BigDecimal((Integer) val1).divide(new BigDecimal((Integer) val2), MATH_CONTEXT);\r\n-                    case Operator.MULT:\r\n+                    case MULT:\r\n                         return ((Integer) val1) * ((Integer) val2);\r\n-                    case Operator.POWER:\r\n+                    case POWER:\r\n                         double d = Math.pow((Integer) val1, (Integer) val2);\r\n                         if (d > Integer.MAX_VALUE) return d;\r\n                         else return (int) d;\r\n-                    case Operator.MOD:\r\n+                    case MOD:\r\n                         return ((Integer) val1) % ((Integer) val2);\r\n \r\n-                    case Operator.GTHAN:\r\n+                    case GTHAN:\r\n                         return ((Integer) val1) > ((Integer) val2) ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.GETHAN:\r\n+                    case GETHAN:\r\n                         return ((Integer) val1) >= ((Integer) val2) ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.LTHAN:\r\n+                    case LTHAN:\r\n                         return ((Integer) val1) < ((Integer) val2) ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.LETHAN:\r\n+                    case LETHAN:\r\n                         return ((Integer) val1) <= ((Integer) val2) ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.EQUAL:\r\n+                    case EQUAL:\r\n                         return ((Integer) val1).intValue() == ((Integer) val2).intValue() ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.NEQUAL:\r\n+                    case NEQUAL:\r\n                         return ((Integer) val1).intValue() != ((Integer) val2).intValue() ? Boolean.TRUE : Boolean.FALSE;\r\n \r\n                 }\r\n@@ -196,153 +196,153 @@ public class IEEEFloatingPointMath implements MathProcessor {\n             case DataTypes.SHORT:\r\n             case DataTypes.W_SHORT:\r\n                 switch (operation) {\r\n-                    case Operator.ADD:\r\n+                    case ADD:\r\n                         return ((Short) val1) + ((Short) val2);\r\n-                    case Operator.SUB:\r\n+                    case SUB:\r\n                         return ((Short) val1) - ((Short) val2);\r\n-                    case Operator.DIV:\r\n+                    case DIV:\r\n                         return new BigDecimal((Short) val1).divide(new BigDecimal((Short) val2), MATH_CONTEXT);\r\n-                    case Operator.MULT:\r\n+                    case MULT:\r\n                         return ((Short) val1) * ((Short) val2);\r\n-                    case Operator.POWER:\r\n+                    case POWER:\r\n                         double d = Math.pow((Short) val1, (Short) val2);\r\n                         if (d > Short.MAX_VALUE) return d;\r\n                         else return (short) d;\r\n-                    case Operator.MOD:\r\n+                    case MOD:\r\n                         return ((Short) val1) % ((Short) val2);\r\n \r\n-                    case Operator.GTHAN:\r\n+                    case GTHAN:\r\n                         return ((Short) val1) > ((Short) val2) ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.GETHAN:\r\n+                    case GETHAN:\r\n                         return ((Short) val1) >= ((Short) val2) ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.LTHAN:\r\n+                    case LTHAN:\r\n                         return ((Short) val1) < ((Short) val2) ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.LETHAN:\r\n+                    case LETHAN:\r\n                         return ((Short) val1) <= ((Short) val2) ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.EQUAL:\r\n+                    case EQUAL:\r\n                         return ((Short) val1).shortValue() == ((Short) val2).shortValue() ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.NEQUAL:\r\n+                    case NEQUAL:\r\n                         return ((Short) val1).shortValue() != ((Short) val2).shortValue() ? Boolean.TRUE : Boolean.FALSE;\r\n                 }\r\n \r\n             case DataTypes.LONG:\r\n             case DataTypes.W_LONG:\r\n                 switch (operation) {\r\n-                    case Operator.ADD:\r\n+                    case ADD:\r\n                         return ((Long) val1) + ((Long) val2);\r\n-                    case Operator.SUB:\r\n+                    case SUB:\r\n                         return ((Long) val1) - ((Long) val2);\r\n-                    case Operator.DIV:\r\n+                    case DIV:\r\n                         return new BigDecimal((Long) val1).divide(new BigDecimal((Long) val2), MATH_CONTEXT);\r\n-                    case Operator.MULT:\r\n+                    case MULT:\r\n                         return ((Long) val1) * ((Long) val2);\r\n-                    case Operator.POWER:\r\n+                    case POWER:\r\n                         double d = Math.pow((Long) val1, (Long) val2);\r\n                         if (d > Long.MAX_VALUE) return d;\r\n                         else return (long) d;\r\n-                    case Operator.MOD:\r\n+                    case MOD:\r\n                         return ((Long) val1) % ((Long) val2);\r\n \r\n-                    case Operator.GTHAN:\r\n+                    case GTHAN:\r\n                         return ((Long) val1) > ((Long) val2) ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.GETHAN:\r\n+                    case GETHAN:\r\n                         return ((Long) val1) >= ((Long) val2) ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.LTHAN:\r\n+                    case LTHAN:\r\n                         return ((Long) val1) < ((Long) val2) ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.LETHAN:\r\n+                    case LETHAN:\r\n                         return ((Long) val1) <= ((Long) val2) ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.EQUAL:\r\n+                    case EQUAL:\r\n                         return ((Long) val1).longValue() == ((Long) val2).longValue() ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.NEQUAL:\r\n+                    case NEQUAL:\r\n                         return ((Long) val1).longValue() != ((Long) val2).longValue() ? Boolean.TRUE : Boolean.FALSE;\r\n                 }\r\n \r\n             case DataTypes.DOUBLE:\r\n             case DataTypes.W_DOUBLE:\r\n                 switch (operation) {\r\n-                    case Operator.ADD:\r\n+                    case ADD:\r\n                         return ((Double) val1) + ((Double) val2);\r\n-                    case Operator.SUB:\r\n+                    case SUB:\r\n                         return ((Double) val1) - ((Double) val2);\r\n-                    case Operator.DIV:\r\n+                    case DIV:\r\n                         return new BigDecimal((Double) val1).divide(new BigDecimal((Double) val2), MATH_CONTEXT);\r\n-                    case Operator.MULT:\r\n+                    case MULT:\r\n                         return ((Double) val1) * ((Double) val2);\r\n-                    case Operator.POWER:\r\n+                    case POWER:\r\n                         return Math.pow((Double) val1, (Double) val2);\r\n-                    case Operator.MOD:\r\n+                    case MOD:\r\n                         return ((Double) val1) % ((Double) val2);\r\n \r\n-                    case Operator.GTHAN:\r\n+                    case GTHAN:\r\n                         return ((Double) val1) > ((Double) val2) ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.GETHAN:\r\n+                    case GETHAN:\r\n                         return ((Double) val1) >= ((Double) val2) ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.LTHAN:\r\n+                    case LTHAN:\r\n                         return ((Double) val1) < ((Double) val2) ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.LETHAN:\r\n+                    case LETHAN:\r\n                         return ((Double) val1) <= ((Double) val2) ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.EQUAL:\r\n+                    case EQUAL:\r\n                         return ((Double) val1).doubleValue() == ((Double) val2).doubleValue() ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.NEQUAL:\r\n+                    case NEQUAL:\r\n                         return ((Double) val1).doubleValue() != ((Double) val2).doubleValue() ? Boolean.TRUE : Boolean.FALSE;\r\n                 }\r\n \r\n             case DataTypes.FLOAT:\r\n             case DataTypes.W_FLOAT:\r\n                 switch (operation) {\r\n-                    case Operator.ADD:\r\n+                    case ADD:\r\n                         return ((Float) val1) + ((Float) val2);\r\n-                    case Operator.SUB:\r\n+                    case SUB:\r\n                         return ((Float) val1) - ((Float) val2);\r\n-                    case Operator.DIV:\r\n+                    case DIV:\r\n                         return new BigDecimal((Float) val1).divide(new BigDecimal((Float) val2), MATH_CONTEXT);\r\n-                    case Operator.MULT:\r\n+                    case MULT:\r\n                         return ((Float) val1) * ((Float) val2);\r\n-                    case Operator.POWER:\r\n+                    case POWER:\r\n                         return new BigDecimal((Float) val1).pow(new BigDecimal((Float) val2).intValue());\r\n-                    case Operator.MOD:\r\n+                    case MOD:\r\n                         return ((Float) val1) % ((Float) val2);\r\n \r\n-                    case Operator.GTHAN:\r\n+                    case GTHAN:\r\n                         return ((Float) val1) > ((Float) val2) ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.GETHAN:\r\n+                    case GETHAN:\r\n                         return ((Float) val1) >= ((Float) val2) ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.LTHAN:\r\n+                    case LTHAN:\r\n                         return ((Float) val1) < ((Float) val2) ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.LETHAN:\r\n+                    case LETHAN:\r\n                         return ((Float) val1) <= ((Float) val2) ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.EQUAL:\r\n+                    case EQUAL:\r\n                         return ((Float) val1).floatValue() == ((Float) val2).floatValue() ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.NEQUAL:\r\n+                    case NEQUAL:\r\n                         return ((Float) val1).floatValue() != ((Float) val2).floatValue() ? Boolean.TRUE : Boolean.FALSE;\r\n                 }\r\n \r\n             case DataTypes.BIG_INTEGER:\r\n                 switch (operation) {\r\n-                    case Operator.ADD:\r\n+                    case ADD:\r\n                         return ((BigInteger) val1).add(((BigInteger) val2));\r\n-                    case Operator.SUB:\r\n+                    case SUB:\r\n                         return ((BigInteger) val1).subtract(((BigInteger) val2));\r\n-                    case Operator.DIV:\r\n+                    case DIV:\r\n                         return ((BigInteger) val1).divide(((BigInteger) val2));\r\n-                    case Operator.MULT:\r\n+                    case MULT:\r\n                         return ((BigInteger) val1).multiply(((BigInteger) val2));\r\n-                    case Operator.POWER:\r\n+                    case POWER:\r\n                         return ((BigInteger) val1).pow(((BigInteger) val2).intValue());\r\n-                    case Operator.MOD:\r\n+                    case MOD:\r\n                         return ((BigInteger) val1).remainder(((BigInteger) val2));\r\n \r\n-                    case Operator.GTHAN:\r\n+                    case GTHAN:\r\n                         return ((BigInteger) val1).compareTo(((BigInteger) val2)) == 1 ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.GETHAN:\r\n+                    case GETHAN:\r\n                         return ((BigInteger) val1).compareTo(((BigInteger) val2)) >= 0 ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.LTHAN:\r\n+                    case LTHAN:\r\n                         return ((BigInteger) val1).compareTo(((BigInteger) val2)) == -1 ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.LETHAN:\r\n+                    case LETHAN:\r\n                         return ((BigInteger) val1).compareTo(((BigInteger) val2)) <= 0 ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.EQUAL:\r\n+                    case EQUAL:\r\n                         return ((BigInteger) val1).compareTo(((BigInteger) val2)) == 0 ? Boolean.TRUE : Boolean.FALSE;\r\n-                    case Operator.NEQUAL:\r\n+                    case NEQUAL:\r\n                         return ((BigInteger) val1).compareTo(((BigInteger) val2)) != 0 ? Boolean.TRUE : Boolean.FALSE;\r\n \r\n                 }\r\n@@ -350,11 +350,11 @@ public class IEEEFloatingPointMath implements MathProcessor {\n \r\n             default:\r\n                 switch (operation) {\r\n-                    case Operator.EQUAL:\r\n+                    case EQUAL:\r\n                         return safeEquals(val2, val1);\r\n-                    case Operator.NEQUAL:\r\n+                    case NEQUAL:\r\n                         return safeNotEquals(val2, val1);\r\n-                    case Operator.ADD:\r\n+                    case ADD:\r\n                         return valueOf(val1) + valueOf(val2);\r\n                 }\r\n         }\r\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\nindex 65ae542..4ad0626 100644\n--- a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n@@ -2399,6 +2399,10 @@ public class CoreConfidenceTests extends AbstractTest {\n         assertFalse((Boolean) MVEL.eval(\"time ~= 'windows|unix'\", new java.util.Date()));\n     }\n \n+    public void testBooleanStrAppend() {\n+        assertEquals(\"footrue\", test(\"\\\"foo\\\" + true\"));\n+    }\n+\n }\n \n \n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T18:16:05.326488Z", "commit_hash": "38e17d2e29a0cf44a0a578f4950168587b910029", "commit_message": "Fix: MVEL-44\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/AbstractParser.java b/src/main/java/org/mvel/AbstractParser.java\nindex 9fff7e9..05bec40 100644\n--- a/src/main/java/org/mvel/AbstractParser.java\n+++ b/src/main/java/org/mvel/AbstractParser.java\n@@ -381,7 +381,7 @@ public class AbstractParser implements Serializable {\n                             if (isAt('=', 1)) {\r\n                                 char[] stmt = subArray(start, trimLeft(cursor));\r\n                                 start = cursor += 2;\r\n-                                captureToEOT();\r\n+                                captureToEOS();\r\n                                 return lastNode = new RegExMatch(stmt, fields, subArray(start, cursor));\r\n                             }\r\n                             break;\r\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\nindex 2ab7cb2..65ae542 100644\n--- a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n@@ -1821,15 +1821,15 @@ public class CoreConfidenceTests extends AbstractTest {\n \n         assertEquals(0, MVEL.executeExpression(s, new DefaultLocalVariableResolverFactory()));\n     }\n-    \n+\n     public void testDynamicImportsWithIdentifierSameAsClassWithDiffCase() {\n         ParserContext ctx = new ParserContext();\n         ctx.addPackageImport(\"org.mvel.tests.main.res\");\n-        ctx.setStrictTypeEnforcement( false );\n+        ctx.setStrictTypeEnforcement(false);\n \n         ExpressionCompiler compiler = new ExpressionCompiler(\"bar.add(\\\"hello\\\")\");\n         Serializable s = compiler.compile(ctx);\n-    }    \n+    }\n \n     public void testTypedAssignment() {\n         assertEquals(\"foobar\", test(\"java.util.Map map = new java.util.HashMap(); map.put('conan', 'foobar'); map['conan'];\"));\n@@ -2382,6 +2382,23 @@ public class CoreConfidenceTests extends AbstractTest {\n     public void testBooleanEvaluation2() {\n         assertEquals(true, test(\"equalityCheck(1,1)||fun||ackbar\"));\n     }\n+\n+    /**\n+     * Submitted by: Dimitar Dimitrov\n+     */\n+    public void testFailing() {\n+        Map<String, Object> map = new HashMap<String, Object>();\n+        map.put(\"os\", \"windows\");\n+        assertTrue((Boolean) MVEL.eval(\"os ~= 'windows|unix'\", map));\n+    }\n+\n+    public void testSuccess() {\n+        Map<String, Object> map = new HashMap<String, Object>();\n+        map.put(\"os\", \"windows\");\n+        assertTrue((Boolean) MVEL.eval(\"'windows' ~= 'windows|unix'\", map));\n+        assertFalse((Boolean) MVEL.eval(\"time ~= 'windows|unix'\", new java.util.Date()));\n+    }\n+\n }\n \n \n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T18:19:15.755973Z", "commit_hash": "f57c54cb953e4dccfd7b4bdc4b726ace7e00650f", "commit_message": "bug fix.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/AbstractParser.java b/src/main/java/org/mvel/AbstractParser.java\nindex 57f6a7e..5ec65f2 100644\n--- a/src/main/java/org/mvel/AbstractParser.java\n+++ b/src/main/java/org/mvel/AbstractParser.java\n@@ -959,7 +959,12 @@ public class AbstractParser implements Serializable {\n         }\r\n         else if (isFlag(ASTNode.BLOCK_FOREACH) || isFlag(ASTNode.BLOCK_WITH)) {\r\n             skipToNextTokenJunction();\r\n-            skipWhitespace();\r\n+            if (debugSymbols) {\r\n+                skipWhitespaceWithLineAccounting();\r\n+            }\r\n+            else {\r\n+                skipWhitespace();\r\n+            }\r\n             return _captureBlock(null, expr, true);\r\n         }\r\n \r\n@@ -972,9 +977,22 @@ public class AbstractParser implements Serializable {\n         int endCond = 0;\r\n \r\n         if (cond) {\r\n-            endCond = cursor = balancedCapture(expr, startCond = cursor, '(');\r\n-            startCond++;\r\n-            cursor++;\r\n+            if (debugSymbols) {\r\n+                int[] cap = balancedCaptureWithLineAccounting(expr, startCond = cursor, '(');\r\n+                endCond = cursor = cap[0];\r\n+\r\n+                startCond++;\r\n+                cursor++;\r\n+\r\n+                line = getParserContext().getLineCount();\r\n+                line += cap[1];\r\n+                getParserContext().setLineCount(line);\r\n+            }\r\n+            else {\r\n+                endCond = cursor = balancedCapture(expr, startCond = cursor, '(');\r\n+                startCond++;\r\n+                cursor++;\r\n+            }\r\n         }\r\n \r\n         int blockStart;\r\n@@ -987,9 +1005,23 @@ public class AbstractParser implements Serializable {\n         }\r\n         else if (expr[cursor] == '{') {\r\n             blockStart = cursor;\r\n-            if ((blockEnd = cursor = balancedCapture(expr, cursor, '{')) == -1) {\r\n+\r\n+            if (debugSymbols) {\r\n+                int[] cap = balancedCaptureWithLineAccounting(expr, cursor, '{');\r\n+                if (cap[0] == -1) {\r\n+                    throw new CompileException(\"unbalanced braces { }\", expr, cursor);\r\n+                }\r\n+\r\n+                blockEnd = cursor = cap[0];\r\n+\r\n+                line = getParserContext().getLineCount();\r\n+                line += cap[1];\r\n+                getParserContext().setLineCount(line);\r\n+            }\r\n+            else if ((blockEnd = cursor = balancedCapture(expr, cursor, '{')) == -1) {\r\n                 throw new CompileException(\"unbalanced braces { }\", expr, cursor);\r\n             }\r\n+\r\n         }\r\n         else {\r\n             blockStart = cursor - 1;\r\ndiff --git a/src/main/java/org/mvel/util/ParseTools.java b/src/main/java/org/mvel/util/ParseTools.java\nindex bd7e82e..379c26d 100644\n--- a/src/main/java/org/mvel/util/ParseTools.java\n+++ b/src/main/java/org/mvel/util/ParseTools.java\n@@ -912,6 +912,57 @@ public class ParseTools {\n         return -1;\n     }\n \n+    public static int[] balancedCaptureWithLineAccounting(char[] chars, int start, char type) {\n+        int depth = 1;\n+        char term = type;\n+        switch (type) {\n+            case'[':\n+                term = ']';\n+                break;\n+            case'{':\n+                term = '}';\n+                break;\n+            case'(':\n+                term = ')';\n+                break;\n+        }\n+\n+        if (type == term) {\n+            for (start++; start < chars.length; start++) {\n+                if (chars[start] == type) {\n+                    return new int[]{start, 0};\n+                }\n+            }\n+        }\n+        else {\n+            int lines = 0;\n+\n+            for (start++; start < chars.length; start++) {\n+                if (isWhitespace(chars[start])) {\n+                    switch (chars[start]) {\n+                        case'\\r':\n+                            continue;\n+                        case'\\n':\n+                            lines++;\n+                    }\n+                }\n+\n+                else if (chars[start] == '\\'' || chars[start] == '\"') {\n+                    start = captureStringLiteral(chars[start], chars, start, chars.length);\n+                }\n+                else if (chars[start] == type) {\n+                    depth++;\n+                }\n+                else if (chars[start] == term && --depth == 0) {\n+                    return new int[]{start, lines};\n+                }\n+\n+            }\n+        }\n+\n+        return new int[]{-1, 0};\n+    }\n+\n     public static String handleStringEscapes(char[] input) {\n         int escapes = 0;\n         for (int i = 0; i < input.length; i++) {\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\nindex 9022157..cb9d218 100644\n--- a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n@@ -965,15 +965,17 @@ public class CoreConfidenceTests extends AbstractTest {\n         assertEquals(4, count);\n \n     }\n-    \n+\n     public void testBreakpointsAcrossWith() {\n         String line1 = \"System.out.println( \\\"a1\\\" );\\n\";\n         String line2 = \"c = new Cheese();\\n\";\n         String line3 = \"with ( c ) { type = 'cheddar',\\n\" +\n-                       \"             price = 10 };\\n\";\n+                \"             price = 10 };\\n\";\n         String line4 = \"System.out.println( \\\"a1\\\" );\\n\";\n         String expr = line1 + line2 + line3 + line4;\n \n+        System.out.println(expr);\n+\n         ExpressionCompiler compiler = new ExpressionCompiler(expr);\n         //      compiler.setDebugSymbols(true);\n \n@@ -997,7 +999,7 @@ public class CoreConfidenceTests extends AbstractTest {\n         }\n         assertEquals(5, count);\n \n-    }    \n+    }\n \n \n     public void testBreakpointsAcrossComments() {\n@@ -2217,6 +2219,54 @@ public class CoreConfidenceTests extends AbstractTest {\n         assertEquals(42, innerMap.get(\"foo\"));\n     }\n \n+\n+    private HashMap<String, Object> context = new HashMap<String, Object>();\n+\n+\n+    public void before() {\n+        HashMap<String, Object> map = new HashMap<String, Object>();\n+\n+        MyBean bean = new MyBean();\n+        bean.setVar(4);\n+\n+        map.put(\"bean\", bean);\n+        context.put(\"map\", map);\n+    }\n+\n+\n+    public void testDeepProperty() {\n+\n+        before();\n+        Serializable compiled = MVEL.compileExpression(\"map.bean.var\");\n+\n+        Object obj = MVEL.executeExpression(compiled, context);\n+        assertEquals(4, obj);\n+    }\n+\n+\n+    public void testDeepProperty2() {\n+        before();\n+\n+        Serializable compiled = MVEL.compileExpression(\"map.bean.getVar()\");\n+\n+        Object obj = MVEL.executeExpression(compiled, context);\n+        assertEquals(4, obj);\n+    }\n+\n+\n+    public class MyBean {\n+        int var;\n+\n+        public int getVar() {\n+            return var;\n+        }\n+\n+        public void setVar(int var) {\n+            this.var = var;\n+        }\n+    }\n+\n+\n }\n \n \n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T18:20:49.790431Z", "commit_hash": "ef5129565b1c03c3573aaea70ba9ee8cf769bb51", "commit_message": "minor regression fix, more unit tests added.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/AbstractParser.java b/src/main/java/org/mvel/AbstractParser.java\nindex 064e54c..1b3c13c 100644\n--- a/src/main/java/org/mvel/AbstractParser.java\n+++ b/src/main/java/org/mvel/AbstractParser.java\n@@ -966,7 +966,8 @@ public class AbstractParser implements Serializable {\n         int endCond = 0;\r\n \r\n         if (cond) {\r\n-            endCond = cursor = balancedCapture(expr, startCond = ++cursor, '(');\r\n+            endCond = cursor = balancedCapture(expr, startCond = cursor, '(');\r\n+            startCond++;\r\n             cursor++;\r\n         }\r\n \r\ndiff --git a/src/main/java/org/mvel/MVEL.java b/src/main/java/org/mvel/MVEL.java\nindex 9dcf13d..b559daa 100644\n--- a/src/main/java/org/mvel/MVEL.java\n+++ b/src/main/java/org/mvel/MVEL.java\n@@ -89,6 +89,10 @@ public class MVEL {\n         return OPTIMIZER;\n     }\n \n+    public static Object eval(String expression) {\n+        return new MVELInterpretedRuntime(expression).parse();\n+    }\n+\n     public static Object eval(String expression, Object ctx) {\n         return new MVELInterpretedRuntime(expression, ctx).parse();\n     }\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\nindex 8a8bceb..0a185d2 100644\n--- a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n@@ -688,7 +688,7 @@ public class CoreConfidenceTests extends AbstractTest {\n         assertEquals(\"Foo\", test(\"if (false) return 'Bar'; else return 'Foo';\"));\n     }\n \n-    public void testForeEach2() {\n+    public void testForEach2() {\n         assertEquals(6, test(\"total = 0; a = {1,2,3}; foreach(item : a) { total += item }; total\"));\n     }\n \n@@ -2091,6 +2091,31 @@ public class CoreConfidenceTests extends AbstractTest {\n         assertEquals(\"foobar\", test(\"Foo = String; new Foo('foobar')\"));\n     }\n \n+    public void testRandomExpression1() {\n+        assertEquals(\"HelloWorld\", test(\"if ((x15 = foo.bar) == foo.bar && x15 == foo.bar) { return 'HelloWorld'; } else { return 'GoodbyeWorld' } \"));\n+    }\n+\n+    public void testRandomExpression2() {\n+        assertEquals(11, test(\"counterX = 0; foreach (item:{1,2,3,4,5,6,7,8,9,10}) { counterX++; }; return counterX + 1;\"));\n+    }\n+\n+    public void testRandomExpression3() {\n+        assertEquals(0, test(\"counterX = 10; foreach (item:{1,1,1,1,1,1,1,1,1,1}) { counterX -= item; } return counterX;\"));\n+    }\n+\n+    public void testRandomExpression4() {\n+        assertEquals(true, test(\"result = org.mvel.MVEL.eval('10 * 3'); result == (10 * 3);\"));\n+    }\n+\n+    public void testRandomExpression5() {\n+        assertEquals(true, test(\"FooClassRef = foo.getClass(); fooInst = new FooClassRef(); name = org.mvel.MVEL.eval('name', fooInst); return name == 'dog'\"));\n+    }\n+\n+    public void testRandomExpression6() {\n+        assertEquals(500, test(\"exprString = '250' + ' ' + '*' + ' ' + '2'; compiledExpr = org.mvel.MVEL.compileExpression(exprString);\" +\n+                \" return org.mvel.MVEL.executeExpression(compiledExpr);\"));\n+    }\n+\n //    public void testSwing() {\n //        test(\"import javax.swing.JFrame;\\n\" +\n //                \"import javax.swing.JLabel;\\n\" +\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T18:23:36.357165Z", "commit_hash": "b131aedad78eb708d8461c44cc0c5fd7324b8454", "commit_message": "additional fixes.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/CompiledExpression.java b/src/main/java/org/mvel/CompiledExpression.java\nindex a59b5b0..096900a 100644\n--- a/src/main/java/org/mvel/CompiledExpression.java\n+++ b/src/main/java/org/mvel/CompiledExpression.java\n@@ -31,10 +31,11 @@ public class CompiledExpression implements Serializable, ExecutableStatement {\n     private ASTIterator tokens;\n \n     private Class knownEgressType;\n-    private Class knownIngressType;     \n+    private Class knownIngressType;\n \n     private boolean convertableIngressEgress;\n     private boolean optimized = false;\n+    private boolean importInjectionRequired = false;\n \n     private Class<? extends AccessorOptimizer> accessorOptimizer;\n \n@@ -43,7 +44,7 @@ public class CompiledExpression implements Serializable, ExecutableStatement {\n     private ParserContext parserContext;\n \n     public CompiledExpression(ASTIterator astMap, String sourceName) {\n-       this.tokens = astMap;\n+        this.tokens = astMap;\n         this.sourceName = sourceName;\n     }\n \n@@ -98,8 +99,8 @@ public class CompiledExpression implements Serializable, ExecutableStatement {\n         return handleParserEgress(execute(false, this, staticContext, factory), false);\n     }\n \n-    public Object getDirectValue(Object staticContext, VariableResolverFactory factory) {    \n-         return execute(false, this, staticContext, factory);\n+    public Object getDirectValue(Object staticContext, VariableResolverFactory factory) {\n+        return execute(false, this, staticContext, factory);\n     }\n \n     private void setupOptimizers() {\n@@ -128,7 +129,6 @@ public class CompiledExpression implements Serializable, ExecutableStatement {\n         this.accessorOptimizer = accessorOptimizer;\n     }\n \n-\n     public String getSourceName() {\n         return sourceName;\n     }\n@@ -146,9 +146,19 @@ public class CompiledExpression implements Serializable, ExecutableStatement {\n     }\n \n     public void setParserContext(ParserContext parserContext) {\n-        this.parserContext = parserContext;\n+        if ((this.parserContext = parserContext) != null) {\n+            this.importInjectionRequired = this.parserContext.getImports() != null;\n+        }\n+    }\n+\n+\n+    public boolean isImportInjectionRequired() {\n+        return importInjectionRequired;\n     }\n \n+    public void setImportInjectionRequired(boolean importInjectionRequired) {\n+        this.importInjectionRequired = importInjectionRequired;\n+    }\n \n     public Object setValue(Object ctx, Object elCtx, VariableResolverFactory variableFactory, Object value) {\n         return null;\ndiff --git a/src/main/java/org/mvel/ExpressionCompiler.java b/src/main/java/org/mvel/ExpressionCompiler.java\nindex e137e26..adb1374 100644\n--- a/src/main/java/org/mvel/ExpressionCompiler.java\n+++ b/src/main/java/org/mvel/ExpressionCompiler.java\n@@ -35,7 +35,8 @@ public class ExpressionCompiler extends AbstractParser {\n         newContext(ctx);\r\n \r\n         CompiledExpression c = _compile();\r\n-    //    c.setParserContext(pCtx);\r\n+\r\n+        removeContext();\r\n \r\n         if (pCtx.isFatalError()) {\r\n             contextControl(REMOVE, null, null);\r\n@@ -187,7 +188,7 @@ public class ExpressionCompiler extends AbstractParser {\n             CompiledExpression ce = new CompiledExpression(optimizeAST(astLinkedList, secondPassOptimization), getCurrentSourceFileName());\r\n             ce.setKnownEgressType(returnType);\r\n             ce.setParserContext(pCtx);\r\n-            \r\n+\r\n             return ce;\r\n \r\n         }\r\ndiff --git a/src/main/java/org/mvel/MVEL.java b/src/main/java/org/mvel/MVEL.java\nindex 4121979..9dcf13d 100644\n--- a/src/main/java/org/mvel/MVEL.java\n+++ b/src/main/java/org/mvel/MVEL.java\n@@ -19,8 +19,8 @@\n \n package org.mvel;\n \n-import static org.mvel.MVELRuntime.execute;\n import static org.mvel.DataConversion.convert;\n+import static org.mvel.MVELRuntime.execute;\n import org.mvel.integration.Interceptor;\n import org.mvel.integration.VariableResolverFactory;\n import org.mvel.integration.impl.MapVariableResolverFactory;\n@@ -348,34 +348,34 @@ public class MVEL {\n         }\n     }\n \n-    public static Object executeSerializedDebugger(CompiledExpression expression, Object ctx, VariableResolverFactory vars) {\n-        try {\n-            if (expression.getParserContext().getImports() != null) {\n-                return handleParserEgress(execute(true, expression, ctx, new MapVariableResolverFactory(expression.getParserContext().getImports(), vars)), false);\n-            }\n-            else {\n-                return handleParserEgress(execute(true, expression, ctx, vars), false);\n-            }\n-        }\n-        catch (EndWithValue e) {\n-            return handleParserEgress(e.getValue(), false);\n-        }\n-    }\n-\n-\n-    public static Object executeSerializedExpression(CompiledExpression expression, Object ctx, VariableResolverFactory vars) {\n-        try {\n-            if (expression.getParserContext().getImports() != null) {\n-                return handleParserEgress(execute(false, expression, ctx, new MapVariableResolverFactory(expression.getParserContext().getImports(), vars)), false);\n-            }\n-            else {\n-                return handleParserEgress(execute(false, expression, ctx, vars), false);\n-            }\n-        }\n-        catch (EndWithValue e) {\n-            return handleParserEgress(e.getValue(), false);\n-        }\n-    }\n+//    public static Object executeSerializedDebugger(CompiledExpression expression, Object ctx, VariableResolverFactory vars) {\n+//        try {\n+//            if (expression.getParserContext().getImports() != null) {\n+//                return handleParserEgress(execute(true, expression, ctx, new MapVariableResolverFactory(expression.getParserContext().getImports(), vars)), false);\n+//            }\n+//            else {\n+//                return handleParserEgress(execute(true, expression, ctx, vars), false);\n+//            }\n+//        }\n+//        catch (EndWithValue e) {\n+//            return handleParserEgress(e.getValue(), false);\n+//        }\n+//    }\n+//\n+//\n+//    public static Object executeSerializedExpression(CompiledExpression expression, Object ctx, VariableResolverFactory vars) {\n+//        try {\n+//            if (expression.getParserContext().getImports() != null) {\n+//                return handleParserEgress(execute(false, expression, ctx, new MapVariableResolverFactory(expression.getParserContext().getImports(), vars)), false);\n+//            }\n+//            else {\n+//                return handleParserEgress(execute(false, expression, ctx, vars), false);\n+//            }\n+//        }\n+//        catch (EndWithValue e) {\n+//            return handleParserEgress(e.getValue(), false);\n+//        }\n+//    }\n \n     @SuppressWarnings({\"unchecked\"})\n     public static <T> T eval(char[] expression, Object ctx, Map vars, Class<T> toType) {\ndiff --git a/src/main/java/org/mvel/MVELRuntime.java b/src/main/java/org/mvel/MVELRuntime.java\nindex 2b905f3..d236325 100644\n--- a/src/main/java/org/mvel/MVELRuntime.java\n+++ b/src/main/java/org/mvel/MVELRuntime.java\n@@ -7,6 +7,7 @@ import org.mvel.ast.LineLabel;\n import org.mvel.debug.Debugger;\r\n import org.mvel.debug.DebuggerContext;\r\n import org.mvel.integration.VariableResolverFactory;\r\n+import org.mvel.integration.impl.MapVariableResolverFactory;\r\n import org.mvel.util.ExecutionStack;\r\n import static org.mvel.util.ParseTools.containsCheck;\r\n import static org.mvel.util.PropertyTools.isEmpty;\r\n@@ -39,6 +40,10 @@ public class MVELRuntime {\n     public static Object execute(boolean debugger, CompiledExpression expression, Object ctx, VariableResolverFactory variableFactory) {\r\n         final ASTLinkedList node = new ASTLinkedList(expression.getTokens().firstNode());\r\n \r\n+        if (expression.isImportInjectionRequired()) {\r\n+            variableFactory = new MapVariableResolverFactory(expression.getParserContext().getImports(), variableFactory);\r\n+        }\r\n+\r\n         Stack stk = new ExecutionStack();\r\n         Object v1, v2;\r\n \r\n@@ -215,9 +220,9 @@ public class MVELRuntime {\n \r\n     /**\r\n      * Register a debugger breakpoint.\r\n-     * \r\n+     *\r\n      * @param source - the source file the breakpoint is registered in\r\n-     * @param line - the line number of the breakpoint\r\n+     * @param line   - the line number of the breakpoint\r\n      */\r\n     public static void registerBreakpoint(String source, int line) {\r\n         ensureDebuggerContext();\r\n@@ -228,7 +233,7 @@ public class MVELRuntime {\n      * Remove a specific breakpoint.\r\n      *\r\n      * @param source - the source file the breakpoint is registered in\r\n-     * @param line - the line number of the breakpoint to be removed\r\n+     * @param line   - the line number of the breakpoint to be removed\r\n      */\r\n     public static void removeBreakpoint(String source, int line) {\r\n         if (hasDebuggerContext()) {\r\n@@ -262,6 +267,7 @@ public class MVELRuntime {\n      * Sets the Debugger instance to handle breakpoints.   A debugger may only be registered once per thread.\r\n      * Calling this method more than once will result in the second and subsequent calls to simply fail silently.\r\n      * To re-register the Debugger, you must call {@link #resetDebugger}\r\n+     *\r\n      * @param debugger - debugger instance\r\n      */\r\n     public static void setThreadDebugger(Debugger debugger) {\r\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/AbstractTest.java b/src/test/java/org/mvel/tests/main/AbstractTest.java\nindex 02c2643..94b7498 100644\n--- a/src/test/java/org/mvel/tests/main/AbstractTest.java\n+++ b/src/test/java/org/mvel/tests/main/AbstractTest.java\n@@ -1,12 +1,12 @@\n package org.mvel.tests.main;\n \n import junit.framework.TestCase;\n+import org.mvel.CompiledExpression;\n import org.mvel.ExpressionCompiler;\n import org.mvel.MVEL;\n import org.mvel.ParserContext;\n-import org.mvel.CompiledExpression;\n-import org.mvel.integration.impl.MapVariableResolverFactory;\n import org.mvel.debug.DebugTools;\n+import org.mvel.integration.impl.MapVariableResolverFactory;\n import org.mvel.optimizers.OptimizerFactory;\n import org.mvel.tests.main.res.*;\n import org.mvel.util.StringAppender;\n@@ -129,16 +129,20 @@ public abstract class AbstractTest extends TestCase {\n             failErrors.append(writer.toCharArray());\n         }\n \n-\n         if (first != null && !first.getClass().isArray()) {\n             if (!first.equals(second)) {\n+                System.out.println(failErrors.toString());\n+\n                 throw new AssertionError(\"Different result from test 1 and 2 (Compiled Re-Run / JIT) [first: \"\n                         + String.valueOf(first) + \"; second: \" + String.valueOf(second) + \"]\");\n             }\n \n             if (!first.equals(third)) {\n+                System.out.println(failErrors.toString());\n+\n+\n                 throw new AssertionError(\"Different result from test 1 and 3 (Compiled to Interpreted) [first: \" +\n-                        String.valueOf(first) + \" (\" + first.getClass().getName() + \"); third: \" + String.valueOf(third) + \" (\" + (second != null ? first.getClass().getName() : \"null\") + \")]\");\n+                        String.valueOf(first) + \" (\" + first.getClass().getName() + \"); third: \" + String.valueOf(third) + \" (\" + (third != null ? third.getClass().getName() : \"null\") + \")]\");\n             }\n         }\n \n@@ -235,7 +239,7 @@ public abstract class AbstractTest extends TestCase {\n         }\n \n         try {\n-            eighth = MVEL.executeSerializedExpression((CompiledExpression) serializationTest(compiledD), base, new MapVariableResolverFactory(map));\n+            eighth = MVEL.executeExpression((CompiledExpression) serializationTest(compiledD), base, new MapVariableResolverFactory(map));\n         }\n         catch (Exception e) {\n             if (failErrors == null) failErrors = new StringAppender();\n@@ -255,7 +259,6 @@ public abstract class AbstractTest extends TestCase {\n         }\n \n \n-\n         if (failErrors != null) {\n             System.out.println(DebugTools.decompile(compiledD));\n             throw new AssertionError(\"Detailed Failure Report:\\n\" + failErrors.toString());\ndiff --git a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\nindex fc53747..ac0640f 100644\n--- a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n@@ -1918,7 +1918,7 @@ public class CoreConfidenceTests extends AbstractTest {\n         CompiledExpression s = compiler.compile(ctx);\n         compiler.removeParserContext();\n \n-        System.out.println(MVEL.executeSerializedExpression(s, null, null));\n+        System.out.println(MVEL.executeExpression(s));\n     }\n \n //    public void testSwing() {\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T18:40:42.053587Z", "commit_hash": "9a41ef646e7390648f99a14a57e749a39cf38bfa", "commit_message": "regression in token generation broken across lines fixed.\n", "related_issues": "", "bug_patch": "diff --git a/README.TXT b/README.TXT\nindex ca4ca10..48d8dfd 100644\n--- a/README.TXT\n+++ b/README.TXT\n@@ -14,7 +14,7 @@ This version of MVEL is a beta, pre-release version, which may contain unknown p\n any problems or bugs in MVEL, please report them promptly to our issue tracking system located at:\r\n http://jira.codehaus.org/browse/MVEL and we will deal with them quickly.\r\n \r\n-* Note that all of the convenience methods have been moved from the class org.mvel.ExpressionParser to the class\r\n+* Note that all of the convenience methods have been moved from the class org.mvel.MVELInterpretedRuntime to the class\r\n   org.mvel.MVEL\r\n \r\n   \n\\ No newline at end of file\ndiff --git a/src/main/java/org/mvel/AbstractParser.java b/src/main/java/org/mvel/AbstractParser.java\nindex 0accce1..fa14782 100644\n--- a/src/main/java/org/mvel/AbstractParser.java\n+++ b/src/main/java/org/mvel/AbstractParser.java\n@@ -136,6 +136,12 @@ public class AbstractParser implements Serializable {\n         }\r\n     }\r\n \r\n+    protected ASTNode nextTokenSkipSymbols() {\r\n+        ASTNode n = nextToken();\r\n+        if (n != null && n.getFields() == -1) n = nextToken();\r\n+        return n;\r\n+    }\r\n+\r\n     /**\r\n      * Retrieve the next token in the expression.\r\n      *\r\ndiff --git a/src/main/java/org/mvel/ExpressionCompiler.java b/src/main/java/org/mvel/ExpressionCompiler.java\nindex 49487ba..599ae66 100644\n--- a/src/main/java/org/mvel/ExpressionCompiler.java\n+++ b/src/main/java/org/mvel/ExpressionCompiler.java\n@@ -93,14 +93,14 @@ public class ExpressionCompiler extends AbstractParser {\n                  * reducing for certain literals like, 'this', ternary and ternary else.\r\n                  */\r\n                 if (tk.isLiteral() && tk.getLiteralValue() != LITERALS.get(\"this\")) {\r\n-                    if ((tkOp = nextToken()) != null && tkOp.isOperator()\r\n+                    if ((tkOp = nextTokenSkipSymbols()) != null && tkOp.isOperator()\r\n                             && !tkOp.isOperator(Operator.TERNARY) && !tkOp.isOperator(Operator.TERNARY_ELSE)) {\r\n \r\n                         /**\r\n                          * If the next token is ALSO a literal, then we have a candidate for a compile-time literal\r\n                          * reduction.\r\n                          */\r\n-                        if ((tkLA = nextToken()) != null && tkLA.isLiteral()) {\r\n+                        if ((tkLA = nextTokenSkipSymbols()) != null && tkLA.isLiteral()) {\r\n                             stk.push(tk.getLiteralValue(), tkLA.getLiteralValue(), tkOp.getLiteralValue());\r\n \r\n                             /**\r\n@@ -113,7 +113,7 @@ public class ExpressionCompiler extends AbstractParser {\n                             /**\r\n                              * Now we need to check to see if this is actually a continuing reduction.\r\n                              */\r\n-                            while ((tkOp2 = nextToken()) != null) {\r\n+                            while ((tkOp2 = nextTokenSkipSymbols()) != null) {\r\n                                 if (!tkOp2.isOperator(tkOp.getOperator())) {\r\n                                     /**\r\n                                      * We can't continue any further because we are dealing with\r\n@@ -123,7 +123,7 @@ public class ExpressionCompiler extends AbstractParser {\n                                     astLinkedList.addTokenNode(verify(pCtx, tkOp2));\r\n                                     break;\r\n                                 }\r\n-                                else if ((tkLA2 = nextToken()) != null\r\n+                                else if ((tkLA2 = nextTokenSkipSymbols()) != null\r\n                                         && tkLA2.isLiteral()) {\r\n \r\n                                     stk.push(tkLA2.getLiteralValue(), tkOp2.getLiteralValue());\r\ndiff --git a/src/main/java/org/mvel/ExpressionParser.java b/src/main/java/org/mvel/ExpressionParser.java\ndeleted file mode 100644\nindex 86f9d06..0000000\n--- a/src/main/java/org/mvel/ExpressionParser.java\n+++ /dev/null\n@@ -1,464 +0,0 @@\n-/**\n- * MVEL (The MVFLEX Expression Language)\n- *\n- * Copyright (C) 2007 Christopher Brock, MVFLEX/Valhalla Project and the Codehaus\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- */\n-\n-package org.mvel;\n-\n-import static org.mvel.DataConversion.canConvert;\n-import static org.mvel.Operator.*;\n-import org.mvel.integration.VariableResolverFactory;\n-import org.mvel.integration.impl.MapVariableResolverFactory;\n-import static org.mvel.optimizers.OptimizerFactory.setThreadAccessorOptimizer;\n-import org.mvel.optimizers.impl.refl.ReflectiveAccessorOptimizer;\n-import org.mvel.util.ExecutionStack;\n-import static org.mvel.util.ParseTools.*;\n-import static org.mvel.util.PropertyTools.isEmpty;\n-import static org.mvel.util.PropertyTools.similarity;\n-import org.mvel.util.Stack;\n-import org.mvel.util.StringAppender;\n-\n-import static java.lang.Class.forName;\n-import static java.lang.String.valueOf;\n-import java.math.BigDecimal;\n-import java.util.Map;\n-import static java.util.regex.Pattern.compile;\n-\n-\n-public class ExpressionParser extends AbstractParser {\n-    private boolean returnBigDecimal = false;\n-    private int roundingMode = BigDecimal.ROUND_HALF_DOWN;\n-\n-    private Object ctx;\n-    private VariableResolverFactory variableFactory;\n-    private final Stack stk = new ExecutionStack();\n-\n-\n-    Object parse() {\n-        setThreadAccessorOptimizer(ReflectiveAccessorOptimizer.class);\n-        debugSymbols = false;\n-\n-        try {\n-            stk.clear();\n-\n-            cursor = 0;\n-\n-            parseAndExecuteInterpreted();\n-\n-            if (parserContext != null\n-                    && (parserContext.get() == null || parserContext.get().getRootParser() == this)) {\n-                \n-                contextControl(REMOVE, null, null);\n-            }\n- \n-            return handleParserEgress(stk.peek(), returnBigDecimal);\n-        }\n-        catch (ArrayIndexOutOfBoundsException e) {\n-            e.printStackTrace();\n-            throw new ParseException(\"unexpected end of statement\", expr, length);\n-        }\n-        catch (NullPointerException e) {\n-            e.printStackTrace();\n-\n-            if (cursor >= length) {\n-                throw new ParseException(\"unexpected end of statement\", expr, length);\n-            }\n-            else\n-                throw e;\n-        }\n-        catch (EndWithValue end) {\n-            return handleParserEgress(end.getValue(), returnBigDecimal);\n-        }\n-    }\n-\n-    /**\n-     * Main interpreter loop.\n-     */\n-    private void parseAndExecuteInterpreted() {\n-        ASTNode tk = null;\n-        Integer operator;\n-        Object holdOverRegister = null;\n-\n-\n-        lastWasIdentifier = false;\n-\n-        try {\n-            while ((tk = nextToken()) != null) {\n-                holdOverRegister = null;\n-\n-                if (lastWasIdentifier && lastNode.isDiscard()) {\n-                    stk.discard();\n-                }\n-\n-                /**\n-                 * If we are at the beginning of a statement, then we immediately push the first token\n-                 * onto the stack.\n-                 */\n-                if (stk.size() == 0) {\n-                    stk.push(tk.getReducedValue(ctx, ctx, variableFactory));\n-                }\n-\n-                if (!tk.isOperator()) {\n-                    continue;\n-                }\n-\n-                switch (operator = tk.getOperator()) {\n-                    case AND:\n-                        if (stk.peek() instanceof Boolean && !((Boolean) stk.peek())) {\n-                            if (unwindStatement()) {\n-                                return;\n-                            }\n-                            else {\n-                                stk.clear();\n-                                continue;\n-                            }\n-                        }\n-                        else {\n-                            stk.discard();\n-                            continue;\n-                        }\n-                    case OR:\n-                        if (stk.peek() instanceof Boolean && ((Boolean) stk.peek())) {\n-                            if (unwindStatement()) {\n-                                return;\n-                            }\n-                            else {\n-                                stk.clear();\n-                                continue;\n-                            }\n-                        }\n-                        else {\n-                            stk.discard();\n-                            continue;\n-                        }\n-\n-                    case TERNARY:\n-                        if (!(Boolean) stk.pop()) {\n-                            stk.clear();\n-\n-                            while ((tk = nextToken()) != null && !tk.isOperator(Operator.TERNARY_ELSE)) {\n-                                //nothing\n-                            }\n-\n-                            continue;\n-                        }\n-\n-\n-                    case TERNARY_ELSE:\n-                        continue;\n-\n-                    case END_OF_STMT:\n-                        /**\n-                         * Assignments are a special scenario for dealing with the stack.  Assignments are basically like\n-                         * held-over failures that basically kickstart the parser when an assignment operator is is\n-                         * encountered.  The originating token is captured, and the the parser is told to march on.  The\n-                         * resultant value on the stack is then used to populate the target variable.\n-                         *\n-                         * The other scenario in which we don't want to wipe the stack, is when we hit the end of the\n-                         * statement, because that top stack value is the value we want back from the parser.\n-                         */\n-\n-                        if (!hasNoMore()) {\n-                            holdOverRegister = stk.pop();\n-                            stk.clear();\n-                        }\n-\n-                        continue;\n-\n-                }\n-\n-\n-                stk.push(nextToken().getReducedValue(ctx, ctx, variableFactory), operator);\n-\n-                reduceTrinary();\n-            }\n-\n-            if (holdOverRegister != null) {\n-                stk.push(holdOverRegister);\n-            }\n-        }\n-        catch (NullPointerException e) {\n-            if (tk != null && tk.isOperator() && cursor >= length) {\n-                throw new CompileException(\"incomplete statement: \"\n-                        + tk.getName() + \" (possible use of reserved keyword as identifier: \" + tk.getName() + \")\");\n-            }\n-            else {\n-                throw e;\n-            }\n-        }\n-    }\n-\n-    private boolean hasNoMore() {\n-        return cursor >= length;\n-    }\n-\n-    /**\n-     * This method is called when we reach the point where we must subEval a trinary operation in the expression.\n-     * (ie. val1 op val2).  This is not the same as a binary operation, although binary operations would appear\n-     * to have 3 structures as well.  A binary structure (or also a junction in the expression) compares the\n-     * current state against 2 downrange structures (usually an op and a val).\n-     */\n-    private void reduceTrinary() {\n-        Object v1 = null, v2 = null;\n-        Integer operator;\n-        try {\n-            while (stk.size() > 1) {\n-                operator = (Integer) stk.pop();\n-                v1 = stk.pop();\n-                v2 = stk.pop();\n-\n-                switch (operator) {\n-                    case ADD:\n-                    case SUB:\n-                    case DIV:\n-                    case MULT:\n-                    case MOD:\n-                    case EQUAL:\n-                    case NEQUAL:\n-                    case GTHAN:\n-                    case LTHAN:\n-                    case GETHAN:\n-                    case LETHAN:\n-                    case POWER:\n-                        stk.push(doOperations(v2, operator, v1));\n-                        break;\n-\n-                    case CHOR:\n-                        if (!isEmpty(v2) || !isEmpty(v1)) {\n-                            stk.clear();\n-                            stk.push(!isEmpty(v2) ? v2 : v1);\n-                            return;\n-                        }\n-                        else stk.push(null);\n-                        break;\n-\n-                    case REGEX:\n-                        stk.push(compile(valueOf(v1)).matcher(valueOf(v2)).matches());\n-                        break;\n-\n-                    case INSTANCEOF:\n-                        if (v1 instanceof Class)\n-                            stk.push(((Class) v1).isInstance(v2));\n-                        else\n-                            stk.push(forName(valueOf(v1)).isInstance(v2));\n-\n-                        break;\n-\n-                    case CONVERTABLE_TO:\n-                        if (v1 instanceof Class)\n-                            stk.push(canConvert(v2.getClass(), (Class) v1));\n-                        else\n-                            stk.push(canConvert(v2.getClass(), forName(valueOf(v1))));\n-                        break;\n-\n-                    case CONTAINS:\n-                        stk.push(containsCheck(v2, v1));\n-                        break;\n-\n-                    case BW_AND:\n-                        stk.push(asInt(v2) & asInt(v1));\n-                        break;\n-\n-                    case BW_OR:\n-                        stk.push(asInt(v2) | asInt(v1));\n-                        break;\n-\n-                    case BW_XOR:\n-                        stk.push(asInt(v2) ^ asInt(v1));\n-                        break;\n-\n-                    case BW_SHIFT_LEFT:\n-                        stk.push(asInt(v2) << asInt(v1));\n-                        break;\n-\n-                    case BW_USHIFT_LEFT:\n-                        int iv2 = asInt(v2);\n-                        if (iv2 < 0) iv2 *= -1;\n-                        stk.push(iv2 << asInt(v1));\n-                        break;\n-\n-                    case BW_SHIFT_RIGHT:\n-                        stk.push(asInt(v2) >> asInt(v1));\n-                        break;\n-\n-                    case BW_USHIFT_RIGHT:\n-                        stk.push(asInt(v2) >>> asInt(v1));\n-                        break;\n-\n-                    case STR_APPEND:\n-                        stk.push(new StringAppender(valueOf(v2)).append(valueOf(v1)).toString());\n-                        break;\n-\n-                    case SOUNDEX:\n-                        stk.push(Soundex.soundex(valueOf(v1)).equals(Soundex.soundex(valueOf(v2))));\n-                        break;\n-\n-                    case SIMILARITY:\n-                        stk.push(similarity(valueOf(v1), valueOf(v2)));\n-                        break;\n-\n-                }\n-            }\n-        }\n-        catch (ClassCastException e) {\n-            if ((fields & ASTNode.LOOKAHEAD) == 0) {\n-                /**\n-                 * This will allow for some developers who like messy expressions to compileAccessor\n-                 * away with some messy constructs like: a + b < c && e + f > g + q instead\n-                 * of using brackets like (a + b < c) && (e + f > g + q)\n-                 */\n-\n-                fields |= ASTNode.LOOKAHEAD;\n-\n-                ASTNode tk = nextToken();\n-                if (tk != null) {\n-                    stk.push(v1, nextToken(), tk.getOperator());\n-\n-                    reduceTrinary();\n-                    return;\n-                }\n-            }\n-            throw new CompileException(\"syntax error or incomptable types (left=\" +\n-                    (v1 != null ? v1.getClass().getName() : \"null\") + \", right=\" +\n-                    (v2 != null ? v2.getClass().getName() : \"null\") + \")\", expr, cursor, e);\n-\n-        }\n-        catch (Exception e) {\n-            throw new CompileException(\"failed to subEval expression\", e);\n-        }\n-\n-    }\n-\n-    private static int asInt(final Object o) {\n-        return (Integer) o;\n-    }\n-\n-    /**\n-     * This method is called to unwind the current statement without any reduction or further parsing.\n-     *\n-     * @return -\n-     */\n-    private boolean unwindStatement() {\n-        ASTNode tk;\n-        while ((tk = nextToken()) != null && !tk.isOperator(Operator.END_OF_STMT) && !tk.isOperator(Operator.OR)) {\n-            //nothing\n-        }\n-        return tk == null;\n-    }\n-\n-    public ExpressionParser setExpressionArray(char[] expressionArray) {\n-        this.length = (this.expr = expressionArray).length;\n-        return this;\n-    }\n-\n-    public int getRoundingMode() {\n-        return roundingMode;\n-    }\n-\n-    public void setRoundingMode(int roundingMode) {\n-        this.roundingMode = roundingMode;\n-    }\n-\n-    public boolean isReturnBigDecimal() {\n-        return returnBigDecimal;\n-    }\n-\n-    public void setReturnBigDecimal(boolean returnBigDecimal) {\n-        this.returnBigDecimal = returnBigDecimal;\n-    }\n-\n-    ExpressionParser(char[] expression, Object ctx, Map<String, Object> variables) {\n-        this.expr = expression;\n-        this.length = expr.length;\n-        this.ctx = ctx;\n-        this.variableFactory = new MapVariableResolverFactory(variables);\n-    }\n-\n-    ExpressionParser(char[] expression, Object ctx) {\n-        this.expr = expression;\n-        this.length = expr.length;\n-        this.ctx = ctx;\n-    }\n-\n-    ExpressionParser(String expression, Object ctx, Map<String, Object> variables) {\n-        setExpression(expression);\n-        this.ctx = ctx;\n-        this.variableFactory = new MapVariableResolverFactory(variables);\n-    }\n-\n-    ExpressionParser(String expression) {\n-        setExpression(expression);\n-    }\n-\n-    ExpressionParser(char[] expression) {\n-        this.length = (this.expr = expression).length;\n-    }\n-\n-    ExpressionParser(char[] expr, Object ctx, VariableResolverFactory resolverFactory) {\n-        this.length = (this.expr = expr).length;\n-        this.ctx = ctx;\n-        this.variableFactory = resolverFactory;\n-    }\n-\n-    ExpressionParser(Object ctx, Map<String, Object> variables) {\n-        this.ctx = ctx;\n-        this.variableFactory = new MapVariableResolverFactory(variables);\n-    }\n-\n-    ExpressionParser(String expression, Object ctx, VariableResolverFactory resolverFactory) {\n-        setExpression(expression);\n-        this.ctx = ctx;\n-        this.variableFactory = resolverFactory;\n-    }\n-\n-    ExpressionParser(String expression, VariableResolverFactory resolverFactory) {\n-        setExpression(expression);\n-        this.variableFactory = resolverFactory;\n-    }\n-\n-    ExpressionParser(String expression, Object ctx) {\n-        setExpression(expression);\n-        this.ctx = ctx;\n-    }\n-\n-    private void chainFactory(VariableResolverFactory factory) {\n-        VariableResolverFactory vrf = variableFactory;\n-        while (vrf.getNextFactory() != null) {\n-            vrf = vrf.getNextFactory();\n-        }\n-        vrf.setNextFactory(factory);\n-    }\n-\n-\n-    protected boolean hasImport(String name) {\n-        if (getParserContext().hasImport(name)) {\n-            return true;\n-        }\n-        else {\n-            VariableResolverFactory vrf = findClassImportResolverFactory(variableFactory);\n-            return vrf != null && vrf.isResolveable(name);\n-        }\n-    }\n-\n-    protected Class getImport(String name) {\n-        if (getParserContext().hasImport(name)) return getParserContext().getImport(name);\n-\n-        VariableResolverFactory vrf = findClassImportResolverFactory(variableFactory);\n-        return (Class) vrf.getVariableResolver(name).getValue();\n-    }\n-}\n-\ndiff --git a/src/main/java/org/mvel/MVEL.java b/src/main/java/org/mvel/MVEL.java\nindex e6cef0d..c1605e9 100644\n--- a/src/main/java/org/mvel/MVEL.java\n+++ b/src/main/java/org/mvel/MVEL.java\n@@ -65,7 +65,7 @@ public class MVEL {\n         THREAD_SAFE = threadSafe;\n         PropertyAccessor.configureFactory();\n         TemplateInterpreter.configureFactory();\n-        ExpressionParser.configureFactory();\n+        MVELInterpretedRuntime.configureFactory();\n     }\n \n     public static boolean isThreadSafe() {\n@@ -89,30 +89,30 @@ public class MVEL {\n     }\n \n     public static Object eval(String expression, Object ctx) {\n-        return new ExpressionParser(expression, ctx).parse();\n+        return new MVELInterpretedRuntime(expression, ctx).parse();\n     }\n \n     public static Object eval(String expression, VariableResolverFactory resolverFactory) {\n-        return new ExpressionParser(expression, resolverFactory).parse();\n+        return new MVELInterpretedRuntime(expression, resolverFactory).parse();\n \n     }\n \n     public static Object eval(char[] expression, Object ctx, VariableResolverFactory resolverFactory) {\n-        return new ExpressionParser(expression, ctx, resolverFactory).parse();\n+        return new MVELInterpretedRuntime(expression, ctx, resolverFactory).parse();\n     }\n \n     public static Object eval(String expression, Object ctx, VariableResolverFactory resolverFactory) {\n-        return new ExpressionParser(expression, ctx, resolverFactory).parse();\n+        return new MVELInterpretedRuntime(expression, ctx, resolverFactory).parse();\n     }\n \n     @SuppressWarnings({\"unchecked\"})\n     public static Object eval(String expression, Map tokens) {\n-        return new ExpressionParser(expression, null, tokens).parse();\n+        return new MVELInterpretedRuntime(expression, null, tokens).parse();\n     }\n \n     @SuppressWarnings({\"unchecked\"})\n     public static Object eval(String expression, Object ctx, Map tokens) {\n-        return new ExpressionParser(expression, ctx, tokens).parse();\n+        return new MVELInterpretedRuntime(expression, ctx, tokens).parse();\n     }\n \n \n@@ -352,7 +352,7 @@ public class MVEL {\n     @SuppressWarnings({\"unchecked\"})\n     public static <T> T eval(char[] expression, Object ctx, Map vars, Class<T> toType) {\n         try {\n-            return convert(new ExpressionParser(expression, ctx, vars).parse(), toType);\n+            return convert(new MVELInterpretedRuntime(expression, ctx, vars).parse(), toType);\n         }\n         catch (EndWithValue end) {\n             return convert(handleParserEgress(end.getValue(), false), toType);\n@@ -362,7 +362,7 @@ public class MVEL {\n     @SuppressWarnings({\"unchecked\"})\n     public static <T> T eval(char[] expression, Object ctx, Class<T> toType) {\n         try {\n-            return convert(new ExpressionParser(expression, ctx).parse(), toType);\n+            return convert(new MVELInterpretedRuntime(expression, ctx).parse(), toType);\n         }\n         catch (EndWithValue end) {\n             return convert(handleParserEgress(end.getValue(), false), toType);\n@@ -372,7 +372,7 @@ public class MVEL {\n     @SuppressWarnings({\"unchecked\"})\n     public static <T> T eval(String expression, Object ctx, Class<T> toType) {\n         try {\n-            return convert(new ExpressionParser(expression, ctx).parse(), toType);\n+            return convert(new MVELInterpretedRuntime(expression, ctx).parse(), toType);\n         }\n         catch (EndWithValue end) {\n             return convert(handleParserEgress(end.getValue(), false), toType);\n@@ -382,7 +382,7 @@ public class MVEL {\n     @SuppressWarnings({\"unchecked\"})\n     public static <T> T eval(String expression, Object ctx, Map vars, Class<T> toType) {\n         try {\n-            return convert(new ExpressionParser(expression, ctx, vars).parse(), toType);\n+            return convert(new MVELInterpretedRuntime(expression, ctx, vars).parse(), toType);\n         }\n         catch (EndWithValue end) {\n             return convert(handleParserEgress(end.getValue(), false), toType);\n@@ -392,7 +392,7 @@ public class MVEL {\n     @SuppressWarnings({\"unchecked\"})\n     public static <T> T eval(char[] expression, Object ctx, VariableResolverFactory vars, Class<T> toType) {\n         try {\n-            return convert(new ExpressionParser(expression, ctx, vars).parse(), toType);\n+            return convert(new MVELInterpretedRuntime(expression, ctx, vars).parse(), toType);\n         }\n         catch (EndWithValue end) {\n             return convert(handleParserEgress(end.getValue(), false), toType);\n@@ -402,7 +402,7 @@ public class MVEL {\n     @SuppressWarnings({\"unchecked\"})\n     public static <T> T eval(String expression, Object ctx, VariableResolverFactory vars, Class<T> toType) {\n         try {\n-            return convert(new ExpressionParser(expression, ctx, vars).parse(), toType);\n+            return convert(new MVELInterpretedRuntime(expression, ctx, vars).parse(), toType);\n         }\n         catch (EndWithValue end) {\n             return convert(handleParserEgress(end.getValue(), false), toType);\n@@ -413,7 +413,7 @@ public class MVEL {\n     @SuppressWarnings({\"unchecked\"})\n     public static <T> T eval(String expression, Map vars, Class<T> toType) {\n         try {\n-            return convert(new ExpressionParser(expression, null, vars).parse(), toType);\n+            return convert(new MVELInterpretedRuntime(expression, null, vars).parse(), toType);\n         }\n         catch (EndWithValue end) {\n             return convert(handleParserEgress(end.getValue(), false), toType);\n@@ -423,7 +423,7 @@ public class MVEL {\n     @SuppressWarnings({\"unchecked\"})\n     public static <T> T eval(String expression, VariableResolverFactory vars, Class<T> toType) {\n         try {\n-            return convert(new ExpressionParser(expression, null, vars).parse(), toType);\n+            return convert(new MVELInterpretedRuntime(expression, null, vars).parse(), toType);\n         }\n         catch (EndWithValue end) {\n             return convert(handleParserEgress(end.getValue(), false), toType);\n@@ -434,7 +434,7 @@ public class MVEL {\n     @SuppressWarnings({\"unchecked\"})\n     public static <T> T eval(char[] expression, Map vars, Class<T> toType) {\n         try {\n-            return convert(new ExpressionParser(expression, null, vars).parse(), toType);\n+            return convert(new MVELInterpretedRuntime(expression, null, vars).parse(), toType);\n         }\n         catch (EndWithValue end) {\n             return convert(handleParserEgress(end.getValue(), false), toType);\n@@ -444,7 +444,7 @@ public class MVEL {\n     @SuppressWarnings({\"unchecked\"})\n     public static Object eval(char[] expression, Object ctx, Map vars) {\n         try {\n-            return new ExpressionParser(expression, ctx, vars).parse();\n+            return new MVELInterpretedRuntime(expression, ctx, vars).parse();\n         }\n         catch (EndWithValue end) {\n             return handleParserEgress(end.getValue(), false);\ndiff --git a/src/main/java/org/mvel/MVELInterpretedRuntime.java b/src/main/java/org/mvel/MVELInterpretedRuntime.java\nnew file mode 100644\nindex 0000000..cf5deb1\n--- /dev/null\n+++ b/src/main/java/org/mvel/MVELInterpretedRuntime.java\n@@ -0,0 +1,464 @@\n+/**\n+ * MVEL (The MVFLEX Expression Language)\n+ *\n+ * Copyright (C) 2007 Christopher Brock, MVFLEX/Valhalla Project and the Codehaus\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.mvel;\n+\n+import static org.mvel.DataConversion.canConvert;\n+import static org.mvel.Operator.*;\n+import org.mvel.integration.VariableResolverFactory;\n+import org.mvel.integration.impl.MapVariableResolverFactory;\n+import static org.mvel.optimizers.OptimizerFactory.setThreadAccessorOptimizer;\n+import org.mvel.optimizers.impl.refl.ReflectiveAccessorOptimizer;\n+import org.mvel.util.ExecutionStack;\n+import static org.mvel.util.ParseTools.*;\n+import static org.mvel.util.PropertyTools.isEmpty;\n+import static org.mvel.util.PropertyTools.similarity;\n+import org.mvel.util.Stack;\n+import org.mvel.util.StringAppender;\n+\n+import static java.lang.Class.forName;\n+import static java.lang.String.valueOf;\n+import java.math.BigDecimal;\n+import java.util.Map;\n+import static java.util.regex.Pattern.compile;\n+\n+\n+public class MVELInterpretedRuntime extends AbstractParser {\n+    private boolean returnBigDecimal = false;\n+    private int roundingMode = BigDecimal.ROUND_HALF_DOWN;\n+\n+    private Object ctx;\n+    private VariableResolverFactory variableFactory;\n+    private final Stack stk = new ExecutionStack();\n+\n+\n+    Object parse() {\n+        setThreadAccessorOptimizer(ReflectiveAccessorOptimizer.class);\n+        debugSymbols = false;\n+\n+        try {\n+            stk.clear();\n+\n+            cursor = 0;\n+\n+            parseAndExecuteInterpreted();\n+\n+            if (parserContext != null\n+                    && (parserContext.get() == null || parserContext.get().getRootParser() == this)) {\n+                \n+                contextControl(REMOVE, null, null);\n+            }\n+ \n+            return handleParserEgress(stk.peek(), returnBigDecimal);\n+        }\n+        catch (ArrayIndexOutOfBoundsException e) {\n+            e.printStackTrace();\n+            throw new ParseException(\"unexpected end of statement\", expr, length);\n+        }\n+        catch (NullPointerException e) {\n+            e.printStackTrace();\n+\n+            if (cursor >= length) {\n+                throw new ParseException(\"unexpected end of statement\", expr, length);\n+            }\n+            else\n+                throw e;\n+        }\n+        catch (EndWithValue end) {\n+            return handleParserEgress(end.getValue(), returnBigDecimal);\n+        }\n+    }\n+\n+    /**\n+     * Main interpreter loop.\n+     */\n+    private void parseAndExecuteInterpreted() {\n+        ASTNode tk = null;\n+        Integer operator;\n+        Object holdOverRegister = null;\n+\n+\n+        lastWasIdentifier = false;\n+\n+        try {\n+            while ((tk = nextToken()) != null) {\n+                holdOverRegister = null;\n+\n+                if (lastWasIdentifier && lastNode.isDiscard()) {\n+                    stk.discard();\n+                }\n+\n+                /**\n+                 * If we are at the beginning of a statement, then we immediately push the first token\n+                 * onto the stack.\n+                 */\n+                if (stk.size() == 0) {\n+                    stk.push(tk.getReducedValue(ctx, ctx, variableFactory));\n+                }\n+\n+                if (!tk.isOperator()) {\n+                    continue;\n+                }\n+\n+                switch (operator = tk.getOperator()) {\n+                    case AND:\n+                        if (stk.peek() instanceof Boolean && !((Boolean) stk.peek())) {\n+                            if (unwindStatement()) {\n+                                return;\n+                            }\n+                            else {\n+                                stk.clear();\n+                                continue;\n+                            }\n+                        }\n+                        else {\n+                            stk.discard();\n+                            continue;\n+                        }\n+                    case OR:\n+                        if (stk.peek() instanceof Boolean && ((Boolean) stk.peek())) {\n+                            if (unwindStatement()) {\n+                                return;\n+                            }\n+                            else {\n+                                stk.clear();\n+                                continue;\n+                            }\n+                        }\n+                        else {\n+                            stk.discard();\n+                            continue;\n+                        }\n+\n+                    case TERNARY:\n+                        if (!(Boolean) stk.pop()) {\n+                            stk.clear();\n+\n+                            while ((tk = nextToken()) != null && !tk.isOperator(Operator.TERNARY_ELSE)) {\n+                                //nothing\n+                            }\n+\n+                            continue;\n+                        }\n+\n+\n+                    case TERNARY_ELSE:\n+                        continue;\n+\n+                    case END_OF_STMT:\n+                        /**\n+                         * Assignments are a special scenario for dealing with the stack.  Assignments are basically like\n+                         * held-over failures that basically kickstart the parser when an assignment operator is is\n+                         * encountered.  The originating token is captured, and the the parser is told to march on.  The\n+                         * resultant value on the stack is then used to populate the target variable.\n+                         *\n+                         * The other scenario in which we don't want to wipe the stack, is when we hit the end of the\n+                         * statement, because that top stack value is the value we want back from the parser.\n+                         */\n+\n+                        if (!hasNoMore()) {\n+                            holdOverRegister = stk.pop();\n+                            stk.clear();\n+                        }\n+\n+                        continue;\n+\n+                }\n+\n+\n+                stk.push(nextToken().getReducedValue(ctx, ctx, variableFactory), operator);\n+\n+                reduceTrinary();\n+            }\n+\n+            if (holdOverRegister != null) {\n+                stk.push(holdOverRegister);\n+            }\n+        }\n+        catch (NullPointerException e) {\n+            if (tk != null && tk.isOperator() && cursor >= length) {\n+                throw new CompileException(\"incomplete statement: \"\n+                        + tk.getName() + \" (possible use of reserved keyword as identifier: \" + tk.getName() + \")\");\n+            }\n+            else {\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    private boolean hasNoMore() {\n+        return cursor >= length;\n+    }\n+\n+    /**\n+     * This method is called when we reach the point where we must subEval a trinary operation in the expression.\n+     * (ie. val1 op val2).  This is not the same as a binary operation, although binary operations would appear\n+     * to have 3 structures as well.  A binary structure (or also a junction in the expression) compares the\n+     * current state against 2 downrange structures (usually an op and a val).\n+     */\n+    private void reduceTrinary() {\n+        Object v1 = null, v2 = null;\n+        Integer operator;\n+        try {\n+            while (stk.size() > 1) {\n+                operator = (Integer) stk.pop();\n+                v1 = stk.pop();\n+                v2 = stk.pop();\n+\n+                switch (operator) {\n+                    case ADD:\n+                    case SUB:\n+                    case DIV:\n+                    case MULT:\n+                    case MOD:\n+                    case EQUAL:\n+                    case NEQUAL:\n+                    case GTHAN:\n+                    case LTHAN:\n+                    case GETHAN:\n+                    case LETHAN:\n+                    case POWER:\n+                        stk.push(doOperations(v2, operator, v1));\n+                        break;\n+\n+                    case CHOR:\n+                        if (!isEmpty(v2) || !isEmpty(v1)) {\n+                            stk.clear();\n+                            stk.push(!isEmpty(v2) ? v2 : v1);\n+                            return;\n+                        }\n+                        else stk.push(null);\n+                        break;\n+\n+                    case REGEX:\n+                        stk.push(compile(valueOf(v1)).matcher(valueOf(v2)).matches());\n+                        break;\n+\n+                    case INSTANCEOF:\n+                        if (v1 instanceof Class)\n+                            stk.push(((Class) v1).isInstance(v2));\n+                        else\n+                            stk.push(forName(valueOf(v1)).isInstance(v2));\n+\n+                        break;\n+\n+                    case CONVERTABLE_TO:\n+                        if (v1 instanceof Class)\n+                            stk.push(canConvert(v2.getClass(), (Class) v1));\n+                        else\n+                            stk.push(canConvert(v2.getClass(), forName(valueOf(v1))));\n+                        break;\n+\n+                    case CONTAINS:\n+                        stk.push(containsCheck(v2, v1));\n+                        break;\n+\n+                    case BW_AND:\n+                        stk.push(asInt(v2) & asInt(v1));\n+                        break;\n+\n+                    case BW_OR:\n+                        stk.push(asInt(v2) | asInt(v1));\n+                        break;\n+\n+                    case BW_XOR:\n+                        stk.push(asInt(v2) ^ asInt(v1));\n+                        break;\n+\n+                    case BW_SHIFT_LEFT:\n+                        stk.push(asInt(v2) << asInt(v1));\n+                        break;\n+\n+                    case BW_USHIFT_LEFT:\n+                        int iv2 = asInt(v2);\n+                        if (iv2 < 0) iv2 *= -1;\n+                        stk.push(iv2 << asInt(v1));\n+                        break;\n+\n+                    case BW_SHIFT_RIGHT:\n+                        stk.push(asInt(v2) >> asInt(v1));\n+                        break;\n+\n+                    case BW_USHIFT_RIGHT:\n+                        stk.push(asInt(v2) >>> asInt(v1));\n+                        break;\n+\n+                    case STR_APPEND:\n+                        stk.push(new StringAppender(valueOf(v2)).append(valueOf(v1)).toString());\n+                        break;\n+\n+                    case SOUNDEX:\n+                        stk.push(Soundex.soundex(valueOf(v1)).equals(Soundex.soundex(valueOf(v2))));\n+                        break;\n+\n+                    case SIMILARITY:\n+                        stk.push(similarity(valueOf(v1), valueOf(v2)));\n+                        break;\n+\n+                }\n+            }\n+        }\n+        catch (ClassCastException e) {\n+            if ((fields & ASTNode.LOOKAHEAD) == 0) {\n+                /**\n+                 * This will allow for some developers who like messy expressions to compileAccessor\n+                 * away with some messy constructs like: a + b < c && e + f > g + q instead\n+                 * of using brackets like (a + b < c) && (e + f > g + q)\n+                 */\n+\n+                fields |= ASTNode.LOOKAHEAD;\n+\n+                ASTNode tk = nextToken();\n+                if (tk != null) {\n+                    stk.push(v1, nextToken(), tk.getOperator());\n+\n+                    reduceTrinary();\n+                    return;\n+                }\n+            }\n+            throw new CompileException(\"syntax error or incomptable types (left=\" +\n+                    (v1 != null ? v1.getClass().getName() : \"null\") + \", right=\" +\n+                    (v2 != null ? v2.getClass().getName() : \"null\") + \")\", expr, cursor, e);\n+\n+        }\n+        catch (Exception e) {\n+            throw new CompileException(\"failed to subEval expression\", e);\n+        }\n+\n+    }\n+\n+    private static int asInt(final Object o) {\n+        return (Integer) o;\n+    }\n+\n+    /**\n+     * This method is called to unwind the current statement without any reduction or further parsing.\n+     *\n+     * @return -\n+     */\n+    private boolean unwindStatement() {\n+        ASTNode tk;\n+        while ((tk = nextToken()) != null && !tk.isOperator(Operator.END_OF_STMT) && !tk.isOperator(Operator.OR)) {\n+            //nothing\n+        }\n+        return tk == null;\n+    }\n+\n+    public MVELInterpretedRuntime setExpressionArray(char[] expressionArray) {\n+        this.length = (this.expr = expressionArray).length;\n+        return this;\n+    }\n+\n+    public int getRoundingMode() {\n+        return roundingMode;\n+    }\n+\n+    public void setRoundingMode(int roundingMode) {\n+        this.roundingMode = roundingMode;\n+    }\n+\n+    public boolean isReturnBigDecimal() {\n+        return returnBigDecimal;\n+    }\n+\n+    public void setReturnBigDecimal(boolean returnBigDecimal) {\n+        this.returnBigDecimal = returnBigDecimal;\n+    }\n+\n+    MVELInterpretedRuntime(char[] expression, Object ctx, Map<String, Object> variables) {\n+        this.expr = expression;\n+        this.length = expr.length;\n+        this.ctx = ctx;\n+        this.variableFactory = new MapVariableResolverFactory(variables);\n+    }\n+\n+    MVELInterpretedRuntime(char[] expression, Object ctx) {\n+        this.expr = expression;\n+        this.length = expr.length;\n+        this.ctx = ctx;\n+    }\n+\n+    MVELInterpretedRuntime(String expression, Object ctx, Map<String, Object> variables) {\n+        setExpression(expression);\n+        this.ctx = ctx;\n+        this.variableFactory = new MapVariableResolverFactory(variables);\n+    }\n+\n+    MVELInterpretedRuntime(String expression) {\n+        setExpression(expression);\n+    }\n+\n+    MVELInterpretedRuntime(char[] expression) {\n+        this.length = (this.expr = expression).length;\n+    }\n+\n+    MVELInterpretedRuntime(char[] expr, Object ctx, VariableResolverFactory resolverFactory) {\n+        this.length = (this.expr = expr).length;\n+        this.ctx = ctx;\n+        this.variableFactory = resolverFactory;\n+    }\n+\n+    MVELInterpretedRuntime(Object ctx, Map<String, Object> variables) {\n+        this.ctx = ctx;\n+        this.variableFactory = new MapVariableResolverFactory(variables);\n+    }\n+\n+    MVELInterpretedRuntime(String expression, Object ctx, VariableResolverFactory resolverFactory) {\n+        setExpression(expression);\n+        this.ctx = ctx;\n+        this.variableFactory = resolverFactory;\n+    }\n+\n+    MVELInterpretedRuntime(String expression, VariableResolverFactory resolverFactory) {\n+        setExpression(expression);\n+        this.variableFactory = resolverFactory;\n+    }\n+\n+    MVELInterpretedRuntime(String expression, Object ctx) {\n+        setExpression(expression);\n+        this.ctx = ctx;\n+    }\n+\n+    private void chainFactory(VariableResolverFactory factory) {\n+        VariableResolverFactory vrf = variableFactory;\n+        while (vrf.getNextFactory() != null) {\n+            vrf = vrf.getNextFactory();\n+        }\n+        vrf.setNextFactory(factory);\n+    }\n+\n+\n+    protected boolean hasImport(String name) {\n+        if (getParserContext().hasImport(name)) {\n+            return true;\n+        }\n+        else {\n+            VariableResolverFactory vrf = findClassImportResolverFactory(variableFactory);\n+            return vrf != null && vrf.isResolveable(name);\n+        }\n+    }\n+\n+    protected Class getImport(String name) {\n+        if (getParserContext().hasImport(name)) return getParserContext().getImport(name);\n+\n+        VariableResolverFactory vrf = findClassImportResolverFactory(variableFactory);\n+        return (Class) vrf.getVariableResolver(name).getValue();\n+    }\n+}\n+\ndiff --git a/src/main/java/org/mvel/TemplateInterpreter.java b/src/main/java/org/mvel/TemplateInterpreter.java\nindex b65dfbd..2744532 100644\n--- a/src/main/java/org/mvel/TemplateInterpreter.java\n+++ b/src/main/java/org/mvel/TemplateInterpreter.java\n@@ -372,7 +372,7 @@ public class TemplateInterpreter {\n \n         try {\n             //noinspection unchecked\n-            ExpressionParser oParser = new ExpressionParser(ctx, tokens);\n+            MVELInterpretedRuntime oParser = new MVELInterpretedRuntime(ctx, tokens);\n \n             initStack();\n             pushAndForward();\n@@ -412,7 +412,7 @@ public class TemplateInterpreter {\n                                 Iterator[] iters = new Iterator[lists.length];\n                                 for (int i = 0; i < lists.length; i++) {\n                                     //noinspection unchecked\n-                                    Object listObject = new ExpressionParser(lists[i], ctx, tokens).parse();\n+                                    Object listObject = new MVELInterpretedRuntime(lists[i], ctx, tokens).parse();\n                                     if (listObject instanceof Object[]) {\n                                         listObject = Arrays.asList((Object[]) listObject);\n                                     }\ndiff --git a/src/main/java/org/mvel/util/CompilerTools.java b/src/main/java/org/mvel/util/CompilerTools.java\nindex 29a0bb9..61095f8 100644\n--- a/src/main/java/org/mvel/util/CompilerTools.java\n+++ b/src/main/java/org/mvel/util/CompilerTools.java\n@@ -49,7 +49,7 @@ public class CompilerTools {\n                      * right here.\n                      */\n                     while (astLinkedList.hasMoreNodes() && (tkOp2 = astLinkedList.nextNode()).isOperator()\n-                            && tkOp2.getOperator() < 12) {\n+                            && tkOp2.getFields() != -1 && tkOp2.getOperator() < 12) {\n                         bo = new BinaryOperation(((tkOp = tkOp2).getOperator()), bo, astLinkedList.nextNode());\n                     }\n                     optimizedAst.addTokenNode(bo);\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\nindex a97a046..3cd8708 100644\n--- a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n@@ -1683,7 +1683,7 @@ public class CoreConfidenceTests extends AbstractTest {\n \n         compiler.compile(parserContext);\n \n-    }\n+    }                                                                                \n \n     public void testParsingStability3() {\n         assertEquals(false, test(\"!( [\\\"X\\\", \\\"Y\\\"] contains \\\"Y\\\" )\"));\n@@ -1693,14 +1693,23 @@ public class CoreConfidenceTests extends AbstractTest {\n         assertEquals(true, test(\"vv=\\\"Edson\\\"; !(vv ~= \\\"Mark\\\")\"));\n     }\n \n+    public void testConcatWithLineBreaks() {\n+        ExpressionCompiler parser = new ExpressionCompiler(\"\\\"foo\\\"+\\n\\\"bar\\\"\");\n+\n+        ParserContext ctx = new ParserContext();\n+        ctx.setDebugSymbols(true);\n+        ctx.setSourceFile(\"source.mv\");\n+\n+        Serializable c = parser.compile(ctx);\n+\n+        assertEquals(\"foobar\", MVEL.executeExpression(c));\n+    }\n \n     /**\n      * Community provided test cases\n      */\n-\n     @SuppressWarnings({\"unchecked\"})\n     public void testCalculateAge() {\n-        //    System.out.println(\"Calculating the Age\");\n         Calendar c1 = Calendar.getInstance();\n         c1.set(1999, 0, 10); // 1999 jan 20\n         Map objectMap = new HashMap(1);\n@@ -1828,4 +1837,7 @@ public class CoreConfidenceTests extends AbstractTest {\n         assertEquals(\"q\", ((Map) test(\"['Person.age' : [1, 2, 3, 4],'Person.rating' : 'q']\")).get(\"Person.rating\"));\n         assertEquals(\"q\", ((Map) test(\"['Person.age' : [1, 2, 3, 4], 'Person.rating' : 'q']\")).get(\"Person.rating\"));\n     }\n+\n+\n+\n }\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T18:41:25.566798Z", "commit_hash": "35976c1102f02e4c4f42472ad4efc078ae4645e0", "commit_message": "precedence order for || and && fixed.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/AbstractParser.java b/src/main/java/org/mvel/AbstractParser.java\nindex 3ff2938..58f81b9 100644\n--- a/src/main/java/org/mvel/AbstractParser.java\n+++ b/src/main/java/org/mvel/AbstractParser.java\n@@ -604,7 +604,6 @@ public class AbstractParser implements Serializable {\n                             switch (expr[cursor]) {\r\n                                 case'(':\r\n                                     brace++;\r\n-                                    skipWhitespace();\r\n                                     break;\r\n                                 case')':\r\n                                     brace--;\r\ndiff --git a/src/main/java/org/mvel/ExpressionParser.java b/src/main/java/org/mvel/ExpressionParser.java\nindex 6a4fcc9..86f9d06 100644\n--- a/src/main/java/org/mvel/ExpressionParser.java\n+++ b/src/main/java/org/mvel/ExpressionParser.java\n@@ -354,7 +354,7 @@ public class ExpressionParser extends AbstractParser {\n      */\n     private boolean unwindStatement() {\n         ASTNode tk;\n-        while ((tk = nextToken()) != null && !tk.isOperator(Operator.END_OF_STMT)) {\n+        while ((tk = nextToken()) != null && !tk.isOperator(Operator.END_OF_STMT) && !tk.isOperator(Operator.OR)) {\n             //nothing\n         }\n         return tk == null;\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\nindex 6722b3a..7d5a3ff 100644\n--- a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n@@ -1577,6 +1577,9 @@ public class CoreConfidenceTests extends TestCase {\n         assertEquals(Integer.MIN_VALUE, test(\"list = [java.lang.Integer.MIN_VALUE]; list[0]\"));\n     }\n \n+    public void testPrecedenceOrder() {\n+        assertTrue((Boolean) test(\"5 > 6 && 2 < 1 || 10 > 9\"));\n+    }\n \n     public Object test(String ex) {\n         return compiledExecute(ex, this.base, this.map);\ndiff --git a/src/test/java/org/mvel/tests/main/res/Base.java b/src/test/java/org/mvel/tests/main/res/Base.java\nindex 0941643..5c01156 100644\n--- a/src/test/java/org/mvel/tests/main/res/Base.java\n+++ b/src/test/java/org/mvel/tests/main/res/Base.java\n@@ -84,4 +84,9 @@ public class Base {\n     public String getDATA() {\n         return data;\n     }\n+\n+    public boolean ord(boolean val, int num) {\n+        System.out.println(\"num: \" + num);\n+        return val;\n+    }\n }\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T18:43:01.140965Z", "commit_hash": "7505f3ae8f7fbce5db81926374ff87c71cb0efae", "commit_message": "BUGFIX: MVEL-27\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/util/CollectionParser.java b/src/main/java/org/mvel/util/CollectionParser.java\nindex 987aaed..f01b538 100644\n--- a/src/main/java/org/mvel/util/CollectionParser.java\n+++ b/src/main/java/org/mvel/util/CollectionParser.java\n@@ -1,5 +1,7 @@\n package org.mvel.util;\r\n \r\n+import static org.mvel.util.ParseTools.balancedCapture;\r\n+\r\n import java.util.ArrayList;\r\n import java.util.HashMap;\r\n import java.util.List;\r\n@@ -62,7 +64,7 @@ public class CollectionParser {\n                     break;\r\n                 case MAP:\r\n                     map = new HashMap<Object, Object>();\r\n-                     break;\r\n+                    break;\r\n             }\r\n         }\r\n \r\n@@ -70,7 +72,7 @@ public class CollectionParser {\n \r\n         int newType = -1;\r\n \r\n-        int end;\r\n+        //   int end;\r\n         for (; cursor < length; cursor++) {\r\n             switch (property[cursor]) {\r\n                 case'{':\r\n@@ -83,7 +85,8 @@ public class CollectionParser {\n                     }\r\n \r\n                     start = cursor;\r\n-                    end = balancedCapture(property[cursor]);\r\n+\r\n+                    end = cursor = balancedCapture(property, start, property[start]);\r\n \r\n                     Object o = new CollectionParser(newType).parseCollection(subset(property, start + 1, end));\r\n \r\n@@ -94,7 +97,7 @@ public class CollectionParser {\n                         list.add(curr = o);\r\n                     }\r\n \r\n-                    if ((start = ++cursor) < (length - 1) && property[start] == ',') {\r\n+                    if ((start = ++cursor) < (length - 1) && property[start] != ',') {\r\n                         start = ++cursor;\r\n                     }\r\n \r\n@@ -102,10 +105,13 @@ public class CollectionParser {\n \r\n                 case'\\\"':\r\n                 case'\\'':\r\n-                    end = balancedCapture(property[start = cursor]);\r\n-                    if (end == -1)\r\n-                        throw new RuntimeException(\"unterminated string literal\");\r\n+                    end = cursor = balancedCapture(property, start = cursor, property[start]);\r\n+\r\n+                    if (end == -1) {\r\n+                        throw new RuntimeException(\"unterminated string literal starting at index \" + start + \" {\" + property[start] + \"}: \" + new String(property));\r\n+                    }\r\n \r\n+                    \r\n                     break;\r\n \r\n                 case',':\r\n@@ -136,7 +142,7 @@ public class CollectionParser {\n             if (cursor < (length - 1)) cursor++;\r\n \r\n             if (type == MAP) {\r\n-                map.put(curr,  new String(subset(property, start, cursor)).trim());\r\n+                map.put(curr, new String(subset(property, start, cursor)).trim());\r\n             }\r\n             else {\r\n                 if (cursor < length) cursor++;\r\n@@ -164,39 +170,6 @@ public class CollectionParser {\n         return newA;\r\n     }\r\n \r\n-    private int balancedCapture(char type) {\r\n-        int depth = 1;\r\n-        char term = type;\r\n-        switch (type) {\r\n-            case'[':\r\n-                term = ']';\r\n-                break;\r\n-            case'{':\r\n-                term = '}';\r\n-                break;\r\n-        }\r\n-\r\n-        if (type == term) {\r\n-            for (cursor++; cursor < length; cursor++) {\r\n-                if (property[cursor] == type) {\r\n-                    return end = cursor;\r\n-                }\r\n-            }\r\n-        }\r\n-        else {\r\n-            for (cursor++; cursor < length; cursor++) {\r\n-                if (property[cursor] == type) {\r\n-                    depth++;\r\n-                }\r\n-                else if (property[cursor] == term && --depth == 0) {\r\n-                    return end = cursor;\r\n-                }\r\n-            }\r\n-        }\r\n-\r\n-        return -1;\r\n-    }\r\n-\r\n \r\n     public int getEnd() {\r\n         return end;\r\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\nindex 1a53e7c..5479dea 100644\n--- a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n@@ -62,279 +62,279 @@ public class CoreConfidenceTests extends TestCase {\n     }\n \n     public void testSingleProperty() {\n-        assertEquals(false, parseDirect(\"fun\"));\n+        assertEquals(false, test(\"fun\"));\n     }\n \n \n     public void testMethodOnValue() {\n-        assertEquals(\"DOG\", parseDirect(\"foo.bar.name.toUpperCase()\"));\n+        assertEquals(\"DOG\", test(\"foo.bar.name.toUpperCase()\"));\n     }\n \n     public void testSimpleProperty() {\n-        assertEquals(\"dog\", parseDirect(\"foo.bar.name\"));\n+        assertEquals(\"dog\", test(\"foo.bar.name\"));\n     }\n \n     public void testSimpleProperty2() {\n-        assertEquals(\"cat\", parseDirect(\"DATA\"));\n+        assertEquals(\"cat\", test(\"DATA\"));\n     }\n \n     public void testPropertyViaDerivedClass() {\n-        assertEquals(\"cat\", parseDirect(\"derived.data\"));\n+        assertEquals(\"cat\", test(\"derived.data\"));\n     }\n \n     public void testDeepAssignment() {\n-        assertEquals(\"crap\", parseDirect(\"foo.bar.assignTest = 'crap'\"));\n-        assertEquals(\"crap\", parseDirect(\"foo.bar.assignTest\"));\n+        assertEquals(\"crap\", test(\"foo.bar.assignTest = 'crap'\"));\n+        assertEquals(\"crap\", test(\"foo.bar.assignTest\"));\n     }\n \n     public void testThroughInterface() {\n-        assertEquals(\"FOOBAR!\", parseDirect(\"testImpl.name\"));\n+        assertEquals(\"FOOBAR!\", test(\"testImpl.name\"));\n     }\n \n     public void testThroughInterface2() {\n-        assertEquals(true, parseDirect(\"testImpl.foo\"));\n+        assertEquals(true, test(\"testImpl.foo\"));\n     }\n \n     public void testMapAccessWithMethodCall() {\n-        assertEquals(\"happyBar\", parseDirect(\"funMap['foo'].happy()\"));\n+        assertEquals(\"happyBar\", test(\"funMap['foo'].happy()\"));\n     }\n \n     public void testBooleanOperator() {\n-        assertEquals(true, parseDirect(\"foo.bar.woof == true\"));\n+        assertEquals(true, test(\"foo.bar.woof == true\"));\n     }\n \n     public void testBooleanOperator2() {\n-        assertEquals(false, parseDirect(\"foo.bar.woof == false\"));\n+        assertEquals(false, test(\"foo.bar.woof == false\"));\n     }\n \n     public void testBooleanOperator3() {\n-        assertEquals(true, parseDirect(\"foo.bar.woof== true\"));\n+        assertEquals(true, test(\"foo.bar.woof== true\"));\n     }\n \n     public void testBooleanOperator4() {\n-        assertEquals(false, parseDirect(\"foo.bar.woof ==false\"));\n+        assertEquals(false, test(\"foo.bar.woof ==false\"));\n     }\n \n     public void testBooleanOperator5() {\n-        assertEquals(true, parseDirect(\"foo.bar.woof == true\"));\n+        assertEquals(true, test(\"foo.bar.woof == true\"));\n     }\n \n     public void testBooleanOperator6() {\n-        assertEquals(false, parseDirect(\"foo.bar.woof==false\"));\n+        assertEquals(false, test(\"foo.bar.woof==false\"));\n     }\n \n     public void testTextComparison() {\n-        assertEquals(true, parseDirect(\"foo.bar.name == 'dog'\"));\n+        assertEquals(true, test(\"foo.bar.name == 'dog'\"));\n     }\n \n     public void testNETextComparison() {\n-        assertEquals(true, parseDirect(\"foo.bar.name != 'foo'\"));\n+        assertEquals(true, test(\"foo.bar.name != 'foo'\"));\n     }\n \n     public void testChor() {\n-        assertEquals(\"cat\", parseDirect(\"a or b or c\"));\n+        assertEquals(\"cat\", test(\"a or b or c\"));\n     }\n \n     public void testChorWithLiteral() {\n-        assertEquals(\"fubar\", parseDirect(\"a or 'fubar'\"));\n+        assertEquals(\"fubar\", test(\"a or 'fubar'\"));\n     }\n \n     public void testNullCompare() {\n-        assertEquals(true, parseDirect(\"c != null\"));\n+        assertEquals(true, test(\"c != null\"));\n     }\n \n     public void testUninitializedInt() {\n-        assertEquals(0, parseDirect(\"sarahl\"));\n+        assertEquals(0, test(\"sarahl\"));\n     }\n \n     public void testAnd() {\n-        assertEquals(true, parseDirect(\"c != null && foo.bar.name == 'dog' && foo.bar.woof\"));\n+        assertEquals(true, test(\"c != null && foo.bar.name == 'dog' && foo.bar.woof\"));\n     }\n \n     public void testAnd2() {\n-        assertEquals(true, parseDirect(\"c!=null&&foo.bar.name=='dog'&&foo.bar.woof\"));\n+        assertEquals(true, test(\"c!=null&&foo.bar.name=='dog'&&foo.bar.woof\"));\n     }\n \n     public void testMath() {\n-        assertEquals(188.4f, parseDirect(\"pi * hour\"));\n+        assertEquals(188.4f, test(\"pi * hour\"));\n     }\n \n     public void testMath2() {\n-        assertEquals(3, parseDirect(\"foo.number-1\"));\n+        assertEquals(3, test(\"foo.number-1\"));\n     }\n \n     public void testPowerOf() {\n-        assertEquals(25, parseDirect(\"5 ** 2\"));\n+        assertEquals(25, test(\"5 ** 2\"));\n     }\n-    \n+\n     public void EmptyTestWhileUsingImports() {\n         Map imports = new HashMap();\n-        imports.put( \"List\", java.util.List.class);\n-        imports.put( \"ArrayList\", java.util.ArrayList.class);\n-        \n-        ParserContext context = new ParserContext(imports, null, \"testfile\");        \n-        ExpressionCompiler compiler = new ExpressionCompiler( \"List list = new ArrayList(); return (list == empty)\" );                \n-        assertTrue ( (Boolean) MVEL.executeExpression( compiler.compile(context) ) );        \n-    }\n-    \n+        imports.put(\"List\", java.util.List.class);\n+        imports.put(\"ArrayList\", java.util.ArrayList.class);\n+\n+        ParserContext context = new ParserContext(imports, null, \"testfile\");\n+        ExpressionCompiler compiler = new ExpressionCompiler(\"List list = new ArrayList(); return (list == empty)\");\n+        assertTrue((Boolean) MVEL.executeExpression(compiler.compile(context)));\n+    }\n+\n     public void NullTestWhileUsingImports() {\n         Map imports = new HashMap();\n-        imports.put( \"List\", java.util.List.class);\n-        imports.put( \"ArrayList\", java.util.ArrayList.class);\n-        \n-        ParserContext context = new ParserContext(imports, null, \"testfile\");        \n-        ExpressionCompiler compiler = new ExpressionCompiler( \"List list = new ArrayList(); return (list == null)\" );                \n-        assertTrue ( (Boolean) MVEL.executeExpression( compiler.compile(context) ) );        \n-    }    \n+        imports.put(\"List\", java.util.List.class);\n+        imports.put(\"ArrayList\", java.util.ArrayList.class);\n+\n+        ParserContext context = new ParserContext(imports, null, \"testfile\");\n+        ExpressionCompiler compiler = new ExpressionCompiler(\"List list = new ArrayList(); return (list == null)\");\n+        assertTrue((Boolean) MVEL.executeExpression(compiler.compile(context)));\n+    }\n \n     public void testComplexExpression() {\n-        assertEquals(\"bar\", parseDirect(\"a = 'foo'; b = 'bar'; c = 'jim'; list = {a,b,c}; list[1]\"));\n+        assertEquals(\"bar\", test(\"a = 'foo'; b = 'bar'; c = 'jim'; list = {a,b,c}; list[1]\"));\n     }\n \n     public void testComplexAnd() {\n-        assertEquals(true, parseDirect(\"(pi * hour) > 0 && foo.happy() == 'happyBar'\"));\n+        assertEquals(true, test(\"(pi * hour) > 0 && foo.happy() == 'happyBar'\"));\n     }\n \n     public void testShortPathExpression() {\n-        assertEquals(null, parseDirect(\"3 > 4 && foo.toUC('test'); foo.register\"));\n+        assertEquals(null, test(\"3 > 4 && foo.toUC('test'); foo.register\"));\n     }\n \n     public void testShortPathExpression2() {\n-        assertEquals(true, parseDirect(\"4 > 3 || foo.toUC('test')\"));\n+        assertEquals(true, test(\"4 > 3 || foo.toUC('test')\"));\n     }\n \n     public void testShortPathExpression4() {\n-        assertEquals(true, parseDirect(\"4>3||foo.toUC('test')\"));\n+        assertEquals(true, test(\"4>3||foo.toUC('test')\"));\n     }\n \n     public void testOrOperator() {\n-        assertEquals(true, parseDirect(\"true||true\"));\n+        assertEquals(true, test(\"true||true\"));\n     }\n \n     public void testOrOperator2() {\n-        assertEquals(true, parseDirect(\"2 > 3 || 3 > 2\"));\n+        assertEquals(true, test(\"2 > 3 || 3 > 2\"));\n     }\n \n     public void testOrOperator3() {\n-        assertEquals(true, parseDirect(\"pi > 5 || pi > 6 || pi > 3\"));\n+        assertEquals(true, test(\"pi > 5 || pi > 6 || pi > 3\"));\n     }\n \n \n     public void testShortPathExpression3() {\n-        assertEquals(false, parseDirect(\"defnull != null  && defnull.length() > 0\"));\n+        assertEquals(false, test(\"defnull != null  && defnull.length() > 0\"));\n     }\n \n     public void testModulus() {\n         assertEquals(38392 % 2,\n-                parseDirect(\"38392 % 2\"));\n+                test(\"38392 % 2\"));\n     }\n \n \n     public void testLessThan() {\n-        assertEquals(true, parseDirect(\"pi < 3.15\"));\n-        assertEquals(true, parseDirect(\"pi <= 3.14\"));\n-        assertEquals(false, parseDirect(\"pi > 3.14\"));\n-        assertEquals(true, parseDirect(\"pi >= 3.14\"));\n+        assertEquals(true, test(\"pi < 3.15\"));\n+        assertEquals(true, test(\"pi <= 3.14\"));\n+        assertEquals(false, test(\"pi > 3.14\"));\n+        assertEquals(true, test(\"pi >= 3.14\"));\n     }\n \n     public void testMethodAccess() {\n-        assertEquals(\"happyBar\", parseDirect(\"foo.happy()\"));\n+        assertEquals(\"happyBar\", test(\"foo.happy()\"));\n     }\n \n     public void testMethodAccess2() {\n-        assertEquals(\"FUBAR\", parseDirect(\"foo.toUC('fubar')\"));\n+        assertEquals(\"FUBAR\", test(\"foo.toUC('fubar')\"));\n     }\n \n     public void testMethodAccess3() {\n-        assertEquals(true, parseDirect(\"equalityCheck(c, 'cat')\"));\n+        assertEquals(true, test(\"equalityCheck(c, 'cat')\"));\n     }\n \n     public void testMethodAccess4() {\n-        assertEquals(null, parseDirect(\"readBack(null)\"));\n+        assertEquals(null, test(\"readBack(null)\"));\n     }\n \n     public void testMethodAccess5() {\n-        assertEquals(\"nulltest\", parseDirect(\"appendTwoStrings(null, 'test')\"));\n+        assertEquals(\"nulltest\", test(\"appendTwoStrings(null, 'test')\"));\n     }\n \n     public void testMethodAccess6() {\n-        assertEquals(true, parseDirect(\"   equalityCheck(   c  \\n  ,   \\n   'cat'      )   \"));\n+        assertEquals(true, test(\"   equalityCheck(   c  \\n  ,   \\n   'cat'      )   \"));\n     }\n \n     public void testNegation() {\n-        assertEquals(true, parseDirect(\"!fun && !fun\"));\n+        assertEquals(true, test(\"!fun && !fun\"));\n     }\n \n     public void testNegation2() {\n-        assertEquals(false, parseDirect(\"fun && !fun\"));\n+        assertEquals(false, test(\"fun && !fun\"));\n     }\n \n     public void testNegation3() {\n-        assertEquals(true, parseDirect(\"!(fun && fun)\"));\n+        assertEquals(true, test(\"!(fun && fun)\"));\n     }\n \n     public void testNegation4() {\n-        assertEquals(false, parseDirect(\"(fun && fun)\"));\n+        assertEquals(false, test(\"(fun && fun)\"));\n     }\n \n     public void testMultiStatement() {\n-        assertEquals(true, parseDirect(\"populate(); barfoo == 'sarah'\"));\n+        assertEquals(true, test(\"populate(); barfoo == 'sarah'\"));\n     }\n \n     public void testAssignment() {\n-        assertEquals(true, parseDirect(\"populate(); blahfoo = 'sarah'; blahfoo == 'sarah'\"));\n+        assertEquals(true, test(\"populate(); blahfoo = 'sarah'; blahfoo == 'sarah'\"));\n     }\n \n     public void testAssignment2() {\n-        assertEquals(\"sarah\", parseDirect(\"populate(); blahfoo = barfoo\"));\n+        assertEquals(\"sarah\", test(\"populate(); blahfoo = barfoo\"));\n     }\n \n     public void testAssignment3() {\n-        assertEquals(java.lang.Integer.class, parseDirect(\"blah = 5\").getClass());\n+        assertEquals(java.lang.Integer.class, test(\"blah = 5\").getClass());\n     }\n \n     public void testAssignment4() {\n-        assertEquals(102, parseDirect(\"a = 100 + 1 + 1\"));\n+        assertEquals(102, test(\"a = 100 + 1 + 1\"));\n     }\n \n     public void testOr() {\n-        assertEquals(true, parseDirect(\"fun || true\"));\n+        assertEquals(true, test(\"fun || true\"));\n     }\n \n     public void testLiteralPassThrough() {\n-        assertEquals(true, parseDirect(\"true\"));\n+        assertEquals(true, test(\"true\"));\n     }\n \n     public void testLiteralPassThrough2() {\n-        assertEquals(false, parseDirect(\"false\"));\n+        assertEquals(false, test(\"false\"));\n     }\n \n     public void testLiteralPassThrough3() {\n-        assertEquals(null, parseDirect(\"null\"));\n+        assertEquals(null, test(\"null\"));\n     }\n \n     public void testRegEx() {\n-        assertEquals(true, parseDirect(\"foo.bar.name ~= '[a-z].+'\"));\n+        assertEquals(true, test(\"foo.bar.name ~= '[a-z].+'\"));\n     }\n \n     public void testRegExNegate() {\n-        assertEquals(false, parseDirect(\"!(foo.bar.name ~= '[a-z].+')\"));\n+        assertEquals(false, test(\"!(foo.bar.name ~= '[a-z].+')\"));\n     }\n \n     public void testRegEx2() {\n-        assertEquals(true, parseDirect(\"foo.bar.name ~= '[a-z].+' && foo.bar.name != null\"));\n+        assertEquals(true, test(\"foo.bar.name ~= '[a-z].+' && foo.bar.name != null\"));\n     }\n \n     public void testRegEx3() {\n-        assertEquals(true, parseDirect(\"foo.bar.name~='[a-z].+'&&foo.bar.name!=null\"));\n+        assertEquals(true, test(\"foo.bar.name~='[a-z].+'&&foo.bar.name!=null\"));\n     }\n \n     public void testBlank() {\n-        assertEquals(true, parseDirect(\"'' == empty\"));\n+        assertEquals(true, test(\"'' == empty\"));\n     }\n \n     public void testBlank2() {\n-        assertEquals(true, parseDirect(\"BWAH == empty\"));\n+        assertEquals(true, test(\"BWAH == empty\"));\n     }\n \n     public void testBooleanModeOnly2() {\n@@ -346,112 +346,112 @@ public class CoreConfidenceTests extends TestCase {\n     }\n \n     public void testTernary() {\n-        assertEquals(\"foobie\", parseDirect(\"zero==0?'foobie':zero\"));\n+        assertEquals(\"foobie\", test(\"zero==0?'foobie':zero\"));\n     }\n \n     public void testTernary2() {\n-        assertEquals(\"blimpie\", parseDirect(\"zero==1?'foobie':'blimpie'\"));\n+        assertEquals(\"blimpie\", test(\"zero==1?'foobie':'blimpie'\"));\n     }\n \n     public void testTernary3() {\n-        assertEquals(\"foobiebarbie\", parseDirect(\"zero==1?'foobie':'foobie'+'barbie'\"));\n+        assertEquals(\"foobiebarbie\", test(\"zero==1?'foobie':'foobie'+'barbie'\"));\n     }\n \n     public void testStrAppend() {\n-        assertEquals(\"foobarcar\", parseDirect(\"'foo' + 'bar' + 'car'\"));\n+        assertEquals(\"foobarcar\", test(\"'foo' + 'bar' + 'car'\"));\n     }\n \n     public void testStrAppend2() {\n-        assertEquals(\"foobarcar1\", parseDirect(\"'foobar' + 'car' + 1\"));\n+        assertEquals(\"foobarcar1\", test(\"'foobar' + 'car' + 1\"));\n     }\n \n     public void testInstanceCheck1() {\n-        assertEquals(true, parseDirect(\"c is java.lang.String\"));\n+        assertEquals(true, test(\"c is java.lang.String\"));\n     }\n \n     public void testInstanceCheck2() {\n-        assertEquals(false, parseDirect(\"pi is java.lang.Integer\"));\n+        assertEquals(false, test(\"pi is java.lang.Integer\"));\n     }\n \n     public void testInstanceCheck3() {\n-        assertEquals(true, parseDirect(\"foo is org.mvel.tests.main.res.Foo\"));\n+        assertEquals(true, test(\"foo is org.mvel.tests.main.res.Foo\"));\n     }\n \n     public void testBitwiseOr1() {\n-        assertEquals(6, parseDirect(\"2|4\"));\n+        assertEquals(6, test(\"2|4\"));\n     }\n \n     public void testBitwiseOr2() {\n-        assertEquals(true, parseDirect(\"(2 | 1) > 0\"));\n+        assertEquals(true, test(\"(2 | 1) > 0\"));\n     }\n \n     public void testBitwiseOr3() {\n-        assertEquals(true, parseDirect(\"(2|1) == 3\"));\n+        assertEquals(true, test(\"(2|1) == 3\"));\n     }\n \n     public void testBitwiseAnd1() {\n-        assertEquals(2, parseDirect(\"2 & 3\"));\n+        assertEquals(2, test(\"2 & 3\"));\n     }\n \n     public void testShiftLeft() {\n-        assertEquals(4, parseDirect(\"2 << 1\"));\n+        assertEquals(4, test(\"2 << 1\"));\n     }\n \n     public void testUnsignedShiftLeft() {\n-        assertEquals(2, parseDirect(\"-2 <<< 0\"));\n+        assertEquals(2, test(\"-2 <<< 0\"));\n     }\n \n     public void testShiftRight() {\n-        assertEquals(128, parseDirect(\"256 >> 1\"));\n+        assertEquals(128, test(\"256 >> 1\"));\n     }\n \n     public void testXOR() {\n-        assertEquals(3, parseDirect(\"1 ^ 2\"));\n+        assertEquals(3, test(\"1 ^ 2\"));\n     }\n \n     public void testContains1() {\n-        assertEquals(true, parseDirect(\"list contains 'Happy!'\"));\n+        assertEquals(true, test(\"list contains 'Happy!'\"));\n     }\n \n     public void testContains2() {\n-        assertEquals(false, parseDirect(\"list contains 'Foobie'\"));\n+        assertEquals(false, test(\"list contains 'Foobie'\"));\n     }\n \n     public void testContains3() {\n-        assertEquals(true, parseDirect(\"sentence contains 'fox'\"));\n+        assertEquals(true, test(\"sentence contains 'fox'\"));\n     }\n \n     public void testContains4() {\n-        assertEquals(false, parseDirect(\"sentence contains 'mike'\"));\n+        assertEquals(false, test(\"sentence contains 'mike'\"));\n     }\n \n     public void testContains5() {\n-        assertEquals(true, parseDirect(\"!(sentence contains 'mike')\"));\n+        assertEquals(true, test(\"!(sentence contains 'mike')\"));\n     }\n \n     public void testInvert() {\n-        assertEquals(~10, parseDirect(\"~10\"));\n+        assertEquals(~10, test(\"~10\"));\n     }\n \n     public void testInvert2() {\n-        assertEquals(~(10 + 1), parseDirect(\"~(10 + 1)\"));\n+        assertEquals(~(10 + 1), test(\"~(10 + 1)\"));\n     }\n \n     public void testInvert3() {\n-        assertEquals(~10 + (1 + ~50), parseDirect(\"~10 + (1 + ~50)\"));\n+        assertEquals(~10 + (1 + ~50), test(\"~10 + (1 + ~50)\"));\n     }\n \n \n     public void testListCreation2() {\n-        assertTrue(parseDirect(\"[\\\"test\\\"]\") instanceof List);\n+        assertTrue(test(\"[\\\"test\\\"]\") instanceof List);\n     }\n \n     public void testListCreation3() {\n-        assertTrue(parseDirect(\"[66]\") instanceof List);\n+        assertTrue(test(\"[66]\") instanceof List);\n     }\n \n     public void testListCreation4() {\n-        List ar = (List) parseDirect(\"[   66   , \\\"test\\\"   ]\");\n+        List ar = (List) test(\"[   66   , \\\"test\\\"   ]\");\n         assertEquals(2, ar.size());\n         assertEquals(66, ar.get(0));\n         assertEquals(\"test\", ar.get(1));\n@@ -459,64 +459,64 @@ public class CoreConfidenceTests extends TestCase {\n \n \n     public void testListCreationWithCall() {\n-        assertEquals(1, parseDirect(\"[\\\"apple\\\"].size()\"));\n+        assertEquals(1, test(\"[\\\"apple\\\"].size()\"));\n     }\n \n     public void testArrayCreationWithLength() {\n-        assertEquals(2, parseDirect(\"Array.getLength({'foo', 'bar'})\"));\n+        assertEquals(2, test(\"Array.getLength({'foo', 'bar'})\"));\n     }\n \n     public void testEmptyList() {\n-        assertTrue(parseDirect(\"[]\") instanceof List);\n+        assertTrue(test(\"[]\") instanceof List);\n     }\n \n     public void testEmptyArray() {\n-        assertTrue(((Object[]) parseDirect(\"{}\")).length == 0);\n+        assertTrue(((Object[]) test(\"{}\")).length == 0);\n     }\n \n     public void testEmptyArray2() {\n-        assertTrue(((Object[]) parseDirect(\"{    }\")).length == 0);\n+        assertTrue(((Object[]) test(\"{    }\")).length == 0);\n     }\n \n     public void testArrayCreation() {\n-        assertEquals(0, parseDirect(\"arrayTest = {{1, 2, 3}, {2, 1, 0}}; arrayTest[1][2]\"));\n+        assertEquals(0, test(\"arrayTest = {{1, 2, 3}, {2, 1, 0}}; arrayTest[1][2]\"));\n     }\n \n     public void testMapCreation() {\n-        assertEquals(\"sarah\", parseDirect(\"map = ['mike':'sarah','tom':'jacquelin']; map['mike']\"));\n+        assertEquals(\"sarah\", test(\"map = ['mike':'sarah','tom':'jacquelin']; map['mike']\"));\n     }\n \n     public void testMapCreation2() {\n-        assertEquals(\"sarah\", parseDirect(\"map = ['mike' :'sarah'  ,'tom'  :'jacquelin'  ]; map['mike']\"));\n+        assertEquals(\"sarah\", test(\"map = ['mike' :'sarah'  ,'tom'  :'jacquelin'  ]; map['mike']\"));\n     }\n \n     public void testMapCreation3() {\n-        assertEquals(\"foo\", parseDirect(\"map = [1 : 'foo']; map[1]\"));\n+        assertEquals(\"foo\", test(\"map = [1 : 'foo']; map[1]\"));\n     }\n \n     public void testProjectionSupport() {\n-        assertEquals(true, parseDirect(\"(name in things)contains'Bob'\"));\n+        assertEquals(true, test(\"(name in things)contains'Bob'\"));\n     }\n \n     public void testProjectionSupport1() {\n-        assertEquals(true, parseDirect(\"(name in things) contains 'Bob'\"));\n+        assertEquals(true, test(\"(name in things) contains 'Bob'\"));\n     }\n \n     public void testProjectionSupport2() {\n-        assertEquals(3, parseDirect(\"(name in things).size()\"));\n+        assertEquals(3, test(\"(name in things).size()\"));\n     }\n \n     public void testSizeOnInlineArray() {\n-        assertEquals(3, parseDirect(\"{1,2,3}.size()\"));\n+        assertEquals(3, test(\"{1,2,3}.size()\"));\n     }\n \n \n     public void testStaticMethodFromLiteral() {\n-        assertEquals(String.class.getName(), parseDirect(\"String.valueOf(Class.forName('java.lang.String').getName())\"));\n+        assertEquals(String.class.getName(), test(\"String.valueOf(Class.forName('java.lang.String').getName())\"));\n     }\n \n //    public void testMethodCallsEtc() {\n-//        parseDirect(\"title = 1; \" +\n+//        test(\"title = 1; \" +\n //                \"frame = new javax.swing.JFrame; \" +\n //                \"label = new javax.swing.JLabel; \" +\n //                \"title = title + 1;\" +\n@@ -528,71 +528,71 @@ public class CoreConfidenceTests extends TestCase {\n //    }\n \n     public void testObjectInstantiation() {\n-        parseDirect(\"new java.lang.String('foobie')\");\n+        test(\"new java.lang.String('foobie')\");\n     }\n \n     public void testObjectInstantiationWithMethodCall() {\n-        parseDirect(\"new String('foobie')  . toString()\");\n+        test(\"new String('foobie')  . toString()\");\n     }\n \n     public void testObjectInstantiation2() {\n-        parseDirect(\"new String() is String\");\n+        test(\"new String() is String\");\n     }\n \n     public void testObjectInstantiation3() {\n-        parseDirect(\"new java.text.SimpleDateFormat('yyyy').format(new java.util.Date(System.currentTimeMillis()))\");\n+        test(\"new java.text.SimpleDateFormat('yyyy').format(new java.util.Date(System.currentTimeMillis()))\");\n     }\n \n     public void testArrayCoercion() {\n-        assertEquals(\"gonk\", parseDirect(\"funMethod( {'gonk', 'foo'} )\"));\n+        assertEquals(\"gonk\", test(\"funMethod( {'gonk', 'foo'} )\"));\n     }\n \n     public void testArrayCoercion2() {\n-        assertEquals(10, parseDirect(\"sum({2,2,2,2,2})\"));\n+        assertEquals(10, test(\"sum({2,2,2,2,2})\"));\n     }\n \n     public void testMapAccess() {\n-        assertEquals(\"dog\", parseDirect(\"funMap['foo'].bar.name\"));\n+        assertEquals(\"dog\", test(\"funMap['foo'].bar.name\"));\n     }\n \n     public void testMapAccess2() {\n-        assertEquals(\"dog\", parseDirect(\"funMap.foo.bar.name\"));\n+        assertEquals(\"dog\", test(\"funMap.foo.bar.name\"));\n     }\n \n     public void testSoundex() {\n-        assertTrue((Boolean) parseDirect(\"'foobar' soundslike 'fubar'\"));\n+        assertTrue((Boolean) test(\"'foobar' soundslike 'fubar'\"));\n     }\n \n     public void testSoundex2() {\n-        assertFalse((Boolean) parseDirect(\"'flexbar' soundslike 'fubar'\"));\n+        assertFalse((Boolean) test(\"'flexbar' soundslike 'fubar'\"));\n     }\n \n     public void testThisReference() {\n-        assertEquals(true, parseDirect(\"this\") instanceof Base);\n+        assertEquals(true, test(\"this\") instanceof Base);\n     }\n \n     public void testThisReference2() {\n-        assertEquals(true, parseDirect(\"this.funMap\") instanceof Map);\n+        assertEquals(true, test(\"this.funMap\") instanceof Map);\n     }\n \n     public void testThisReference3() {\n-        assertEquals(true, parseDirect(\"this is org.mvel.tests.main.res.Base\"));\n+        assertEquals(true, test(\"this is org.mvel.tests.main.res.Base\"));\n     }\n \n     public void testThisReference4() {\n-        assertEquals(true, parseDirect(\"this.funMap instanceof java.util.Map\"));\n+        assertEquals(true, test(\"this.funMap instanceof java.util.Map\"));\n     }\n \n     public void testThisReference5() {\n-        assertEquals(true, parseDirect(\"this.data == 'cat'\"));\n+        assertEquals(true, test(\"this.data == 'cat'\"));\n     }\n \n     public void testThisReferenceInMethodCall() {\n-        assertEquals(101, parseDirect(\"Integer.parseInt(this.number)\"));\n+        assertEquals(101, test(\"Integer.parseInt(this.number)\"));\n     }\n \n     public void testThisReferenceInConstructor() {\n-        assertEquals(\"101\", parseDirect(\"new String(this.number)\"));\n+        assertEquals(\"101\", test(\"new String(this.number)\"));\n     }\n \n \n@@ -643,11 +643,11 @@ public class CoreConfidenceTests extends TestCase {\n     }\n \n     public void testStringEscaping() {\n-        assertEquals(\"\\\"Mike Brock\\\"\", parseDirect(\"\\\"\\\\\\\"Mike Brock\\\\\\\"\\\"\"));\n+        assertEquals(\"\\\"Mike Brock\\\"\", test(\"\\\"\\\\\\\"Mike Brock\\\\\\\"\\\"\"));\n     }\n \n     public void testStringEscaping2() {\n-        assertEquals(\"MVEL's Parser is Fast\", parseDirect(\"'MVEL\\\\'s Parser is Fast'\"));\n+        assertEquals(\"MVEL's Parser is Fast\", test(\"'MVEL\\\\'s Parser is Fast'\"));\n     }\n \n     public void testEvalToBoolean() {\n@@ -661,7 +661,7 @@ public class CoreConfidenceTests extends TestCase {\n     }\n \n     public void testSubListInMap() {\n-        assertEquals(\"pear\", parseDirect(\"map = ['test' : 'poo', 'foo' : [c, 'pear']]; map['foo'][1]\"));\n+        assertEquals(\"pear\", test(\"map = ['test' : 'poo', 'foo' : [c, 'pear']]; map['foo'][1]\"));\n     }\n \n     public void testCompiledMethodCall() {\n@@ -670,82 +670,82 @@ public class CoreConfidenceTests extends TestCase {\n     }\n \n     public void testStaticNamespaceCall() {\n-        assertEquals(java.util.ArrayList.class, parseDirect(\"java.util.ArrayList\"));\n+        assertEquals(java.util.ArrayList.class, test(\"java.util.ArrayList\"));\n     }\n \n     public void testStaticNamespaceClassWithMethod() {\n-        assertEquals(\"FooBar\", parseDirect(\"java.lang.String.valueOf('FooBar')\"));\n+        assertEquals(\"FooBar\", test(\"java.lang.String.valueOf('FooBar')\"));\n     }\n \n     public void testConstructor() {\n-        assertEquals(\"foo\", parseDirect(\"a = 'foobar'; new String(a.toCharArray(), 0, 3)\"));\n+        assertEquals(\"foo\", test(\"a = 'foobar'; new String(a.toCharArray(), 0, 3)\"));\n     }\n \n     public void testStaticNamespaceClassWithField() {\n-        assertEquals(Integer.MAX_VALUE, parseDirect(\"java.lang.Integer.MAX_VALUE\"));\n+        assertEquals(Integer.MAX_VALUE, test(\"java.lang.Integer.MAX_VALUE\"));\n     }\n \n     public void testStaticNamespaceClassWithField2() {\n-        assertEquals(Integer.MAX_VALUE, parseDirect(\"Integer.MAX_VALUE\"));\n+        assertEquals(Integer.MAX_VALUE, test(\"Integer.MAX_VALUE\"));\n     }\n \n     public void testStaticFieldAsMethodParm() {\n-        assertEquals(String.valueOf(Integer.MAX_VALUE), parseDirect(\"String.valueOf(Integer.MAX_VALUE)\"));\n+        assertEquals(String.valueOf(Integer.MAX_VALUE), test(\"String.valueOf(Integer.MAX_VALUE)\"));\n     }\n \n     public void testEmptyIf() {\n-        assertEquals(5, parseDirect(\"a = 5; if (a == 5) { }; return a;\"));\n+        assertEquals(5, test(\"a = 5; if (a == 5) { }; return a;\"));\n     }\n \n     public void testEmptyIf2() {\n-        assertEquals(5, parseDirect(\"a=5;if(a==5){};return a;\"));\n+        assertEquals(5, test(\"a=5;if(a==5){};return a;\"));\n     }\n \n     public void testIf() {\n-        assertEquals(10, parseDirect(\"if (5 > 4) { return 10; } else { return 5; }\"));\n+        assertEquals(10, test(\"if (5 > 4) { return 10; } else { return 5; }\"));\n     }\n \n     public void testIf2() {\n-        assertEquals(10, parseDirect(\"if (5 < 4) { return 5; } else { return 10; }\"));\n+        assertEquals(10, test(\"if (5 < 4) { return 5; } else { return 10; }\"));\n     }\n \n     public void testIf3() {\n-        assertEquals(10, parseDirect(\"if(5<4){return 5;}else{return 10;}\"));\n+        assertEquals(10, test(\"if(5<4){return 5;}else{return 10;}\"));\n     }\n \n     public void testIfAndElse() {\n-        assertEquals(true, parseDirect(\"if (false) { return false; } else { return true; }\"));\n+        assertEquals(true, test(\"if (false) { return false; } else { return true; }\"));\n     }\n \n     public void testIfAndElseif() {\n-        assertEquals(true, parseDirect(\"if (false) { return false; } else if(100 < 50) { return false; } else if (10 > 5) return true;\"));\n+        assertEquals(true, test(\"if (false) { return false; } else if(100 < 50) { return false; } else if (10 > 5) return true;\"));\n     }\n \n     public void testIfAndElseIfCondensedGrammar() {\n-        assertEquals(\"Foo\", parseDirect(\"if (false) return 'Bar'; else return 'Foo';\"));\n+        assertEquals(\"Foo\", test(\"if (false) return 'Bar'; else return 'Foo';\"));\n     }\n \n     public void testForeEach2() {\n-        assertEquals(6, parseDirect(\"total = 0; a = {1,2,3}; foreach(item : a) { total += item }; total\"));\n+        assertEquals(6, test(\"total = 0; a = {1,2,3}; foreach(item : a) { total += item }; total\"));\n     }\n \n     public void testForEach3() {\n-        assertEquals(true, parseDirect(\"a = {1,2,3}; foreach (i : a) { if (i == 1) { return true; } }\"));\n+        assertEquals(true, test(\"a = {1,2,3}; foreach (i : a) { if (i == 1) { return true; } }\"));\n     }\n \n     public void testForEach4() {\n-        assertEquals(\"OneTwoThreeFour\", parseDirect(\"a = {1,2,3,4}; builder = ''; foreach (i : a) {\" +\n+        assertEquals(\"OneTwoThreeFour\", test(\"a = {1,2,3,4}; builder = ''; foreach (i : a) {\" +\n                 \" if (i == 1) { builder += 'One' } else if (i == 2) { builder += 'Two' } \" +\n                 \"else if (i == 3) { builder += 'Three' } else { builder += 'Four' }\" +\n                 \"}; builder;\"));\n     }\n \n     public void testWith() {\n-        assertEquals(\"OneTwo\", parseDirect(\"with (foo) {aValue = 'One',bValue='Two'}; foo.aValue + foo.bValue;\"));\n+        assertEquals(\"OneTwo\", test(\"with (foo) {aValue = 'One',bValue='Two'}; foo.aValue + foo.bValue;\"));\n     }\n \n     public void testWith2() {\n-        assertEquals(\"OneTwo\", parseDirect(\n+        assertEquals(\"OneTwo\", test(\n                 \"with (foo) { \\n\" +\n                         \"aValue = 'One', \\n\" +\n                         \"bValue='Two' \\n\" +\n@@ -755,7 +755,7 @@ public class CoreConfidenceTests extends TestCase {\n \n     public void testAssertion() {\n         try {\n-            parseDirect(\"assert false\");\n+            test(\"assert false\");\n             assertTrue(false);\n         }\n         catch (AssertionError error) {\n@@ -764,7 +764,7 @@ public class CoreConfidenceTests extends TestCase {\n \n     public void testAssertion2() {\n         try {\n-            parseDirect(\"assert true;\");\n+            test(\"assert true;\");\n         }\n         catch (AssertionError error) {\n             assertTrue(false);\n@@ -772,20 +772,20 @@ public class CoreConfidenceTests extends TestCase {\n     }\n \n     public void testMagicArraySize() {\n-        assertEquals(5, parseDirect(\"stringArray.size()\"));\n+        assertEquals(5, test(\"stringArray.size()\"));\n     }\n \n     public void testMagicArraySize2() {\n-        assertEquals(5, parseDirect(\"intArray.size()\"));\n+        assertEquals(5, test(\"intArray.size()\"));\n     }\n \n     public void testStaticVarAssignment() {\n-        assertEquals(\"1\", parseDirect(\"String mikeBrock = 1; mikeBrock\"));\n+        assertEquals(\"1\", test(\"String mikeBrock = 1; mikeBrock\"));\n     }\n \n     public void testIntentionalFailure() {\n         try {\n-            parseDirect(\"int = 0\"); // should fail because int is a reserved word.\n+            test(\"int = 0\"); // should fail because int is a reserved word.\n             assertTrue(false);\n         }\n         catch (Exception e) {\n@@ -793,67 +793,67 @@ public class CoreConfidenceTests extends TestCase {\n     }\n \n     public void testImport() {\n-        assertEquals(HashMap.class, parseDirect(\"import java.util.HashMap; HashMap;\"));\n+        assertEquals(HashMap.class, test(\"import java.util.HashMap; HashMap;\"));\n     }\n \n     public void testStaticImport() {\n-        assertEquals(2.0, parseDirect(\"import_static java.lang.Math.sqrt; sqrt(4)\"));\n+        assertEquals(2.0, test(\"import_static java.lang.Math.sqrt; sqrt(4)\"));\n     }\n \n     public void testFunctionPointer() {\n-        assertEquals(2.0, parseDirect(\"squareRoot = java.lang.Math.sqrt; squareRoot(4)\"));\n+        assertEquals(2.0, test(\"squareRoot = java.lang.Math.sqrt; squareRoot(4)\"));\n     }\n \n     public void testFunctionPointerAsParam() {\n-        assertEquals(\"2.0\", parseDirect(\"squareRoot = Math.sqrt; new String(String.valueOf(squareRoot(4)));\"));\n+        assertEquals(\"2.0\", test(\"squareRoot = Math.sqrt; new String(String.valueOf(squareRoot(4)));\"));\n     }\n \n     public void testFunctionPointerInAssignment() {\n-        assertEquals(5.0, parseDirect(\"squareRoot = Math.sqrt; i = squareRoot(25); return i;\"));\n+        assertEquals(5.0, test(\"squareRoot = Math.sqrt; i = squareRoot(25); return i;\"));\n     }\n \n     public void testIncrementOperator() {\n-        assertEquals(2, parseDirect(\"x = 1; x++; x\"));\n+        assertEquals(2, test(\"x = 1; x++; x\"));\n     }\n \n     public void testPreIncrementOperator() {\n-        assertEquals(2, parseDirect(\"x = 1; ++x\"));\n+        assertEquals(2, test(\"x = 1; ++x\"));\n     }\n \n     public void testDecrementOperator() {\n-        assertEquals(1, parseDirect(\"x = 2; x--; x\"));\n+        assertEquals(1, test(\"x = 2; x--; x\"));\n     }\n \n     public void testPreDecrementOperator() {\n-        assertEquals(1, parseDirect(\"x = 2; --x\"));\n+        assertEquals(1, test(\"x = 2; --x\"));\n     }\n \n     public void testQualifiedStaticTyping() {\n-        assertEquals(20, parseDirect(\"java.math.BigDecimal a = new java.math.BigDecimal( 10.0 ); java.math.BigDecimal b = new java.math.BigDecimal( 10.0 ); java.math.BigDecimal c = a + b; return c; \"));\n+        assertEquals(20, test(\"java.math.BigDecimal a = new java.math.BigDecimal( 10.0 ); java.math.BigDecimal b = new java.math.BigDecimal( 10.0 ); java.math.BigDecimal c = a + b; return c; \"));\n     }\n \n     public void testUnQualifiedStaticTyping() {\n-        assertEquals(20, parseDirect(\"import java.math.BigDecimal; BigDecimal a = new BigDecimal( 10.0 ); BigDecimal b = new BigDecimal( 10.0 ); BigDecimal c = a + b; return c; \"));\n+        assertEquals(20, test(\"import java.math.BigDecimal; BigDecimal a = new BigDecimal( 10.0 ); BigDecimal b = new BigDecimal( 10.0 ); BigDecimal c = a + b; return c; \"));\n     }\n \n     public void testObjectCreation() {\n-        assertEquals(6, parseDirect(\"new Integer( 6 )\"));\n+        assertEquals(6, test(\"new Integer( 6 )\"));\n     }\n \n     public void testTernary4() {\n-        assertEquals(\"<test>\", parseDirect(\"true ? '<test>' : '<poo>'\"));\n+        assertEquals(\"<test>\", test(\"true ? '<test>' : '<poo>'\"));\n     }\n \n     public void testStringAsCollection() {\n-        assertEquals('o', parseDirect(\"abc = 'foo'; abc[1]\"));\n+        assertEquals('o', test(\"abc = 'foo'; abc[1]\"));\n     }\n \n     public void testSubExpressionIndexer() {\n-        assertEquals(\"bar\", parseDirect(\"xx = new java.util.HashMap(); xx.put('foo', 'bar'); prop = 'foo'; xx[prop];\"));\n+        assertEquals(\"bar\", test(\"xx = new java.util.HashMap(); xx.put('foo', 'bar'); prop = 'foo'; xx[prop];\"));\n     }\n \n     public void testCompileTimeLiteralReduction() {\n-        assertEquals(1000, parseDirect(\"10 * 100\"));\n+        assertEquals(1000, test(\"10 * 100\"));\n     }\n \n     public void testInterfaceResolution() {\n@@ -874,7 +874,7 @@ public class CoreConfidenceTests extends TestCase {\n      */\n     public void testCreationOfSet() {\n         assertEquals(\"foo bar foo bar\",\n-                parseDirect(\"set = new java.util.HashSet(); \" +\n+                test(\"set = new java.util.HashSet(); \" +\n                         \"set.add('foo');\" +\n                         \"set.add('bar');\" +\n                         \"output = '';\" +\n@@ -891,7 +891,7 @@ public class CoreConfidenceTests extends TestCase {\n \n \n     public void testCreationOfList() {\n-        assertEquals(5, parseDirect(\"l = new java.util.LinkedList();\" +\n+        assertEquals(5, test(\"l = new java.util.LinkedList();\" +\n                 \"l.add('fun');\" +\n                 \"l.add('happy');\" +\n                 \"l.add('fun');\" +\n@@ -902,7 +902,7 @@ public class CoreConfidenceTests extends TestCase {\n     }\n \n     public void testMapOperations() {\n-        assertEquals(\"poo5\", parseDirect(\n+        assertEquals(\"poo5\", test(\n                 \"l = new java.util.ArrayList();\" +\n                         \"l.add('plop');\" +\n                         \"l.add('poo');\" +\n@@ -919,7 +919,7 @@ public class CoreConfidenceTests extends TestCase {\n     }\n \n     public void testStackOperations() {\n-        assertEquals(10, parseDirect(\n+        assertEquals(10, test(\n                 \"stk = new java.util.Stack();\" +\n                         \"stk.push(5);\" +\n                         \"stk.push(5);\" +\n@@ -928,7 +928,7 @@ public class CoreConfidenceTests extends TestCase {\n     }\n \n     public void testSystemOutPrint() {\n-        parseDirect(\"a = 0;\\r\\nSystem.out.println('This is a test');\");\n+        test(\"a = 0;\\r\\nSystem.out.println('This is a test');\");\n     }\n \n     public void testBreakpoints() {\n@@ -1162,7 +1162,7 @@ public class CoreConfidenceTests extends TestCase {\n \n \n     public void testReflectionCache() {\n-        assertEquals(\"happyBar\", parseDirect(\"foo.happy(); foo.bar.happy()\"));\n+        assertEquals(\"happyBar\", test(\"foo.happy(); foo.bar.happy()\"));\n     }\n \n     public void testVarInputs() {\n@@ -1327,22 +1327,22 @@ public class CoreConfidenceTests extends TestCase {\n     }\n \n     public void testComments() {\n-        assertEquals(10, parseDirect(\"// This is a comment\\n5 + 5\"));\n+        assertEquals(10, test(\"// This is a comment\\n5 + 5\"));\n     }\n \n     public void testComments2() {\n-        assertEquals(20, parseDirect(\"10 + 10; // This is a comment\"));\n+        assertEquals(20, test(\"10 + 10; // This is a comment\"));\n     }\n \n     public void testComments3() {\n-        assertEquals(30, parseDirect(\"/* This is a test of\\r\\n\" +\n+        assertEquals(30, test(\"/* This is a test of\\r\\n\" +\n                 \"MVEL's support for\\r\\n\" +\n                 \"multi-line comments\\r\\n\" +\n                 \"*/\\r\\n 15 + 15\"));\n     }\n \n     public void testComments4() {\n-        assertEquals(50, parseDirect(\"/** This is a fun test script **/\\r\\n\" +\n+        assertEquals(50, test(\"/** This is a fun test script **/\\r\\n\" +\n                 \"a = 10;\\r\\n\" +\n                 \"/**\\r\\n\" +\n                 \"* Here is a useful variable\\r\\n\" +\n@@ -1353,7 +1353,7 @@ public class CoreConfidenceTests extends TestCase {\n     }\n \n     public void testSubtractNoSpace1() {\n-        assertEquals(59, parseDirect(\"hour-1\"));\n+        assertEquals(59, test(\"hour-1\"));\n     }\n \n     public void testStrictTypingCompilation() {\n@@ -1449,7 +1449,7 @@ public class CoreConfidenceTests extends TestCase {\n         map.put(\"dt1\", new Date(currentTimeMillis() - 100000));\n         map.put(\"dt2\", new Date(currentTimeMillis()));\n \n-        assertTrue((Boolean) parseDirect(\"dt1 < dt2\"));\n+        assertTrue((Boolean) test(\"dt1 < dt2\"));\n     }\n \n     public void testDynamicDeop() {\n@@ -1470,47 +1470,47 @@ public class CoreConfidenceTests extends TestCase {\n     }\n \n     public void testMapPropertyCreateCondensed() {\n-        assertEquals(\"foo\", parseDirect(\"map = new java.util.HashMap(); map['test'] = 'foo'; map['test'];\"));\n+        assertEquals(\"foo\", test(\"map = new java.util.HashMap(); map['test'] = 'foo'; map['test'];\"));\n     }\n \n     public void testClassLiteral() {\n-        assertEquals(String.class, parseDirect(\"java.lang.String\"));\n+        assertEquals(String.class, test(\"java.lang.String\"));\n     }\n \n     public void testDeepMethod() {\n-        assertEquals(false, parseDirect(\"foo.bar.testList.add(new String()); foo.bar.testList == empty\"));\n+        assertEquals(false, test(\"foo.bar.testList.add(new String()); foo.bar.testList == empty\"));\n     }\n \n     public void testArrayAccessorAssign() {\n-        assertEquals(\"foo\", parseDirect(\"a = {'f00', 'bar'}; a[0] = 'foo'; a[0]\"));\n+        assertEquals(\"foo\", test(\"a = {'f00', 'bar'}; a[0] = 'foo'; a[0]\"));\n     }\n \n     public void testListAccessorAssign() {\n-        assertEquals(\"bar\", parseDirect(\"a = new java.util.ArrayList(); a.add('foo'); a.add('BAR'); a[1] = 'bar'; a[1]\"));\n+        assertEquals(\"bar\", test(\"a = new java.util.ArrayList(); a.add('foo'); a.add('BAR'); a[1] = 'bar'; a[1]\"));\n     }\n \n     public void testBracketInString() {\n-        parseDirect(\"System.out.println('1)your guess was:');\");\n+        test(\"System.out.println('1)your guess was:');\");\n     }\n \n     public void testNesting() {\n-        assertEquals(\"foo\", parseDirect(\"new String(new String(new String(\\\"foo\\\")));\"));\n+        assertEquals(\"foo\", test(\"new String(new String(new String(\\\"foo\\\")));\"));\n     }\n \n     public void testDeepPropertyAdd() {\n-        assertEquals(10, parseDirect(\"foo.countTest+ 10\"));\n+        assertEquals(10, test(\"foo.countTest+ 10\"));\n     }\n \n     public void testDeepAssignmentIncrement() {\n-        assertEquals(true, parseDirect(\"foo.countTest += 5; if (foo.countTest == 5) { foo.countTest = 0; return true; } else { foo.countTest = 0; return false; }\"));\n+        assertEquals(true, test(\"foo.countTest += 5; if (foo.countTest == 5) { foo.countTest = 0; return true; } else { foo.countTest = 0; return false; }\"));\n     }\n \n     public void testDeepAssignmentWithBlock() {\n-        assertEquals(true, parseDirect(\"with (foo) { countTest += 5 }; if (foo.countTest == 5) { foo.countTest = 0; return true; } else { foo.countTest = 0; return false; }\"));\n+        assertEquals(true, test(\"with (foo) { countTest += 5 }; if (foo.countTest == 5) { foo.countTest = 0; return true; } else { foo.countTest = 0; return false; }\"));\n     }\n \n     public void testTypeCast() {\n-        assertEquals(\"10\", parseDirect(\"(String) 10\"));\n+        assertEquals(\"10\", test(\"(String) 10\"));\n     }\n \n     public void testMapAccessSemantics() {\n@@ -1574,7 +1574,7 @@ public class CoreConfidenceTests extends TestCase {\n         assertEquals(0, MVEL.executeExpression(s, new LocalVariableResolverFactory()));\n     }\n \n-    public Object parseDirect(String ex) {\n+    public Object test(String ex) {\n         return compiledExecute(ex, this.base, this.map);\n     }\n \n@@ -1727,7 +1727,7 @@ public class CoreConfidenceTests extends TestCase {\n     public void testToList() {\n         String text = \"misc.toList(foo.bar.name, 'hello', 42, ['key1' : 'value1', c : [ foo.bar.age, 'car', 42 ]], [42, [c : 'value1']] )\";\n \n-        List list = (List) parseDirect(text);\n+        List list = (List) test(text);\n \n         assertSame(\"dog\", list.get(0));\n         assertEquals(\"hello\", list.get(1));\n@@ -2183,4 +2183,13 @@ public class CoreConfidenceTests extends TestCase {\n             this.bigint = bigint;\n         }\n     }\n+\n+    /**\n+     * Submitted by: Michael Neale\n+     */\n+\n+    public void testInlineCollectionParser1() {\n+        assertEquals(\"q\", ((Map) test(\"['Person.age' : [1, 2, 3, 4],'Person.rating' : 'q']\")).get(\"Person.rating\"));\n+        assertEquals(\"q\", ((Map) test(\"['Person.age' : [1, 2, 3, 4], 'Person.rating' : 'q']\")).get(\"Person.rating\"));\n+    }\n }\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T18:45:22.819619Z", "commit_hash": "829a1e6521856a63e9a7310b2bf2168ab039f4dc", "commit_message": "regression fixed.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/ast/WithNode.java b/src/main/java/org/mvel/ast/WithNode.java\nindex 02753ca..fb35842 100644\n--- a/src/main/java/org/mvel/ast/WithNode.java\n+++ b/src/main/java/org/mvel/ast/WithNode.java\n@@ -2,11 +2,12 @@ package org.mvel.ast;\n \r\n import org.mvel.CompileException;\r\n import org.mvel.ExecutableStatement;\r\n-import static org.mvel.MVEL.setProperty;\r\n+import org.mvel.MVEL;\r\n import org.mvel.Operator;\r\n import org.mvel.integration.VariableResolverFactory;\r\n import static org.mvel.util.ParseTools.*;\r\n \r\n+import java.io.Serializable;\r\n import java.util.ArrayList;\r\n import java.util.List;\r\n \r\n@@ -31,10 +32,12 @@ public class WithNode extends BlockNode implements NestedStatement {\n         Object ctxObject = nestedStatement.getValue(ctx, thisValue, factory);\r\n \r\n         for (ParmValuePair pvp : withExpressions) {\r\n-            if (pvp.getParameter() != null)\r\n-                setProperty(ctxObject, pvp.getParameter(), pvp.getStatement().getValue(ctx, thisValue, factory));\r\n-            else\r\n+            if (pvp.getSetExpression() != null) {\r\n+                MVEL.executeSetExpression(pvp.getSetExpression(), ctxObject, factory, pvp.getStatement().getValue(ctx, thisValue, factory));\r\n+            }\r\n+            else {\r\n                 pvp.getStatement().getValue(ctxObject, ctxObject, factory);\r\n+            }\r\n         }\r\n \r\n         return ctxObject;\r\n@@ -60,33 +63,36 @@ public class WithNode extends BlockNode implements NestedStatement {\n                     if ((i = balancedCapture(block, i, block[i])) == -1) {\r\n                         throw new CompileException(\"unbalanced braces\", block, i);\r\n                     }\r\n-                    break;\r\n+                    continue;\r\n \r\n                 case'*':\r\n                     if (i < block.length && block[i + 1] == '=') {\r\n                         oper = Operator.MULT;\r\n-                        break;\r\n                     }\r\n+                    continue;\r\n+\r\n                 case'/':\r\n                     if (i < block.length && block[i + 1] == '=') {\r\n                         oper = Operator.DIV;\r\n-                        break;\r\n                     }\r\n+                    continue;\r\n+\r\n                 case'-':\r\n                     if (i < block.length && block[i + 1] == '=') {\r\n                         oper = Operator.SUB;\r\n-                        break;\r\n                     }\r\n+                    continue;\r\n+\r\n                 case'+':\r\n                     if (i < block.length && block[i + 1] == '=') {\r\n                         oper = Operator.ADD;\r\n-                        break;\r\n                     }\r\n+                    continue;\r\n \r\n                 case'=':\r\n                     parm = new String(block, start, i - start - (oper != -1 ? 1 : 0)).trim();\r\n                     start = ++i;\r\n-                    break;\r\n+                    continue;\r\n \r\n                 case',':\r\n                     if (parm == null) {\r\n@@ -141,23 +147,24 @@ public class WithNode extends BlockNode implements NestedStatement {\n     }\r\n \r\n     public static final class ParmValuePair {\r\n-        private String parameter;\r\n+        private Serializable setExpression;\r\n         private ExecutableStatement statement;\r\n \r\n         public ParmValuePair() {\r\n         }\r\n \r\n         public ParmValuePair(String parameter, ExecutableStatement statement) {\r\n-            this.parameter = parameter;\r\n+            this.setExpression = MVEL.compileSetExpression(parameter);\r\n             this.statement = statement;\r\n         }\r\n \r\n-        public String getParameter() {\r\n-            return parameter;\r\n+\r\n+        public Serializable getSetExpression() {\r\n+            return setExpression;\r\n         }\r\n \r\n-        public void setParameter(String parameter) {\r\n-            this.parameter = parameter;\r\n+        public void setSetExpression(Serializable setExpression) {\r\n+            this.setExpression = setExpression;\r\n         }\r\n \r\n         public ExecutableStatement getStatement() {\r\ndiff --git a/src/main/java/org/mvel/util/ParseTools.java b/src/main/java/org/mvel/util/ParseTools.java\nindex d9e38ba..b33d279 100644\n--- a/src/main/java/org/mvel/util/ParseTools.java\n+++ b/src/main/java/org/mvel/util/ParseTools.java\n@@ -555,7 +555,9 @@ public class ParseTools {\n     }\n \n     public static char[] createShortFormOperativeAssignment(String name, char[] statement, int operation) {\n-        if (operation == -1) return statement;\n+        if (operation == -1) {\n+            return statement;\n+        }\n \n         char[] stmt;\n         char op = 0;\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\nindex c837942..7acfaa6 100644\n--- a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n@@ -1223,7 +1223,7 @@ public class CoreConfidenceTests extends TestCase {\n \n         ResolverTools.appendFactory(mvf, classes);\n \n-        Serializable compiled = compileExpression(\"p = new Person('tom'); p.age = 20; with( p ) { age = p.age + 1 }; return p.ag;e\", classes.getImportedClasses());\n+        Serializable compiled = compileExpression(\"p = new Person('tom'); p.age = 20; with( p ) { age = p.age + 1 }; return p.age;\", classes.getImportedClasses());\n \n         assertEquals(21, executeExpression(compiled, mvf) );\n     }        \n@@ -1271,7 +1271,7 @@ public class CoreConfidenceTests extends TestCase {\n \n         interceptors.put(\"Modify\", new Interceptor() {\n             public int doBefore(ASTNode node, VariableResolverFactory factory) {\n-                Object object = ((WithNode) node).getNestedStatement().getValue(null,\n+                ((WithNode) node).getNestedStatement().getValue(null,\n                         factory);\n                 factory.createVariable(\"mod\", \"FOOBAR!\");\n                 return 0;\n@@ -1555,10 +1555,9 @@ public class CoreConfidenceTests extends TestCase {\n                         + String.valueOf(first) + \"; second: \" + String.valueOf(second) + \"]\");\n             }\n \n-\n             if (!first.equals(third)) {\n                 throw new AssertionError(\"Different result from test 1 and 3 (Compiled to Interpreted) [first: \" +\n-                        String.valueOf(first) + \" (\" + (first != null ? first.getClass().getName() : \"null\") + \"); third: \" + String.valueOf(third) + \" (\" + (second != null ? first.getClass().getName() : \"null\") + \")]\");\n+                        String.valueOf(first) + \" (\" + first.getClass().getName() + \"); third: \" + String.valueOf(third) + \" (\" + (second != null ? first.getClass().getName() : \"null\") + \")]\");\n             }\n         }\n \n@@ -1963,6 +1962,14 @@ public class CoreConfidenceTests extends TestCase {\n             this.street = street;\n         }\n \n+\n+        public String getStreet() {\n+            return street;\n+        }\n+\n+        public void setStreet(String street) {\n+            this.street = street;\n+        }\n     }\n \n     public static class Drools {\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T18:46:10.064115Z", "commit_hash": "2be16c94a5d445e415c9da35538e731c129cd24c", "commit_message": "minor compiler regression fixed.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/ast/LiteralNode.java b/src/main/java/org/mvel/ast/LiteralNode.java\nindex fba641a..534ffb8 100644\n--- a/src/main/java/org/mvel/ast/LiteralNode.java\n+++ b/src/main/java/org/mvel/ast/LiteralNode.java\n@@ -35,4 +35,9 @@ public class LiteralNode extends ASTNode {\n     public Object getLiteralValue() {\r\n         return literal;\r\n     }\r\n+\r\n+\r\n+    public boolean isLiteral() {\r\n+        return true;\r\n+    }\r\n }\r\ndiff --git a/src/main/java/org/mvel/optimizers/impl/asm/ASMAccessorOptimizer.java b/src/main/java/org/mvel/optimizers/impl/asm/ASMAccessorOptimizer.java\nindex 51f1b9f..3b077f6 100644\n--- a/src/main/java/org/mvel/optimizers/impl/asm/ASMAccessorOptimizer.java\n+++ b/src/main/java/org/mvel/optimizers/impl/asm/ASMAccessorOptimizer.java\n@@ -283,38 +283,46 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n     private Object getBeanProperty(Object ctx, String property)\r\n             throws IllegalAccessException, InvocationTargetException {\r\n \r\n-        debug(\"\\n  **  ENTER -> {bean: \" + property + \"}\");\r\n+        debug(\"\\n  **  ENTER -> {bean: \" + property + \"; ctx=\" + ctx + \"}\");\r\n \r\n         Class cls = (ctx instanceof Class ? ((Class) ctx) : ctx != null ? ctx.getClass() : null);\r\n         Member member = cls != null ? PropertyTools.getFieldOrAccessor(cls, property) : null;\r\n \r\n-        if (first && variableFactory != null && variableFactory.isResolveable(property)) {\r\n-            try {\r\n-                debug(\"ALOAD 3\");\r\n-                mv.visitVarInsn(ALOAD, 3);\r\n+        if (first) {\r\n+            if (variableFactory != null && variableFactory.isResolveable(property)) {\r\n+                try {\r\n+                    debug(\"ALOAD 3\");\r\n+                    mv.visitVarInsn(ALOAD, 3);\r\n \r\n-                debug(\"LDC :\" + property);\r\n-                mv.visitLdcInsn(property);\r\n+                    debug(\"LDC :\" + property);\r\n+                    mv.visitLdcInsn(property);\r\n \r\n-                debug(\"INVOKEINTERFACE org/mvel/integration/VariableResolverFactory.getVariableResolver\");\r\n-                mv.visitMethodInsn(INVOKEINTERFACE, \"org/mvel/integration/VariableResolverFactory\",\r\n-                        \"getVariableResolver\", \"(Ljava/lang/String;)Lorg/mvel/integration/VariableResolver;\");\r\n+                    debug(\"INVOKEINTERFACE org/mvel/integration/VariableResolverFactory.getVariableResolver\");\r\n+                    mv.visitMethodInsn(INVOKEINTERFACE, \"org/mvel/integration/VariableResolverFactory\",\r\n+                            \"getVariableResolver\", \"(Ljava/lang/String;)Lorg/mvel/integration/VariableResolver;\");\r\n \r\n-                debug(\"INVOKEINTERFACE org/mvel/integration/VariableResolver.getValue\");\r\n-                mv.visitMethodInsn(INVOKEINTERFACE, \"org/mvel/integration/VariableResolver\",\r\n-                        \"getValue\", \"()Ljava/lang/Object;\");\r\n+                    debug(\"INVOKEINTERFACE org/mvel/integration/VariableResolver.getValue\");\r\n+                    mv.visitMethodInsn(INVOKEINTERFACE, \"org/mvel/integration/VariableResolver\",\r\n+                            \"getValue\", \"()Ljava/lang/Object;\");\r\n \r\n-                returnType = Object.class;\r\n+                    returnType = Object.class;\r\n+\r\n+                }\r\n+                catch (Exception e) {\r\n+                    throw new OptimizationFailure(\"critical error in JIT\", e);\r\n+                }\r\n \r\n+\r\n+                return variableFactory.getVariableResolver(property).getValue();\r\n             }\r\n-            catch (Exception e) {\r\n-                throw new OptimizationFailure(\"critical error in JIT\", e);\r\n+            else {\r\n+                mv.visitVarInsn(ALOAD, 1);\r\n             }\r\n+                    \r\n+        }\r\n \r\n \r\n-            return variableFactory.getVariableResolver(property).getValue();\r\n-        }\r\n-        else if (member instanceof Field) {\r\n+         if (member instanceof Field) {\r\n             Object o = ((Field) member).get(ctx);\r\n \r\n             if (first) {\r\n@@ -488,7 +496,7 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n             throws IllegalAccessException, InvocationTargetException {\r\n         if (prop.length() > 0) ctx = getBeanProperty(ctx, prop);\r\n \r\n-        debug(\"\\n  **  ENTER -> {collections: \" + prop + \"}\");\r\n+        debug(\"\\n  **  ENTER -> {collections: \" + prop + \"; ctx=\" + ctx + \"}\");\r\n \r\n         int start = ++cursor;\r\n \r\n@@ -500,9 +508,12 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n         if (!scanTo(']'))\r\n             throw new PropertyAccessException(\"unterminated '['\");\r\n \r\n+        String tk = new String(expr, start, cursor - start);\r\n+\r\n+        debug(\"{collection token:<<\" + tk + \">>}\");\r\n \r\n         boolean literal = false;\r\n-        ExecutableStatement compiled = (ExecutableStatement) ParseTools.subCompileExpression(new String(expr, start, cursor - start));\r\n+        ExecutableStatement compiled = (ExecutableStatement) ParseTools.subCompileExpression(tk);\r\n         Object item;\r\n \r\n         if (compiled instanceof ExecutableLiteral) {\r\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\nindex d255e93..096d785 100644\n--- a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n@@ -1463,12 +1463,22 @@ public class CoreConfidenceTests extends TestCase {\n         assertEquals(\"10\", parseDirect(\"(String) 10\"));\n     }\n \n+    public void testMapAccessSemantics() {\n+        Map<String, Object> outermap = new HashMap<String, Object>();\n+        Map<String, Object> innermap = new HashMap<String, Object>();\n+\n+        innermap.put(\"test\", \"foo\");\n+        outermap.put(\"innermap\", innermap);\n+\n+        assertEquals(\"foo\", compiledExecute(\"innermap['test']\", outermap, null));\n+    }\n+\n \n     public Object parseDirect(String ex) {\n-        return compiledExecute(ex);\n+        return compiledExecute(ex, this.base, this.map);\n     }\n \n-    public Object compiledExecute(String ex) {\n+    public Object compiledExecute(String ex, Object base, Map map) {\n         OptimizerFactory.setDefaultOptimizer(\"ASM\");\n \n         ExpressionCompiler compiler = new ExpressionCompiler(ex);\n@@ -1542,18 +1552,18 @@ public class CoreConfidenceTests extends TestCase {\n \n         return second;\n     }\n-\n-    public Object compiledExecute(String ex, Object base, Map map) {\n-        Serializable compiled = compileExpression(ex);\n-\n-        Object first = executeExpression(compiled, base, map);\n-        Object second = executeExpression(compiled, base, map);\n-\n-        if (first != null && !first.getClass().isArray())\n-            assertSame(first, second);\n-\n-        return second;\n-    }\n+//\n+//    public Object compiledExecute(String ex, Object base, Map map) {\n+//        Serializable compiled = compileExpression(ex);\n+//\n+//        Object first = executeExpression(compiled, base, map);\n+//        Object second = executeExpression(compiled, base, map);\n+//\n+//        if (first != null && !first.getClass().isArray())\n+//            assertSame(first, second);\n+//\n+//        return second;\n+//    }\n \n \n     @SuppressWarnings({\"unchecked\"})\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T18:48:34.275870Z", "commit_hash": "9e5c71cacbebf1f7afb883bbcf61d4f5bfe173d6", "commit_message": "fix.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/ASTNode.java b/src/main/java/org/mvel/ASTNode.java\nindex 4f7ab66..9849586 100644\n--- a/src/main/java/org/mvel/ASTNode.java\n+++ b/src/main/java/org/mvel/ASTNode.java\n@@ -340,7 +340,7 @@ public class ASTNode implements Cloneable, Serializable {\n         Object sa = tryStaticAccess(ctx, factory);\n         if (sa == null) throw new UnresolveablePropertyException(this);\n         return valRet(sa);\n-         \n+\n     }\n \n \n@@ -462,12 +462,6 @@ public class ASTNode implements Cloneable, Serializable {\n             literal = handleNumericConversion(name);\n             egressType = literal.getClass();\n \n-            if (literal instanceof Integer) {\n-                intRegister = (Integer) literal;\n-                fields |= INTEGER32;\n-\n-            }\n-\n             if ((fields & INVERT) != 0) {\n                 try {\n                     literal = ~((Integer) literal);\n@@ -477,6 +471,12 @@ public class ASTNode implements Cloneable, Serializable {\n                 }\n             }\n \n+            if (literal instanceof Integer) {\n+                intRegister = (Integer) literal;\n+                fields |= INTEGER32;\n+\n+            }\n+\n             return;\n         }\n         else if ((fields & INLINE_COLLECTION) != 0) {\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\nindex 8cb7b7f..f6fb224 100644\n--- a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n@@ -2,9 +2,7 @@ package org.mvel.tests.main;\n \n import junit.framework.TestCase;\n import org.mvel.*;\n-\n import static org.mvel.MVEL.*;\n-\n import org.mvel.ast.WithNode;\n import org.mvel.debug.DebugTools;\n import org.mvel.debug.Debugger;\n@@ -1448,12 +1446,16 @@ public class CoreConfidenceTests extends TestCase {\n         OptimizerFactory.setDefaultOptimizer(\"ASM\");\n \n         ExpressionCompiler compiler = new ExpressionCompiler(ex);\n+\n+\n         Serializable compiled = compiler.compile();\n \n         //     System.out.println(DebugTools.decompile(compiled));\n \n         Object first = executeExpression(compiled, base, map);\n         Object second = executeExpression(compiled, base, map);\n+\n+\n         Object third = MVEL.eval(ex, base, map);\n \n \n@@ -1486,6 +1488,31 @@ public class CoreConfidenceTests extends TestCase {\n             }\n         }\n \n+        ParserContext ctx = new ParserContext();\n+        ctx.setSourceFile(\"unittest\");\n+        ExpressionCompiler debuggingCompiler = new ExpressionCompiler(ex);\n+        debuggingCompiler.setDebugSymbols(true);\n+\n+        Serializable compiledD = debuggingCompiler.compile(ctx);\n+\n+        Object sixth = executeExpression(compiledD, base, map);\n+        if (sixth != null && !sixth.getClass().isArray()) {\n+      //      assertEquals(fifth, sixth);\n+            if (!fifth.equals(sixth)) {\n+                System.out.println(\"Payload 1 -- No Symbols: \");\n+                System.out.println(DebugTools.decompile(compiled));\n+                System.out.println();\n+\n+                System.out.println(\"Payload 2 -- With Symbols: \");\n+                System.out.println(DebugTools.decompile(compiledD));\n+                System.out.println();\n+\n+                throw new AssertionError(\"Different result from test 5 and 6 (Compiled to Compiled+DebuggingSymbols) [first: \"\n+                        + String.valueOf(fifth) + \"; second: \" + String.valueOf(sixth) + \"]\");\n+            }\n+        }\n+\n+\n         return second;\n     }\n \n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T18:49:22.277414Z", "commit_hash": "ddc364bbe14067d7b661eb84cfff561dd36bc255", "commit_message": "windows CR fix\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/AbstractParser.java b/src/main/java/org/mvel/AbstractParser.java\nindex c0878bd..ba132d2 100644\n--- a/src/main/java/org/mvel/AbstractParser.java\n+++ b/src/main/java/org/mvel/AbstractParser.java\n@@ -175,11 +175,10 @@ public class AbstractParser implements Serializable {\n \r\n                 line = pCtx.getLineCount();\r\n \r\n-                int scan = cursor;\r\n+//                int scan = cursor;\r\n \r\n-                while (expr[scan] == '\\n') {\r\n-                    scan++;\r\n-                    line++;\r\n+                if (expr[cursor] == '\\n' || expr[cursor] == '\\r') {\r\n+                    skipWhitespaceWithLineAccounting();\r\n                 }\r\n \r\n                 if (lastWasComment) {\r\n@@ -190,7 +189,6 @@ public class AbstractParser implements Serializable {\n                 pCtx.setLineCount(line);\r\n \r\n                 if (!pCtx.isKnownLine(pCtx.getSourceFile(), line)) {\r\n-\r\n                     lastWasLineLabel = true;\r\n \r\n                     pCtx.setLineAndOffset(line, cursor);\r\n@@ -206,7 +204,7 @@ public class AbstractParser implements Serializable {\n                 lastWasComment = lastWasLineLabel = false;\r\n             }\r\n         }\r\n-        \r\n+\r\n         /**\r\n          * Skip any whitespace currently under the starting point.\r\n          */\r\n@@ -588,8 +586,12 @@ public class AbstractParser implements Serializable {\n                                  * Since multi-line comments may cross lines, we must keep track of any line-break\r\n                                  * we encounter.\r\n                                  */\r\n-                                if (debugSymbols && expr[cursor] == '\\n') {\r\n-                                    line++;\r\n+//                                if (debugSymbols && expr[cursor] == '\\n') {\r\n+//                                    line++;\r\n+//                                }\r\n+\r\n+                                if (debugSymbols && (expr[cursor] == '\\n' || expr[cursor] == '\\r')) {\r\n+                                    skipWhitespaceWithLineAccounting();\r\n                                 }\r\n \r\n                                 if (cursor == len) {\r\n@@ -605,6 +607,10 @@ public class AbstractParser implements Serializable {\n \r\n                             if (debugSymbols) {\r\n                                 getParserContext().setLineCount(line);\r\n+                                if (lastNode instanceof LineLabel) {\r\n+                                    getParserContext().getFirstLineLabel().setLineNumber(line);\r\n+                                }\r\n+                                lastWasComment = true;\r\n                             }\r\n \r\n                             continue;\r\n@@ -888,6 +894,24 @@ public class AbstractParser implements Serializable {\n         return -1;\r\n     }\r\n \r\n+    public int captureLineBreaks() {\r\n+        int count = 0;\r\n+\r\n+        while (cursor < length) {\r\n+            switch (expr[cursor]) {\r\n+                case'\\r':\r\n+                    cursor++;\r\n+                    continue;\r\n+                case'\\n':\r\n+                    cursor++;\r\n+                    count++;\r\n+                    continue;\r\n+                default:\r\n+                    return count;\r\n+            }\r\n+        }\r\n+        return count;\r\n+    }\r\n \r\n     /**\r\n      * Most of this method should be self-explanatory.\r\n@@ -1110,8 +1134,20 @@ public class AbstractParser implements Serializable {\n     }\r\n \r\n     protected void skipWhitespaceWithLineAccounting() {\r\n-        while (isWhitespace(expr[cursor])) {\r\n-            if (expr[cursor] == '\\n') line++;\r\n+        while (cursor < length && isWhitespace(expr[cursor])) {\r\n+            //    if (expr[cursor] == '\\n') line++;\r\n+            //     line += captureLineBreaks();\r\n+\r\n+            switch (expr[cursor]) {\r\n+                case'\\r':\r\n+                    cursor++;\r\n+                    continue;\r\n+                case'\\n':\r\n+                    cursor++;\r\n+                    line++;\r\n+                    continue;\r\n+            }\r\n+\r\n             cursor++;\r\n         }\r\n     }\r\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\nindex 0c54a2f..33383d7 100644\n--- a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n@@ -892,7 +892,7 @@ public class CoreConfidenceTests extends TestCase {\n                 \"System.out.println( \\\"a4\\\" );\\n\";\n \n         ExpressionCompiler compiler = new ExpressionCompiler(expr);\n-        compiler.setDebugSymbols(true);\n+  //      compiler.setDebugSymbols(true);\n \n         ParserContext context = new ParserContext();\n         context.addImport(\"System\", System.class);\n@@ -917,7 +917,15 @@ public class CoreConfidenceTests extends TestCase {\n \n \n     public void testBreakpointsAcrossComments() {\n-        ExpressionCompiler compiler = new ExpressionCompiler(\"/** This is a comment\\nSecond comment line\\nThird Comment Line\\n*/\\nSystem.out.println('4');\\nSystem.out.println('5');\\na = 0;\\n b = 1;\\n a + b\");\n+        ExpressionCompiler compiler = new ExpressionCompiler(\"/** This is a comment\\n\" +\n+                \"Second comment line\\n\" +\n+                \"Third Comment Line\\n\" +\n+                \"*/\\n\" +\n+                \"System.out.println('4');\\n\" +\n+                \"System.out.println('5');\\n\" +\n+                \"a = 0;\\n\" +\n+                \" b = 1;\\n\" +\n+                \" a + b\");\n         compiler.setDebugSymbols(true);\n \n         ParserContext ctx = new ParserContext();\n@@ -995,7 +1003,9 @@ public class CoreConfidenceTests extends TestCase {\n         Serializable compiledExpression = compiler.compile(ctx);           \n         \n         String s = org.mvel.debug.DebugTools.decompile( compiledExpression );\n-        \n+\n+        System.out.println(s);\n+\n         int fromIndex=0;\n         int count = 0;\n         while ((fromIndex = s.indexOf( \"DEBUG_SYMBOL\", fromIndex+1 )) > -1) {\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T18:51:00.276615Z", "commit_hash": "b8490faea80c1ebe3cfcfc2d672641c991774beb", "commit_message": "Regression fixed.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/AbstractParser.java b/src/main/java/org/mvel/AbstractParser.java\nindex 833bbd3..2668183 100644\n--- a/src/main/java/org/mvel/AbstractParser.java\n+++ b/src/main/java/org/mvel/AbstractParser.java\n@@ -1,8 +1,8 @@\n package org.mvel;\r\n \r\n-import static org.mvel.util.ParseTools.captureStringLiteral;\r\n import static org.mvel.Operator.*;\r\n import org.mvel.ast.*;\r\n+import org.mvel.util.ArrayTools;\r\n import org.mvel.util.ExecutionStack;\r\n import org.mvel.util.ParseTools;\r\n import static org.mvel.util.ParseTools.*;\r\n@@ -461,6 +461,31 @@ public class AbstractParser implements Serializable {\n                  */\r\n                 trimWhitespace();\r\n \r\n+                if (parserContext != null) {\r\n+                    char[] _subset = subset(expr, start, cursor - start);\r\n+                    int offset;\r\n+\r\n+                    Class cls;\r\n+                    if ((offset = ArrayTools.findFirst('.', _subset)) != -1) {\r\n+                        String iStr;\r\n+                        if (getParserContext().hasImport(iStr = new String(_subset, 0, offset))) {\r\n+                            lastWasIdentifier = true;\r\n+                            return lastNode = new LiteralDeepPropertyNode(subset(_subset, offset + 1, _subset.length - offset - 1), fields, getParserContext().getImport(iStr)); \r\n+// /                            return lastNode = new Union(_subset, offset + 1, _subset.length, fields, new LiteralNode(getParserContext().getImport(iStr)));\r\n+                        }\r\n+//                        else if ((cls = createClassSafe(iStr = new String(_subset, offset = ArrayTools.findLast('.', _subset), _subset.length - offset))) != null) {\r\n+//\r\n+//                        }\r\n+\r\n+                    }\r\n+\r\n+                    else {\r\n+                        ASTNode node = new ASTNode(_subset, 0, _subset.length, fields);\r\n+                        lastWasIdentifier = node.isIdentifier();\r\n+                        return lastNode = node;\r\n+                    }\r\n+                }\r\n+\r\n                 return createToken(expr, start, cursor, fields);\r\n             }\r\n             else\r\n@@ -626,7 +651,7 @@ public class AbstractParser implements Serializable {\n                                      * Check to see if we should disqualify this current token as a potential\r\n                                      * type-cast candidate.\r\n                                      */\r\n-                                    if (lastWS || isIdentifierPart(expr[cursor])) {\r\n+                                    if (lastWS || !isIdentifierPart(expr[cursor])) {\r\n                                         singleToken = false;\r\n                                     }\r\n                                     else if (isWhitespace(expr[cursor])) {\r\ndiff --git a/src/main/java/org/mvel/ExecutableAccessor.java b/src/main/java/org/mvel/ExecutableAccessor.java\nindex 8dd0eae..bd4a56a 100644\n--- a/src/main/java/org/mvel/ExecutableAccessor.java\n+++ b/src/main/java/org/mvel/ExecutableAccessor.java\n@@ -36,7 +36,7 @@ public class ExecutableAccessor implements ExecutableStatement {\n     }\r\n \r\n     public Object getValue(Object ctx, Object elCtx, VariableResolverFactory variableFactory) {\r\n-        return handleParserEgress(node.getReducedValueAccelerated(ctx, ctx, variableFactory),\r\n+        return handleParserEgress(node.getReducedValueAccelerated(ctx, elCtx, variableFactory),\r\n                 returnBigDecimal);\r\n     }\r\n \r\ndiff --git a/src/main/java/org/mvel/ParserContext.java b/src/main/java/org/mvel/ParserContext.java\nindex 5619d66..1f0e4ce 100644\n--- a/src/main/java/org/mvel/ParserContext.java\n+++ b/src/main/java/org/mvel/ParserContext.java\n@@ -91,7 +91,7 @@ public class ParserContext implements Serializable {\n     }\n \n     public Class getImport(String name) {\n-        return imports != null ? (Class) imports.get(name) : null;\n+        return (imports != null ? (Class) imports.get(name) : (Class) AbstractParser.LITERALS.get(name));\n     }\n \n     public Method getStaticImport(String name) {\ndiff --git a/src/main/java/org/mvel/ast/StaticField.java b/src/main/java/org/mvel/ast/StaticField.java\nnew file mode 100644\nindex 0000000..fe27ca9\n--- /dev/null\n+++ b/src/main/java/org/mvel/ast/StaticField.java\n@@ -0,0 +1,33 @@\n+package org.mvel.ast;\n+\n+import org.mvel.ASTNode;\n+import org.mvel.PropertyAccessException;\n+import org.mvel.integration.VariableResolverFactory;\n+\n+import java.lang.reflect.Field;\n+\n+public class StaticField extends ASTNode {\n+    Class clazz;\n+    Field field;\n+\n+    public StaticField(Class cls, Field field) {\n+        super();\n+\n+        this.clazz = cls;\n+        this.field = field;\n+    }\n+\n+\n+    public Object getReducedValueAccelerated(Object ctx, Object thisValue, VariableResolverFactory factory) {\n+        try {\n+            return field.get(null);\n+        }\n+        catch (Exception e) {\n+            throw new PropertyAccessException(\"unable to access static field\", e);\n+        }\n+    }\n+\n+    public Object getReducedValue(Object ctx, Object thisValue, VariableResolverFactory factory) {\n+        return getReducedValueAccelerated(ctx, thisValue, factory);  \n+    }\n+}\ndiff --git a/src/main/java/org/mvel/ast/Union.java b/src/main/java/org/mvel/ast/Union.java\nindex faf1dc7..9637e8b 100644\n--- a/src/main/java/org/mvel/ast/Union.java\n+++ b/src/main/java/org/mvel/ast/Union.java\n@@ -23,7 +23,7 @@ public class Union extends ASTNode {\n         catch (NullPointerException e) {\n             if (accessor != null) throw e;\n             AccessorOptimizer o = OptimizerFactory.getDefaultAccessorCompiler();\n-            accessor = o.optimizeAccessor(name, ctx, thisValue, factory, false);\n+            accessor = o.optimizeAccessor(name, main.getReducedValueAccelerated(ctx, thisValue, factory), thisValue, factory, false);\n             return o.getResultOptPass();\n         }\n     }\ndiff --git a/src/main/java/org/mvel/optimizers/impl/asm/ASMAccessorOptimizer.java b/src/main/java/org/mvel/optimizers/impl/asm/ASMAccessorOptimizer.java\nindex bd53323..bc7031d 100644\n--- a/src/main/java/org/mvel/optimizers/impl/asm/ASMAccessorOptimizer.java\n+++ b/src/main/java/org/mvel/optimizers/impl/asm/ASMAccessorOptimizer.java\n@@ -655,29 +655,15 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n \r\n         int st = cursor;\r\n \r\n-   //     int depth = 1;\r\n-\r\n         cursor = ParseTools.balancedCapture(expr, cursor, '(');\r\n \r\n-//        while (cursor++ < length - 1 && depth != 0) {\r\n-//            switch (expr[cursor]) {\r\n-//                case'(':\r\n-//                    depth++;\r\n-//                    continue;\r\n-//                case')':\r\n-//                    depth--;\r\n-//\r\n-//            }\r\n-//        }\r\n- //       cursor--;\r\n-\r\n         String tk = (cursor - st) > 1 ? new String(expr, st + 1, cursor - st - 1) : \"\";\r\n \r\n         cursor++;\r\n \r\n         Object[] preConvArgs;\r\n         Object[] args;\r\n-        ExecutableStatement[] es;\r\n+        Accessor[] es;\r\n \r\n         if (tk.length() == 0) {\r\n             //noinspection ZeroLengthArrayAllocation\r\n@@ -695,7 +681,7 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n             preConvArgs = new Object[es.length];\r\n \r\n             for (int i = 0; i < subtokens.length; i++) {\r\n-                preConvArgs[i] = args[i] = (es[i] = (ExecutableStatement) ParseTools.subCompileExpression(subtokens[i])).getValue(this.ctx, variableFactory);\r\n+                preConvArgs[i] = args[i] = (es[i] = (ExecutableStatement) ParseTools.subCompileExpression(subtokens[i])).getValue( this.ctx, this.thisRef,  variableFactory);\r\n             }\r\n         }\r\n \r\n@@ -704,7 +690,7 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n \r\n         if (es != null) {\r\n             for (int i = 0; i < es.length; i++) {\r\n-                ExecutableStatement e = es[i];\r\n+                Accessor e = es[i];\r\n                 if (e instanceof ExecutableLiteral) {\r\n                     continue;\r\n                 }\r\n@@ -716,7 +702,7 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n                     continue;\r\n                 }\r\n \r\n-                compiledInputs.add(e);\r\n+                compiledInputs.add((ExecutableStatement) e);\r\n             }\r\n         }\r\n         /**\r\n@@ -777,7 +763,7 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n             if (es != null) {\r\n                 ExecutableStatement cExpr;\r\n                 for (int i = 0; i < es.length; i++) {\r\n-                    if ((cExpr = es[i]).getKnownIngressType() == null) {\r\n+                    if ((cExpr = (ExecutableStatement) es[i]).getKnownIngressType() == null) {\r\n                         cExpr.setKnownIngressType(parameterTypes[i]);\r\n                         cExpr.computeTypeConversionRule();\r\n                     }\r\ndiff --git a/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java b/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\nindex 2fade0d..a32d47b 100644\n--- a/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\n+++ b/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\n@@ -468,15 +468,6 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n \r\n             return ((List) ctx).get((Integer) idx);\r\n         }\r\n-//        else if (ctx instanceof Collection) {\r\n-//            int count = parseInt(item);\r\n-//            if (count > ((Collection) ctx).size())\r\n-//                throw new PropertyAccessException(\"index [\" + count + \"] out of bounds on collections\");\r\n-//\r\n-//            Iterator iter = ((Collection) ctx).iterator();\r\n-//            for (int i = 0; i < count; i++) iter.next();\r\n-//            return iter.next();\r\n-//        }\r\n         else if (ctx instanceof Object[]) {\r\n             if (itemSubExpr) {\r\n                 ArrayAccessorNest accessor = new ArrayAccessorNest();\r\n@@ -530,28 +521,14 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n         int st = cursor;\r\n \r\n         cursor = ParseTools.balancedCapture(expr, cursor, '(');\r\n-        \r\n-\r\n-//        int depth = 1;\r\n-//\r\n-//        while (cursor++ < length - 1 && depth != 0) {\r\n-//            switch (expr[cursor]) {\r\n-//                case'(':\r\n-//                    depth++;\r\n-//                    continue;\r\n-//                case')':\r\n-//                    depth--;\r\n-//\r\n-//            }\r\n-//        }\r\n-//        cursor--;\r\n+\r\n \r\n         String tk = (cursor - st) > 1 ? new String(expr, st + 1, cursor - st - 1) : \"\";\r\n \r\n         cursor++;\r\n \r\n         Object[] args;\r\n-        ExecutableStatement[] es;\r\n+        Accessor[] es;\r\n \r\n         if (tk.length() == 0) {\r\n             args = ParseTools.EMPTY_OBJ_ARR;\r\n@@ -562,7 +539,7 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n             es = new ExecutableStatement[subtokens.length];\r\n             args = new Object[subtokens.length];\r\n             for (int i = 0; i < subtokens.length; i++) {\r\n-                args[i] = (es[i] = (ExecutableStatement) ParseTools.subCompileExpression(subtokens[i])).getValue(this.ctx, variableFactory);\r\n+                args[i] = (es[i] = (ExecutableStatement) ParseTools.subCompileExpression(subtokens[i])).getValue(this.ctx, thisRef, variableFactory);\r\n             }\r\n         }\r\n \r\n@@ -616,7 +593,7 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n             if (es != null) {\r\n                 ExecutableStatement cExpr;\r\n                 for (int i = 0; i < es.length; i++) {\r\n-                    cExpr = es[i];\r\n+                    cExpr = (ExecutableStatement) es[i];\r\n                     if (cExpr.getKnownIngressType() == null) {\r\n                         cExpr.setKnownIngressType(parameterTypes[i]);\r\n                         cExpr.computeTypeConversionRule();\r\n@@ -637,7 +614,7 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n \r\n             MethodAccessor access = new MethodAccessor();\r\n             access.setMethod(ParseTools.getWidenedTarget(m));\r\n-            access.setParms(es);\r\n+            access.setParms((ExecutableStatement[]) es);\r\n \r\n             addAccessorNode(access);\r\n \r\ndiff --git a/src/main/java/org/mvel/util/ParseTools.java b/src/main/java/org/mvel/util/ParseTools.java\nindex 9251025..86f9659 100644\n--- a/src/main/java/org/mvel/util/ParseTools.java\n+++ b/src/main/java/org/mvel/util/ParseTools.java\n@@ -346,6 +346,15 @@ public class ParseTools {\n \n     private static Map<Class, Constructor[]> CLASS_CONSTRUCTOR_CACHE = new WeakHashMap<Class, Constructor[]>(10);\n \n+    public static Class createClassSafe(String className) {\n+        try {\n+            return createClass(className);\n+        }\n+        catch (ClassNotFoundException e) {\n+            return null;\n+        }\n+    }\n+\n     public static Class createClass(String className) throws ClassNotFoundException {\n         if (CLASS_RESOLVER_CACHE.containsKey(className))\n             return CLASS_RESOLVER_CACHE.get(className);\n@@ -550,7 +559,7 @@ public class ParseTools {\n \n         char[] stmt;\n         char op = 0;\n-        switch (operation) {                                                                                         \n+        switch (operation) {\n             case Operator.ADD:\n                 op = '+';\n                 break;\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\nindex d4ad1eb..b917326 100644\n--- a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n@@ -1568,7 +1568,7 @@ public class CoreConfidenceTests extends TestCase {\n     }\n     \n     public void testStaticNested() {        \n-        assertEquals(1, MVEL.eval( \"org.mvel.tests.main.Message.GOODBYE\", new HashMap() ) );\n+        assertEquals(1, MVEL.eval( \"org.mvel.tests.main.CoreConfidenceTests$Message.GOODBYE\", new HashMap() ) );\n     }        \n     \n     public void testStaticNestedWithImport() {\n@@ -1580,7 +1580,8 @@ public class CoreConfidenceTests extends TestCase {\n         context.setStrictTypeEnforcement(false);\n     \n         context.addImport(\"Message\", Message.class);\n-        Serializable compiledExpression = compiler.compile(context);        \n+        Serializable compiledExpression = compiler.compile(context);\n+        \n         assertEquals(1, MVEL.executeExpression( compiledExpression ) );\n     }    \n \n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T18:51:49.102098Z", "commit_hash": "db25501657df0bc93c07d292512cdc26f5876266", "commit_message": "regression fixed\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/CompileException.java b/src/main/java/org/mvel/CompileException.java\nindex c4dcd9e..a8f737a 100644\n--- a/src/main/java/org/mvel/CompileException.java\n+++ b/src/main/java/org/mvel/CompileException.java\n@@ -48,13 +48,13 @@ public class CompileException extends RuntimeException {\n \n \n     public CompileException(String message, char[] expr, int cursor, Exception e) {\n-        super(\"Failed to _compile:\\n[Error: \" + message + \"]\\n[Near: \\\"\" + showCodeNearError(expr, cursor) + \"\\\"]\", e);\n+        super(\"Failed to compile:\\n[Error: \" + message + \"]\\n[Near: \\\"\" + showCodeNearError(expr, cursor) + \"\\\"]\", e);\n         this.expr = expr;\n         this.cursor = cursor;\n     }\n \n     public CompileException(String message, char[] expr, int cursor) {\n-        super(\"Failed to _compile:\\n[Error: \" + message + \"]\\n[Near: \\\"\" + showCodeNearError(expr, cursor) + \"\\\"]\");\n+        super(\"Failed to compile:\\n[Error: \" + message + \"]\\n[Near: \\\"\" + showCodeNearError(expr, cursor) + \"\\\"]\");\n         this.expr = expr;\n         this.cursor = cursor;\n     }\ndiff --git a/src/main/java/org/mvel/util/ParseTools.java b/src/main/java/org/mvel/util/ParseTools.java\nindex 31b6e7d..9251025 100644\n--- a/src/main/java/org/mvel/util/ParseTools.java\n+++ b/src/main/java/org/mvel/util/ParseTools.java\n@@ -98,7 +98,7 @@ public class ParseTools {\n                                 i = captureStringLiteral('\\'', parm, i, parm.length);\n                                 continue;\n                             case'\"':\n-                                i = captureStringLiteral('\\'', parm, i, parm.length);\n+                                i = captureStringLiteral('\"', parm, i, parm.length);\n \n                         }\n                     }\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\nindex c35faba..765744f 100644\n--- a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n@@ -1584,7 +1584,7 @@ public class CoreConfidenceTests extends TestCase {\n         compiler.compile(pCtx);\n     }\n \n-    public void FIXME_testCompileWithNewInsideMethodCall() {\n+    public void testCompileWithNewInsideMethodCall() {\n         String expr = \"     p.name = \\\"goober\\\";\\n\"+\n                       \"     System.out.println(p.name);\\n\"+ \n                       \"     drools.insert(new Address(\\\"Latona\\\"));\\n\";  \n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T18:52:37.981710Z", "commit_hash": "ebfc1f5918cf97ebefb25025f92527c526976ca4", "commit_message": "regression fixed.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/AbstractParser.java b/src/main/java/org/mvel/AbstractParser.java\nindex c97e65b..ec8ce35 100644\n--- a/src/main/java/org/mvel/AbstractParser.java\n+++ b/src/main/java/org/mvel/AbstractParser.java\n@@ -622,7 +622,11 @@ public class AbstractParser implements Serializable {\n                                     }\r\n                                     break;\r\n                                 default:\r\n-                                    if (lastWS) {\r\n+                                    /**\r\n+                                     * Check to see if we should disqualify this current token as a potential\r\n+                                     * type-cast candidate.\r\n+                                     */\r\n+                                    if (lastWS || isIdentifierPart(expr[cursor])) {\r\n                                         singleToken = false;\r\n                                     }\r\n                                     else if (isWhitespace(expr[cursor])) {\r\n@@ -637,8 +641,10 @@ public class AbstractParser implements Serializable {\n                             throw new CompileException(\"unbalanced braces in expression: (\" + brace + \"):\", expr, cursor);\r\n                         }\r\n \r\n+                        char[] _subset = null;\r\n                         if (singleToken) {\r\n-                            String tokenStr = new String(expr, trimRight(start + 1), trimLeft(cursor - 1) - (start + 1));\r\n+                            _subset = subset(expr, trimRight(start + 1), trimLeft(cursor - 1) - (start + 1));\r\n+                            String tokenStr = new String(_subset);\r\n \r\n                             if (getParserContext().hasImport(tokenStr)) {\r\n                                 start = cursor;\r\n@@ -678,7 +684,12 @@ public class AbstractParser implements Serializable {\n                             return createToken(expr, trimRight(start), cursor, ASTNode.FOLD);\r\n                         }\r\n \r\n-                        return handleUnion(new Substatement(expr, trimRight(start + 1), trimLeft(cursor - 1), fields));\r\n+                        if (_subset != null) {\r\n+                            return handleUnion(new Substatement(_subset, fields));\r\n+                        }\r\n+                        else {\r\n+                            return handleUnion(new Substatement(subset(expr, trimRight(start + 1), trimLeft(cursor - 1) - (start + 1)), fields));\r\n+                        }\r\n                     }\r\n \r\n                     case'}':\r\ndiff --git a/src/main/java/org/mvel/ast/IfNode.java b/src/main/java/org/mvel/ast/IfNode.java\nindex a55c9c7..895d59b 100644\n--- a/src/main/java/org/mvel/ast/IfNode.java\n+++ b/src/main/java/org/mvel/ast/IfNode.java\n@@ -3,8 +3,8 @@ package org.mvel.ast;\n import org.mvel.ASTNode;\r\n import org.mvel.ExecutableStatement;\r\n import org.mvel.MVEL;\r\n-import org.mvel.util.ParseTools;\r\n import org.mvel.integration.VariableResolverFactory;\r\n+import static org.mvel.util.ParseTools.subCompileExpression;\r\n \r\n /**\r\n  * @author Christopher Brock\r\n@@ -22,8 +22,8 @@ public class IfNode extends ASTNode implements NestedStatement {\n         this.block = block;\r\n \r\n         if ((fields & COMPILE_IMMEDIATE) != 0) {\r\n-            this.condition = (ExecutableStatement) ParseTools.subCompileExpression(condition);\r\n-            this.nestedStatement = (ExecutableStatement) ParseTools.subCompileExpression(block);\r\n+            this.condition = (ExecutableStatement) subCompileExpression(condition);\r\n+            this.nestedStatement = (ExecutableStatement) subCompileExpression(block);\r\n         }\r\n     }\r\n \r\n@@ -70,6 +70,6 @@ public class IfNode extends ASTNode implements NestedStatement {\n     }\r\n \r\n     public void setElseBlock(char[] block) {\r\n-        elseBlock = (ExecutableStatement) ParseTools.subCompileExpression(block);\r\n+        elseBlock = (ExecutableStatement) subCompileExpression(block);\r\n     }\r\n }\r\ndiff --git a/src/main/java/org/mvel/ast/Substatement.java b/src/main/java/org/mvel/ast/Substatement.java\nindex 04aa22f..671b673 100644\n--- a/src/main/java/org/mvel/ast/Substatement.java\n+++ b/src/main/java/org/mvel/ast/Substatement.java\n@@ -9,8 +9,8 @@ import org.mvel.integration.VariableResolverFactory;\n public class Substatement extends ASTNode {                \n     private ExecutableStatement statement;\n \n-    public Substatement(char[] expr, int start, int end, int fields) {\n-        this.name = ParseTools.subset(expr, start, end - start);\n+    public Substatement(char[] expr, int fields) {\n+        this.name = expr;\n         this.fields = fields;\n \n         if ((fields & COMPILE_IMMEDIATE) != 0) this.statement = (ExecutableStatement) ParseTools.subCompileExpression(this.name);\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\nindex 1bdaaca..d22b15f 100644\n--- a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n@@ -182,7 +182,7 @@ public class CoreConfidenceTests extends TestCase {\n     }\n \n     public void testOrOperator() {\n-        assertEquals(true, parseDirect(\"true || true\"));\n+        assertEquals(true, parseDirect(\"true||true\"));\n     }\n \n     public void testOrOperator2() {\n@@ -360,7 +360,7 @@ public class CoreConfidenceTests extends TestCase {\n     }\n \n     public void testBitwiseOr3() {\n-        assertEquals(true, parseDirect(\"(2 | 1) == 3\"));\n+        assertEquals(true, parseDirect(\"(2|1) == 3\"));\n     }\n \n     public void testBitwiseAnd1() {\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T18:53:27.737880Z", "commit_hash": "112d70f18f5498650d347df86f5a57458c53920d", "commit_message": "minor parser fixes.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/AbstractParser.java b/src/main/java/org/mvel/AbstractParser.java\nindex 42b3e78..d1d240a 100644\n--- a/src/main/java/org/mvel/AbstractParser.java\n+++ b/src/main/java/org/mvel/AbstractParser.java\n@@ -983,9 +983,10 @@ public class AbstractParser implements Serializable {\n \r\n     protected boolean blockContinues() {\r\n         if ((cursor + 4) < length) {\r\n+            if (expr[cursor] != ';') cursor--;\r\n             skipWhitespace();\r\n             return expr[cursor] == 'e' && expr[cursor + 1] == 'l' && expr[cursor + 2] == 's' && expr[cursor + 3] == 'e'\r\n-                    && (isWhitespace(expr[cursor + 4]) || expr[cursor] == '{');\r\n+                    && (isWhitespace(expr[cursor + 4]) || expr[cursor + 4] == '{');\r\n         }\r\n         return false;\r\n     }\r\n@@ -1055,6 +1056,7 @@ public class AbstractParser implements Serializable {\n     protected void skipToNextTokenJunction() {\r\n         while (cursor < length) {\r\n             switch (expr[cursor]) {\r\n+                case'{':\r\n                 case'(':\r\n                     return;\r\n                 default:\r\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\nindex 62d8065..1a97820 100644\n--- a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n@@ -105,6 +105,22 @@ public class CoreConfidenceTests extends TestCase {\n         assertEquals(false, parseDirect(\"foo.bar.woof == false\"));\n     }\n \n+    public void testBooleanOperator3() {\n+        assertEquals(true, parseDirect(\"foo.bar.woof== true\"));\n+    }\n+\n+    public void testBooleanOperator4() {\n+        assertEquals(false, parseDirect(\"foo.bar.woof ==false\"));\n+    }\n+\n+    public void testBooleanOperator5() {\n+        assertEquals(true, parseDirect(\"foo.bar.woof == true\"));\n+    }\n+\n+    public void testBooleanOperator6() {\n+        assertEquals(false, parseDirect(\"foo.bar.woof==false\"));\n+    }\n+\n     public void testTextComparison() {\n         assertEquals(true, parseDirect(\"foo.bar.name == 'dog'\"));\n     }\n@@ -161,6 +177,10 @@ public class CoreConfidenceTests extends TestCase {\n         assertEquals(true, parseDirect(\"4 > 3 || foo.toUC('test')\"));\n     }\n \n+    public void testShortPathExpression4() {\n+        assertEquals(true, parseDirect(\"4>3||foo.toUC('test')\"));\n+    }\n+\n     public void testOrOperator() {\n         assertEquals(true, parseDirect(\"true || true\"));\n     }\n@@ -580,6 +600,10 @@ public class CoreConfidenceTests extends TestCase {\n         assertEquals(5, parseDirect(\"a = 5; if (a == 5) { }; return a;\"));\n     }\n \n+    public void testEmptyIf2() {\n+        assertEquals(5, parseDirect(\"a=5;if(a==5){};return a;\"));\n+    }\n+\n     public void testIf() {\n         assertEquals(10, parseDirect(\"if (5 > 4) { return 10; } else { return 5; }\"));\n     }\n@@ -588,6 +612,10 @@ public class CoreConfidenceTests extends TestCase {\n         assertEquals(10, parseDirect(\"if (5 < 4) { return 5; } else { return 10; }\"));\n     }\n \n+    public void testIf3() {\n+        assertEquals(10, parseDirect(\"if(5<4){return 5;}else{return 10;}\"));\n+    }\n+\n     public void testIfAndElse() {\n         assertEquals(true, parseDirect(\"if (false) { return false; } else { return true; }\"));\n     }\n@@ -1005,8 +1033,8 @@ public class CoreConfidenceTests extends TestCase {\n \n         interceptors.put(\"Modify\", new Interceptor() {\n             public int doBefore(ASTNode node, VariableResolverFactory factory) {\n-                Object object = ((WithNode) node).getNestedStatement().getValue( null,\n-                                                                                 factory );\n+                Object object = ((WithNode) node).getNestedStatement().getValue(null,\n+                        factory);\n                 factory.createVariable(\"mod\", \"FOOBAR!\");\n                 return 0;\n             }\n@@ -1021,16 +1049,16 @@ public class CoreConfidenceTests extends TestCase {\n                 return \"@Modify with\";\n             }\n         });\n-        \n-        ExpressionCompiler compiler = new ExpressionCompiler(parseMacros(\"modify (foo) { aValue = 'poo' }; mod\", macros) );\n+\n+        ExpressionCompiler compiler = new ExpressionCompiler(parseMacros(\"modify (foo) { aValue = 'poo' }; mod\", macros));\n         compiler.setDebugSymbols(true);\n-        \n+\n         ParserContext ctx = new ParserContext(null, interceptors, null);\n-        ctx.setSourceFile( \"test.mv\" );\n+        ctx.setSourceFile(\"test.mv\");\n \n-        CompiledExpression compiled = compiler.compile(ctx);        \n+        CompiledExpression compiled = compiler.compile(ctx);\n \n-        assertEquals(\"FOOBAR!\", MVEL.executeExpression( compiled, null, vars ) );\n+        assertEquals(\"FOOBAR!\", MVEL.executeExpression(compiled, null, vars));\n     }\n \n     public void testComments() {\n@@ -1055,7 +1083,8 @@ public class CoreConfidenceTests extends TestCase {\n                 \"* Here is a useful variable\\r\\n\" +\n                 \"*/\\r\\n\" +\n                 \"b = 20; // set b to '20'\\r\\n\" +\n-                \"return ((a + b) * 2) - 10;\"));\n+                \"return ((a + b) * 2) - 10;\\r\\n\" +\n+                \"// last comment\\n\"));\n     }\n \n     public void testSubtractNoSpace1() {\n@@ -1065,7 +1094,7 @@ public class CoreConfidenceTests extends TestCase {\n     public void testStrictTypingCompilation() {\n         ExpressionCompiler compiler = new ExpressionCompiler(\"a.foo;\\nb.foo;\\n x = 5\");\n         ParserContext ctx = new ParserContext();\n-        ctx.setStrictTypeEnforcement(true);\n+        ctx.setStrictTypeEnforcement(true);      \n \n         try {\n             compiler.compile(ctx);\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T18:54:16.479031Z", "commit_hash": "f68d14ac4e8dc97236adad34d14ec7e4cf7e95bd", "commit_message": "bug fixes, improvements.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/AbstractParser.java b/src/main/java/org/mvel/AbstractParser.java\nindex 1ff9970..42b3e78 100644\n--- a/src/main/java/org/mvel/AbstractParser.java\n+++ b/src/main/java/org/mvel/AbstractParser.java\n@@ -1,5 +1,6 @@\n package org.mvel;\r\n \r\n+import static org.mvel.util.ParseTools.captureStringLiteral;\r\n import static org.mvel.Operator.*;\r\n import org.mvel.ast.*;\r\n import org.mvel.util.ExecutionStack;\r\n@@ -296,20 +297,8 @@ public class AbstractParser implements Serializable {\n                                 cursor = captureStringLiteral('\\'', expr, cursor, length) + 1;\r\n                                 break;\r\n \r\n-//                                cursor++;\r\n-//                                //noinspection StatementWithEmptyBody\r\n-//                                while (cursor < length && expr[cursor] != '\\'') cursor++;\r\n-//                                if (cursor++ == length)\r\n-//                                    throw new CompileException(\"unterminated string literal\", expr, cursor);\r\n-//                                break;\r\n-\r\n                             case'\"':\r\n                                 cursor = captureStringLiteral('\"', expr, cursor, length) + 1;\r\n-//                                cursor++;\r\n-//                                //noinspection StatementWithEmptyBody\r\n-//                                while (cursor < length && expr[cursor] != '\"') cursor++;\r\n-//                                if (cursor++ == length)\r\n-//                                    throw new CompileException(\"unterminated string literal\", expr, cursor);\r\n                                 break;\r\n \r\n                         }\r\n@@ -342,7 +331,13 @@ public class AbstractParser implements Serializable {\n                                     name = new String(expr, start, trimLeft(cursor));\r\n                                     start = cursor += 2;\r\n                                     captureToEOS();\r\n-                                    return new AssignAdd(subArray(start, cursor), fields, name);\r\n+\r\n+                                    if (union) {\r\n+                                        return new DeepAssignmentNode(subArray(start, cursor), fields, Operator.ADD, t);\r\n+                                    }\r\n+                                    else {\r\n+                                        return new AssignmentNode(subArray(start, cursor), fields, Operator.ADD, name);\r\n+                                    }\r\n                             }\r\n \r\n                             break;\r\n@@ -615,10 +610,10 @@ public class AbstractParser implements Serializable {\n                                     brace--;\r\n                                     break;\r\n                                 case'\\'':\r\n-                                    cursor = ParseTools.captureStringLiteral('\\'', expr, cursor, length);\r\n+                                    cursor = captureStringLiteral('\\'', expr, cursor, length);\r\n                                     break;\r\n                                 case'\"':\r\n-                                    cursor = ParseTools.captureStringLiteral('\\'', expr, cursor, length);\r\n+                                    cursor = captureStringLiteral('\\'', expr, cursor, length);\r\n                                     break;\r\n \r\n                                 case'i':\r\n@@ -719,29 +714,14 @@ public class AbstractParser implements Serializable {\n                     }\r\n \r\n                     case'\\'':\r\n-                        cursor = ParseTools.captureStringLiteral('\\'', expr, cursor, length);\r\n-//                        \r\n-//                        while (++cursor < length && expr[cursor] != '\\'') {\r\n-//                            if (expr[cursor] == '\\\\') handleEscapeSequence(expr[++cursor]);\r\n-//                        }\r\n-//\r\n-//                        if (cursor == length || expr[cursor] != '\\'') {\r\n-//                            throw new CompileException(\"unterminated literal\", expr, cursor);\r\n-//                        }\r\n-\r\n+                        cursor = captureStringLiteral('\\'', expr, cursor, length);\r\n                         return new LiteralNode(handleStringEscapes(subset(expr, start + 1, cursor++ - start - 1)), String.class);\r\n \r\n \r\n                     case'\"':\r\n-                        while (++cursor < length && expr[cursor] != '\"') {\r\n-                            if (expr[cursor] == '\\\\') handleEscapeSequence(expr[++cursor]);\r\n-                        }\r\n-                        if (cursor == length || expr[cursor] != '\"') {\r\n-                            throw new CompileException(\"unterminated literal\", expr, cursor);\r\n-                        }\r\n-                        else {\r\n-                            return new LiteralNode(handleStringEscapes(subset(expr, start + 1, cursor++ - start - 1)), String.class);\r\n-                        }\r\n+                        cursor = captureStringLiteral('\"', expr, cursor, length);\r\n+                        return new LiteralNode(handleStringEscapes(subset(expr, start + 1, cursor++ - start - 1)), String.class);\r\n+\r\n \r\n                     case'&': {\r\n                         if (expr[cursor++ + 1] == '&') {\r\ndiff --git a/src/main/java/org/mvel/PropertyAccessor.java b/src/main/java/org/mvel/PropertyAccessor.java\nindex 810ad81..aeb5321 100644\n--- a/src/main/java/org/mvel/PropertyAccessor.java\n+++ b/src/main/java/org/mvel/PropertyAccessor.java\n@@ -141,6 +141,10 @@ public class PropertyAccessor {\n         new PropertyAccessor(property, ctx).set(value);\r\n     }\r\n \r\n+    public static void set(Object ctx, VariableResolverFactory resolver, String property, Object value) {\r\n+        new PropertyAccessor(property.toCharArray(), ctx, resolver, null).set(value);\r\n+    }\r\n+\r\n     private Object get() {\r\n         curr = ctx;\r\n \r\ndiff --git a/src/main/java/org/mvel/ast/AssignmentNode.java b/src/main/java/org/mvel/ast/AssignmentNode.java\nindex e89061d..6ee8f96 100644\n--- a/src/main/java/org/mvel/ast/AssignmentNode.java\n+++ b/src/main/java/org/mvel/ast/AssignmentNode.java\n@@ -1,15 +1,14 @@\n package org.mvel.ast;\r\n \r\n-import org.mvel.ASTNode;\r\n-import org.mvel.CompiledSetExpression;\r\n-import org.mvel.ExecutableStatement;\r\n-import org.mvel.MVEL;\r\n+import org.mvel.*;\r\n import static org.mvel.MVEL.compileSetExpression;\r\n import org.mvel.integration.VariableResolverFactory;\r\n import static org.mvel.util.ArrayTools.findFirst;\r\n import static org.mvel.util.ParseTools.*;\r\n import static org.mvel.util.PropertyTools.find;\r\n \r\n+import static java.lang.System.arraycopy;\r\n+\r\n /**\r\n  * @author Christopher Brock\r\n  */\r\n@@ -24,32 +23,63 @@ public class AssignmentNode extends ASTNode implements Assignment {\n     private boolean col = false;\r\n     //   private String index;\r\n \r\n-    public AssignmentNode(char[] expr, int fields) {\r\n+    public AssignmentNode(char[] expr, int fields, int operation, String name) {\r\n         super(expr, fields);\r\n \r\n-\r\n         int assignStart;\r\n-        if ((assignStart = find(expr, '=')) != -1) {\r\n-            name = new String(expr, 0, assignStart).trim();\r\n+\r\n+        if (operation != -1) {\r\n+            checkNameSafety(this.name = name.trim());\r\n+\r\n+            char op = 0;\r\n+            switch (operation) {\r\n+                case Operator.ADD:\r\n+                    op = '+';\r\n+                    break;\r\n+                case Operator.SUB:\r\n+                    op = '-';\r\n+                    break;\r\n+                case Operator.MULT:\r\n+                    op = '*';\r\n+                    break;\r\n+                case Operator.DIV:\r\n+                    op = '/';\r\n+                    break;\r\n+            }\r\n+\r\n+            arraycopy(this.name.toCharArray(), 0, (stmt = new char[this.name.length() + expr.length + 1]), 0, this.name.length());\r\n+            stmt[this.name.length()] = op;\r\n+            arraycopy(expr, 0, stmt, this.name.length() + 1, expr.length);\r\n+\r\n+            this.egressType = (statement = (ExecutableStatement) subCompileExpression(stmt)).getKnownEgressType();\r\n+\r\n+        }\r\n+        else if ((assignStart = find(expr, '=')) != -1) {\r\n+\r\n+\r\n+            this.name = new String(expr, 0, assignStart).trim();\r\n             this.egressType = (statement = (ExecutableStatement) subCompileExpression(stmt = subset(expr, assignStart + 1))).getKnownEgressType();\r\n \r\n-            if (col = ((endOfName = findFirst('[', index = name.toCharArray())) > 0)) {\r\n+            if (col = ((endOfName = findFirst('[', index = this.name.toCharArray())) > 0)) {\r\n                 this.fields |= COLLECTION;\r\n \r\n                 if ((fields & COMPILE_IMMEDIATE) != 0) {\r\n                     setExpr = (CompiledSetExpression) compileSetExpression(index);\r\n                 }\r\n \r\n-                name = new String(expr, 0, endOfName);\r\n+                this.name = new String(expr, 0, endOfName);\r\n                 index = subset(index, endOfName, index.length - endOfName);\r\n             }\r\n \r\n-            checkNameSafety(name);\r\n+            checkNameSafety(this.name);\r\n         }\r\n         else {\r\n-            checkNameSafety(name = new String(expr));\r\n+            checkNameSafety(this.name = new String(expr));\r\n         }\r\n+    }\r\n \r\n+    public AssignmentNode(char[] expr, int fields) {\r\n+        this(expr, fields, -1, null);\r\n     }\r\n \r\n     public Object getReducedValueAccelerated(Object ctx, Object thisValue, VariableResolverFactory factory) {\r\ndiff --git a/src/main/java/org/mvel/ast/DeepAssignmentNode.java b/src/main/java/org/mvel/ast/DeepAssignmentNode.java\nindex 718930a..0619a5e 100644\n--- a/src/main/java/org/mvel/ast/DeepAssignmentNode.java\n+++ b/src/main/java/org/mvel/ast/DeepAssignmentNode.java\n@@ -1,14 +1,16 @@\n package org.mvel.ast;\r\n \r\n-import static org.mvel.PropertyAccessor.set;\r\n-import static org.mvel.MVEL.eval;\r\n import org.mvel.*;\r\n import static org.mvel.MVEL.compileSetExpression;\r\n+import static org.mvel.MVEL.eval;\r\n+import static org.mvel.PropertyAccessor.set;\r\n import org.mvel.integration.VariableResolverFactory;\r\n import static org.mvel.util.ParseTools.subCompileExpression;\r\n import static org.mvel.util.ParseTools.subset;\r\n import static org.mvel.util.PropertyTools.find;\r\n \r\n+import static java.lang.System.arraycopy;\r\n+\r\n /**\r\n  * @author Christopher Brock\r\n  */\r\n@@ -19,11 +21,38 @@ public class DeepAssignmentNode extends ASTNode implements Assignment {\n     private CompiledSetExpression set;\r\n     private Accessor statement;\r\n \r\n-    public DeepAssignmentNode(char[] expr, int fields) {\r\n+    public DeepAssignmentNode(char[] expr, int fields, int operation, String name) {\r\n         super(expr, fields);\r\n-\r\n         int mark;\r\n-        if ((mark = find(expr, '=')) != -1) {\r\n+\r\n+\r\n+        if (operation != -1) {\r\n+            this.property = name.trim();\r\n+\r\n+            char op = 0;\r\n+            switch (operation) {\r\n+                case Operator.ADD:\r\n+                    op = '+';\r\n+                    break;\r\n+                case Operator.SUB:\r\n+                    op = '-';\r\n+                    break;\r\n+                case Operator.MULT:\r\n+                    op = '*';\r\n+                    break;\r\n+                case Operator.DIV:\r\n+                    op = '/';\r\n+                    break;\r\n+            }\r\n+\r\n+            arraycopy(this.property.toCharArray(), 0, (stmt = new char[this.property.length() + expr.length + 1]), 0, this.property.length());\r\n+            stmt[this.property.length()] = op;\r\n+            arraycopy(expr, 0, stmt, this.property.length() + 1, expr.length);\r\n+\r\n+            this.egressType = ((ExecutableStatement)(statement = (ExecutableStatement) subCompileExpression(stmt))).getKnownEgressType();\r\n+\r\n+        }\r\n+        else if ((mark = find(expr, '=')) != -1) {\r\n             property = new String(expr, 0, mark).trim();\r\n             statement = (ExecutableStatement) subCompileExpression(stmt = subset(expr, mark + 1));\r\n         }\r\n@@ -36,6 +65,10 @@ public class DeepAssignmentNode extends ASTNode implements Assignment {\n         }\r\n     }\r\n \r\n+    public DeepAssignmentNode(char[] expr, int fields) {\r\n+        this(expr, fields, -1, null);\r\n+    }\r\n+\r\n     public Object getReducedValueAccelerated(Object ctx, Object thisValue, VariableResolverFactory factory) {\r\n         Object val;\r\n         set.setValue(ctx, factory, val = statement.getValue(ctx, thisValue, factory));\r\n@@ -44,7 +77,7 @@ public class DeepAssignmentNode extends ASTNode implements Assignment {\n \r\n     public Object getReducedValue(Object ctx, Object thisValue, VariableResolverFactory factory) {\r\n         Object val;\r\n-        set(ctx, property, val = eval(stmt, ctx, factory));\r\n+        set(ctx, factory, property, val = eval(stmt, ctx, factory));\r\n         return val;\r\n     }\r\n \r\ndiff --git a/src/main/java/org/mvel/ast/WithNode.java b/src/main/java/org/mvel/ast/WithNode.java\nindex 09b3648..e36e348 100644\n--- a/src/main/java/org/mvel/ast/WithNode.java\n+++ b/src/main/java/org/mvel/ast/WithNode.java\n@@ -4,9 +4,7 @@ import org.mvel.CompileException;\n import org.mvel.ExecutableStatement;\r\n import static org.mvel.MVEL.setProperty;\r\n import org.mvel.integration.VariableResolverFactory;\r\n-import org.mvel.util.ParseTools;\r\n-import static org.mvel.util.ParseTools.balancedCapture;\r\n-import static org.mvel.util.ParseTools.subset;\r\n+import static org.mvel.util.ParseTools.*;\r\n \r\n import java.util.ArrayList;\r\n import java.util.List;\r\n@@ -21,7 +19,7 @@ public class WithNode extends BlockNode implements NestedStatement {\n     public WithNode(char[] expr, char[] block, int fields) {\r\n         super(expr, fields, block);\r\n \r\n-        nestedStatement = (ExecutableStatement) ParseTools.subCompileExpression(new String(expr).trim());\r\n+        nestedStatement = (ExecutableStatement) subCompileExpression(new String(expr).trim());\r\n \r\n         compileWithExpressions();\r\n     }\r\n@@ -70,7 +68,7 @@ public class WithNode extends BlockNode implements NestedStatement {\n                     if (parm == null) {\r\n                         parms.add(new ParmValuePair(\r\n                                 null,\r\n-                                (ExecutableStatement) ParseTools.subCompileExpression(subset(block, start, i - start))\r\n+                                (ExecutableStatement) subCompileExpression(subset(block, start, i - start))\r\n                         ));\r\n                         start = ++i;\r\n                     }\r\n@@ -78,7 +76,7 @@ public class WithNode extends BlockNode implements NestedStatement {\n \r\n                         parms.add(new ParmValuePair(\r\n                                 parm,\r\n-                                (ExecutableStatement) ParseTools.subCompileExpression(subset(block, start, i - start)))\r\n+                                (ExecutableStatement) subCompileExpression(subset(block, start, i - start)))\r\n                         );\r\n \r\n                         parm = null;\r\n@@ -92,7 +90,7 @@ public class WithNode extends BlockNode implements NestedStatement {\n         if (parm != null && start != block.length) {\r\n             parms.add(new ParmValuePair(\r\n                     parm,\r\n-                    (ExecutableStatement) ParseTools.subCompileExpression(subset(block, start, block.length - start)))\r\n+                    (ExecutableStatement) subCompileExpression(subset(block, start, block.length - start)))\r\n             );\r\n         }\r\n \r\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\nindex 799c9ec..717e736 100644\n--- a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n@@ -1178,6 +1178,14 @@ public class CoreConfidenceTests extends TestCase {\n         parseDirect(\"System.out.println('1)your guess was:');\");\n     }\n \n+    public void testDeepPropertyAdd() {\n+        assertEquals(10, parseDirect(\"foo.countTest+ 10\"));\n+    }\n+\n+    public void testDeepAssignmentIncrement() {\n+        assertEquals(true, parseDirect(\"foo.countTest += 5; if (foo.countTest == 5) { foo.countTest = 0; return true; } else { foo.countTest = 0; return false; }\"));\n+    }\n+\n     public Object parseDirect(String ex) {\n         return compiledExecute(ex);\n     }\ndiff --git a/src/test/java/org/mvel/tests/main/res/Foo.java b/src/test/java/org/mvel/tests/main/res/Foo.java\nindex 2ad2212..aed52a1 100644\n--- a/src/test/java/org/mvel/tests/main/res/Foo.java\n+++ b/src/test/java/org/mvel/tests/main/res/Foo.java\n@@ -11,6 +11,8 @@ public class Foo {\n \n     private String name = \"dog\";\n \n+    private int countTest = 0;\n+\n     private Collection collectionTest;\n \n     public void abc() {\n@@ -53,4 +55,13 @@ public class Foo {\n     public void setCollectionTest(Collection collectionTest) {\n         this.collectionTest = collectionTest;\n     }\n+\n+\n+    public int getCountTest() {\n+        return countTest;\n+    }\n+\n+    public void setCountTest(int countTest) {\n+        this.countTest = countTest;\n+    }\n }\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T18:55:06.020361Z", "commit_hash": "5b4303292300aee0ed5e9cd39a1794f52bf35872", "commit_message": "bugfix: infinate loop regresson in verifier\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/AbstractParser.java b/src/main/java/org/mvel/AbstractParser.java\nindex 2f160ad..da36b2c 100644\n--- a/src/main/java/org/mvel/AbstractParser.java\n+++ b/src/main/java/org/mvel/AbstractParser.java\n@@ -39,7 +39,7 @@ public class AbstractParser implements Serializable {\n     protected boolean lastWasComment = false;\r\n \r\n     protected boolean debugSymbols = false;\r\n-\r\n+                         \r\n     private int line = 1;\r\n \r\n     protected ASTNode lastNode;\r\n@@ -637,9 +637,9 @@ public class AbstractParser implements Serializable {\n                                      *\r\n                                      *  take a stab in the dark and try and load the class\r\n                                      */\r\n-                                    start = cursor;\r\n+                                    int _start = cursor;\r\n                                     captureToEOS();\r\n-                                    return new TypeCast(expr, start, cursor, fields, createClass(tokenStr));\r\n+                                    return new TypeCast(expr, _start, cursor, fields, createClass(tokenStr));\r\n \r\n                                 }\r\n                                 catch (ClassNotFoundException e) {\r\ndiff --git a/src/main/java/org/mvel/PropertyAccessor.java b/src/main/java/org/mvel/PropertyAccessor.java\nindex 46cc2c6..a616194 100644\n--- a/src/main/java/org/mvel/PropertyAccessor.java\n+++ b/src/main/java/org/mvel/PropertyAccessor.java\n@@ -231,7 +231,7 @@ public class PropertyAccessor {\n                         throw new ConversionException(\"cannot convert type: \"\r\n                                 + value.getClass() + \": to \" + meth.getParameterTypes()[0]);\r\n                     }\r\n-\r\n+                      \r\n                     meth.invoke(curr, convert(value, meth.getParameterTypes()[0]));\r\n                 }\r\n                 else {\r\ndiff --git a/src/main/java/org/mvel/PropertyVerifier.java b/src/main/java/org/mvel/PropertyVerifier.java\nindex f8bef18..18baa76 100644\n--- a/src/main/java/org/mvel/PropertyVerifier.java\n+++ b/src/main/java/org/mvel/PropertyVerifier.java\n@@ -88,8 +88,6 @@ public class PropertyVerifier extends AbstractOptimizer {\n \n \n     private Class getBeanProperty(Class ctx, String property) {\n-\n-\n         if (first) {\n             if (parserContext.hasVarOrInput(property)) {\n                 return parserContext.getVarOrInputType(property);\n@@ -98,14 +96,10 @@ public class PropertyVerifier extends AbstractOptimizer {\n                 return (Class) AbstractParser.LITERALS.get(property);\n             }\n             else {\n-//                if (cursor < length && parserContext.isStrictTypeEnforcement()) {\n-//                    addFatalError(\"unqualified type in strict mode for: \" + property);\n-//                }\n                 return Object.class;\n             }\n         }\n \n-\n         start = cursor;\n \n         Member member = ctx != null ? PropertyTools.getFieldOrAccessor(ctx, property) : null;\n@@ -196,7 +190,6 @@ public class PropertyVerifier extends AbstractOptimizer {\n                     continue;\n                 case')':\n                     depth--;\n-\n             }\n         }\n         cursor--;\n@@ -211,7 +204,6 @@ public class PropertyVerifier extends AbstractOptimizer {\n             for (String token : subtokens) {\n                 verifCompiler = new ExpressionCompiler(token);\n                 verifCompiler._compile();\n-\n             }\n         }\n \ndiff --git a/src/main/java/org/mvel/util/ParseTools.java b/src/main/java/org/mvel/util/ParseTools.java\nindex 3aa6d12..a98935c 100644\n--- a/src/main/java/org/mvel/util/ParseTools.java\n+++ b/src/main/java/org/mvel/util/ParseTools.java\n@@ -91,12 +91,14 @@ public class ParseTools {\n \n         for (; i < end; i++) {\n             switch (parm[i]) {\n+                case'(':\n                 case'[':\n                 case'{':\n                     if (adepth++ == 0)\n                         start = i;\n                     continue;\n \n+                case')':\n                 case']':\n                 case'}':\n                     if (--adepth == 0) {\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\nindex 23ec143..164cb1f 100644\n--- a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n@@ -1465,6 +1465,39 @@ public class CoreConfidenceTests extends TestCase {\n         compiler.compile(context);\n     }\n \n+\n+    /**\n+     * Provided by: Aadi Deshpande\n+     */\n+    public void testPropertyVerfierShoudldNotLoopIndefinately() {\n+        String expr = \"\\t\\tmodel.latestHeadlines = $list;\\n\" +\n+                \"model.latestHeadlines.add( 0, (model.latestHeadlines[2]) );\";\n+\n+        ExpressionCompiler compiler = new ExpressionCompiler(expr);\n+        compiler.setVerifying(true);\n+\n+        ParserContext pCtx = new ParserContext();\n+        pCtx.addInput(\"$list\", List.class);\n+        pCtx.addInput(\"model\", Model.class);\n+\n+        compiler.compile(pCtx);\n+    }\n+\n+\n+    public static class Model {\n+        private List latestHeadlines;\n+\n+\n+        public List getLatestHeadlines() {\n+            return latestHeadlines;\n+        }\n+\n+        public void setLatestHeadlines(List latestHeadlines) {\n+            this.latestHeadlines = latestHeadlines;\n+        }\n+    }\n+\n+\n     public static class Message {\n         public static final int HELLO = 0;\n         public static final int GOODBYE = 1;\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T18:57:34.641901Z", "commit_hash": "46d7173b264a121ae56935b6a68bf3497087dd2c", "commit_message": "bugfix: see JIRA Issue: MVEL-19\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/MVELRuntime.java b/src/main/java/org/mvel/MVELRuntime.java\nindex 3bfd2ac..7a521f1 100644\n--- a/src/main/java/org/mvel/MVELRuntime.java\n+++ b/src/main/java/org/mvel/MVELRuntime.java\n@@ -25,7 +25,6 @@ public class MVELRuntime {\n     private static ThreadLocal<Map<String, Set<Integer>>> threadBreakpoints;\r\n     private static ThreadLocal<Debugger> threadDebugger;\r\n \r\n-\r\n     /**\r\n      * Main interpreter.\r\n      *\r\n@@ -134,10 +133,6 @@ public class MVELRuntime {\n                                 else stk.push(null);\r\n                                 break;\r\n \r\n-//                            case REGEX:\r\n-//                                stk.push(compile(valueOf(v1)).matcher(valueOf(v2)).matches());\r\n-//                                break;\r\n-\r\n                             case INSTANCEOF:\r\n                                 if (v1 instanceof Class)\r\n                                     stk.push(((Class) v1).isInstance(v2));\r\ndiff --git a/src/main/java/org/mvel/PropertyAccessor.java b/src/main/java/org/mvel/PropertyAccessor.java\nindex 5aacd09..60fa03a 100644\n--- a/src/main/java/org/mvel/PropertyAccessor.java\n+++ b/src/main/java/org/mvel/PropertyAccessor.java\n@@ -191,7 +191,6 @@ public class PropertyAccessor {\n     private void set(Object value) {\r\n         curr = ctx;\r\n \r\n-\r\n         try {\r\n             int oLength = length;\r\n             length = ArrayTools.findLast('.', property);\r\n@@ -204,6 +203,7 @@ public class PropertyAccessor {\n \r\n             String tk = captureNext();\r\n \r\n+\r\n             Member member = checkWriteCache(curr.getClass(), tk == null ? 0 : tk.hashCode());\r\n             if (member == null) {\r\n                 addWriteCache(curr.getClass(), tk == null ? 0 : tk.hashCode(), (member = getFieldOrWriteAccessor(curr.getClass(), tk)));\r\n@@ -238,6 +238,10 @@ public class PropertyAccessor {\n                     meth.invoke(curr, value);\r\n                 }\r\n             }\r\n+            else if (curr instanceof Map) {\r\n+                //noinspection unchecked\r\n+                ((Map) curr).put(tk, value);\r\n+            }\r\n             else {\r\n                 throw new PropertyAccessException(\"could not access property (\" + property + \") in: \" + ctx.getClass().getName());\r\n             }\r\ndiff --git a/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java b/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\nindex 8e6ce7f..6ac3c75 100644\n--- a/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\n+++ b/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\n@@ -385,8 +385,7 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n             name = m.getName();\r\n             first = false;\r\n         }\r\n-\r\n-\r\n+        \r\n         int st = cursor;\r\n \r\n         int depth = 1;\r\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\nindex 41fcec3..3db94e1 100644\n--- a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n@@ -1140,6 +1140,16 @@ public class CoreConfidenceTests extends TestCase {\n         assertEquals(\"dog\", MVEL.executeExpression(s, foo.getBar()));\n     }\n \n+    public void testVirtProperty() {\n+        Map<String, Object> testMap = new HashMap<String, Object>();\n+        testMap.put(\"test\", \"foo\");\n+\n+        Map<String, Object> vars = new HashMap<String, Object>();\n+        vars.put(\"mp\", testMap);\n+\n+        assertEquals(\"bar\", MVEL.executeExpression(compileExpression(\"mp.test = 'bar'; mp.test\"), vars));\n+    }\n+\n \n     public Object parseDirect(String ex) {\n         return compiledExecute(ex);\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T18:58:23.647676Z", "commit_hash": "50b9724e1988473b5aa85227d983594862e0159d", "commit_message": "regression fixed, dynamic deoptimization problems fixed.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/ast/ContextDeepPropertyNode.java b/src/main/java/org/mvel/ast/ContextDeepPropertyNode.java\nindex 09f9d74..b6348bf 100644\n--- a/src/main/java/org/mvel/ast/ContextDeepPropertyNode.java\n+++ b/src/main/java/org/mvel/ast/ContextDeepPropertyNode.java\n@@ -2,6 +2,7 @@ package org.mvel.ast;\n \r\n import org.mvel.ASTNode;\r\n import org.mvel.Accessor;\r\n+import org.mvel.PropertyAccessException;\r\n import org.mvel.integration.VariableResolverFactory;\r\n import org.mvel.optimizers.AccessorOptimizer;\r\n import org.mvel.optimizers.OptimizerFactory;\r\n@@ -10,8 +11,7 @@ import org.mvel.optimizers.OptimizerFactory;\n  * @author Christopher Brock\r\n  */\r\n public class ContextDeepPropertyNode extends ASTNode {\r\n-\r\n-    private Accessor accessor;            \r\n+    private Accessor accessor;\r\n \r\n     public ContextDeepPropertyNode(char[] expr, int fields) {\r\n         super(expr, fields);\r\n@@ -31,8 +31,19 @@ public class ContextDeepPropertyNode extends ASTNode {\n                 throw e;\r\n             }\r\n         }\r\n+        catch (ClassCastException e) {\r\n+            return handleDynamicDeoptimization(ctx, thisValue, factory);\r\n+        }\r\n+    }\r\n+\r\n+    private Object handleDynamicDeoptimization(Object ctx, Object thisValue, VariableResolverFactory factory) {\r\n+        synchronized (this) {\r\n+            accessor = null;\r\n+            return getReducedValueAccelerated(ctx, thisValue, factory);\r\n+        }\r\n     }\r\n \r\n+\r\n     public Object getReducedValue(Object ctx, Object thisValue, VariableResolverFactory factory) {\r\n         return getReducedValueAccelerated(ctx, thisValue, factory);\r\n     }\r\ndiff --git a/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java b/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\nindex c0b9b35..8e6ce7f 100644\n--- a/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\n+++ b/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\n@@ -379,7 +379,7 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n      */\r\n     @SuppressWarnings({\"unchecked\"})\r\n     private Object getMethod(Object ctx, String name) throws Exception {\r\n-        if (first && variableFactory.isResolveable(name)) {\r\n+        if (first && variableFactory != null && variableFactory.isResolveable(name)) {\r\n             Method m = (Method) variableFactory.getVariableResolver(name).getValue();\r\n             ctx = m.getDeclaringClass();\r\n             name = m.getName();\r\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\nindex 39445c1..41fcec3 100644\n--- a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n@@ -1,7 +1,5 @@\n package org.mvel.tests.main;\n \n-import static java.lang.System.currentTimeMillis;\n-\n import junit.framework.TestCase;\n import org.mvel.*;\n import static org.mvel.MVEL.*;\n@@ -19,6 +17,7 @@ import org.mvel.optimizers.OptimizerFactory;\n import org.mvel.tests.main.res.*;\n \n import java.io.Serializable;\n+import static java.lang.System.currentTimeMillis;\n import java.text.SimpleDateFormat;\n import java.util.*;\n \n@@ -1134,6 +1133,13 @@ public class CoreConfidenceTests extends TestCase {\n         assertTrue((Boolean) parseDirect(\"dt1 < dt2\"));\n     }\n \n+    public void testDynamicDeop() {\n+        Serializable s = MVEL.compileExpression(\"name\");\n+\n+        assertEquals(\"dog\", MVEL.executeExpression(s, foo));\n+        assertEquals(\"dog\", MVEL.executeExpression(s, foo.getBar()));\n+    }\n+\n \n     public Object parseDirect(String ex) {\n         return compiledExecute(ex);\ndiff --git a/src/test/java/org/mvel/tests/main/res/Foo.java b/src/test/java/org/mvel/tests/main/res/Foo.java\nindex 6dc6e7f..2ad2212 100644\n--- a/src/test/java/org/mvel/tests/main/res/Foo.java\n+++ b/src/test/java/org/mvel/tests/main/res/Foo.java\n@@ -9,6 +9,8 @@ public class Foo {\n     public String aValue = \"\";\n     public String bValue = \"\";\n \n+    private String name = \"dog\";\n+\n     private Collection collectionTest;\n \n     public void abc() {\n@@ -36,6 +38,14 @@ public class Foo {\n     }\n \n \n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n     public Collection getCollectionTest() {\n         return collectionTest;\n     }\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T18:59:12.323406Z", "commit_hash": "b9a87527e8e9d723b43686242c74b81ed6896ca1", "commit_message": "bug fixes.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/MVELRuntime.java b/src/main/java/org/mvel/MVELRuntime.java\nindex 0f38984..3bfd2ac 100644\n--- a/src/main/java/org/mvel/MVELRuntime.java\n+++ b/src/main/java/org/mvel/MVELRuntime.java\n@@ -1,8 +1,8 @@\n package org.mvel;\r\n \r\n-import static org.mvel.Soundex.soundex;\r\n import static org.mvel.DataConversion.canConvert;\r\n import static org.mvel.Operator.*;\r\n+import static org.mvel.Soundex.soundex;\r\n import org.mvel.ast.LineLabel;\r\n import org.mvel.debug.Debugger;\r\n import org.mvel.debug.Frame;\r\n@@ -29,15 +29,14 @@ public class MVELRuntime {\n     /**\r\n      * Main interpreter.\r\n      *\r\n-     * @see org.mvel.MVEL\r\n-     *\r\n-     * @param debugger -\r\n-     * @param expression -\r\n-     * @param ctx -\r\n+     * @param debugger        -\r\n+     * @param expression      -\r\n+     * @param ctx             -\r\n      * @param variableFactory -\r\n      * @return -\r\n+     * @see org.mvel.MVEL\r\n      */\r\n-    public static Object execute(boolean debugger, CompiledExpression expression, Object ctx, VariableResolverFactory variableFactory) {        \r\n+    public static Object execute(boolean debugger, CompiledExpression expression, Object ctx, VariableResolverFactory variableFactory) {\r\n         final ASTLinkedList node = new ASTLinkedList(expression.getTokens().firstNode());\r\n \r\n         Stack stk = new ExecutionStack();\r\n@@ -66,15 +65,20 @@ public class MVELRuntime {\n                     if (debugger) {\r\n                         LineLabel label = (LineLabel) tk;\r\n \r\n-                        if (threadBreakpoints != null\r\n-                                && threadBreakpoints.get().get(label.getSourceFile()).contains(label.getLineNumber())) {\r\n+                        try {\r\n+                            if (threadBreakpoints != null\r\n+                                    && threadBreakpoints.get().get(label.getSourceFile()).contains(label.getLineNumber())) {\r\n \r\n-                              if (threadDebugger == null || threadDebugger.get() == null)  {\r\n-                                  throw new RuntimeException(\"no debugger registered to handle breakpoint.\");\r\n-                              }\r\n+                                if (threadDebugger == null || threadDebugger.get() == null) {\r\n+                                    throw new RuntimeException(\"no debugger registered to handle breakpoint.\");\r\n+                                }\r\n \r\n-                              threadDebugger.get()\r\n-                                      .onBreak(new Frame(label.getSourceFile(), label.getLineNumber(), variableFactory, expression.getParserContext()));\r\n+                                threadDebugger.get()\r\n+                                        .onBreak(new Frame(label.getSourceFile(), label.getLineNumber(), variableFactory, expression.getParserContext()));\r\n+                            }\r\n+                        }\r\n+                        catch (NullPointerException e) {\r\n+                            // do nothing for now.  this isn't as calus as it seems.   \r\n                         }\r\n                     }\r\n                     continue;\r\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/DebuggerTests.java b/src/test/java/org/mvel/tests/DebuggerTests.java\nindex dc352c8..ac5f13a 100644\n--- a/src/test/java/org/mvel/tests/DebuggerTests.java\n+++ b/src/test/java/org/mvel/tests/DebuggerTests.java\n@@ -11,48 +11,84 @@ import org.mvel.integration.impl.LocalVariableResolverFactory;\n public class DebuggerTests extends TestCase {\n \n     private static int count;\n-    private static int a1=0;\n-    private static int a4=0;\n+    private static int a1 = 0;\n+    private static int a4 = 0;\n \n     public void testDebuggerInvoke() {\n+        count = 0;\n \n         MVELRuntime.setThreadDebugger(new Debugger() {\n             public int onBreak(Frame frame) {\n-                if (frame.getFactory().getVariableResolver( \"a1\" )!=null) {\n+                if (frame.getFactory().getVariableResolver(\"a1\") != null) {\n                     a1++;\n                 }\n-                if (frame.getFactory().getVariableResolver( \"a4\" )!=null) {\n+                if (frame.getFactory().getVariableResolver(\"a4\") != null) {\n                     a4++;\n-                    System.out.println(\"HEI \"+frame.getLineNumber());\n+                    System.out.println(\"HEI \" + frame.getLineNumber());\n                 }\n                 count++;\n                 return 0;\n             }\n         });\n \n-        String src=\"a1=7;\\na2=8;\\na3=9;\\na4=10;\\na5=11;\\na6=12;\\na7=13;\\na8=14;\";\n+        String src = \"a1=7;\\na2=8;\\na3=9;\\na4=10;\\na5=11;\\na6=12;\\na7=13;\\na8=14;\";\n         ExpressionCompiler c = new ExpressionCompiler(src);\n-        c.setDebugSymbols( true );\n+        c.setDebugSymbols(true);\n         ParserContext ctx = new ParserContext();\n-        ctx.setSourceFile ( \"mysource\" );               \n+        ctx.setSourceFile(\"mysource\");\n         CompiledExpression compexpr = c.compile(ctx);\n \n         System.out.println(decompile(compexpr));\n \n \n-        MVELRuntime.registerBreakpoint( ctx.getSourceFile(), 1);\n-        MVELRuntime.registerBreakpoint( ctx.getSourceFile(), 3);\n-        MVELRuntime.registerBreakpoint( ctx.getSourceFile (), 7);\n+        MVELRuntime.registerBreakpoint(ctx.getSourceFile(), 1);\n+        MVELRuntime.registerBreakpoint(ctx.getSourceFile(), 3);\n+        MVELRuntime.registerBreakpoint(ctx.getSourceFile(), 7);\n \n         VariableResolverFactory factory = new LocalVariableResolverFactory();\n-        MVEL.executeDebugger( compexpr, null, factory);\n+        MVEL.executeDebugger(compexpr, null, factory);\n \n         System.out.println(a1);\n         System.out.println(a4);\n         System.out.println(count);\n-        assertEquals( 2, a1 );\n+        assertEquals(2, a1);\n         assertEquals(1, a4);   // test passes but the breakpoint should be received by line 7, not by line 3\n-        assertEquals( 3, count ); // three breakpoints FAILS\n+        assertEquals(3, count); // three breakpoints FAILS\n+    }\n+\n+    public void testDebuggerInvoke2() {\n+        count = 0;\n+\n+        MVELRuntime.setThreadDebugger(new Debugger() {\n+            public int onBreak(Frame frame) {\n+                count++;\n+                return 0;\n+            }\n+        });\n+\n+        String src = \"a1=7;\\na2=8;\\nSystem.out.println(\\\"h\\\");\\nac=23;\\nde=23;\\nge=23;\\ngef=34;\";\n+\n+        ExpressionCompiler c = new ExpressionCompiler(src);\n+        c.setDebugSymbols(true);\n+        ParserContext ctx = new ParserContext();\n+        ctx.setSourceFile(\"mysource\");\n+        CompiledExpression compexpr = c.compile(ctx);\n+\n+        System.out.println(decompile(compexpr));\n+\n+\n+        MVELRuntime.registerBreakpoint(ctx.getSourceFile(), 1);\n+        MVELRuntime.registerBreakpoint(ctx.getSourceFile(), 2);\n+        MVELRuntime.registerBreakpoint(ctx.getSourceFile(), 3);\n+        MVELRuntime.registerBreakpoint(ctx.getSourceFile(), 4);\n+        MVELRuntime.registerBreakpoint(ctx.getSourceFile(), 5);\n+\n+\n+        VariableResolverFactory factory = new LocalVariableResolverFactory();\n+        MVEL.executeDebugger(compexpr, null, factory);\n+\n+        System.out.println(count);\n+        assertEquals(5, count);\n     }\n \n }\n\\ No newline at end of file\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T19:03:02.031210Z", "commit_hash": "9cce13dc07fa320574941e30d4c78a249e5a277e", "commit_message": "bug fix: MVEL-17\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/util/ParseTools.java b/src/main/java/org/mvel/util/ParseTools.java\nindex 4e161f1..3aa6d12 100644\n--- a/src/main/java/org/mvel/util/ParseTools.java\n+++ b/src/main/java/org/mvel/util/ParseTools.java\n@@ -217,7 +217,7 @@ public class ParseTools {\n                     else if (parmTypes[i].isAssignableFrom(arguments[i])) {\n                         score += 2;\n                     }\n-                    else if (canConvert(parmTypes[i], arguments[i])) {\n+                    else if (canConvert(parmTypes[i], arguments[i]) || arguments[i] == Object.class) {\n                         score += 1;\n                     }\n                     else {\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\nindex 134b489..b38b1e1 100644\n--- a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n@@ -20,6 +20,7 @@ import org.mvel.tests.main.res.*;\n \n import java.io.Serializable;\n import java.util.*;\n+import java.text.SimpleDateFormat;\n \n public class CoreConfidenceTests extends TestCase {\n     protected Foo foo = new Foo();\n@@ -1262,6 +1263,11 @@ public class CoreConfidenceTests extends TestCase {\n         }\n     }\n \n+\n+    /**\n+     * Community provided test cases\n+     */\n+\n     @SuppressWarnings({\"unchecked\"})\n     public void testCalculateAge() {\n         //    System.out.println(\"Calculating the Age\");\n@@ -1275,4 +1281,68 @@ public class CoreConfidenceTests extends TestCase {\n                 , null, objectMap));\n     }\n \n+    /**\n+     * Provided by: Alex Roytman\n+     */\n+\n+    public void testMethodResolutionWithNullParameter() {\n+        Context ctx = new Context();\n+        ctx.setBean(new Bean());\n+        Map<String, Object> vars = new HashMap<String, Object>();\n+        System.out.println(\"bean.today: \" + MVEL.eval(\"bean.today\", ctx, vars));\n+        System.out.println(\"formatDate(bean.today): \" + MVEL.eval(\"formatDate(bean.today)\", ctx, vars));\n+        //calling method with string param with null parameter works\n+        System.out.println(\"formatString(bean.nullString): \" + MVEL.eval(\"formatString(bean.nullString)\", ctx, vars));\n+        System.out.println(\"bean.myDate = bean.nullDate: \" + MVEL.eval(\"bean.myDate = bean.nullDate; return bean.nullDate;\", ctx, vars));\n+        //calling method with Date param with null parameter fails\n+        System.out.println(\"formatDate(bean.myDate): \" + MVEL.eval(\"formatDate(bean.myDate)\", ctx, vars));\n+        //same here\n+        System.out.println(MVEL.eval(\"formatDate(bean.nullDate)\", ctx, vars));\n+    }\n+\n+    public static class Bean {\n+        private Date myDate = new Date();\n+\n+        public Date getToday() {\n+            return new Date();\n+        }\n+\n+        public Date getNullDate() {\n+            return null;\n+        }\n+\n+        public String getNullString() {\n+            return null;\n+        }\n+\n+        public Date getMyDate() {\n+            return myDate;\n+        }\n+\n+        public void setMyDate(Date myDate) {\n+            this.myDate = myDate;\n+        }\n+    }\n+\n+    public static class Context {\n+        private final SimpleDateFormat dateFormat = new SimpleDateFormat(\"MM/dd/yy\");\n+        private Bean bean;\n+\n+        public Bean getBean() {\n+            return bean;\n+        }\n+\n+        public void setBean(Bean bean) {\n+            this.bean = bean;\n+        }\n+\n+        public String formatDate(Date date) {\n+            return date == null ? null : dateFormat.format(date);\n+        }\n+\n+        public String formatString(String str) {\n+            return str == null ? \"<NULL>\" : str;\n+        }\n+    }\n+\n }\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T19:05:49.768404Z", "commit_hash": "3f9adb62f9d0e4cc58a91d15473c5090528f8f0d", "commit_message": "Verifier regression fixed.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/MVELRuntime.java b/src/main/java/org/mvel/MVELRuntime.java\nindex ea5108c..5fa5589 100644\n--- a/src/main/java/org/mvel/MVELRuntime.java\n+++ b/src/main/java/org/mvel/MVELRuntime.java\n@@ -1,5 +1,6 @@\n package org.mvel;\r\n \r\n+import static org.mvel.Soundex.soundex;\r\n import static org.mvel.DataConversion.canConvert;\r\n import static org.mvel.Operator.*;\r\n import org.mvel.ast.LineLabel;\r\n@@ -30,11 +31,11 @@ public class MVELRuntime {\n      *\r\n      * @see org.mvel.MVEL\r\n      *\r\n-     * @param debugger\r\n-     * @param node\r\n-     * @param ctx\r\n-     * @param variableFactory\r\n-     * @return\r\n+     * @param debugger -\r\n+     * @param node -\r\n+     * @param ctx -\r\n+     * @param variableFactory -\r\n+     * @return -\r\n      */\r\n     public static Object execute(boolean debugger, ASTIterator node, Object ctx, VariableResolverFactory variableFactory) {\r\n         Stack stk = new ExecutionStack();\r\n@@ -184,7 +185,7 @@ public class MVELRuntime {\n                                 break;\r\n \r\n                             case SOUNDEX:\r\n-                                stk.push(Soundex.soundex(valueOf(v1)).equals(Soundex.soundex(valueOf(v2))));\r\n+                                stk.push(soundex(valueOf(v1)).equals(soundex(valueOf(v2))));\r\n                                 break;\r\n \r\n                             case SIMILARITY:\r\ndiff --git a/src/main/java/org/mvel/PropertyVerifier.java b/src/main/java/org/mvel/PropertyVerifier.java\nindex 4fa0304..8f0567e 100644\n--- a/src/main/java/org/mvel/PropertyVerifier.java\n+++ b/src/main/java/org/mvel/PropertyVerifier.java\n@@ -150,6 +150,7 @@ public class PropertyVerifier extends AbstractOptimizer {\n                 addFatalError(\"unqualified type in strict mode for: \" + property);\n             }\n             return Object.class;\n+            \n         }\n     }\n \n@@ -161,40 +162,16 @@ public class PropertyVerifier extends AbstractOptimizer {\n         if (cursor == length)\n             throw new PropertyAccessException(\"unterminated '['\");\n \n-        String item;\n-\n-        if (expr[cursor] == '\\'' || expr[cursor] == '\"') {\n-            start++;\n-\n-            int end;\n-\n-            if (!scanTo(']')) {\n-                addFatalError(\"unterminated [ in token\");\n-                return Object.class;\n-            }\n-\n-            if ((end = containsStringLiteralTermination()) == -1) {\n-                addFatalError(\"unterminated string literal in indexed property\");\n-                return Object.class;\n-            }\n-\n-            item = new String(expr, start, end - start);\n+        if (!scanTo(']')) {\n+            addFatalError(\"unterminated [ in token\");\n         }\n-        else {\n-            if (!scanTo(']')) {\n-                addFatalError(\"unterminated [ in token\");\n-            }\n-\n-            item = new String(expr, start, cursor - start);\n-        }\n-\n \n-        ExpressionCompiler compiler = new ExpressionCompiler(item);\n+        ExpressionCompiler compiler = new ExpressionCompiler(new String(expr, start, cursor - start));\n         compiler._compile();\n \n         ++cursor;\n \n-        return compiler.getReturnType();\n+        return compiler.getReturnType() == null ? Object.class : compiler.getReturnType();\n     }\n \n \n@@ -226,7 +203,7 @@ public class PropertyVerifier extends AbstractOptimizer {\n                 verifCompiler = new ExpressionCompiler(token);\n                 verifCompiler._compile();\n \n-         //       inputs.addAll(verifCompiler.getInputs());\n+                //       inputs.addAll(verifCompiler.getInputs());\n             }\n         }\n \n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/perftests/CompiledPerformanceTests.java b/src/test/java/org/mvel/tests/perftests/CompiledPerformanceTests.java\nindex db80432..31234d8 100644\n--- a/src/test/java/org/mvel/tests/perftests/CompiledPerformanceTests.java\n+++ b/src/test/java/org/mvel/tests/perftests/CompiledPerformanceTests.java\n@@ -19,7 +19,7 @@ import ognl.OgnlContext;\n import ognl.Node;\r\n \r\n public class CompiledPerformanceTests extends TestCase {\r\n-    private static final int ITERATIONS = 100000;\r\n+    private static final int ITERATIONS = 1000000;\r\n \r\n     protected Foo foo = new Foo();\r\n     protected Map<String, Object> map = new HashMap<String, Object>();\r\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T19:16:58.005308Z", "commit_hash": "6327b8c65e7b5a275cb24ae7a118fcbf4c9e7b45", "commit_message": "type inferencing fixed.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/ParserContext.java b/src/main/java/org/mvel/ParserContext.java\nindex 0fb8e8d..a80004a 100644\n--- a/src/main/java/org/mvel/ParserContext.java\n+++ b/src/main/java/org/mvel/ParserContext.java\n@@ -102,6 +102,7 @@ public class ParserContext {\n     }\n \n     public void addInput(String name, Class type) {\n+        if (inputs == null) inputs = new HashMap<String, Class>();\n         if (inputs.containsKey(name)) return;\n         if (type == null) type = Object.class;\n         inputs.put(name, type);\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\nindex 0a5a52a..ff11080 100644\n--- a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n@@ -846,6 +846,7 @@ public class CoreConfidenceTests extends TestCase {\n \n     public void testVarInputs2() {\n         ExpressionCompiler compiler = new ExpressionCompiler(\"test != foo && bo.addSomething(trouble); String bleh = foo; twa = bleh;\");\n+\n         ParserContext ctx = new ParserContext();\n         ctx.setRetainParserState(true);\n \n@@ -983,6 +984,16 @@ public class CoreConfidenceTests extends TestCase {\n         assertTrue(false);\n     }\n \n+    public void testProvidedExternalTypes() {\n+        ExpressionCompiler compiler = new ExpressionCompiler(\"foo.bar\");\n+        ParserContext ctx = new ParserContext();\n+        ctx.setStrictTypeEnforcement(true);\n+        ctx.addInput(\"foo\", Foo.class);\n+\n+        Serializable c = compiler.compile(ctx);\n+\n+    }\n+\n     public Object parseDirect(String ex) {\n         return compiledExecute(ex);\n     }\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T19:17:46.064487Z", "commit_hash": "24b500aef8fd2a6b95bb07abe99baf75d3485808", "commit_message": "type inferencing fixed.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/AbstractParser.java b/src/main/java/org/mvel/AbstractParser.java\nindex b4844ef..7fb39b4 100644\n--- a/src/main/java/org/mvel/AbstractParser.java\n+++ b/src/main/java/org/mvel/AbstractParser.java\n@@ -2,7 +2,6 @@ package org.mvel;\n \r\n import static org.mvel.Operator.*;\r\n import org.mvel.ast.*;\r\n-import org.mvel.integration.Interceptor;\r\n import org.mvel.util.ExecutionStack;\r\n import org.mvel.util.ParseTools;\r\n import static org.mvel.util.ParseTools.*;\r\n@@ -185,6 +184,8 @@ public class AbstractParser {\n \r\n             ParserContext pCtx = parserContext.get();\r\n             pCtx.setLineCount(line);\r\n+            pCtx.setLineOffset(cursor);\r\n+\r\n             return new LineLabel(pCtx.getSourceFile(), line);\r\n         }\r\n         else {\r\n@@ -1028,14 +1029,10 @@ public class AbstractParser {\n \r\n     protected void newContext() {\r\n         if (parserContext == null) parserContext = new ThreadLocal<ParserContext>();\r\n-\r\n         ParserContext ctx = new ParserContext(this);\r\n-\r\n         parserContext.set(ctx);\r\n     }\r\n \r\n-\r\n-\r\n     public boolean isDebugSymbols() {\r\n         return debugSymbols;\r\n     }\r\n@@ -1052,14 +1049,17 @@ public class AbstractParser {\n     }\r\n \r\n     protected void addFatalError(String message) {\r\n-        getParserContext().addError(new ErrorDetail(message, true));\r\n+        getParserContext().addError(new ErrorDetail(getParserContext().getLineCount(), cursor - getParserContext().getLineOffset(), true, message));\r\n+    }\r\n+\r\n+    protected void addFatalError(String message, int row, int cols) {\r\n+        getParserContext().addError(new ErrorDetail(row, cols, true, message));\r\n     }\r\n \r\n     protected void addWarning(String message) {\r\n         getParserContext().addError(new ErrorDetail(message, false));\r\n     }\r\n \r\n-\r\n     public static final int LEVEL_5_CONTROL_FLOW = 5;\r\n     public static final int LEVEL_4_ASSIGNMENT = 4;\r\n     public static final int LEVEL_3_ITERATION = 3;\r\n@@ -1150,12 +1150,9 @@ public class AbstractParser {\n             case 0: // Property access and inline collections\r\n                 OPERATORS.put(\":\", TERNARY_ELSE);\r\n         }\r\n-\r\n     }\r\n \r\n     public static void resetParserContext() {\r\n         if (parserContext != null) parserContext.remove();\r\n     }\r\n-\r\n-\r\n }\r\ndiff --git a/src/main/java/org/mvel/ErrorDetail.java b/src/main/java/org/mvel/ErrorDetail.java\nindex 9f03fa0..f9d433d 100644\n--- a/src/main/java/org/mvel/ErrorDetail.java\n+++ b/src/main/java/org/mvel/ErrorDetail.java\n@@ -18,7 +18,6 @@ public class ErrorDetail {\n         this.message = message;\n     }\n \n-\n     public int getRow() {\n         return row;\n     }\n@@ -54,10 +53,10 @@ public class ErrorDetail {\n \n     public String toString() {\n          if (critical) {\n-             return \"(\" + col + \",\" + row + \") \" + message;\n+             return \"(\" + row + \",\" + col + \") \" + message;\n          }\n          else {\n-             return \"(\" + col + \",\" + row + \") WARNING: \" + message;\n+             return \"(\" + row + \",\" + col + \") WARNING: \" + message;\n          }\n \n     }\ndiff --git a/src/main/java/org/mvel/ExecutableLiteral.java b/src/main/java/org/mvel/ExecutableLiteral.java\nindex 8653fcb..b4afeb0 100644\n--- a/src/main/java/org/mvel/ExecutableLiteral.java\n+++ b/src/main/java/org/mvel/ExecutableLiteral.java\n@@ -45,7 +45,7 @@ public class ExecutableLiteral implements ExecutableStatement {\n     }\r\n \r\n     public Class getKnownEgressType() {\r\n-        return null;\r\n+        return this.literal.getClass();\r\n     }\r\n \r\n     public boolean isConvertableIngressEgress() {\r\ndiff --git a/src/main/java/org/mvel/ExpressionCompiler.java b/src/main/java/org/mvel/ExpressionCompiler.java\nindex 2b01a21..a11d888 100644\n--- a/src/main/java/org/mvel/ExpressionCompiler.java\n+++ b/src/main/java/org/mvel/ExpressionCompiler.java\n@@ -1,7 +1,7 @@\n package org.mvel;\r\n \r\n import static org.mvel.DataConversion.canConvert;\r\n-import org.mvel.ast.AssignmentNode;\r\n+import org.mvel.ast.Assignment;\r\n import org.mvel.ast.LiteralNode;\r\n import org.mvel.ast.Substatement;\r\n import org.mvel.util.ExecutionStack;\r\n@@ -17,9 +17,6 @@ import java.util.regex.Pattern;\n public class ExpressionCompiler extends AbstractParser {\r\n     private final Stack stk = new ExecutionStack();\r\n \r\n- //   private Set<String> inputs;\r\n- //   private Set<String> locals;\r\n-\r\n     private Class returnType;\r\n \r\n     private boolean verifying = true;\r\n@@ -35,8 +32,19 @@ public class ExpressionCompiler extends AbstractParser {\n             parserContext = new ThreadLocal<ParserContext>();\r\n         }\r\n         parserContext.set(ctx);\r\n-        \r\n-        return _compile();\r\n+\r\n+        CompiledExpression c = _compile();\r\n+\r\n+        if (pCtx.isFatalError()) {\r\n+            parserContext.remove();\r\n+            throw new CompileException(\"Failed to _compile: \" + pCtx.getErrorList().size() + \" compilation error(s)\", pCtx.getErrorList());\r\n+        }\r\n+        else if (pCtx.isFatalError()) {\r\n+            parserContext.remove();\r\n+            throw new CompileException(\"Failed to _compile: \" + pCtx.getErrorList().size() + \" compilation error(s)\", pCtx.getErrorList());\r\n+        }\r\n+\r\n+        return c;\r\n     }\r\n \r\n     /**\r\n@@ -58,9 +66,6 @@ public class ExpressionCompiler extends AbstractParser {\n \r\n         try {\r\n             if (verifying) {\r\n-//                inputs = new LinkedHashSet<String>();\r\n-//                locals = new LinkedHashSet<String>();\r\n-\r\n                 getParserContext().initializeTables();\r\n             }\r\n \r\n@@ -74,20 +79,8 @@ public class ExpressionCompiler extends AbstractParser {\n \r\n                 returnType = tk.getEgressType();\r\n \r\n-                if (pCtx.isStrictTypeEnforcement() && tk instanceof AssignmentNode\r\n-                        && (pCtx.getInputs() == null\r\n-                        || !pCtx.getInputs().containsKey(tk.getName()))) {\r\n-\r\n-                    addFatalError(\"untyped var not permitted in strict-mode: \" + tk.getName());\r\n-                }\r\n-\r\n                 if (tk instanceof Substatement) {\r\n-                    ExpressionCompiler subCompiler = new ExpressionCompiler(tk.getNameAsArray());\r\n-                    tk.setAccessor(subCompiler._compile());\r\n-//\r\n-//                    if (verifying) {\r\n-//                        inputs.addAll(subCompiler.getInputs());\r\n-//                    }\r\n+                    tk.setAccessor(new ExpressionCompiler(tk.getNameAsArray())._compile());\r\n                 }\r\n \r\n                 /**\r\n@@ -180,20 +173,9 @@ public class ExpressionCompiler extends AbstractParser {\n             }\r\n \r\n             if (verifying) {\r\n-//                for (String s : locals) {\r\n-//                    inputs.remove(s);\r\n-//                }\r\n                 pCtx.processTables();\r\n             }\r\n \r\n-            if (pCtx.isFatalError()) {\r\n-                parserContext.remove();\r\n-                throw new CompileException(\"Failed to _compile: \" + pCtx.getErrorList().size() + \" compilation error(s)\", pCtx.getErrorList());\r\n-            }\r\n-            else if (pCtx.isFatalError()) {\r\n-                parserContext.remove();\r\n-                throw new CompileException(\"Failed to _compile: \" + pCtx.getErrorList().size() + \" compilation error(s)\", pCtx.getErrorList());\r\n-            }\r\n \r\n             return new CompiledExpression(new ASTArrayList(astLinkedList), getCurrentSourceFileName());\r\n         }\r\n@@ -211,6 +193,21 @@ public class ExpressionCompiler extends AbstractParser {\n         if (tk.isDiscard() || (tk.fields & (ASTNode.OPERATOR | ASTNode.LITERAL)) != 0) return tk;\r\n \r\n         if (verifying) {\r\n+//            if (pCtx.isStrictTypeEnforcement() && tk instanceof Assignment) {\r\n+//\r\n+//            }\r\n+\r\n+\r\n+//            if (pCtx.isStrictTypeEnforcement() && tk instanceof Assignment\r\n+//                    && (pCtx.getInputs() == null\r\n+//                    || !pCtx.getInputs().containsKey(((Assignment) tk).getAssignmentVar()))) {\r\n+//\r\n+//                System.out.println(tk.getEgressType());\r\n+//\r\n+//                addFatalError(\"untyped var not permitted in strict-mode: \" + ((Assignment) tk).getAssignmentVar());\r\n+//                return tk;\r\n+//            }\r\n+\r\n             if (tk.isAssignment()) {\r\n                 char[] assign = tk.getNameAsArray();\r\n                 int c = 0;\r\n@@ -232,7 +229,6 @@ public class ExpressionCompiler extends AbstractParser {\n             else if (tk.isIdentifier()) {\r\n                 PropertyVerifier propVerifier = new PropertyVerifier(tk.getNameAsArray(), getParserContext());\r\n                 pCtx.addInput(tk.getAbsoluteName(), returnType = propVerifier.analyze());\r\n-\r\n             }\r\n         }\r\n         return tk;\r\n@@ -386,15 +382,6 @@ public class ExpressionCompiler extends AbstractParser {\n         return (Integer) o;\r\n     }\r\n \r\n-\r\n-//    public Set<String> getInputs() {\r\n-//        return inputs;\r\n-//    }\r\n-//\r\n-//    public Set<String> getLocals() {\r\n-//        return locals;\r\n-//    }\r\n-\r\n     public ExpressionCompiler(String expression) {\r\n         setExpression(expression);\r\n     }\r\ndiff --git a/src/main/java/org/mvel/MVEL.java b/src/main/java/org/mvel/MVEL.java\nindex bb845c3..105c75d 100644\n--- a/src/main/java/org/mvel/MVEL.java\n+++ b/src/main/java/org/mvel/MVEL.java\n@@ -126,10 +126,8 @@ public class MVEL {\n          */\n         if (OPTIMIZER && tokens.size() == 1) {\n             ASTNode tk = tokens.firstNode();\n-            if (tk.isIdentifier()) {\n-                return new ExecutableAccessor(tk, false);\n-            }\n-            else if (tk.isLiteral() && !tk.isThisVal()) {\n+\n+            if (tk.isLiteral() && !tk.isThisVal()) {\n                 if ((tk.fields & ASTNode.INTEGER32) != 0) {\n                     return new ExecutableLiteral(tk.getIntRegister());\n                 }\n@@ -137,6 +135,9 @@ public class MVEL {\n                     return new ExecutableLiteral(tk.getLiteralValue());\n                 }\n             }\n+            if (tk.isIdentifier()) {\n+                return new ExecutableAccessor(tk, false);\n+            }\n         }\n \n \n@@ -187,10 +188,8 @@ public class MVEL {\n          */\n         if (OPTIMIZER && tokens.size() == 1) {\n             ASTNode tk = tokens.firstNode();\n-            if (tk.isIdentifier()) {\n-                return new ExecutableAccessor(tk, false);\n-            }\n-            else if (tk.isLiteral() && !tk.isThisVal()) {\n+\n+            if (tk.isLiteral() && !tk.isThisVal()) {\n                 if ((tk.fields & ASTNode.INTEGER32) != 0) {\n                     return new ExecutableLiteral(tk.getIntRegister());\n                 }\n@@ -198,6 +197,9 @@ public class MVEL {\n                     return new ExecutableLiteral(tk.getLiteralValue());\n                 }\n             }\n+            if (tk.isIdentifier()) {\n+                return new ExecutableAccessor(tk, false);\n+            }\n         }\n \n         return cExpr;\ndiff --git a/src/main/java/org/mvel/ParserContext.java b/src/main/java/org/mvel/ParserContext.java\nindex cdb0c53..0fb8e8d 100644\n--- a/src/main/java/org/mvel/ParserContext.java\n+++ b/src/main/java/org/mvel/ParserContext.java\n@@ -13,7 +13,9 @@ import java.util.HashMap;\n  */\n public class ParserContext {\n     private String sourceFile;\n+\n     private int lineCount;\n+    private int lineOffset;\n \n     protected Map<String, Class> imports;\n     protected Map<String, Interceptor> interceptors;\n@@ -67,6 +69,14 @@ public class ParserContext {\n         this.lineCount = lineCount;\n     }\n \n+    public int getLineOffset() {\n+        return lineOffset;\n+    }\n+\n+    public void setLineOffset(int lineOffset) {\n+        this.lineOffset = lineOffset;\n+    }\n+\n     public Class getImport(String name) {\n         return imports != null ? imports.get(name) : null;\n     }\ndiff --git a/src/main/java/org/mvel/PropertyVerifier.java b/src/main/java/org/mvel/PropertyVerifier.java\nindex a04419d..4fa0304 100644\n--- a/src/main/java/org/mvel/PropertyVerifier.java\n+++ b/src/main/java/org/mvel/PropertyVerifier.java\n@@ -98,9 +98,9 @@ public class PropertyVerifier extends AbstractOptimizer {\n                 return (Class) AbstractParser.LITERALS.get(property);\n             }\n             else {\n-                if (parserContext.isStrictTypeEnforcement()) {\n-                    addFatalError(\"unqualified type in strict mode for: \" + property);\n-                }\n+//                if (cursor < length && parserContext.isStrictTypeEnforcement()) {\n+//                    addFatalError(\"unqualified type in strict mode for: \" + property);\n+//                }\n                 return Object.class;\n             }\n         }\n@@ -199,14 +199,6 @@ public class PropertyVerifier extends AbstractOptimizer {\n \n \n     private Class getMethod(Class ctx, String name) {\n-//        if (first && variableFactory.isResolveable(name)) {\n-//            Method m = (Method) variableFactory.getVariableResolver(name).getValue();\n-//            ctx = m.getDeclaringClass();\n-//            name = m.getName();\n-//            first = false;\n-//        }\n-\n-\n         int st = cursor;\n \n         int depth = 1;\ndiff --git a/src/main/java/org/mvel/util/ParseTools.java b/src/main/java/org/mvel/util/ParseTools.java\nindex a7ef02a..c2cff3a 100644\n--- a/src/main/java/org/mvel/util/ParseTools.java\n+++ b/src/main/java/org/mvel/util/ParseTools.java\n@@ -890,10 +890,8 @@ public class ParseTools {\n          */\n         if (MVEL.isOptimizationEnabled() && tokens.size() == 1) {\n             ASTNode tk = tokens.firstNode();\n-            if (tk.isIdentifier()) {\n-                return new ExecutableAccessor(tk, false);\n-            }\n-            else if (tk.isLiteral() && !tk.isThisVal()) {\n+\n+            if (tk.isLiteral() && !tk.isThisVal()) {\n                 if ((tk.getFields() & ASTNode.INTEGER32) != 0) {\n                     return new ExecutableLiteral(tk.getIntRegister());\n                 }\n@@ -901,6 +899,9 @@ public class ParseTools {\n                     return new ExecutableLiteral(tk.getLiteralValue());\n                 }\n             }\n+            if (tk.isIdentifier()) {\n+                return new ExecutableAccessor(tk, false);\n+            }\n         }\n \n \n@@ -908,7 +909,6 @@ public class ParseTools {\n     }\n \n \n-\n     public static Serializable subCompileExpression(char[] expression) {\n         ExpressionCompiler parser = new ExpressionCompiler(expression);\n //        parser.setImportedClasses(imports);\n@@ -924,10 +924,7 @@ public class ParseTools {\n          */\n         if (MVEL.isOptimizationEnabled() && tokens.size() == 1) {\n             ASTNode tk = tokens.firstNode();\n-            if (tk.isIdentifier()) {\n-                return new ExecutableAccessor(tk, false);\n-            }\n-            else if (tk.isLiteral() && !tk.isThisVal()) {\n+            if (tk.isLiteral() && !tk.isThisVal()) {\n                 if ((tk.getFields() & ASTNode.INTEGER32) != 0) {\n                     return new ExecutableLiteral(tk.getIntRegister());\n                 }\n@@ -935,6 +932,11 @@ public class ParseTools {\n                     return new ExecutableLiteral(tk.getLiteralValue());\n                 }\n             }\n+\n+            if (tk.isIdentifier()) {\n+                return new ExecutableAccessor(tk, false);\n+            }\n+\n         }\n \n \n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\nindex cf67e34..0a5a52a 100644\n--- a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n@@ -969,7 +969,7 @@ public class CoreConfidenceTests extends TestCase {\n     }\n \n     public void testStrictTypingCompilation() {\n-        ExpressionCompiler compiler = new ExpressionCompiler(\"a = 0; a + 5\");\n+        ExpressionCompiler compiler = new ExpressionCompiler(\"a.foo; b.foo; x = 5\");\n         ParserContext ctx = new ParserContext();\n         ctx.setStrictTypeEnforcement(true);\n \n@@ -977,7 +977,7 @@ public class CoreConfidenceTests extends TestCase {\n             compiler.compile(ctx);\n         }\n         catch (CompileException e) {\n-            assertEquals(1, e.getErrors().size());\n+            assertEquals(2, e.getErrors().size());\n             return;\n         }\n         assertTrue(false);\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T19:20:05.701059Z", "commit_hash": "7b8bfbf5430a73ef0ebb4afb27b6223f0f7f69ba", "commit_message": "BUGFIX: Problem with method declaration targets.  No type-widening was being performed.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/PropertyAccessor.java b/src/main/java/org/mvel/PropertyAccessor.java\nindex a11f797..0bcc669 100644\n--- a/src/main/java/org/mvel/PropertyAccessor.java\n+++ b/src/main/java/org/mvel/PropertyAccessor.java\n@@ -23,7 +23,6 @@ import static org.mvel.DataConversion.convert;\n import org.mvel.integration.VariableResolverFactory;\r\n import org.mvel.util.ArrayTools;\r\n import org.mvel.util.ParseTools;\r\n-import static org.mvel.util.ParseTools.getBestCanadidate;\r\n import static org.mvel.util.ParseTools.parseParameterList;\r\n import static org.mvel.util.PropertyTools.getFieldOrAccessor;\r\n import static org.mvel.util.PropertyTools.getFieldOrWriteAccessor;\r\n@@ -616,7 +615,7 @@ public class PropertyAccessor {\n              * Try to find an instance method from the class target.\r\n              */\r\n \r\n-            if ((m = getBestCanadidate(args, name, cls.getMethods())) != null) {\r\n+            if ((m = ParseTools.getBestCandidate(args, name, cls.getMethods())) != null) {\r\n                 addMethodCache(cls, createSignature(name, tk), m);\r\n                 parameterTypes = m.getParameterTypes();\r\n             }\r\n@@ -625,7 +624,7 @@ public class PropertyAccessor {\n                 /**\r\n                  * If we didn't find anything, maybe we're looking for the actual java.lang.Class methods.\r\n                  */\r\n-                if ((m = getBestCanadidate(args, name, cls.getClass().getDeclaredMethods())) != null) {\r\n+                if ((m = ParseTools.getBestCandidate(args, name, cls.getClass().getDeclaredMethods())) != null) {\r\n                     addMethodCache(cls, createSignature(name, tk), m);\r\n                     parameterTypes = m.getParameterTypes();\r\n                 }\r\ndiff --git a/src/main/java/org/mvel/optimizers/impl/asm/ASMAccessorOptimizer.java b/src/main/java/org/mvel/optimizers/impl/asm/ASMAccessorOptimizer.java\nindex 0c672ff..a00d28f 100644\n--- a/src/main/java/org/mvel/optimizers/impl/asm/ASMAccessorOptimizer.java\n+++ b/src/main/java/org/mvel/optimizers/impl/asm/ASMAccessorOptimizer.java\n@@ -86,7 +86,7 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n     private ClassWriter cw;\r\n     private MethodVisitor mv;\r\n \r\n-    private Object val;                                                                 \r\n+    private Object val;\r\n     private int stacksize = 1;\r\n     private long time;\r\n \r\n@@ -721,7 +721,7 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n          * Try to find an instance method from the class target.\r\n          */\r\n \r\n-        if ((m = getBestCanadidate(args, name, cls.getMethods())) != null) {\r\n+        if ((m = getBestCandidate(args, name, cls.getMethods())) != null) {\r\n             parameterTypes = m.getParameterTypes();\r\n         }\r\n \r\n@@ -729,7 +729,7 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n             /**\r\n              * If we didn't find anything, maybe we're looking for the actual java.lang.Class methods.\r\n              */\r\n-            if ((m = getBestCanadidate(args, name, cls.getClass().getDeclaredMethods())) != null) {\r\n+            if ((m = getBestCandidate(args, name, cls.getClass().getDeclaredMethods())) != null) {\r\n                 parameterTypes = m.getParameterTypes();\r\n             }\r\n         }\r\n@@ -758,6 +758,8 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n             throw new PropertyAccessException(\"unable to resolve method: \" + cls.getName() + \".\" + name + \"(\" + errorBuild.toString() + \") [arglength=\" + args.length + \"]\");\r\n         }\r\n         else {\r\n+            m = ParseTools.getWidenedTarget(m);\r\n+\r\n             if (es != null) {\r\n                 ExecutableStatement cExpr;\r\n                 for (int i = 0; i < es.length; i++) {\r\n@@ -793,9 +795,17 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n                     debug(\"CHECKCAST \" + getInternalName(m.getDeclaringClass()));\r\n                     mv.visitTypeInsn(CHECKCAST, getInternalName(m.getDeclaringClass()));\r\n \r\n-                    debug(\"INVOKEVIRTUAL \" + m.getName());\r\n-                    mv.visitMethodInsn(INVOKEVIRTUAL, getInternalName(m.getDeclaringClass()), m.getName(),\r\n-                            getMethodDescriptor(m));\r\n+                    if (m.getDeclaringClass().isInterface()) {\r\n+                        debug(\"INVOKEINTERFACE \" + m.getName());\r\n+                        mv.visitMethodInsn(INVOKEINTERFACE, getInternalName(m.getDeclaringClass()), m.getName(),\r\n+                                getMethodDescriptor(m));\r\n+\r\n+                    }\r\n+                    else {\r\n+                        debug(\"INVOKEVIRTUAL \" + m.getName());\r\n+                        mv.visitMethodInsn(INVOKEVIRTUAL, getInternalName(m.getDeclaringClass()), m.getName(),\r\n+                                getMethodDescriptor(m));\r\n+                    }\r\n                 }\r\n \r\n                 returnType = m.getReturnType();\r\ndiff --git a/src/main/java/org/mvel/optimizers/impl/refl/GetterAccessor.java b/src/main/java/org/mvel/optimizers/impl/refl/GetterAccessor.java\nindex 7224a43..faebb89 100644\n--- a/src/main/java/org/mvel/optimizers/impl/refl/GetterAccessor.java\n+++ b/src/main/java/org/mvel/optimizers/impl/refl/GetterAccessor.java\n@@ -49,7 +49,9 @@ public class GetterAccessor implements AccessorNode {\n             return MVEL.getProperty(method.getName() + \"()\", ctx);\n         }\n         catch (Exception e) {\n-            throw new CompileException(\"cannot invoke getter\", e);\n+            throw new CompileException(\"cannot invoke getter: \" + method.getName()\n+                    + \" [declr.class: \" + method.getDeclaringClass().getName() + \"; act.class: \"\n+                    + (ctx != null ? ctx.getClass().getName() : \"null\") + \"]\", e);\n         }\n     }\n \ndiff --git a/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java b/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\nindex 1acf5e8..7013bb7 100644\n--- a/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\n+++ b/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\n@@ -444,7 +444,7 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n          * Try to find an instance method from the class target.\r\n          */\r\n \r\n-        if ((m = ParseTools.getBestCanadidate(args, name, cls.getMethods())) != null) {\r\n+        if ((m = ParseTools.getBestCandidate(args, name, cls.getMethods())) != null) {\r\n             parameterTypes = m.getParameterTypes();\r\n         }\r\n \r\n@@ -452,7 +452,7 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n             /**\r\n              * If we didn't find anything, maybe we're looking for the actual java.lang.Class methods.\r\n              */\r\n-            if ((m = ParseTools.getBestCanadidate(args, name, cls.getClass().getDeclaredMethods())) != null) {\r\n+            if ((m = ParseTools.getBestCandidate(args, name, cls.getClass().getDeclaredMethods())) != null) {\r\n                 parameterTypes = m.getParameterTypes();\r\n             }\r\n         }\r\n@@ -496,7 +496,7 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n \r\n \r\n             MethodAccessor access = new MethodAccessor();\r\n-            access.setMethod(m);\r\n+            access.setMethod(ParseTools.getWidenedTarget(m));\r\n             access.setParms(es);\r\n \r\n             addAccessorNode(access);\r\ndiff --git a/src/main/java/org/mvel/util/ParseTools.java b/src/main/java/org/mvel/util/ParseTools.java\nindex 24c6490..32c9f1b 100644\n--- a/src/main/java/org/mvel/util/ParseTools.java\n+++ b/src/main/java/org/mvel/util/ParseTools.java\n@@ -168,7 +168,16 @@ public class ParseTools {\n     private static Map<String, Map<Integer, Method>> RESOLVED_METH_CACHE = new WeakHashMap<String, Map<Integer, Method>>(10);\n \n \n-    public static Method getBestCanadidate(Object[] arguments, String method, Method[] methods) {\n+    public static Method getBestCandidate(Object[] arguments, String method, Method[] methods) {\n+        Class[] targetParms = new Class[arguments.length];\n+        for (int i = 0; i < arguments.length; i++) {\n+            targetParms[i] = arguments[i] != null ? arguments[i].getClass() : Object.class;\n+        }\n+        return getBestCandidate(targetParms, method, methods);\n+    }\n+\n+\n+    public static Method getBestCandidate(Class[] arguments, String method, Method[] methods) {\n         if (methods.length == 0) {\n             return null;\n         }\n@@ -177,13 +186,7 @@ public class ParseTools {\n         int bestScore = 0;\n         int score = 0;\n \n-        Class[] targetParms = new Class[arguments.length];\n-\n-        for (int i = 0; i < arguments.length; i++) {\n-            targetParms[i] = arguments[i] != null ? arguments[i].getClass() : Object.class;\n-        }\n-\n-        Integer hash = createClassSignatureHash(methods[0].getDeclaringClass(), targetParms);\n+        Integer hash = createClassSignatureHash(methods[0].getDeclaringClass(), arguments);\n \n         if (RESOLVED_METH_CACHE.containsKey(method) && RESOLVED_METH_CACHE.get(method).containsKey(hash)) {\n             return RESOLVED_METH_CACHE.get(method).get(hash);\n@@ -193,26 +196,28 @@ public class ParseTools {\n             if (method.equals(meth.getName())) {\n                 if ((parmTypes = meth.getParameterTypes()).length != arguments.length)\n                     continue;\n-                else if (arguments.length == 0 && parmTypes.length == 0)\n-                    return meth;\n+                else if (arguments.length == 0 && parmTypes.length == 0) {\n+                    bestCandidate = meth;\n+                    break;\n+                }\n \n                 for (int i = 0; i < arguments.length; i++) {\n-                    if (parmTypes[i] == targetParms[i]) {\n+                    if (parmTypes[i] == arguments[i]) {\n                         score += 5;\n                     }\n-                    else if (parmTypes[i].isPrimitive() && boxPrimitive(parmTypes[i]) == targetParms[i]) {\n+                    else if (parmTypes[i].isPrimitive() && boxPrimitive(parmTypes[i]) == arguments[i]) {\n                         score += 4;\n                     }\n-                    else if (targetParms[i].isPrimitive() && unboxPrimitive(targetParms[i]) == parmTypes[i]) {\n+                    else if (arguments[i].isPrimitive() && unboxPrimitive(arguments[i]) == parmTypes[i]) {\n                         score += 4;\n                     }\n-                    else if (isNumericallyCoercible(targetParms[i], parmTypes[i])) {\n+                    else if (isNumericallyCoercible(arguments[i], parmTypes[i])) {\n                         score += 3;\n                     }\n-                    else if (parmTypes[i].isAssignableFrom(targetParms[i])) {\n+                    else if (parmTypes[i].isAssignableFrom(arguments[i])) {\n                         score += 2;\n                     }\n-                    else if (canConvert(parmTypes[i], targetParms[i])) {\n+                    else if (canConvert(parmTypes[i], arguments[i])) {\n                         score += 1;\n                     }\n                     else {\n@@ -239,6 +244,25 @@ public class ParseTools {\n         return bestCandidate;\n     }\n \n+    public static Method getWidenedTarget(Method method) {\n+        Class cls = method.getDeclaringClass();\n+        Method m = method;\n+        Class[] args = method.getParameterTypes();\n+        String name = method.getName();\n+\n+        do {\n+            for (Class iface : cls.getInterfaces()) {\n+                m = getBestCandidate(args, name, iface.getMethods());\n+                if (m != null && m.getDeclaringClass().getSuperclass() != null) {\n+                    cls = m.getDeclaringClass();\n+                }\n+            }\n+        }\n+        while ((cls = cls.getSuperclass()) != null);\n+\n+        return m != null ? m : method;\n+    }\n+\n     private static Map<Class, Map<Integer, Constructor>> RESOLVED_CONST_CACHE = new WeakHashMap<Class, Map<Integer, Constructor>>(10);\n \n     private static Map<Constructor, Class[]> CONSTRUCTOR_PARMS_CACHE = new WeakHashMap<Constructor, Class[]>(10);\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\nindex 2d58848..41d3f0e 100644\n--- a/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n+++ b/src/test/java/org/mvel/tests/main/CoreConfidenceTests.java\n@@ -714,6 +714,19 @@ public class CoreConfidenceTests extends TestCase {\n         assertEquals(1000, parseDirect(\"10 * 100\"));\n     }\n \n+    public void testInterfaceResolution() {        \n+        Serializable ex = MVEL.compileExpression(\"foo.collectionTest.size()\");\n+\n+        foo.setCollectionTest(new HashSet());\n+        Object result1 = MVEL.executeExpression(ex, map);\n+\n+        foo.setCollectionTest(new ArrayList());\n+        Object result2 = MVEL.executeExpression(ex, map);\n+\n+        assertEquals(result1, result2);\n+    }\n+\n+\n     /**\n      * Start collections framework based compliance tests\n      */\ndiff --git a/src/test/java/org/mvel/tests/main/res/Foo.java b/src/test/java/org/mvel/tests/main/res/Foo.java\nindex bf6abb2..6dc6e7f 100644\n--- a/src/test/java/org/mvel/tests/main/res/Foo.java\n+++ b/src/test/java/org/mvel/tests/main/res/Foo.java\n@@ -1,5 +1,7 @@\n package org.mvel.tests.main.res;\n \n+import java.util.Collection;\n+\n public class Foo {\n     private Bar bar = new Bar();\n     public String register;\n@@ -7,6 +9,8 @@ public class Foo {\n     public String aValue = \"\";\n     public String bValue = \"\";\n \n+    private Collection collectionTest;\n+\n     public void abc() {\n     }\n \n@@ -30,4 +34,13 @@ public class Foo {\n     public int getNumber() {\n         return 4;\n     }\n+\n+\n+    public Collection getCollectionTest() {\n+        return collectionTest;\n+    }\n+\n+    public void setCollectionTest(Collection collectionTest) {\n+        this.collectionTest = collectionTest;\n+    }\n }\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T19:22:21.915187Z", "commit_hash": "be548b8d3c39e01642a869366d3b75dedcca87af", "commit_message": "unit test added, minor fix for debugging (line count maintained)\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/AbstractParser.java b/src/main/java/org/mvel/AbstractParser.java\nindex f10043a..167632d 100644\n--- a/src/main/java/org/mvel/AbstractParser.java\n+++ b/src/main/java/org/mvel/AbstractParser.java\n@@ -561,11 +561,22 @@ public class AbstractParser {\n                             int len = length - 1;\r\n                             while (true) {\r\n                                 cursor++;\r\n+\r\n+                                /**\r\n+                                 * Since multi-line comments may cross lines, we must keep track of any line-break\r\n+                                 * we encounter.\r\n+                                 */\r\n+                                if (debugSymbols && expr[cursor] == '\\n') {\r\n+                                    line++;\r\n+                                }\r\n+\r\n                                 if (cursor == len) {\r\n                                     throw new CompileException(\"unterminated block comment\", expr, cursor);\r\n                                 }\r\n-                                if (isAt('*', 1) && isAt('/', 2)) {\r\n-                                    if ((start = ++cursor) >= length) return null;\r\n+                                if (expr[cursor] == '*' && isAt('/', 1)) {\r\n+                                    if ((cursor += 2) >= length) return null;\r\n+                                    skipWhitespace();\r\n+                                    start = cursor;\r\n                                     break;\r\n                                 }\r\n                             }\r\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CompiledUnitTest.java b/src/test/java/org/mvel/tests/main/CompiledUnitTest.java\nindex 21d65b3..c80d5f2 100644\n--- a/src/test/java/org/mvel/tests/main/CompiledUnitTest.java\n+++ b/src/test/java/org/mvel/tests/main/CompiledUnitTest.java\n@@ -901,6 +901,12 @@ public class CompiledUnitTest extends TestCase {\n         assertEquals(20, parseDirect(\"10 + 10; // This is a comment\"));\n     }\n \n+    public void testComments3() {\n+        assertEquals(30, parseDirect(\"/* This is a test of\\n\" +\n+                \"MVEL's support for\\n\" +\n+                \"multi-line comments\\n\" +\n+                \"*/\\n 15 + 15\"));\n+    }\n \n     public Object parseDirect(String ex) {\n         return compiledExecute(ex);\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T19:23:09.381480Z", "commit_hash": "631000b8cd8e2aebe442a4b69b7128540222507f", "commit_message": "macro processor fixed.  single-line comments and multi-line comment support added to the MVEL core parser.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/AbstractParser.java b/src/main/java/org/mvel/AbstractParser.java\nindex 25e9d6d..f10043a 100644\n--- a/src/main/java/org/mvel/AbstractParser.java\n+++ b/src/main/java/org/mvel/AbstractParser.java\n@@ -545,10 +545,36 @@ public class AbstractParser {\n                         return lastNode = new EndOfStatement();\r\n \r\n                     case'#':\r\n+                    case'/':\r\n+                        if (isAt(expr[cursor], 1)) {\r\n+                            /**\r\n+                             * Handle single line comments.\r\n+                             */\r\n+                            while (cursor < length && expr[cursor] != '\\n') cursor++;\r\n+                            if ((start = ++cursor) >= length) return null;\r\n+                            continue;\r\n+                        }\r\n+                        else if (expr[cursor] == '/' && isAt('*', 1)) {\r\n+                            /**\r\n+                             * Handle multi-line comments.\r\n+                             */\r\n+                            int len = length - 1;\r\n+                            while (true) {\r\n+                                cursor++;\r\n+                                if (cursor == len) {\r\n+                                    throw new CompileException(\"unterminated block comment\", expr, cursor);\r\n+                                }\r\n+                                if (isAt('*', 1) && isAt('/', 2)) {\r\n+                                    if ((start = ++cursor) >= length) return null;\r\n+                                    break;\r\n+                                }\r\n+                            }\r\n+                            continue;\r\n+                        }\r\n+\r\n                     case'?':\r\n                     case':':\r\n                     case'^':\r\n-                    case'/':\r\n                     case'%': {\r\n                         return createToken(expr, start, cursor++ + 1, fields);\r\n                     }\r\ndiff --git a/src/main/java/org/mvel/MVEL.java b/src/main/java/org/mvel/MVEL.java\nindex 035a55f..21b1db2 100644\n--- a/src/main/java/org/mvel/MVEL.java\n+++ b/src/main/java/org/mvel/MVEL.java\n@@ -128,12 +128,10 @@ public class MVEL {\n             ASTNode tk = tokens.firstToken();\n             if (tk.isIdentifier()) {\n                 return new ExecutableAccessor(tk, false);\n-            }\n-            else if (tk.isLiteral() && !tk.isThisVal()) {\n+            } else if (tk.isLiteral() && !tk.isThisVal()) {\n                 if ((tk.fields & ASTNode.INTEGER32) != 0) {\n                     return new ExecutableLiteral(tk.getIntRegister());\n-                }\n-                else {\n+                } else {\n                     return new ExecutableLiteral(tk.getLiteralValue());\n                 }\n             }\n@@ -183,12 +181,10 @@ public class MVEL {\n             ASTNode tk = tokens.firstToken();\n             if (tk.isIdentifier()) {\n                 return new ExecutableAccessor(tk, false);\n-            }\n-            else if (tk.isLiteral() && !tk.isThisVal()) {\n+            } else if (tk.isLiteral() && !tk.isThisVal()) {\n                 if ((tk.fields & ASTNode.INTEGER32) != 0) {\n                     return new ExecutableLiteral(tk.getIntRegister());\n-                }\n-                else {\n+                } else {\n                     return new ExecutableLiteral(tk.getLiteralValue());\n                 }\n             }\n@@ -550,7 +546,21 @@ public class MVEL {\n     }\n \n     public static String parseMacros(String input, Map<String, Macro> macros) {\n-        return new MacroProcessor(input).parse(macros);\n+        MacroProcessor macroProcessor = new MacroProcessor();\n+        macroProcessor.setMacros(macros);\n+        return macroProcessor.parse(input);\n+    }\n+\n+    public static String preprocess(char[] input, PreProcessor[] preprocessors) {\n+        char[] ex = input;\n+        for (PreProcessor proc : preprocessors) {\n+            ex = proc.parse(ex);\n+        }\n+        return new String(ex);\n+    }\n+\n+    public static String preprocess(String input, PreProcessor[] preprocessors) {\n+        return preprocess(input.toCharArray(), preprocessors);\n     }\n \n \ndiff --git a/src/main/java/org/mvel/MacroProcessor.java b/src/main/java/org/mvel/MacroProcessor.java\nindex 23f00ab..fef4434 100644\n--- a/src/main/java/org/mvel/MacroProcessor.java\n+++ b/src/main/java/org/mvel/MacroProcessor.java\n@@ -1,32 +1,38 @@\n package org.mvel;\r\n \r\n-import static java.lang.Character.isWhitespace;\r\n-\r\n import org.mvel.util.StringAppender;\r\n-import org.mvel.util.ParseTools;\r\n \r\n+import static java.lang.Character.isWhitespace;\r\n import java.util.Map;\r\n \r\n /**\r\n  * @author Christopher Brock\r\n  */\r\n-public class MacroProcessor extends AbstractParser {\r\n+public class MacroProcessor extends AbstractParser implements PreProcessor {\r\n+    private Map<String, Macro> macros;\r\n+\r\n+    public char[] parse(char[] input) {\r\n+        setExpression(input);\r\n \r\n-    public String parse(Map<String, Macro> macros) {\r\n         StringAppender appender = new StringAppender();\r\n \r\n         int start;\r\n         String token;\r\n \r\n         for (; cursor < length; cursor++) {\r\n-            skipWhitespace();\r\n-\r\n+            while (cursor < length && isWhitespace(expr[cursor])) {\r\n+                appender.append(expr[cursor++]);\r\n+            }\r\n+            \r\n             start = cursor;\r\n \r\n             while (cursor < length\r\n                     && (!isWhitespace(expr[cursor]) \r\n                     && expr[cursor] != '('\r\n-                    && expr[cursor] != ')')) cursor++;\r\n+                    && expr[cursor] != ')')) {\r\n+\r\n+                cursor++;\r\n+            }\r\n \r\n             if (macros.containsKey(token = new String(expr, start, cursor - start))) {\r\n                 appender.append(macros.get(token).doMacro());\r\n@@ -35,18 +41,24 @@ public class MacroProcessor extends AbstractParser {\n                 appender.append(token);\r\n             }\r\n \r\n-            if (cursor < length) appender.append(expr[cursor]);\r\n+            if (cursor < length) {\r\n+                appender.append(expr[cursor]);\r\n+            }\r\n         }\r\n \r\n-        return appender.toString();\r\n+        return appender.toChars();\r\n+    }\r\n+\r\n+    public String parse(String input) {\r\n+        return new String(parse(input.toCharArray()));\r\n     }\r\n \r\n-    public MacroProcessor(char[] expr) {\r\n-        setExpression(expr);\r\n+    public Map<String, Macro> getMacros() {\r\n+        return macros;\r\n     }\r\n \r\n-    public MacroProcessor(String expr) {\r\n-        setExpression(expr);\r\n+    public void setMacros(Map<String, Macro> macros) {\r\n+        this.macros = macros;\r\n     }\r\n \r\n     public void captureToWhitespace() {\r\ndiff --git a/src/main/java/org/mvel/PreProcessor.java b/src/main/java/org/mvel/PreProcessor.java\nnew file mode 100644\nindex 0000000..7d20c79\n--- /dev/null\n+++ b/src/main/java/org/mvel/PreProcessor.java\n@@ -0,0 +1,6 @@\n+package org.mvel;\n+\n+public interface PreProcessor {\n+    public char[] parse(char[] input);\n+    public String parse(String input);\n+}\ndiff --git a/src/main/java/org/mvel/optimizers/impl/asm/ASMAccessorOptimizer.java b/src/main/java/org/mvel/optimizers/impl/asm/ASMAccessorOptimizer.java\nindex 0858af2..0c672ff 100644\n--- a/src/main/java/org/mvel/optimizers/impl/asm/ASMAccessorOptimizer.java\n+++ b/src/main/java/org/mvel/optimizers/impl/asm/ASMAccessorOptimizer.java\n@@ -86,7 +86,7 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n     private ClassWriter cw;\r\n     private MethodVisitor mv;\r\n \r\n-    private Object val;\r\n+    private Object val;                                                                 \r\n     private int stacksize = 1;\r\n     private long time;\r\n \r\ndiff --git a/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java b/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\nindex 08dada4..1acf5e8 100644\n--- a/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\n+++ b/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\n@@ -714,5 +714,4 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n         return returnType;\r\n     }\r\n \r\n-\r\n }\r\ndiff --git a/src/main/java/org/mvel/util/StringAppender.java b/src/main/java/org/mvel/util/StringAppender.java\nindex 2e895ab..8156714 100644\n--- a/src/main/java/org/mvel/util/StringAppender.java\n+++ b/src/main/java/org/mvel/util/StringAppender.java\n@@ -81,11 +81,17 @@ public class StringAppender implements CharSequence {\n     \r\n     public char[] getChars(int start, int count) {\r\n         char[] chars = new char[count];\r\n-        \r\n         System.arraycopy( str, start, chars, 0, count );\r\n         return chars;\r\n     }\r\n \r\n+    public char[] toChars() {\r\n+        char[] chars = new char[size];\r\n+        System.arraycopy(str, 0, chars, 0, size);\r\n+        return chars;\r\n+    }\r\n+\r\n+\r\n     public String toString() {\r\n         if (size == capacity) return new String(str);\r\n         else return new String(str, 0, size);\r\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CompiledUnitTest.java b/src/test/java/org/mvel/tests/main/CompiledUnitTest.java\nindex 39fa6ba..21d65b3 100644\n--- a/src/test/java/org/mvel/tests/main/CompiledUnitTest.java\n+++ b/src/test/java/org/mvel/tests/main/CompiledUnitTest.java\n@@ -1,5 +1,6 @@\n package org.mvel.tests.main;\n \n+import static org.mvel.MVEL.parseMacros;\n import junit.framework.TestCase;\n import org.mvel.*;\n \n@@ -892,6 +893,14 @@ public class CompiledUnitTest extends TestCase {\n         assertEquals(\"FOOBAR!\", executeExpression(s, vars));\n     }\n \n+    public void testComments() {\n+        assertEquals(10, parseDirect(\"// This is a comment\\n5 + 5\"));\n+    }\n+\n+    public void testComments2() {\n+        assertEquals(20, parseDirect(\"10 + 10; // This is a comment\"));\n+    }\n+\n \n     public Object parseDirect(String ex) {\n         return compiledExecute(ex);\n@@ -924,6 +933,7 @@ public class CompiledUnitTest extends TestCase {\n     }\n \n \n+    @SuppressWarnings({\"unchecked\"})\n     public void testDifferentImplSameCompile() {\n         Serializable compiled = compileExpression(\"a.funMap.hello\");\n \n@@ -945,6 +955,7 @@ public class CompiledUnitTest extends TestCase {\n         }\n     }\n     \n+    @SuppressWarnings({\"unchecked\"})\n     public void testInterfaceMethodCallWithSpace() {\n         Serializable compiled = compileExpression(\"drools.retract (cheese)\");\n         Map map = new HashMap();\n@@ -957,6 +968,7 @@ public class CompiledUnitTest extends TestCase {\n         assertSame(cheese, helper.retracted.get( 0 ));\n     }\n     \n+    @SuppressWarnings({\"unchecked\"})\n     public void testInterfaceMethodCallWithMacro() {\n         Map macros = new HashMap(1);       \n         \n@@ -967,7 +979,7 @@ public class CompiledUnitTest extends TestCase {\n                         }\n                     } ); \n                 \n-        Serializable compiled = compileExpression(new MacroProcessor( \"retract(cheese)\" ).parse(macros));\n+        Serializable compiled = compileExpression(parseMacros(\"retract(cheese)\", macros));\n         Map map = new HashMap();\n         DefaultKnowledgeHelper helper = new DefaultKnowledgeHelper();\n         map.put( \"drools\",  helper);\n@@ -979,6 +991,7 @@ public class CompiledUnitTest extends TestCase {\n     }    \n \n \n+    @SuppressWarnings({\"UnnecessaryBoxing\"})\n     public void testToList() {\n         String text = \"misc.toList(foo.bar.name, 'hello', 42, ['key1' : 'value1', c : [ foo.bar.age, 'car', 42 ]], [42, [c : 'value1']] )\";\n         List list = (List) parseDirect(text);\n@@ -1008,6 +1021,7 @@ public class CompiledUnitTest extends TestCase {\n     public static class MiscTestClass {\n         int exec = 0;\n \n+        @SuppressWarnings({\"unchecked\", \"UnnecessaryBoxing\"})\n         public List toList(Object object1, String string, int integer, Map map, List list) {\n             exec++;\n             List l = new ArrayList();\n@@ -1025,6 +1039,7 @@ public class CompiledUnitTest extends TestCase {\n         }\n     }\n \n+    @SuppressWarnings({\"unchecked\"})\n     public void testCalculateAge() {\n         //    System.out.println(\"Calculating the Age\");\n         Calendar c1 = Calendar.getInstance();\ndiff --git a/src/test/java/org/mvel/tests/main/KnowledgeHelperFixerTest.java b/src/test/java/org/mvel/tests/main/KnowledgeHelperFixerTest.java\nindex fd525d3..89a615c 100644\n--- a/src/test/java/org/mvel/tests/main/KnowledgeHelperFixerTest.java\n+++ b/src/test/java/org/mvel/tests/main/KnowledgeHelperFixerTest.java\n@@ -37,9 +37,10 @@ public class KnowledgeHelperFixerTest extends TestCase {\n     }   \r\n     \r\n     public void testMultiLineComment() {\r\n-        String result = KnowledgeHelperFixerTest.fixer.fix( \"        /*System.out.println( \\\"help\\\" );\\r\\n*/        System.out.println( \\\"help\\\" );  \\r\\n     list.add( $person );\" );\r\n+        String result = KnowledgeHelperFixerTest.fixer.fix(\"        /*System.out.println( \\\"help\\\" );\\r\\n*/       System.out.println( \\\"help\\\" );  \\r\\n     list.add( $person );\" );\r\n         assertEquals( \"        /*System.out.println( \\\"help\\\" );\\r\\n*/       System.out.println( \\\"help\\\" );  \\r\\n     list.add( $person );\",\r\n                       result );\r\n+       \r\n     }     \r\n \r\n     public void testAdd__Handle__Simple() {\r\ndiff --git a/src/test/java/org/mvel/tests/main/res/KnowledgeHelperFixer.java b/src/test/java/org/mvel/tests/main/res/KnowledgeHelperFixer.java\nindex 43c9d62..6ba70b1 100644\n--- a/src/test/java/org/mvel/tests/main/res/KnowledgeHelperFixer.java\n+++ b/src/test/java/org/mvel/tests/main/res/KnowledgeHelperFixer.java\n@@ -16,13 +16,11 @@ package org.mvel.tests.main.res;\n  * limitations under the License.\r\n  */\r\n \r\n+import static org.mvel.MVEL.parseMacros;\r\n+import org.mvel.Macro;\r\n+\r\n import java.util.HashMap;\r\n import java.util.Map;\r\n-import java.util.regex.Matcher;\r\n-import java.util.regex.Pattern;\r\n-\r\n-import org.mvel.Macro;\r\n-import org.mvel.MacroProcessor;\r\n \r\n public class KnowledgeHelperFixer {\r\n \r\n@@ -74,7 +72,8 @@ public class KnowledgeHelperFixer {\n                             return \"drools.retract\";\r\n                         }\r\n                     } );           \r\n-        return new MacroProcessor( raw ).parse(macros);\r\n-    }\r\n \r\n+\r\n+        return parseMacros(raw, macros);\r\n+    }\r\n }\n\\ No newline at end of file\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T19:23:57.396657Z", "commit_hash": "1e3ff0540889ad1989f43dafe7066edd1d29f434", "commit_message": "one bug fixed.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/AbstractParser.java b/src/main/java/org/mvel/AbstractParser.java\nindex da2e65d..25e9d6d 100644\n--- a/src/main/java/org/mvel/AbstractParser.java\n+++ b/src/main/java/org/mvel/AbstractParser.java\n@@ -55,7 +55,35 @@ public class AbstractParser {\n \r\n     protected ExecutionStack splitAccumulator = new ExecutionStack();\r\n \r\n-    protected static ThreadLocal<Integer> linecounter;\r\n+    protected static ThreadLocal<ParserContext> parserContext;\r\n+\r\n+    protected String sourceFile;\r\n+\r\n+    static class ParserContext {\r\n+        private String sourceFile;\r\n+        private int lineCount;\r\n+\r\n+        public ParserContext(String sourceFile, int lineCount) {\r\n+            this.sourceFile = sourceFile;\r\n+            this.lineCount = lineCount;\r\n+        }\r\n+\r\n+        public String getSourceFile() {\r\n+            return sourceFile;\r\n+        }\r\n+\r\n+        public void setSourceFile(String sourceFile) {\r\n+            this.sourceFile = sourceFile;\r\n+        }\r\n+\r\n+        public int getLineCount() {\r\n+            return lineCount;\r\n+        }\r\n+\r\n+        public void setLineCount(int lineCount) {\r\n+            this.lineCount = lineCount;\r\n+        }\r\n+    }\r\n \r\n \r\n     static {\r\n@@ -236,18 +264,18 @@ public class AbstractParser {\n         boolean capture = false;\r\n         boolean union = false;\r\n \r\n-        if (!debugSymbols && linecounter != null && linecounter.get() != null) {\r\n+        if (!debugSymbols && parserContext != null && parserContext.get() != null) {\r\n             debugSymbols = true;\r\n             if (expr[cursor] != '\\n') lastWasLineLabel = true;\r\n         }\r\n \r\n         if (debugSymbols && !lastWasLineLabel && (expr[cursor] == '\\n' || cursor == 0)) {\r\n-            if (linecounter == null) {\r\n-                linecounter = new ThreadLocal<Integer>();\r\n-                linecounter.set(0);\r\n+            if (parserContext == null) {\r\n+                parserContext = new ThreadLocal<ParserContext>();\r\n+                parserContext.set(new ParserContext(sourceFile, 0));\r\n             }\r\n             else {\r\n-                line = linecounter.get();\r\n+                line = parserContext.get().getLineCount();\r\n             }\r\n \r\n             lastWasLineLabel = true;\r\n@@ -259,7 +287,7 @@ public class AbstractParser {\n                 line++;\r\n             }\r\n \r\n-            linecounter.set(line);\r\n+            parserContext.get().setLineCount(line);\r\n \r\n             return new LineLabel(line);\r\n         }\r\n@@ -928,8 +956,6 @@ public class AbstractParser {\n             switch (expr[cursor]) {\r\n                 case'(':\r\n                     return;\r\n-//                case'{':\r\n-//                    return;\r\n                 default:\r\n                     if (isWhitespace(expr[cursor])) return;\r\n                     cursor++;\r\n@@ -1029,6 +1055,15 @@ public class AbstractParser {\n         this.interceptors = interceptors;\r\n     }\r\n \r\n+\r\n+    public String getSourceFile() {\r\n+        return sourceFile;\r\n+    }\r\n+\r\n+    public void setSourceFile(String sourceFile) {\r\n+        this.sourceFile = sourceFile;\r\n+    }\r\n+\r\n     public boolean isDebugSymbols() {\r\n         return debugSymbols;\r\n     }\r\ndiff --git a/src/main/java/org/mvel/MVELRuntime.java b/src/main/java/org/mvel/MVELRuntime.java\nindex ca1d760..f3bdf6f 100644\n--- a/src/main/java/org/mvel/MVELRuntime.java\n+++ b/src/main/java/org/mvel/MVELRuntime.java\n@@ -29,7 +29,7 @@ public class MVELRuntime {\n      * @return -\r\n      */\r\n     public static Object execute(boolean debugger, FastASTIterator tokens, Object ctx, VariableResolverFactory variableFactory) {\r\n-        int i1, i2, i3, i4;  // 4 int registers\r\n+     //   int i1, i2, i3, i4;  // 4 int registers\r\n \r\n         Stack stk = new ExecutionStack();\r\n         Object v1, v2;\r\ndiff --git a/src/main/java/org/mvel/PropertyAccessor.java b/src/main/java/org/mvel/PropertyAccessor.java\nindex 00ef213..5d6acd9 100644\n--- a/src/main/java/org/mvel/PropertyAccessor.java\n+++ b/src/main/java/org/mvel/PropertyAccessor.java\n@@ -71,8 +71,7 @@ public class PropertyAccessor {\n             READ_PROPERTY_RESOLVER_CACHE = synchronizedMap(new WeakHashMap<Class, Map<Integer, Member>>(10));\r\n             WRITE_PROPERTY_RESOLVER_CACHE = synchronizedMap(new WeakHashMap<Class, Map<Integer, Member>>(10));\r\n             METHOD_RESOLVER_CACHE = synchronizedMap(new WeakHashMap<Class, Map<Integer, Object[]>>(10));\r\n-        }\r\n-        else {\r\n+        } else {\r\n             READ_PROPERTY_RESOLVER_CACHE = (new WeakHashMap<Class, Map<Integer, Member>>(10));\r\n             WRITE_PROPERTY_RESOLVER_CACHE = (new WeakHashMap<Class, Map<Integer, Member>>(10));\r\n             METHOD_RESOLVER_CACHE = (new WeakHashMap<Class, Map<Integer, Object[]>>(10));\r\n@@ -220,11 +219,9 @@ public class PropertyAccessor {\n                     }\r\n \r\n                     fld.set(curr, convert(value, fld.getType()));\r\n-                }\r\n-                else\r\n+                } else\r\n                     fld.set(curr, value);\r\n-            }\r\n-            else if (member != null) {\r\n+            } else if (member != null) {\r\n                 Method meth = (Method) member;\r\n \r\n                 if (value != null && !meth.getParameterTypes()[0].isAssignableFrom(value.getClass())) {\r\n@@ -234,12 +231,10 @@ public class PropertyAccessor {\n                     }\r\n \r\n                     meth.invoke(curr, convert(value, meth.getParameterTypes()[0]));\r\n-                }\r\n-                else {\r\n+                } else {\r\n                     meth.invoke(curr, value);\r\n                 }\r\n-            }\r\n-            else {\r\n+            } else {\r\n                 throw new PropertyAccessException(\"could not access property (\" + property + \") in: \" + ctx.getClass().getName());\r\n             }\r\n         }\r\n@@ -271,6 +266,7 @@ public class PropertyAccessor {\n \r\n \r\n         if (cursor < length) {\r\n+            while (isWhitespace(property[cursor])) cursor++;\r\n             switch (property[cursor]) {\r\n                 case'[':\r\n                     return COL;\r\n@@ -284,7 +280,12 @@ public class PropertyAccessor {\n     }\r\n \r\n     private String capture() {\r\n-        return new String(property, start, cursor - start);\r\n+        return new String(property, start, trimLeft(cursor) - start);\r\n+    }\r\n+\r\n+    protected int trimLeft(int pos) {\r\n+        while (pos > 0 && isWhitespace(property[pos - 1])) pos--;\r\n+        return pos;\r\n     }\r\n \r\n \r\n@@ -371,8 +372,7 @@ public class PropertyAccessor {\n \r\n         if (member instanceof Field) {\r\n             return ((Field) member).get(ctx);\r\n-        }\r\n-        else if (member != null) {\r\n+        } else if (member != null) {\r\n             try {\r\n                 return ((Method) member).invoke(ctx, EMPTYARG);\r\n             }\r\n@@ -388,14 +388,11 @@ public class PropertyAccessor {\n                 }\r\n             }\r\n \r\n-        }\r\n-        else if (ctx instanceof Map && ((Map) ctx).containsKey(property)) {\r\n+        } else if (ctx instanceof Map && ((Map) ctx).containsKey(property)) {\r\n             return ((Map) ctx).get(property);\r\n-        }\r\n-        else if (\"this\".equals(property)) {\r\n+        } else if (\"this\".equals(property)) {\r\n             return this.thisReference;\r\n-        }\r\n-        else if (ctx instanceof Class) {\r\n+        } else if (ctx instanceof Class) {\r\n             Class c = (Class) ctx;\r\n             for (Method m : c.getMethods()) {\r\n                 if (property.equals(m.getName())) {\r\n@@ -481,11 +478,9 @@ public class PropertyAccessor {\n \r\n         if (ctx instanceof Map) {\r\n             return ((Map) ctx).get(item);\r\n-        }\r\n-        else if (ctx instanceof List) {\r\n+        } else if (ctx instanceof List) {\r\n             return ((List) ctx).get((Integer) item);\r\n-        }\r\n-        else if (ctx instanceof Collection) {\r\n+        } else if (ctx instanceof Collection) {\r\n             int count = (Integer) item;\r\n             if (count > ((Collection) ctx).size())\r\n                 throw new PropertyAccessException(\"index [\" + count + \"] out of bounds on collections\");\r\n@@ -493,14 +488,11 @@ public class PropertyAccessor {\n             Iterator iter = ((Collection) ctx).iterator();\r\n             for (int i = 0; i < count; i++) iter.next();\r\n             return iter.next();\r\n-        }\r\n-        else if (ctx instanceof Object[]) {\r\n+        } else if (ctx instanceof Object[]) {\r\n             return ((Object[]) ctx)[(Integer) item];\r\n-        }\r\n-        else if (ctx instanceof CharSequence) {\r\n+        } else if (ctx instanceof CharSequence) {\r\n             return ((CharSequence) ctx).charAt((Integer) item);\r\n-        }\r\n-        else {\r\n+        } else {\r\n             throw new PropertyAccessException(\"illegal use of []: unknown type: \" + (ctx == null ? null : ctx.getClass().getName()));\r\n         }\r\n     }\r\n@@ -543,8 +535,7 @@ public class PropertyAccessor {\n         if (tk.length() == 0) {\r\n             args = ParseTools.EMPTY_OBJ_ARR;\r\n             es = null;\r\n-        }\r\n-        else {\r\n+        } else {\r\n             if (SUBEXPRESSION_CACHE.containsKey(tk)) {\r\n                 es = SUBEXPRESSION_CACHE.get(tk);\r\n                 args = new Object[es.length];\r\n@@ -552,8 +543,7 @@ public class PropertyAccessor {\n                     args[i] = MVEL.executeExpression(es[i], thisReference, resolver);\r\n                 }\r\n \r\n-            }\r\n-            else {\r\n+            } else {\r\n                 String[] subtokens = parseParameterList(tk.toCharArray(), 0, -1);\r\n \r\n                 es = new Serializable[subtokens.length];\r\n@@ -590,8 +580,7 @@ public class PropertyAccessor {\n         if (cache != null) {\r\n             m = (Method) cache[0];\r\n             parameterTypes = (Class[]) cache[1];\r\n-        }\r\n-        else {\r\n+        } else {\r\n             m = null;\r\n             parameterTypes = null;\r\n         }\r\n@@ -632,8 +621,7 @@ public class PropertyAccessor {\n             }\r\n \r\n             throw new PropertyAccessException(\"unable to resolve method: \" + cls.getName() + \".\" + name + \"(\" + errorBuild.toString() + \") [arglength=\" + args.length + \"]\");\r\n-        }\r\n-        else {\r\n+        } else {\r\n             if (es != null) {\r\n                 ExecutableStatement cExpr;\r\n                 for (int i = 0; i < es.length; i++) {\r\n@@ -646,8 +634,7 @@ public class PropertyAccessor {\n                         args[i] = convert(args[i], parameterTypes[i]);\r\n                     }\r\n                 }\r\n-            }\r\n-            else {\r\n+            } else {\r\n                 /**\r\n                  * Coerce any types if required.\r\n                  */\r\ndiff --git a/src/main/java/org/mvel/ast/LineLabel.java b/src/main/java/org/mvel/ast/LineLabel.java\nindex 001466f..b759283 100644\n--- a/src/main/java/org/mvel/ast/LineLabel.java\n+++ b/src/main/java/org/mvel/ast/LineLabel.java\n@@ -7,6 +7,7 @@ import org.mvel.integration.VariableResolverFactory;\n  * @author Christopher Brock\r\n  */\r\n public class LineLabel extends ASTNode {\r\n+    private String sourceFile;\r\n     private int lineNumber;\r\n \r\n     public LineLabel(int lineNumber) {\r\n@@ -15,6 +16,20 @@ public class LineLabel extends ASTNode {\n         this.fields = -1;\r\n     }\r\n \r\n+   public LineLabel(String sourceFile, int lineNumber) {\r\n+       super();\r\n+       this.lineNumber = lineNumber;\r\n+       this.sourceFile = sourceFile;\r\n+   }\r\n+\r\n+    public String getSourceFile() {\r\n+        return sourceFile;\r\n+    }\r\n+\r\n+    public void setSourceFile(String sourceFile) {\r\n+        this.sourceFile = sourceFile;\r\n+    }\r\n+\r\n     public int getLineNumber() {\r\n         return lineNumber;\r\n     }\r\ndiff --git a/src/main/java/org/mvel/debug/Debugger.java b/src/main/java/org/mvel/debug/Debugger.java\nindex a285f19..e2d6a91 100644\n--- a/src/main/java/org/mvel/debug/Debugger.java\n+++ b/src/main/java/org/mvel/debug/Debugger.java\n@@ -3,4 +3,5 @@ package org.mvel.debug;\n \n public interface Debugger {\n     public int onBreak();\n-}\n+    public boolean breakOn(int lineNumber);\n+}\n\\ No newline at end of file\ndiff --git a/src/main/java/org/mvel/optimizers/AbstractOptimizer.java b/src/main/java/org/mvel/optimizers/AbstractOptimizer.java\nindex bee3580..197782b 100644\n--- a/src/main/java/org/mvel/optimizers/AbstractOptimizer.java\n+++ b/src/main/java/org/mvel/optimizers/AbstractOptimizer.java\n@@ -69,13 +69,14 @@ public class AbstractOptimizer extends AbstractParser {\n                 return COL;\r\n             case'.':\r\n                 cursor = ++start;\r\n+\r\n         }\r\n \r\n         //noinspection StatementWithEmptyBody\r\n         while (++cursor < length && Character.isJavaIdentifierPart(expr[cursor])) ;\r\n \r\n-\r\n         if (cursor < length) {\r\n+            skipWhitespace();\r\n             switch (expr[cursor]) {\r\n                 case'[':\r\n                     return COL;\r\n@@ -89,7 +90,10 @@ public class AbstractOptimizer extends AbstractParser {\n     }\r\n \r\n     protected String capture() {\r\n-        return new String(expr, start, cursor - start);\r\n+        /**\r\n+         * Trim off any whitespace.\r\n+         */        \r\n+        return new String(expr, start, trimLeft(cursor) - start);\r\n     }\r\n \r\n     protected void whiteSpaceSkip() {\r\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/res/DefaultKnowledgeHelper.java b/src/test/java/org/mvel/tests/main/res/DefaultKnowledgeHelper.java\nindex 770d29a..f9b59cc 100644\n--- a/src/test/java/org/mvel/tests/main/res/DefaultKnowledgeHelper.java\n+++ b/src/test/java/org/mvel/tests/main/res/DefaultKnowledgeHelper.java\n@@ -3,12 +3,10 @@ package org.mvel.tests.main.res;\n import java.util.ArrayList;\r\n import java.util.List;\r\n \r\n-public class DefaultKnowledgeHelper\r\n-    implements\r\n-    KnowledgeHelper {\r\n+public class DefaultKnowledgeHelper implements KnowledgeHelper {\r\n \r\n     public List retracted = new ArrayList();\r\n-    \r\n+\r\n     public void insert(Object object) {\r\n     }\r\n \r\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T19:25:33.047252Z", "commit_hash": "a0a371cdf047f3730ecd2c355ae2c4b73868176e", "commit_message": "bug fix, integer accessors in maps\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/PropertyAccessor.java b/src/main/java/org/mvel/PropertyAccessor.java\nindex 7760041..00ef213 100644\n--- a/src/main/java/org/mvel/PropertyAccessor.java\n+++ b/src/main/java/org/mvel/PropertyAccessor.java\n@@ -32,7 +32,6 @@ import org.mvel.util.StringAppender;\n import java.io.Serializable;\r\n import static java.lang.Character.isJavaIdentifierPart;\r\n import static java.lang.Character.isWhitespace;\r\n-import static java.lang.Integer.parseInt;\r\n import java.lang.reflect.*;\r\n import java.util.*;\r\n import static java.util.Collections.synchronizedMap;\r\n@@ -452,26 +451,31 @@ public class PropertyAccessor {\n         if (cursor == length)\r\n             throw new PropertyAccessException(\"unterminated '['\");\r\n \r\n-        String item;\r\n-\r\n-        if (property[cursor] == '\\'' || property[cursor] == '\"') {\r\n-            start++;\r\n-\r\n-            int end;\r\n+        Object item;\r\n+\r\n+//        if (property[cursor] == '\\'' || property[cursor] == '\"') {\r\n+//            start++;\r\n+//\r\n+//            int end;\r\n+//\r\n+//            if (!scanTo(']'))\r\n+//                throw new PropertyAccessException(\"unterminated '['\");\r\n+//            if ((end = containsStringLiteralTermination()) == -1)\r\n+//                throw new PropertyAccessException(\"unterminated string literal in collections accessor\");\r\n+//\r\n+//            item = new String(property, start, end - start);\r\n+//        }\r\n+//        else {\r\n+\r\n+        //      = );\r\n+//        }\r\n+\r\n+        if (!scanTo(']'))\r\n+            throw new PropertyAccessException(\"unterminated '['\");\r\n \r\n-            if (!scanTo(']'))\r\n-                throw new PropertyAccessException(\"unterminated '['\");\r\n-            if ((end = containsStringLiteralTermination()) == -1)\r\n-                throw new PropertyAccessException(\"unterminated string literal in collections accessor\");\r\n+        String ex = new String(property, start, cursor - start);\r\n \r\n-            item = new String(property, start, end - start);\r\n-        }\r\n-        else {\r\n-            if (!scanTo(']'))\r\n-                throw new PropertyAccessException(\"unterminated '['\");\r\n-\r\n-            item = new String(property, start, cursor - start);\r\n-        }\r\n+        item = MVEL.eval(ex, ctx, resolver);\r\n \r\n         ++cursor;\r\n \r\n@@ -479,10 +483,10 @@ public class PropertyAccessor {\n             return ((Map) ctx).get(item);\r\n         }\r\n         else if (ctx instanceof List) {\r\n-            return ((List) ctx).get(parseInt(item));\r\n+            return ((List) ctx).get((Integer) item);\r\n         }\r\n         else if (ctx instanceof Collection) {\r\n-            int count = parseInt(item);\r\n+            int count = (Integer) item;\r\n             if (count > ((Collection) ctx).size())\r\n                 throw new PropertyAccessException(\"index [\" + count + \"] out of bounds on collections\");\r\n \r\n@@ -491,10 +495,10 @@ public class PropertyAccessor {\n             return iter.next();\r\n         }\r\n         else if (ctx instanceof Object[]) {\r\n-            return ((Object[]) ctx)[parseInt(item)];\r\n+            return ((Object[]) ctx)[(Integer) item];\r\n         }\r\n         else if (ctx instanceof CharSequence) {\r\n-            return ((CharSequence) ctx).charAt(parseInt(item));\r\n+            return ((CharSequence) ctx).charAt((Integer) item);\r\n         }\r\n         else {\r\n             throw new PropertyAccessException(\"illegal use of []: unknown type: \" + (ctx == null ? null : ctx.getClass().getName()));\r\ndiff --git a/src/main/java/org/mvel/optimizers/impl/asm/ASMAccessorOptimizer.java b/src/main/java/org/mvel/optimizers/impl/asm/ASMAccessorOptimizer.java\nindex f839bab..0cbd3c2 100644\n--- a/src/main/java/org/mvel/optimizers/impl/asm/ASMAccessorOptimizer.java\n+++ b/src/main/java/org/mvel/optimizers/impl/asm/ASMAccessorOptimizer.java\n@@ -18,9 +18,8 @@\n  */\r\n package org.mvel.optimizers.impl.asm;\r\n \r\n-import static org.mvel.util.ParseTools.isPrimitiveWrapper;\r\n-import static org.mvel.DataConversion.canConvert;\r\n import org.mvel.*;\r\n+import static org.mvel.DataConversion.canConvert;\r\n import static org.mvel.DataConversion.convert;\r\n import static org.mvel.MVEL.compileExpression;\r\n import static org.mvel.MVEL.isAdvancedDebugging;\r\n@@ -519,9 +518,8 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n             mv.visitTypeInsn(CHECKCAST, \"java/util/Map\");\r\n \r\n             if (!itemSubExpr) {\r\n-                debug(\"LDC: \\\"\" + item + \"\\\"\");\r\n-                mv.visitLdcInsn(item);\r\n-\r\n+                intPush(parseInt(item));\r\n+                wrapPrimitive(int.class);\r\n                 debug(\"INVOKEINTERFACE: get\");\r\n                 mv.visitMethodInsn(INVOKEINTERFACE, \"java/util/Map\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\");\r\n \r\n@@ -1226,7 +1224,7 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n                 mv.visitMethodInsn(INVOKESTATIC, \"java/lang/Double\", \"valueOf\", \"(D)Ljava/lang/Double;\");\r\n             }\r\n             else if (cls == short.class || cls == Short.class) {\r\n-                debug(\"INVOKESTATIC java/lang/Short.valueOf\");                \r\n+                debug(\"INVOKESTATIC java/lang/Short.valueOf\");\r\n                 mv.visitMethodInsn(INVOKESTATIC, \"java/lang/Short\", \"valueOf\", \"(S)Ljava/lang/Short;\");\r\n             }\r\n             else if (cls == long.class || cls == Long.class) {\r\ndiff --git a/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java b/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\nindex 530e79c..8ab581d 100644\n--- a/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\n+++ b/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\n@@ -277,24 +277,11 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n \r\n         String item;\r\n \r\n-//        if (expr[cursor] == '\\'' || expr[cursor] == '\"') {\r\n-//            start++;\r\n-//\r\n-//            int end;\r\n-//\r\n-//            if (!scanTo(']'))\r\n-//                throw new PropertyAccessException(\"unterminated '['\");\r\n-//            if ((end = containsStringLiteralTermination()) == -1)\r\n-//                throw new PropertyAccessException(\"unterminated string literal in collections accessor\");\r\n-//\r\n-//            item = new String(expr, start, end - start);\r\n-//        }\r\n-//        else {\r\n+\r\n         if (!scanTo(']'))\r\n             throw new PropertyAccessException(\"unterminated '['\");\r\n \r\n         item = new String(expr, start, cursor - start);\r\n-        //      }\r\n \r\n         boolean itemSubExpr = true;\r\n \r\n@@ -324,7 +311,7 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n             }\r\n             else {\r\n                 MapAccessor accessor = new MapAccessor();\r\n-                accessor.setProperty(item);\r\n+                accessor.setProperty(parseInt(item));\r\n                 addAccessorNode(accessor);\r\n             }\r\n \r\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CompiledUnitTest.java b/src/test/java/org/mvel/tests/main/CompiledUnitTest.java\nindex f38e60f..d011dfd 100644\n--- a/src/test/java/org/mvel/tests/main/CompiledUnitTest.java\n+++ b/src/test/java/org/mvel/tests/main/CompiledUnitTest.java\n@@ -417,6 +417,10 @@ public class CompiledUnitTest extends TestCase {\n         assertEquals(\"sarah\", parseDirect(\"map = ['mike' :'sarah'  ,'tom'  :'jacquelin'  ]; map['mike']\"));\n     }\n \n+    public void testMapCreation3() {\n+        assertEquals(\"foo\", parseDirect(\"map = [1 : 'foo']; map[1]\"));\n+    }\n+\n     public void testProjectionSupport() {\n         assertEquals(true, parseDirect(\"(name in things) contains 'Bob'\"));\n     }\n@@ -908,13 +912,13 @@ public class CompiledUnitTest extends TestCase {\n \n     public Object compiledExecute(String ex, Object base, Map map) {\n         Serializable compiled = compileExpression(ex);\n-        \n+\n         Object first = executeExpression(compiled, base, map);\n         Object second = executeExpression(compiled, base, map);\n \n         if (first != null && !first.getClass().isArray())\n             assertSame(first, second);\n-        \n+\n         return second;\n     }\n \n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T19:26:20.762528Z", "commit_hash": "c055d470e71f4ae1894ae8258e04f9a4e036815d", "commit_message": "analyzer fixed.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/ExpressionCompiler.java b/src/main/java/org/mvel/ExpressionCompiler.java\nindex 25dfc8e..6063065 100644\n--- a/src/main/java/org/mvel/ExpressionCompiler.java\n+++ b/src/main/java/org/mvel/ExpressionCompiler.java\n@@ -151,7 +151,7 @@ public class ExpressionCompiler extends AbstractParser {\n \r\n     protected ASTNode verify(ASTNode tk) {\r\n         if (verifying) {\r\n-            if (tk.isDiscard()) return tk;\r\n+            if (tk.isDiscard() || (tk.fields & (ASTNode.OPERATOR | ASTNode.LITERAL)) != 0) return tk;\r\n             if (tk.isAssignment()) {\r\n                 char[] assign = tk.getNameAsArray();\r\n                 int c = 0;\r\ndiff --git a/src/main/java/org/mvel/MVELRuntime.java b/src/main/java/org/mvel/MVELRuntime.java\nindex 5231974..4747a08 100644\n--- a/src/main/java/org/mvel/MVELRuntime.java\n+++ b/src/main/java/org/mvel/MVELRuntime.java\n@@ -107,15 +107,10 @@ public class MVELRuntime {\n \r\n                     case END_OF_STMT:\r\n                         /**\r\n-                         * Assignments are a special scenario for dealing with the stack.  Assignments are basically like\r\n-                         * held-over failures that basically kickstart the parser when an assignment operator is is\r\n-                         * encountered.  The originating token is captured, and the the parser is told to march on.  The\r\n-                         * resultant value on the stack is then used to populate the target variable.\r\n-                         *\r\n-                         * The other scenario in which we don't want to wipe the stack, is when we hit the end of the\r\n-                         * statement, because that top stack value is the value we want back from the parser.\r\n+                         * If the program doesn't end here then we wipe anything off the stack that remains.\r\n+                         * Althought it may seem like intuitive stack optimizations could be leveraged by\r\n+                         * leaving hanging values on the stack,  trust me it's not a good idea.\r\n                          */\r\n-\r\n                         if (tokens.hasMoreTokens()) {\r\n                             stk.clear();\r\n                         }\r\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CompiledUnitTest.java b/src/test/java/org/mvel/tests/main/CompiledUnitTest.java\nindex 16f5467..cc94470 100644\n--- a/src/test/java/org/mvel/tests/main/CompiledUnitTest.java\n+++ b/src/test/java/org/mvel/tests/main/CompiledUnitTest.java\n@@ -774,7 +774,7 @@ public class CompiledUnitTest extends TestCase {\n     }\n \n     public void testVarInputs() {\n-        ExpressionCompiler compiler = new ExpressionCompiler(\"test != foo && bo.addSomething(trouble); String bleh = foo; twa = bleh\");\n+        ExpressionCompiler compiler = new ExpressionCompiler(\"test != foo && bo.addSomething(trouble); String bleh = foo; twa = bleh;\");\n \n         CompiledExpression c = compiler.compile();\n \n@@ -793,6 +793,19 @@ public class CompiledUnitTest extends TestCase {\n         assertEquals(String.class, DebugTools.determineType(\"bleh\", c));\n     }\n \n+    public void testAnalyzer() {\n+        ExpressionCompiler compiler = new ExpressionCompiler(\"order.id == 10\");\n+        compiler.compile();\n+\n+        for (String input : compiler.getInputs()) {\n+            System.out.println(\"input>\" + input);\n+        }\n+\n+        assertEquals(1, compiler.getInputs().size());\n+        assertTrue(compiler.getInputs().contains(\"order\"));\n+    }\n+\n+\n     public void testClassImportViaFactory() {\n         MapVariableResolverFactory mvf = new MapVariableResolverFactory(map);\n         ClassImportResolverFactory classes = new ClassImportResolverFactory();\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T19:27:50.626910Z", "commit_hash": "ae7455d78bf5c6056280dbf3468ec533b8ce9c1c", "commit_message": "bug fix\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/MVELRuntime.java b/src/main/java/org/mvel/MVELRuntime.java\nindex 3a2a378..8aa5863 100644\n--- a/src/main/java/org/mvel/MVELRuntime.java\n+++ b/src/main/java/org/mvel/MVELRuntime.java\n@@ -30,6 +30,8 @@ public class MVELRuntime {\n      */\r\n     public static Object execute(boolean debugger, FastASTIterator tokens, Object ctx, VariableResolverFactory variableFactory) {\r\n         Stack stk = new ExecutionStack();\r\n+        Object v1, v2;\r\n+\r\n         ASTNode tk = null;\r\n         Integer operator;\r\n \r\n@@ -123,7 +125,6 @@ public class MVELRuntime {\n \r\n                 stk.push(tokens.nextToken().getReducedValueAccelerated(ctx, ctx, variableFactory), operator);\r\n \r\n-                Object v1, v2;\r\n                 try {\r\n                     while (stk.size() > 1) {\r\n                         operator = (Integer) stk.pop();\r\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/perftests/CompiledPerformanceTests.java b/src/test/java/org/mvel/tests/perftests/CompiledPerformanceTests.java\nindex 9adf0b1..e70bdef 100644\n--- a/src/test/java/org/mvel/tests/perftests/CompiledPerformanceTests.java\n+++ b/src/test/java/org/mvel/tests/perftests/CompiledPerformanceTests.java\n@@ -39,7 +39,6 @@ public class CompiledPerformanceTests extends TestCase {\n         String text = \"misc.toList(foo.bar.name, 'hello', 42, ['key1' : 'value1', c : [ foo.bar.age, 'car', 42 ]], [42, [c : 'value1']] )\";\r\n \r\n         MapVariableResolverFactory variableTable = new MapVariableResolverFactory(map);\r\n-        //   variableTable.pack();\r\n \r\n         Serializable compiled = MVEL.compileExpression(text);\r\n         for (int i = 0; i < ITERATIONS; i++) {\r\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T19:28:35.552739Z", "commit_hash": "7955d30c86e7ac2311dd66a92b62164608698f36", "commit_message": "minor bug fix.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/AbstractParser.java b/src/main/java/org/mvel/AbstractParser.java\nindex 717b18c..c4ad19c 100644\n--- a/src/main/java/org/mvel/AbstractParser.java\n+++ b/src/main/java/org/mvel/AbstractParser.java\n@@ -32,7 +32,7 @@ public class AbstractParser {\n     protected boolean lastWasIdentifier = false;\r\n     protected boolean lastWasLineLabel = false;\r\n \r\n-    private boolean debugSymbols = false;\r\n+    protected boolean debugSymbols = false;\r\n     private int line = 1;\r\n \r\n     protected ASTNode lastNode;\r\ndiff --git a/src/main/java/org/mvel/ExpressionCompiler.java b/src/main/java/org/mvel/ExpressionCompiler.java\nindex 1b6bb74..737be3a 100644\n--- a/src/main/java/org/mvel/ExpressionCompiler.java\n+++ b/src/main/java/org/mvel/ExpressionCompiler.java\n@@ -1,5 +1,6 @@\n package org.mvel;\r\n \r\n+import org.mvel.ast.LiteralNode;\r\n import org.mvel.util.*;\r\n import static org.mvel.util.ParseTools.doOperations;\r\n \r\n@@ -23,6 +24,7 @@ public class ExpressionCompiler extends AbstractParser {\n     public CompiledExpression compile() {\r\n         ASTNode tk;\r\n         ASTNode tkOp;\r\n+        ASTNode tkOp2;\r\n         ASTNode tkLA;\r\n         ASTNode tkLA2;\r\n         ASTSet tokenSet = new ASTSet();\r\n@@ -73,9 +75,16 @@ public class ExpressionCompiler extends AbstractParser {\n                         /**\r\n                          * Now we need to check to see if this is actually a continuing reduction.\r\n                          */\r\n-                        while ((tkOp = nextToken()) != null) {\r\n-                            if ((tkLA2 = nextToken()) != null && tkLA2.isLiteral()) {\r\n-                                stk.push(tkLA2.getLiteralValue(), tkOp.getLiteralValue());\r\n+                        while ((tkOp2 = nextToken()) != null) {\r\n+                            if (!tkOp2.isOperator(tkOp.getOperator())) {\r\n+                                tokenSet.addTokenNode(new LiteralNode(stk.pop()));\r\n+                                tokenSet.addTokenNode(tkOp2);\r\n+                                break;\r\n+                            }\r\n+                            else if ((tkLA2 = nextToken()) != null\r\n+                                    && tkLA2.isLiteral()) {\r\n+\r\n+                                stk.push(tkLA2.getLiteralValue(), tkOp2.getLiteralValue());\r\n                                 reduceTrinary();\r\n                                 firstLA = false;\r\n                             }\r\ndiff --git a/src/main/java/org/mvel/ExpressionParser.java b/src/main/java/org/mvel/ExpressionParser.java\nindex 53f8b3a..b589c3b 100644\n--- a/src/main/java/org/mvel/ExpressionParser.java\n+++ b/src/main/java/org/mvel/ExpressionParser.java\n@@ -50,6 +50,7 @@ public class ExpressionParser extends AbstractParser {\n \n     Object parse() {\n         setThreadAccessorOptimizer(ReflectiveAccessorOptimizer.class);\n+        debugSymbols = false;\n \n         try {\n             stk.clear();\n@@ -104,7 +105,6 @@ public class ExpressionParser extends AbstractParser {\n                     continue;\n                 }\n \n-\n                 switch (reduceBinary(operator = tk.getOperator())) {\n                     case FRAME_END:\n                         return;\ndiff --git a/src/main/java/org/mvel/ast/LiteralNode.java b/src/main/java/org/mvel/ast/LiteralNode.java\nindex d57b3cb..548db89 100644\n--- a/src/main/java/org/mvel/ast/LiteralNode.java\n+++ b/src/main/java/org/mvel/ast/LiteralNode.java\n@@ -9,8 +9,8 @@ import org.mvel.integration.VariableResolverFactory;\n public class LiteralNode extends ASTNode {\r\n     private Object literal;\r\n \r\n-    public LiteralNode(char[] expr, int fields, Object literal) {\r\n-        super(expr, fields);\r\n+    public LiteralNode(Object literal) {\r\n+        super();\r\n         if (literal instanceof String) {\r\n             this.literal = ((String) literal).intern();\r\n         }\r\ndiff --git a/src/main/java/org/mvel/ast/PropertyASTNode.java b/src/main/java/org/mvel/ast/PropertyASTNode.java\nindex f5637bb..4a7cb60 100644\n--- a/src/main/java/org/mvel/ast/PropertyASTNode.java\n+++ b/src/main/java/org/mvel/ast/PropertyASTNode.java\n@@ -35,7 +35,7 @@ public class PropertyASTNode extends ASTNode {\n \r\n     private Object initializePropertyNode(Object ctx, Object thisValue, VariableResolverFactory factory) {\r\n         if ((fields & STR_LITERAL) != 0) {\r\n-            wrappedNode = new LiteralNode(name, fields, new String(name));\r\n+            wrappedNode = new LiteralNode(new String(name));\r\n             return wrappedNode.getReducedValueAccelerated(ctx, thisValue, factory);\r\n         }\r\n         else if ((fields & LITERAL) != 0) {\r\n@@ -44,7 +44,7 @@ public class PropertyASTNode extends ASTNode {\n                 return wrappedNode.getReducedValueAccelerated(ctx, thisValue, factory);\r\n             }\r\n             else {\r\n-                wrappedNode = new LiteralNode(name, fields, literal);\r\n+                wrappedNode = new LiteralNode(literal);\r\n                 return wrappedNode.getReducedValueAccelerated(ctx, thisValue, factory);\r\n             }\r\n         }\r\n@@ -95,7 +95,7 @@ public class PropertyASTNode extends ASTNode {\n                     Object sa = tryStaticAccess(ctx, factory);\r\n                     if (sa == null) throw e;\r\n \r\n-                    wrappedNode = new LiteralNode(name, fields, sa);\r\n+                    wrappedNode = new LiteralNode(sa);\r\n                     return wrappedNode.getReducedValueAccelerated(ctx, thisValue, factory);\r\n                 }\r\n             }\r\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CompiledUnitTest.java b/src/test/java/org/mvel/tests/main/CompiledUnitTest.java\nindex 00b9cc3..db21c80 100644\n--- a/src/test/java/org/mvel/tests/main/CompiledUnitTest.java\n+++ b/src/test/java/org/mvel/tests/main/CompiledUnitTest.java\n@@ -154,6 +154,10 @@ public class CompiledUnitTest extends TestCase {\n         assertEquals(true, parseDirect(\"true || true\"));\n     }\n \n+    public void testOrOperator2() {\n+        assertEquals(true, parseDirect(\"2 > 3 || 3 > 2\"));\n+    }\n+\n     public void testShortPathExpression3() {\n         assertEquals(false, parseDirect(\"defnull != null  && defnull.length() > 0\"));\n     }\ndiff --git a/src/test/java/org/mvel/tests/main/ParserUnitTest.java b/src/test/java/org/mvel/tests/main/ParserUnitTest.java\nindex 1e019ac..80b4562 100644\n--- a/src/test/java/org/mvel/tests/main/ParserUnitTest.java\n+++ b/src/test/java/org/mvel/tests/main/ParserUnitTest.java\n@@ -160,6 +160,7 @@ public class ParserUnitTest extends TestCase {\n         assertEquals(\"dogDOGGIE133.5\", parse(\"@{foo.bar.name}DOGGIE@{hour*2.225+1-1}\"));\n     }\n \n+\n     public void testComplexAnd() {\n         assertEquals(true, parse(\"@{(pi * hour) > 0 && foo.happy() == 'happyBar'}\"));\n     }\n@@ -204,9 +205,9 @@ public class ParserUnitTest extends TestCase {\n     public void testMethodAccess6() {\n         assertEquals(false, parse(\"@{!foo.bar.isWoof()}\"));\n     }\n-    \n-    public void testPrimitiveClassMethodAccess() {               \n-        assertEquals( \"int\", parseDirect( \"Integer.TYPE.getName()\" ) );\n+\n+    public void testPrimitiveClassMethodAccess() {\n+        assertEquals(\"int\", parseDirect(\"Integer.TYPE.getName()\"));\n     }\n \n     public void testNegation() {\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T19:29:20.865167Z", "commit_hash": "d2110e54d414b8aaeb5fead96224e8ef63bcc06d", "commit_message": "breakpoint support fixed.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/ExpressionCompiler.java b/src/main/java/org/mvel/ExpressionCompiler.java\nindex 3ae9487..1b6bb74 100644\n--- a/src/main/java/org/mvel/ExpressionCompiler.java\n+++ b/src/main/java/org/mvel/ExpressionCompiler.java\n@@ -205,6 +205,14 @@ public class ExpressionCompiler extends AbstractParser {\n                         stk.push(doOperations(v2, operator, v1));\r\n                         break;\r\n \r\n+                    case Operator.AND:\r\n+                        stk.push(((Boolean) v2) && ((Boolean) v1));\r\n+                        break;\r\n+\r\n+                    case Operator.OR:\r\n+                        stk.push(((Boolean) v2) || ((Boolean) v1));\r\n+                        break;\r\n+\r\n                     case Operator.CHOR:\r\n                         if (!PropertyTools.isEmpty(v2) || !PropertyTools.isEmpty(v1)) {\r\n                             stk.clear();\r\ndiff --git a/src/main/java/org/mvel/MVELRuntime.java b/src/main/java/org/mvel/MVELRuntime.java\nindex e03e632..14e9c10 100644\n--- a/src/main/java/org/mvel/MVELRuntime.java\n+++ b/src/main/java/org/mvel/MVELRuntime.java\n@@ -130,7 +130,7 @@ public class MVELRuntime {\n                 }\r\n                 else {\r\n                     stk.discard();\r\n-                    return 1;\r\n+                    return FRAME_NEXT;\r\n                 }\r\n             case OR:\r\n                 if (stk.peek() instanceof Boolean && ((Boolean) stk.peek())) {\r\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CompiledUnitTest.java b/src/test/java/org/mvel/tests/main/CompiledUnitTest.java\nindex d98affe..00b9cc3 100644\n--- a/src/test/java/org/mvel/tests/main/CompiledUnitTest.java\n+++ b/src/test/java/org/mvel/tests/main/CompiledUnitTest.java\n@@ -150,6 +150,10 @@ public class CompiledUnitTest extends TestCase {\n         assertEquals(true, parseDirect(\"4 > 3 || foo.toUC('test')\"));\n     }\n \n+    public void testOrOperator() {\n+        assertEquals(true, parseDirect(\"true || true\"));\n+    }\n+\n     public void testShortPathExpression3() {\n         assertEquals(false, parseDirect(\"defnull != null  && defnull.length() > 0\"));\n     }\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T19:30:06.804422Z", "commit_hash": "46de242193708bb471cb149dd05134181dea035e", "commit_message": "breakpoint support fixed.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/AbstractParser.java b/src/main/java/org/mvel/AbstractParser.java\nindex 38a430b..717b18c 100644\n--- a/src/main/java/org/mvel/AbstractParser.java\n+++ b/src/main/java/org/mvel/AbstractParser.java\n@@ -238,6 +238,7 @@ public class AbstractParser {\n \r\n         if (!debugSymbols && linecounter != null && linecounter.get() != null) {\r\n             debugSymbols = true;\r\n+            if (expr[cursor] != '\\n') lastWasLineLabel = true;\r\n         }\r\n \r\n         if (debugSymbols && !lastWasLineLabel && (expr[cursor] == '\\n' || cursor == 0)) {\r\ndiff --git a/src/main/java/org/mvel/MVELRuntime.java b/src/main/java/org/mvel/MVELRuntime.java\nindex 6b23192..e03e632 100644\n--- a/src/main/java/org/mvel/MVELRuntime.java\n+++ b/src/main/java/org/mvel/MVELRuntime.java\n@@ -22,7 +22,7 @@ import static java.util.regex.Pattern.compile;\n public class MVELRuntime {\r\n     private final ASTIterator tokens;\r\n     private final Stack stk = new ExecutionStack();\r\n-    private Set<Integer> breakpoints;\r\n+    private static ThreadLocal<Set<Integer>> breakpoints;\r\n     private boolean debugger = false;\r\n \r\n     public MVELRuntime(CompiledExpression expression) {\r\n@@ -47,12 +47,17 @@ public class MVELRuntime {\n         try {\r\n             while ((tk = tokens.nextToken()) != null) {\r\n                 if (tk.fields == -1) {\r\n+\r\n+                    if (breakpoints != null && breakpoints.get() != null) {\r\n+                        debugger = true;\r\n+                    }\r\n+\r\n                     if (debugger && breakpoints != null\r\n-                            && breakpoints.contains(((LineLabel) tk).getLineNumber())) {\r\n-                        System.out.println(\"[Encountered Breakpoint!]\");\r\n+                            && breakpoints.get().contains(((LineLabel) tk).getLineNumber())) {\r\n+                        System.out.println(\"[Encountered Breakpoint!]: \" + ((LineLabel) tk).getLineNumber());\r\n \r\n                         try {\r\n-                            Thread.sleep(5000);\r\n+                            Thread.sleep(10);\r\n                         }\r\n                         catch (InterruptedException e) {\r\n                         }\r\n@@ -314,19 +319,22 @@ public class MVELRuntime {\n     }\r\n \r\n     public void registerBreakpoint(int line) {\r\n-        if (breakpoints == null) breakpoints = new HashSet<Integer>();\r\n-        breakpoints.add(line);\r\n+        if (breakpoints == null) {\r\n+            breakpoints = new ThreadLocal<Set<Integer>>();\r\n+            breakpoints.set(new HashSet<Integer>());\r\n+        }\r\n+        breakpoints.get().add(line);\r\n     }\r\n \r\n     public void removeBreakpoint(int line) {\r\n-        if (breakpoints != null) {\r\n-            breakpoints.remove(line);\r\n+        if (breakpoints != null && breakpoints.get() != null) {\r\n+            breakpoints.get().remove(line);\r\n         }\r\n     }\r\n \r\n     public void clearAllBreakpoints() {\r\n-        if (breakpoints != null) {\r\n-            breakpoints.clear();\r\n+        if (breakpoints != null && breakpoints.get() != null) {\r\n+            breakpoints.get().clear();\r\n         }\r\n     }\r\n \r\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CompiledUnitTest.java b/src/test/java/org/mvel/tests/main/CompiledUnitTest.java\nindex 753c827..d98affe 100644\n--- a/src/test/java/org/mvel/tests/main/CompiledUnitTest.java\n+++ b/src/test/java/org/mvel/tests/main/CompiledUnitTest.java\n@@ -758,7 +758,7 @@ public class CompiledUnitTest extends TestCase {\n \n         MVELRuntime debug = new MVELRuntime(compiled);\n         debug.setDebugger(true);\n-        debug.registerBreakpoint(2);\n+        debug.registerBreakpoint(7);\n \n         assertEquals(10, MVEL.executeDebugger(debug, null, new MapVariableResolverFactory(map)));\n     }\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T19:31:38.806856Z", "commit_hash": "387458284962bff20a6949a8be65a18d0fd0ee31", "commit_message": "BUGFIX: Property Verifier not working right with typed vars.  Everything happy now.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/ExpressionCompiler.java b/src/main/java/org/mvel/ExpressionCompiler.java\nindex 2cf62cb..c81372c 100644\n--- a/src/main/java/org/mvel/ExpressionCompiler.java\n+++ b/src/main/java/org/mvel/ExpressionCompiler.java\n@@ -106,61 +106,65 @@ public class ExpressionCompiler extends AbstractParser {\n                         continue;\r\n                     }\r\n                     else {\r\n-                        tokenSet.addTokenNode(tk, tkOp);\r\n-                        if (tkLA != null) tokenSet.addTokenNode(tkLA);\r\n+                        tokenSet.addTokenNode(verify(tk), verify(tkOp));\r\n+                        if (tkLA != null) tokenSet.addTokenNode(verify(tkLA));\r\n                         continue;\r\n                     }\r\n                 }\r\n                 else {\r\n-                    tokenSet.addTokenNode(tk);\r\n-                    if (tkOp != null) tokenSet.addTokenNode(tkOp);\r\n+                    tokenSet.addTokenNode(verify(tk));\r\n+                    if (tkOp != null) tokenSet.addTokenNode(verify(tkOp));\r\n \r\n                     continue;\r\n                 }\r\n             }\r\n \r\n-            if (verifying) {\r\n-                if (tk.isAssignment()) {\r\n-                    char[] assign = tk.getNameAsArray();\r\n-                    int c = 0;\r\n-                    while (c < assign.length && assign[c] != '=') c++;\r\n+            tokenSet.addTokenNode(verify(tk));\r\n+        }\r\n+\r\n+        if (verifying) {\r\n+            for (String s : locals) {\r\n+                inputs.remove(s);\r\n+            }\r\n+        }\r\n \r\n-                    String varName = new String(assign, 0, c++).trim();\r\n+        return new CompiledExpression(new FastTokenIterator(tokenSet));\r\n+    }\r\n \r\n-                    if (isReservedWord(varName)) {\r\n-                        throw new CompileException(\"invalid assignment - variable name is a reserved keyword: \" + varName);\r\n-                    }\r\n+    protected ASTNode verify(ASTNode tk) {\r\n+        if (verifying) {\r\n+            if (tk.isAssignment()) {\r\n+                char[] assign = tk.getNameAsArray();\r\n+                int c = 0;\r\n+                while (c < assign.length && assign[c] != '=') c++;\r\n \r\n-                    locals.add(varName);\r\n+                String varName = new String(assign, 0, c++).trim();\r\n \r\n-                    ExpressionCompiler subCompiler =\r\n-                            new ExpressionCompiler(new String(assign, c, assign.length - c).trim());\r\n+                if (isReservedWord(varName)) {\r\n+                    throw new CompileException(\"invalid assignment - variable name is a reserved keyword: \" + varName);\r\n+                }\r\n \r\n-                    subCompiler.compile();\r\n+                locals.add(varName);\r\n \r\n-                    inputs.addAll(subCompiler.getInputs());\r\n+                ExpressionCompiler subCompiler =\r\n+                        new ExpressionCompiler(new String(assign, c, assign.length - c).trim());\r\n \r\n-                }\r\n-                else if (tk.isIdentifier()) {\r\n-                    inputs.add(tk.getAbsoluteName());\r\n+                subCompiler.compile();\r\n \r\n-                    PropertyVerifier propVerifier = new PropertyVerifier(tk.getNameAsArray());\r\n-                    propVerifier.analyze();\r\n+                inputs.addAll(subCompiler.getInputs());\r\n \r\n-                    inputs.addAll(propVerifier.getInputs());\r\n-                }\r\n             }\r\n+            else if (tk.isIdentifier()) {\r\n+                inputs.add(tk.getAbsoluteName());\r\n \r\n-            tokenSet.addTokenNode(tk);\r\n-        }\r\n+                PropertyVerifier propVerifier = new PropertyVerifier(tk.getNameAsArray());\r\n+                propVerifier.analyze();\r\n \r\n-        if (verifying) {\r\n-            for (String s : locals) {\r\n-                inputs.remove(s);\r\n+                inputs.addAll(propVerifier.getInputs());\r\n             }\r\n         }\r\n \r\n-        return new CompiledExpression(new FastTokenIterator(tokenSet));\r\n+        return tk;\r\n     }\r\n \r\n \r\ndiff --git a/src/main/java/org/mvel/PropertyVerifier.java b/src/main/java/org/mvel/PropertyVerifier.java\nindex 0cf2f67..4c612fb 100644\n--- a/src/main/java/org/mvel/PropertyVerifier.java\n+++ b/src/main/java/org/mvel/PropertyVerifier.java\n@@ -40,6 +40,7 @@ public class PropertyVerifier {\n \n     public PropertyVerifier(char[] property) {\n         this.property = property;\n+\n         this.length = property.length;\n     }\n \ndiff --git a/src/main/java/org/mvel/ast/TypedVarNode.java b/src/main/java/org/mvel/ast/TypedVarNode.java\nindex de33edf..9462a20 100644\n--- a/src/main/java/org/mvel/ast/TypedVarNode.java\n+++ b/src/main/java/org/mvel/ast/TypedVarNode.java\n@@ -21,6 +21,7 @@ public class TypedVarNode extends ASTNode {\n \r\n         int assignStart;\r\n         if ((assignStart = find(expr, '=')) != -1) {\r\n+            fields |= ASSIGN;\r\n             checkNameSafety(name = new String(expr, 0, assignStart).trim());\r\n             statement = (ExecutableStatement) compileExpression(subset(expr, assignStart + 1));\r\n         }\r\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CompiledUnitTest.java b/src/test/java/org/mvel/tests/main/CompiledUnitTest.java\nindex 09ca2a1..a3378da 100644\n--- a/src/test/java/org/mvel/tests/main/CompiledUnitTest.java\n+++ b/src/test/java/org/mvel/tests/main/CompiledUnitTest.java\n@@ -754,7 +754,7 @@ public class CompiledUnitTest extends TestCase {\n     }\n \n     public void testVarInputs() {\n-        ExpressionCompiler compiler = new ExpressionCompiler(\"test != foo && bo.addSomething(trouble); bleh = foo; twa = bleh\");\n+        ExpressionCompiler compiler = new ExpressionCompiler(\"test != foo && bo.addSomething(trouble); String bleh = foo; twa = bleh\");\n         compiler.compile();\n \n         assertTrue(compiler.getInputs().contains(\"test\"));\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T19:32:24.604067Z", "commit_hash": "ce17720b3d903cd1dfd831114026e2d852a67e42", "commit_message": "-Fixed the error for accessing methods on a primitive's class\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/util/ParseTools.java b/src/main/java/org/mvel/util/ParseTools.java\nindex fee8214..c6f7cb6 100644\n--- a/src/main/java/org/mvel/util/ParseTools.java\n+++ b/src/main/java/org/mvel/util/ParseTools.java\n@@ -167,7 +167,11 @@ public class ParseTools {\n \n     private static Map<String, Map<Integer, Method>> RESOLVED_METH_CACHE = new WeakHashMap<String, Map<Integer, Method>>(10);\n \n+    \n     public static Method getBestCanadidate(Object[] arguments, String method, Method[] methods) {\n+        if ( methods.length == 0) {\n+            return null;\n+        }\n         Class[] parmTypes;\n         Method bestCandidate = null;\n         int bestScore = 0;\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/ParserUnitTest.java b/src/test/java/org/mvel/tests/main/ParserUnitTest.java\nindex 0934033..1e019ac 100644\n--- a/src/test/java/org/mvel/tests/main/ParserUnitTest.java\n+++ b/src/test/java/org/mvel/tests/main/ParserUnitTest.java\n@@ -204,6 +204,10 @@ public class ParserUnitTest extends TestCase {\n     public void testMethodAccess6() {\n         assertEquals(false, parse(\"@{!foo.bar.isWoof()}\"));\n     }\n+    \n+    public void testPrimitiveClassMethodAccess() {               \n+        assertEquals( \"int\", parseDirect( \"Integer.TYPE.getName()\" ) );\n+    }\n \n     public void testNegation() {\n         assertEquals(true, parse(\"@{!fun && !fun}\"));\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T19:36:53.414956Z", "commit_hash": "3577a5cf24770d165c611652f5e7a159328ef821", "commit_message": "post/prefix inc/decrement operators implemented.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/AbstractParser.java b/src/main/java/org/mvel/AbstractParser.java\nindex 251c16c..e4815c3 100644\n--- a/src/main/java/org/mvel/AbstractParser.java\n+++ b/src/main/java/org/mvel/AbstractParser.java\n@@ -333,6 +333,26 @@ public class AbstractParser {\n                  */\r\n                 if (cursor < length) {\r\n                     switch (expr[cursor]) {\r\n+                        case'+':\r\n+                            if (isAt('+', 1)) {\r\n+                                ASTNode n = new PostFixIncNode(subArray(start, cursor), fields);\r\n+                                cursor += 2;\r\n+                                return n;\r\n+                            }\r\n+                            else {\r\n+                                break;\r\n+                            }\r\n+\r\n+                        case'-':\r\n+                            if (isAt('-', 1)) {\r\n+                                ASTNode n = new PostFixDecNode(subArray(start, cursor), fields);\r\n+                                cursor += 2;\r\n+                                return n;\r\n+                            }\r\n+                            else {\r\n+                                break;\r\n+                            }\r\n+\r\n                         case']':\r\n                             if ((fields & (ASTNode.INLINE_COLLECTION)) != 0) {\r\n                                 break;\r\n@@ -347,7 +367,7 @@ public class AbstractParser {\n                             cursor++;\r\n                             continue;\r\n                         case'=':\r\n-                            if (greedy && expr[cursor + 1] != '=') {\r\n+                            if (greedy && !isAt('=', 1)) {\r\n                                 cursor++;\r\n \r\n                                 fields |= ASTNode.ASSIGN;\r\n@@ -378,7 +398,7 @@ public class AbstractParser {\n                                 }\r\n                             }\r\n                         case'i': // handle \"in\" fold operator\r\n-                            if (greedy && (cursor + 2) < length && expr[cursor + 1] == 'n' && isWhitespace(expr[cursor + 2])) {\r\n+                            if (greedy && isRemain(2) && lookAhead(1) == 'n' && isWhitespace(lookAhead(2))) {\r\n                                 cursor += 2;\r\n \r\n                                 fields |= ASTNode.FOLD;\r\n@@ -402,7 +422,7 @@ public class AbstractParser {\n             else\r\n                 switch (expr[cursor]) {\r\n                     case'=': {\r\n-                        if (expr[cursor + 1] != '=') {\r\n+                        if (!isAt('=', 1)) {\r\n                             return createToken(expr, start, ++cursor, fields |= ASTNode.ASSIGN);\r\n                         }\r\n                         else {\r\n@@ -411,26 +431,30 @@ public class AbstractParser {\n                     }\r\n \r\n                     case'-':\r\n-                        if (cursor + 1 < length && expr[cursor + 1] == '-') {\r\n-                            cursor++;\r\n+                        if (isAt('-', 1)) {\r\n+                            start = cursor += 2;\r\n+                            captureToEOT();\r\n+                            return new PreFixDecNode(subArray(start, cursor), fields);\r\n                         }\r\n-                        else if ((cursor > 0 && !isWhitespace(expr[cursor - 1])) || !isDigit(expr[cursor + 1])) {\r\n+                        else if ((cursor > 0 && !isWhitespace(lookBehind(1))) || !isDigit(lookAhead(1))) {\r\n                             return createToken(expr, start, cursor++ + 1, fields);\r\n                         }\r\n-                        else if ((cursor - 1) < 0 || (!isDigit(expr[cursor - 1])) && isDigit(expr[cursor + 1])) {\r\n+                        else if ((cursor - 1) < 0 || (!isDigit(lookBehind(1))) && isDigit(lookAhead(1))) {\r\n                             cursor++;\r\n                             break;\r\n                         }\r\n \r\n \r\n                     case'+':\r\n-                        if (cursor + 1 < length && expr[cursor + 1] == '+') {\r\n-                            cursor++;\r\n+                        if (isAt('+', 1)) {\r\n+                            start = cursor += 2;\r\n+                            captureToEOT();\r\n+                            return new PreFixIncNode(subArray(start, cursor), fields);\r\n                         }\r\n                         return createToken(expr, start, cursor++ + 1, fields);\r\n \r\n                     case'*':\r\n-                        if (cursor < length && expr[cursor + 1] == '*') {\r\n+                        if (isAt('*', 1)) {\r\n                             cursor++;\r\n                         }\r\n                         return createToken(expr, start, cursor++ + 1, fields);\r\n@@ -571,7 +595,7 @@ public class AbstractParser {\n                     }\r\n \r\n                     case'~':\r\n-                        if ((cursor - 1 < 0 || !isIdentifierPart(expr[cursor - 1]))\r\n+                        if ((cursor - 1 < 0 || !isIdentifierPart(lookBehind(1)))\r\n                                 && isDigit(expr[cursor + 1])) {\r\n \r\n                             fields |= ASTNode.INVERT;\r\n@@ -953,4 +977,26 @@ public class AbstractParser {\n     public static boolean isReservedWord(String name) {\r\n         return LITERALS.containsKey(name) || OPERATORS.containsKey(name);\r\n     }\r\n+\r\n+    protected char lookBehind(int range) {\r\n+        if ((cursor - range) <= 0) return 0;\r\n+        else {\r\n+            return expr[cursor - range];\r\n+        }\r\n+    }\r\n+\r\n+    protected char lookAhead(int range) {\r\n+        if ((cursor + range) >= length) return 0;\r\n+        else {\r\n+            return expr[cursor + range];\r\n+        }\r\n+    }\r\n+\r\n+    protected boolean isRemain(int range) {\r\n+        return (cursor + range) < length;\r\n+    }\r\n+\r\n+    protected boolean isAt(char c, int range) {\r\n+        return lookAhead(range) == c;\r\n+    }\r\n }\r\ndiff --git a/src/main/java/org/mvel/ast/PostFixDecNode.java b/src/main/java/org/mvel/ast/PostFixDecNode.java\nnew file mode 100644\nindex 0000000..da6c56b\n--- /dev/null\n+++ b/src/main/java/org/mvel/ast/PostFixDecNode.java\n@@ -0,0 +1,31 @@\n+package org.mvel.ast;\r\n+\r\n+import org.mvel.ASTNode;\r\n+import org.mvel.Operator;\r\n+import org.mvel.integration.VariableResolver;\r\n+import org.mvel.integration.VariableResolverFactory;\r\n+import static org.mvel.util.ParseTools.doOperations;\r\n+\r\n+/**\r\n+ * @author Christopher Brock\r\n+ */\r\n+public class PostFixDecNode extends ASTNode {\r\n+    private String name;\r\n+\r\n+    public PostFixDecNode(char[] expr, int fields) {\r\n+        super(expr, fields);\r\n+        name = new String(expr);\r\n+    }\r\n+\r\n+\r\n+    public Object getReducedValueAccelerated(Object ctx, Object thisValue, VariableResolverFactory factory) {\r\n+        VariableResolver vResolver = factory.getVariableResolver(name);\r\n+        Object o = vResolver.getValue();\r\n+        vResolver.setValue(doOperations(o, Operator.SUB, 1));\r\n+        return o;\r\n+    }\r\n+\r\n+    public Object getReducedValue(Object ctx, Object thisValue, VariableResolverFactory factory) {\r\n+        return getReducedValueAccelerated(ctx, thisValue, factory);\r\n+    }\r\n+}\r\ndiff --git a/src/main/java/org/mvel/ast/PostFixIncNode.java b/src/main/java/org/mvel/ast/PostFixIncNode.java\nnew file mode 100644\nindex 0000000..9dabc60\n--- /dev/null\n+++ b/src/main/java/org/mvel/ast/PostFixIncNode.java\n@@ -0,0 +1,31 @@\n+package org.mvel.ast;\r\n+\r\n+import org.mvel.ASTNode;\r\n+import org.mvel.Operator;\r\n+import org.mvel.integration.VariableResolver;\r\n+import org.mvel.integration.VariableResolverFactory;\r\n+import static org.mvel.util.ParseTools.doOperations;\r\n+\r\n+/**\r\n+ * @author Christopher Brock\r\n+ */\r\n+public class PostFixIncNode extends ASTNode {\r\n+    private String name;\r\n+\r\n+    public PostFixIncNode(char[] expr, int fields) {\r\n+        super(expr, fields);\r\n+        name = new String(expr);\r\n+    }\r\n+\r\n+\r\n+    public Object getReducedValueAccelerated(Object ctx, Object thisValue, VariableResolverFactory factory) {\r\n+        VariableResolver vResolver = factory.getVariableResolver(name);\r\n+        Object o = vResolver.getValue();\r\n+        vResolver.setValue(doOperations(o, Operator.ADD, 1));\r\n+        return o;\r\n+    }\r\n+\r\n+    public Object getReducedValue(Object ctx, Object thisValue, VariableResolverFactory factory) {\r\n+        return getReducedValueAccelerated(ctx, thisValue, factory);\r\n+    }\r\n+}\r\ndiff --git a/src/main/java/org/mvel/ast/PreFixDecNode.java b/src/main/java/org/mvel/ast/PreFixDecNode.java\nnew file mode 100644\nindex 0000000..96ed82f\n--- /dev/null\n+++ b/src/main/java/org/mvel/ast/PreFixDecNode.java\n@@ -0,0 +1,30 @@\n+package org.mvel.ast;\r\n+\r\n+import org.mvel.ASTNode;\r\n+import org.mvel.Operator;\r\n+import org.mvel.integration.VariableResolver;\r\n+import org.mvel.integration.VariableResolverFactory;\r\n+import static org.mvel.util.ParseTools.doOperations;\r\n+\r\n+/**\r\n+ * @author Christopher Brock\r\n+ */\r\n+public class PreFixDecNode extends ASTNode {\r\n+    private String name;\r\n+\r\n+    public PreFixDecNode(char[] expr, int fields) {\r\n+        super(expr, fields);\r\n+        name = new String(expr);\r\n+    }\r\n+\r\n+    public Object getReducedValueAccelerated(Object ctx, Object thisValue, VariableResolverFactory factory) {\r\n+        VariableResolver vResolver = factory.getVariableResolver(name);\r\n+        Object o;\r\n+        vResolver.setValue(o = doOperations(vResolver.getValue(), Operator.SUB, 1));\r\n+        return o;\r\n+    }\r\n+\r\n+    public Object getReducedValue(Object ctx, Object thisValue, VariableResolverFactory factory) {\r\n+        return getReducedValueAccelerated(ctx, thisValue, factory);\r\n+    }\r\n+}\r\ndiff --git a/src/main/java/org/mvel/ast/PreFixIncNode.java b/src/main/java/org/mvel/ast/PreFixIncNode.java\nnew file mode 100644\nindex 0000000..34483b9\n--- /dev/null\n+++ b/src/main/java/org/mvel/ast/PreFixIncNode.java\n@@ -0,0 +1,30 @@\n+package org.mvel.ast;\r\n+\r\n+import org.mvel.ASTNode;\r\n+import org.mvel.Operator;\r\n+import org.mvel.integration.VariableResolver;\r\n+import org.mvel.integration.VariableResolverFactory;\r\n+import static org.mvel.util.ParseTools.doOperations;\r\n+\r\n+/**\r\n+ * @author Christopher Brock\r\n+ */\r\n+public class PreFixIncNode extends ASTNode {\r\n+    private String name;\r\n+\r\n+    public PreFixIncNode(char[] expr, int fields) {\r\n+        super(expr, fields);\r\n+        name = new String(expr);\r\n+    }\r\n+\r\n+    public Object getReducedValueAccelerated(Object ctx, Object thisValue, VariableResolverFactory factory) {\r\n+        VariableResolver vResolver = factory.getVariableResolver(name);\r\n+        Object o;\r\n+        vResolver.setValue(o = doOperations(vResolver.getValue(), Operator.ADD, 1));\r\n+        return o;\r\n+    }\r\n+\r\n+    public Object getReducedValue(Object ctx, Object thisValue, VariableResolverFactory factory) {\r\n+        return getReducedValueAccelerated(ctx, thisValue, factory);\r\n+    }\r\n+}\r\ndiff --git a/src/main/java/org/mvel/util/ParseTools.java b/src/main/java/org/mvel/util/ParseTools.java\nindex 87b50a0..d1392ec 100644\n--- a/src/main/java/org/mvel/util/ParseTools.java\n+++ b/src/main/java/org/mvel/util/ParseTools.java\n@@ -22,15 +22,12 @@ import java.util.*;\n \n public class ParseTools {\n     public static final Object[] EMPTY_OBJ_ARR = new Object[0];\n-//    public static final MathContext MATH_CONTEXT = MathContext.DECIMAL128;\n-\n     public static final MathProcessor MATH_PROCESSOR;\n \n     static {\n         try {\n             double version = parseDouble(System.getProperty(\"java.version\").substring(0, 3));\n             if (version == 1.4) {\n-\n                 MATH_PROCESSOR = (MathProcessor) forName(\"org.mvel.math.JDK14CompatabilityMath\").newInstance();\n             }\n             else if (version > 1.4) {\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CompiledUnitTest.java b/src/test/java/org/mvel/tests/main/CompiledUnitTest.java\nindex 88653e7..c0c7190 100644\n--- a/src/test/java/org/mvel/tests/main/CompiledUnitTest.java\n+++ b/src/test/java/org/mvel/tests/main/CompiledUnitTest.java\n@@ -635,10 +635,11 @@ public class CompiledUnitTest extends TestCase {\n     public void testFunctionPointerAsParam() {\n         assertEquals(\"2.0\", parseDirect(\"squareRoot = Math.sqrt; new String(String.valueOf(squareRoot(4)));\"));\n     }\n-//\n-//    public void testIncrementOperator() {\n-//        assertEquals(2, parseDirect(\"x = 1; x++;\"));\n-//    }\n+\n+    //\n+    public void testIncrementOperator() {\n+        assertEquals(2, parseDirect(\"x = 1; x++; x\"));\n+    }\n //\n //    public void testDecrementOperator() {\n //        assertEquals(1, parseDirect(\"x = 2; x--;\"));\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T19:39:01.991991Z", "commit_hash": "f0abb3cf3800e580a3157a68bde789c1483271a9", "commit_message": "fix to bean method accessor generation rules.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/ASTNode.java b/src/main/java/org/mvel/ASTNode.java\nindex a011816..dfa3127 100644\n--- a/src/main/java/org/mvel/ASTNode.java\n+++ b/src/main/java/org/mvel/ASTNode.java\n@@ -26,7 +26,6 @@ import org.mvel.optimizers.OptimizationNotSupported;\n import static org.mvel.optimizers.OptimizerFactory.*;\n import org.mvel.util.ArrayTools;\n import static org.mvel.util.ArrayTools.findFirst;\n-import org.mvel.util.ParseTools;\n import static org.mvel.util.ParseTools.handleEscapeSequence;\n import static org.mvel.util.PropertyTools.handleNumericConversion;\n import static org.mvel.util.PropertyTools.isNumber;\n@@ -361,10 +360,9 @@ public class ASTNode implements Cloneable, Serializable {\n                 else {\n                     int mBegin = ArrayTools.findFirst('(', name);\n                     if (mBegin != -1) {\n-                        VariableResolverFactory vrf = ParseTools.findStaticMethodImportResolverFactory(factory);\n-                        if (vrf.isTarget(s = new String(name, 0, mBegin))) {\n-                            Method m = (Method) vrf.getVariableResolver(s).getValue();\n-                            return valRet(get(name, m.getDeclaringClass(), factory, thisValue));\n+                        if (factory.isResolveable(s = new String(name, 0, mBegin))) {\n+                            Method m = (Method) factory.getVariableResolver(s).getValue();\n+                            return valRet(get(m.getName(), m.getDeclaringClass(), factory, thisValue));\n                         }\n                     }\n                 }\ndiff --git a/src/main/java/org/mvel/PropertyAccessor.java b/src/main/java/org/mvel/PropertyAccessor.java\nindex 621bae2..04947d8 100644\n--- a/src/main/java/org/mvel/PropertyAccessor.java\n+++ b/src/main/java/org/mvel/PropertyAccessor.java\n@@ -390,10 +390,17 @@ public class PropertyAccessor {\n         else if (\"this\".equals(property)) {\r\n             return this.thisReference;\r\n         }\r\n+        else if (ctx instanceof Class) {\r\n+            Class c = (Class) ctx;\r\n+            for (Method m : c.getMethods()) {\r\n+                if (property.equals(m.getName())) {\r\n+                    return m;\r\n+                }\r\n+            }\r\n+\r\n \r\n-        else {\r\n-            throw new PropertyAccessException(\"could not access property (\" + property + \")\");\r\n         }\r\n+        throw new PropertyAccessException(\"could not access property (\" + property + \")\");\r\n     }\r\n \r\n     private void whiteSpaceSkip() {\r\ndiff --git a/src/main/java/org/mvel/optimizers/impl/asm/ASMAccessorOptimizer.java b/src/main/java/org/mvel/optimizers/impl/asm/ASMAccessorOptimizer.java\nindex 3949ac4..374868b 100644\n--- a/src/main/java/org/mvel/optimizers/impl/asm/ASMAccessorOptimizer.java\n+++ b/src/main/java/org/mvel/optimizers/impl/asm/ASMAccessorOptimizer.java\n@@ -20,10 +20,7 @@ package org.mvel.optimizers.impl.asm;\n \r\n import org.mvel.*;\r\n import static org.mvel.MVEL.compileExpression;\r\n-import org.mvel.asm.ClassWriter;\r\n-import org.mvel.asm.FieldVisitor;\r\n-import org.mvel.asm.MethodVisitor;\r\n-import org.mvel.asm.Opcodes;\r\n+import org.mvel.asm.*;\r\n import static org.mvel.asm.Opcodes.*;\r\n import static org.mvel.asm.Type.*;\r\n import org.mvel.ast.NewObjectASTNode;\r\n@@ -72,6 +69,7 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n     private static final Object[] EMPTYARG = new Object[0];\r\n \r\n     private boolean first = true;\r\n+    private boolean deferFinish = false;\r\n \r\n     private String className;\r\n     private ClassWriter cw;\r\n@@ -140,25 +138,29 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n     }\r\n \r\n     private void _finishJIT() {\r\n-        if (returnType != null && returnType.isPrimitive()) {\r\n-            //noinspection unchecked\r\n-            wrapPrimitive(returnType);\r\n-        }\r\n+        if (!deferFinish) {\r\n \r\n-        if (returnType == void.class) {\r\n-            debug(\"ACONST_NULL\");\r\n-            mv.visitInsn(ACONST_NULL);\r\n-        }\r\n+            if (returnType != null && returnType.isPrimitive()) {\r\n+                //noinspection unchecked\r\n+                wrapPrimitive(returnType);\r\n+            }\r\n \r\n-        debug(\"ARETURN\");\r\n+            if (returnType == void.class) {\r\n+                debug(\"ACONST_NULL\");\r\n+                mv.visitInsn(ACONST_NULL);\r\n+            }\r\n \r\n-        mv.visitInsn(ARETURN);\r\n+            debug(\"ARETURN\");\r\n+\r\n+            mv.visitInsn(ARETURN);\r\n+        }\r\n \r\n         debug(\"\\n{METHOD STATS (maxstack=\" + stacksize + \")}\\n\");\r\n         mv.visitMaxs(stacksize, 1);\r\n \r\n         mv.visitEnd();\r\n \r\n+\r\n         buildInputs();\r\n \r\n         cw.visitEnd();\r\n@@ -252,7 +254,6 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n         Class cls = (ctx instanceof Class ? ((Class) ctx) : ctx != null ? ctx.getClass() : null);\r\n         Member member = cls != null ? PropertyTools.getFieldOrAccessor(cls, property) : null;\r\n \r\n-\r\n         if (first && variableFactory != null && variableFactory.isResolveable(property)) {\r\n             try {\r\n                 debug(\"ALOAD 3\");\r\n@@ -390,8 +391,57 @@ public class ASMAccessorOptimizer extends AbstractOptimizer implements AccessorO\n                 }\r\n \r\n             }\r\n-            else\r\n-                throw new PropertyAccessException(\"could not access property (\" + property + \")\");\r\n+            else if (ctx instanceof Class) {\r\n+                Class c = (Class) ctx;\r\n+                for (Method m : c.getMethods()) {\r\n+                    if (property.equals(m.getName())) {\r\n+\r\n+                        mv.visitLdcInsn(getType(\"Ljava/lang/Math;\"));\r\n+                        mv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Class\", \"getMethods\", \"()[Ljava/lang/reflect/Method;\");\r\n+                        mv.visitVarInsn(ASTORE, 7);\r\n+                        mv.visitInsn(ICONST_0);\r\n+                        mv.visitVarInsn(ISTORE, 5);\r\n+                        mv.visitVarInsn(ALOAD, 7);\r\n+                        mv.visitInsn(ARRAYLENGTH);\r\n+                        mv.visitVarInsn(ISTORE, 6);\r\n+                        Label l1 = new Label();\r\n+                        mv.visitJumpInsn(GOTO, l1);\r\n+                        Label l2 = new Label();\r\n+                        mv.visitLabel(l2);\r\n+                        mv.visitVarInsn(ALOAD, 7);\r\n+                        mv.visitVarInsn(ILOAD, 5);\r\n+                        mv.visitInsn(AALOAD);\r\n+                        mv.visitVarInsn(ASTORE, 4);\r\n+                        Label l3 = new Label();\r\n+                        mv.visitLabel(l3);\r\n+                        mv.visitLdcInsn(m.getName());\r\n+                        mv.visitVarInsn(ALOAD, 4);\r\n+                        mv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/reflect/Method\", \"getName\", \"()Ljava/lang/String;\");\r\n+                        mv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/String\", \"equals\", \"(Ljava/lang/Object;)Z\");\r\n+                        Label l4 = new Label();\r\n+                        mv.visitJumpInsn(IFEQ, l4);\r\n+                        Label l5 = new Label();\r\n+                        mv.visitLabel(l5);\r\n+                        mv.visitVarInsn(ALOAD, 4);\r\n+                        mv.visitInsn(ARETURN);\r\n+                        mv.visitLabel(l4);\r\n+                        mv.visitIincInsn(5, 1);\r\n+                        mv.visitLabel(l1);\r\n+                        mv.visitVarInsn(ILOAD, 5);\r\n+                        mv.visitVarInsn(ILOAD, 6);\r\n+                        mv.visitJumpInsn(IF_ICMPLT, l2);\r\n+                        Label l6 = new Label();\r\n+                        mv.visitLabel(l6);\r\n+                        mv.visitInsn(ACONST_NULL);\r\n+                        mv.visitInsn(ARETURN);\r\n+\r\n+                        return m;\r\n+                    }\r\n+                }\r\n+            }\r\n+\r\n+\r\n+            throw new PropertyAccessException(\"could not access property (\" + property + \")\");\r\n         }\r\n     }\r\n \r\ndiff --git a/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java b/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\nindex 095cc0b..f583889 100644\n--- a/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\n+++ b/src/main/java/org/mvel/optimizers/impl/refl/ReflectiveAccessorOptimizer.java\n@@ -180,6 +180,8 @@ public class ReflectiveAccessorOptimizer extends AbstractOptimizer implements Ac\n             return ((Field) member).get(ctx);\r\n         }\r\n         else if (member != null) {\r\n+            System.out.println(\"member = \" + member);\r\n+\r\n             Object o;\r\n \r\n             try {\r\ndiff --git a/src/main/java/org/mvel/util/ReflectionUtil.java b/src/main/java/org/mvel/util/ReflectionUtil.java\nindex 5944ba6..4cf2e83 100644\n--- a/src/main/java/org/mvel/util/ReflectionUtil.java\n+++ b/src/main/java/org/mvel/util/ReflectionUtil.java\n@@ -1,12 +1,11 @@\n package org.mvel.util;\n \n-import static java.util.regex.Pattern.compile;\n-\n import java.lang.reflect.Field;\n import java.lang.reflect.Method;\n import java.util.HashSet;\n import java.util.Set;\n import java.util.regex.Pattern;\n+import static java.util.regex.Pattern.compile;\n \n /**\n  * Utilities for working with reflection.\n@@ -28,8 +27,12 @@ public class ReflectionUtil {\n         chars[1] = 'e';\n         chars[2] = 't';\n \n-        if (s.charAt(0) > 'Z')\n+        if (s.charAt(0) > 'Z') {\n             chars[3] = (char) (s.charAt(0) - ('z' - 'Z'));\n+        }\n+        else {\n+            chars[3] = s.charAt(0);\n+        }\n \n         for (int i = s.length() - 1; i != 0; i--) {\n             chars[i + 3] = s.charAt(i);\n@@ -47,8 +50,12 @@ public class ReflectionUtil {\n         chars[1] = 'e';\n         chars[2] = 't';\n \n-        if (s.charAt(0) > 'Z')\n+        if (c[0] > 'Z') {\n             chars[3] = (char) (c[0] - ('z' - 'Z'));\n+        }\n+        else {\n+            chars[3] = (c[0]);\n+        }\n \n         System.arraycopy(c, 1, chars, 4, c.length - 1);\n \n@@ -63,8 +70,12 @@ public class ReflectionUtil {\n         chars[0] = 'i';\n         chars[1] = 's';\n \n-        if (s.charAt(0) > 'Z')\n+        if (s.charAt(0) > 'Z') {\n             chars[2] = (char) (s.charAt(0) - ('z' - 'Z'));\n+        }\n+        else {\n+            chars[2] = c[0];\n+        }\n \n         System.arraycopy(c, 1, chars, 3, c.length - 1);\n \n@@ -138,5 +149,5 @@ public class ReflectionUtil {\n         for (Field fld : cls.getFields()) allFields.add(fld);\n         return allFields;\n     }\n-    \n+\n }\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/AccessorBMModel.java b/src/test/java/org/mvel/tests/AccessorBMModel.java\nindex f318579..d5c83bb 100644\n--- a/src/test/java/org/mvel/tests/AccessorBMModel.java\n+++ b/src/test/java/org/mvel/tests/AccessorBMModel.java\n@@ -1,17 +1,25 @@\n package org.mvel.tests;\r\n \r\n import org.mvel.Accessor;\r\n-import org.mvel.DataConversion;\r\n import org.mvel.ExecutableStatement;\r\n import org.mvel.integration.VariableResolverFactory;\r\n \r\n+import java.lang.reflect.Method;\r\n+\r\n \r\n public class AccessorBMModel implements Accessor {\r\n     private ExecutableStatement p0;\r\n \r\n \r\n     public Object getValue(Object ctx, Object elCtx, VariableResolverFactory variableFactory) {\r\n-        return Math.sqrt(DataConversion.convert(p0.getValue(ctx, variableFactory), Double.class).doubleValue());\r\n+        // return Math.sqrt(DataConversion.convert(p0.getValue(ctx, variableFactory), Double.class).doubleValue());\r\n+        for (Method m : Math.class.getMethods()) {\r\n+            if (\"sqrt\".equals(m.getName())) {\r\n+                return m;\r\n+            }\r\n+        }\r\n+\r\n+        return null;\r\n     }\r\n \r\n \r\ndiff --git a/src/test/java/org/mvel/tests/main/CompiledUnitTest.java b/src/test/java/org/mvel/tests/main/CompiledUnitTest.java\nindex 78b8cb0..8ce9966 100644\n--- a/src/test/java/org/mvel/tests/main/CompiledUnitTest.java\n+++ b/src/test/java/org/mvel/tests/main/CompiledUnitTest.java\n@@ -61,6 +61,10 @@ public class CompiledUnitTest extends TestCase {\n         assertEquals(\"dog\", parseDirect(\"foo.bar.name\"));\n     }\n \n+    public void testSimpleProperty2() {\n+        assertEquals(\"cat\", parseDirect(\"DATA\"));\n+    }\n+\n     public void testPropertyViaDerivedClass() {\n         assertEquals(\"cat\", parseDirect(\"derived.data\"));\n     }\ndiff --git a/src/test/java/org/mvel/tests/main/res/Base.java b/src/test/java/org/mvel/tests/main/res/Base.java\nindex e92a503..0941643 100644\n--- a/src/test/java/org/mvel/tests/main/res/Base.java\n+++ b/src/test/java/org/mvel/tests/main/res/Base.java\n@@ -80,4 +80,8 @@ public class Base {\n     public String appendTwoStrings(String a, String b) {\n         return a + b;\n     }\n+\n+    public String getDATA() {\n+        return data;\n+    }\n }\ndiff --git a/src/test/java/org/mvel/tests/perftests/ELComparisons.java b/src/test/java/org/mvel/tests/perftests/ELComparisons.java\nindex 50a63aa..75f0f6c 100644\n--- a/src/test/java/org/mvel/tests/perftests/ELComparisons.java\n+++ b/src/test/java/org/mvel/tests/perftests/ELComparisons.java\n@@ -34,7 +34,7 @@ public class ELComparisons implements Runnable {\n     private static int ALL = RUN_MVEL + RUN_OGNL + RUN_COMMONS_EL + RUN_JAVA_NATIVE;\n \n     private static final int TESTNUM = 10000;\n-    private static final int TESTITER = 5;\n+    private static final int TESTITER = 3;\n \n     private long ognlTotal = 0;\n     private long mvelTotal = 0;\n@@ -50,14 +50,16 @@ public class ELComparisons implements Runnable {\n     private final static Map<String, Object> variables = new HashMap<String, Object>();\n \n     static {\n-        NativeTest nt = new NativeTest() {\n+        NativeTest nt;\n \n-            public Object run(Object baseClass, Map vars) {\n-                return \"Hello World\";\n-            }\n-        };\n-\n-        tests.add(new PerfTest(\"Simple String Pass-Through\", \"'Hello World'\", ALL, nt));\n+//        nt = new NativeTest() {\n+//\n+//            public Object run(Object baseClass, Map vars) {\n+//                return \"Hello World\";\n+//            }\n+//        };\n+//\n+//        tests.add(new PerfTest(\"Simple String Pass-Through\", \"'Hello World'\", ALL, nt));\n \n         nt = new NativeTest() {\n \n@@ -74,7 +76,7 @@ public class ELComparisons implements Runnable {\n             }\n         };\n \n-        //     tests.add(new PerfTest(\"Deep Property\", \"foo.bar.name\", ALL, nt));\n+//          tests.add(new PerfTest(\"Deep Property\", \"foo.bar.name\", ALL, nt));\n //        tests.add(new PerfTest(\"Static Field Access (MVEL)\", \"Integer.MAX_VALUE\", RUN_MVEL));\n //        tests.add(new PerfTest(\"Static Field Access (OGNL)\", \"@java.lang.Integer@MAX_VALUE\", RUN_OGNL));\n //        tests.add(new PerfTest(\"Inline Array Creation (MVEL)\", \"{'foo', 'bar'}\", RUN_MVEL));\n@@ -87,11 +89,18 @@ public class ELComparisons implements Runnable {\n             }\n         };\n \n+        nt = new NativeTest() {\n+\n+            public Object run(Object baseClass, Map vars) {\n+                return 10 + 1 - 1;\n+            }\n+        };\n+\n         //      tests.add(new PerfTest(\"Collection Access + Method Call\", \"funMap['foo'].happy()\", RUN_MVEL + RUN_OGNL + RUN_JAVA_NATIVE, nt));\n //        tests.add(new PerfTest(\"Boolean compare\", \"data == 'cat'\", ALL));\n //        tests.add(new PerfTest(\"Object instantiation\", \"new String('Hello')\", RUN_OGNL + RUN_MVEL));\n //        tests.add(new PerfTest(\"Method access\", \"readBack('this is a string')\", RUN_OGNL + RUN_MVEL));\n-//        tests.add(new PerfTest(\"Arithmetic\", \"10 + 1 - 1\", ALL));\n+        tests.add(new PerfTest(\"Arithmetic\", \"10 + 1 - 1\", ALL, nt));\n     }\n \n \n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T19:42:33.621027Z", "commit_hash": "355c3d040fd80c26f0397ce4419c60e0952fd7be", "commit_message": "fixed problems with compiled statements.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/ExpressionCompiler.java b/src/main/java/org/mvel/ExpressionCompiler.java\nindex 5ffeb69..1c17d04 100644\n--- a/src/main/java/org/mvel/ExpressionCompiler.java\n+++ b/src/main/java/org/mvel/ExpressionCompiler.java\n@@ -27,6 +27,8 @@ public class ExpressionCompiler extends AbstractParser {\n         }\r\n \r\n         while ((tk = nextToken()) != null) {\r\n+\r\n+\r\n             if (tk.isSubeval()) {\r\n                 ExpressionCompiler subCompiler = new ExpressionCompiler(tk.getNameAsArray());\r\n                 tk.setAccessor(subCompiler.compile(verifying));\r\n@@ -104,10 +106,14 @@ public class ExpressionCompiler extends AbstractParser {\n                     }\r\n                 }\r\n                 else {\r\n-\r\n+                    if (tk.isDiscard()) {\r\n+                        tokenSet.addTokenNode(tkOp);\r\n+                        continue;\r\n+                    }\r\n \r\n                     tokenSet.addTokenNode(tk);\r\n                     if (tkOp != null) tokenSet.addTokenNode(tkOp);\r\n+\r\n                     continue;\r\n                 }\r\n             }\r\ndiff --git a/src/main/java/org/mvel/TokenSet.java b/src/main/java/org/mvel/TokenSet.java\nindex b8ebe87..babaf34 100644\n--- a/src/main/java/org/mvel/TokenSet.java\n+++ b/src/main/java/org/mvel/TokenSet.java\n@@ -72,10 +72,6 @@ public class TokenSet implements TokenIterator {\n         finally {\n             current = current.nextASTNode;\n         }\n-\n-        // Token tk = current.token;\n-        //  current = current.next;\n-        //  return tk;\n     }\n \n \n@@ -92,9 +88,6 @@ public class TokenSet implements TokenIterator {\n             return null;\n     }\n \n-//    public boolean peekNextTokenFlags(int flags) {\n-//        return current != null && (flags & current.nextToken.getFlags()) != 0;\n-//    }\n \n     public ASTNode peekToken() {\n         if (current == null) return null;\n@@ -124,7 +117,6 @@ public class TokenSet implements TokenIterator {\n         throw new RuntimeException(\"unimplemented\");\n     }\n \n-\n     public int size() {\n         return size;\n     }\ndiff --git a/src/main/java/org/mvel/ast/TypedVarASTNode.java b/src/main/java/org/mvel/ast/TypedVarASTNode.java\nindex ce0207c..6f8850e 100644\n--- a/src/main/java/org/mvel/ast/TypedVarASTNode.java\n+++ b/src/main/java/org/mvel/ast/TypedVarASTNode.java\n@@ -4,6 +4,7 @@ import org.mvel.ASTNode;\n import org.mvel.ExecutableStatement;\r\n import static org.mvel.MVEL.compileExpression;\r\n import org.mvel.integration.VariableResolverFactory;\r\n+import static org.mvel.util.ParseTools.finalLocalVariableFactory;\r\n import static org.mvel.util.ParseTools.subset;\r\n import static org.mvel.util.PropertyTools.find;\r\n \r\n@@ -33,7 +34,9 @@ public class TypedVarASTNode extends ASTNode {\n     public Object getReducedValueAccelerated(Object ctx, Object thisValue, VariableResolverFactory factory) {\r\n         if (statement != null) {\r\n             Object o = statement.getValue(ctx, thisValue, factory);\r\n-            factory.createVariable(name, o, type);\r\n+\r\n+            finalLocalVariableFactory(factory).createVariable(name, o, type);\r\n+\r\n             return Void.class;\r\n         }\r\n         else {\r\ndiff --git a/src/main/java/org/mvel/debug/DebugTools.java b/src/main/java/org/mvel/debug/DebugTools.java\nindex 3fd158e..7effba8 100644\n--- a/src/main/java/org/mvel/debug/DebugTools.java\n+++ b/src/main/java/org/mvel/debug/DebugTools.java\n@@ -44,6 +44,9 @@ public class DebugTools {\n             else if (tk.isIdentifier()) {\r\n                 sbuf.append(\"PUSH VAR :: \").append(tk.getName());\r\n             }\r\n+            else {\r\n+                sbuf.append(\"ASTNODE [\" + tk.getName() + \"]\");\r\n+            }\r\n \r\n             sbuf.append(\"\\n\");\r\n \r\ndiff --git a/src/main/java/org/mvel/integration/impl/MapVariableResolver.java b/src/main/java/org/mvel/integration/impl/MapVariableResolver.java\nindex 3dfa0fc..a91d326 100644\n--- a/src/main/java/org/mvel/integration/impl/MapVariableResolver.java\n+++ b/src/main/java/org/mvel/integration/impl/MapVariableResolver.java\n@@ -60,13 +60,6 @@ public class MapVariableResolver implements VariableResolver {\n     }\r\n \r\n     public Class getKnownType() {\r\n-        if (knownType == null && variableMap.containsKey(name)) {\r\n-            knownType = variableMap.get(name) != null ? variableMap.get(name).getClass() : Object.class;\r\n-        }\r\n-        else {\r\n-            knownType = Object.class;\r\n-        }\r\n-\r\n         return knownType;\r\n     }\r\n \r\ndiff --git a/src/main/java/org/mvel/integration/impl/MapVariableResolverFactory.java b/src/main/java/org/mvel/integration/impl/MapVariableResolverFactory.java\nindex 9a0af66..710b466 100644\n--- a/src/main/java/org/mvel/integration/impl/MapVariableResolverFactory.java\n+++ b/src/main/java/org/mvel/integration/impl/MapVariableResolverFactory.java\n@@ -55,8 +55,8 @@ public class MapVariableResolverFactory implements VariableResolverFactory {\n \r\n     public VariableResolver createVariable(String name, Object value, Class<?> type) {\r\n         VariableResolver vr = getVariableResolver(name);\r\n-        if (vr != null) {\r\n-            throw new CompileException(\"variable already defined within scope: \" + name);\r\n+        if (vr != null && vr.getKnownType() != null) {\r\n+            throw new CompileException(\"variable already defined within scope: \" + vr.getKnownType() + \" \" + name);\r\n         }\r\n         else {\r\n             addResolver(name, vr = new MapVariableResolver(variables, name, type));\r\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CompiledUnitTest.java b/src/test/java/org/mvel/tests/main/CompiledUnitTest.java\nindex 527fe94..9a51b00 100644\n--- a/src/test/java/org/mvel/tests/main/CompiledUnitTest.java\n+++ b/src/test/java/org/mvel/tests/main/CompiledUnitTest.java\n@@ -598,6 +598,10 @@ public class CompiledUnitTest extends TestCase {\n         assertEquals(5, parseDirect(\"intArray.size()\"));\n     }\n \n+    public void testStaticVarAssignment() {\n+        assertEquals(\"1\", parseDirect(\"String mikeBrock = 1; mikeBrock\"));\n+    }\n+\n     public void testVarInputs() {\n         ExpressionCompiler compiler = new ExpressionCompiler(\"test != foo && bo.addSomething(trouble); bleh = foo; twa = bleh\");\n         compiler.compile(true);\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T19:43:24.147262Z", "commit_hash": "f59c1c98173ac28191d76d3fb11331d58dc89fe4", "commit_message": "quick bug fix in parser.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/AbstractParser.java b/src/main/java/org/mvel/AbstractParser.java\nindex 8fb1cad..a596f33 100644\n--- a/src/main/java/org/mvel/AbstractParser.java\n+++ b/src/main/java/org/mvel/AbstractParser.java\n@@ -695,7 +695,6 @@ public class AbstractParser {\n         else if (isFlag(Token.BLOCK_FOREACH) || isFlag(Token.BLOCK_WITH)) {\r\n             skipToNextTokenJunction();\r\n             skipWhitespace();\r\n-\r\n             return _captureBlock(null, expr, true);\r\n         }\r\n \r\n@@ -720,7 +719,7 @@ public class AbstractParser {\n         skipWhitespace();\r\n \r\n         if (expr[cursor] == '{') {\r\n-            blockStart = ++cursor;\r\n+            blockStart = cursor;\r\n             if ((blockEnd = balancedCapture('{')) == -1) {\r\n                 throw new CompileException(\"unbalanced braces { }\", expr, cursor);\r\n             }\r\n@@ -736,11 +735,11 @@ public class AbstractParser {\n \r\n             if (node != null) {\r\n                 if (!cond) {\r\n-                    ifNode.setElseBlock(subArray(trimRight(blockStart), trimLeft(blockEnd - 1)));\r\n+                    ifNode.setElseBlock(subArray(trimRight(blockStart + 1), trimLeft(blockEnd - 1)));\r\n                     return node;\r\n                 }\r\n                 else {\r\n-                    IfToken tk = (IfToken) createBlockToken(startCond, endCond, trimRight(blockStart),\r\n+                    IfToken tk = (IfToken) createBlockToken(startCond, endCond, trimRight(blockStart + 1),\r\n                             trimLeft(blockEnd));\r\n \r\n                     ifNode.setElseIf(tk);\r\ndiff --git a/src/main/java/org/mvel/block/WithToken.java b/src/main/java/org/mvel/block/WithToken.java\nindex f92c02a..ad007ab 100644\n--- a/src/main/java/org/mvel/block/WithToken.java\n+++ b/src/main/java/org/mvel/block/WithToken.java\n@@ -24,6 +24,8 @@ public class WithToken extends BlockToken {\n         super(expr, fields, block);\r\n         name = new String(expr).trim();\r\n \r\n+        System.out.println(\"<<\" + new String(block) + \">>\");\r\n+\r\n         compileWithExpressions();\r\n     }\r\n \r\n@@ -87,7 +89,6 @@ public class WithToken extends BlockToken {\n         }\r\n \r\n         if (parm != null && start != block.length) {\r\n-\r\n             parms.add(new ParmValuePair(\r\n                     parm,\r\n                     (ExecutableStatement) compileExpression(subset(block, start, block.length - start)))\r\n@@ -105,6 +106,7 @@ public class WithToken extends BlockToken {\n         }\r\n \r\n         public ParmValuePair(String parameter, ExecutableStatement statement) {\r\n+            System.out.println(\"adding parm [\" + parameter + \"]\");\r\n             this.parameter = parameter;\r\n             this.statement = statement;\r\n         }\r\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/CompiledUnitTest.java b/src/test/java/org/mvel/tests/main/CompiledUnitTest.java\nindex dbf3f22..1e54198 100644\n--- a/src/test/java/org/mvel/tests/main/CompiledUnitTest.java\n+++ b/src/test/java/org/mvel/tests/main/CompiledUnitTest.java\n@@ -560,7 +560,7 @@ public class CompiledUnitTest extends TestCase {\n     }\n \n     public void testWith() {\n-        assertEquals(\"OneTwo\", parseDirect(\"with (foo) { aValue = 'One', bValue='Two' }; foo.aValue + foo.bValue;\"));\n+        assertEquals(\"OneTwo\", parseDirect(\"with (foo) {aValue = 'One',bValue='Two'}; foo.aValue + foo.bValue;\"));\n     }\n \n     public void testVarInputs() {\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T19:44:11.838689Z", "commit_hash": "ccb9cf1abdd7dc2499586bc03ae0fc180714d37e", "commit_message": "-fixed params error for IncludeByRef, incorrect positions while determining params.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/TemplateCompiler.java b/src/main/java/org/mvel/TemplateCompiler.java\nindex 0516514..843db28 100644\n--- a/src/main/java/org/mvel/TemplateCompiler.java\n+++ b/src/main/java/org/mvel/TemplateCompiler.java\n@@ -311,11 +311,11 @@ public class TemplateCompiler {\n         while (i < text.length && text[i++] != '(') ;\n         if (i == text.length) throw new ParseException(\"expected '('\");\n \n-        int end = i;\n+        int end = i-1;\n \n-        String name = new String(text, start, end - start - 1);\n+        String name = new String(text, start, end - start);\n \n-        Map<String, String> parmVars = parseParameters(subset(text, end, balancedCapture(text, i, ')') - end));\n+        Map<String, String> parmVars = parseParameters(subset(text, end+1, balancedCapture(text, end, ')') - end));\n         List<IncludeRefParam> params = new ArrayList<IncludeRefParam>();\n \n         for (String k : parmVars.keySet()) {\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/ParserUnitTest.java b/src/test/java/org/mvel/tests/main/ParserUnitTest.java\nindex 679f5d9..e192d7f 100644\n--- a/src/test/java/org/mvel/tests/main/ParserUnitTest.java\n+++ b/src/test/java/org/mvel/tests/main/ParserUnitTest.java\n@@ -670,6 +670,13 @@ public class ParserUnitTest extends TestCase {\n         assertEquals(\"xvalue1catx\", parse(\"x@includeByRef{templateName(var1 = \\\"value1\\\", var2 = c)}x\", registry));\n     }\n     \n+    public void testIncludeByRefNoParams() {\n+        TemplateRegistry registry = new MVELTemplateRegistry();\n+        registry.registerTemplate(\"templateName\", \"hello\");\n+\n+        assertEquals(\"xhellox\", parse(\"x@includeByRef{templateName()}x\", registry));\n+    }    \n+    \n     public void testIncludeByRefNoSpaces() {\n         TemplateRegistry registry = new MVELTemplateRegistry();\n         registry.registerTemplate(\"templateName\", \"@{var1}@{var2}\");\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T19:44:59.028780Z", "commit_hash": "3ba4a77f12e17dc58b9c7db1e1570736fe010676", "commit_message": "bugfix\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/TemplateCompiler.java b/src/main/java/org/mvel/TemplateCompiler.java\nindex 1b8b019..e37ac96 100644\n--- a/src/main/java/org/mvel/TemplateCompiler.java\n+++ b/src/main/java/org/mvel/TemplateCompiler.java\n@@ -265,8 +265,8 @@ public class TemplateCompiler {\n                         depth--;\n                 }\n \n-                System.out.println(indent(depth) + \" + Node (\" + e.getNode() + \") [\" + getNodeTypeName(e.getNodeType()) + \"] \" + e.getToken()\n-                        + \" {\" + e.getStartPos() + \",\" + e.getEndPos() + \"} --> \" + e.getEndNode());\n+                System.out.println(indent(depth) + \" + Node (\" + e.getNode() + \") [\" + getNodeTypeName(e.getNodeType()) + \"] \"\n+                        + \" {\" + e.getStartPos() + \",\" + e.getEndPos() + \"} --> \" + e.getEndNode() + \" ['\" + new String(expressionArray, e.getStartPos(), e.getEndPos() - e.getStartPos()) + \"']\");\n \n                 switch (e.getToken()) {\n                     case IF:\n@@ -284,7 +284,7 @@ public class TemplateCompiler {\n         return expressions;\n     }\n \n-    private static String getNodeTypeName(int node) {\n+    public static String getNodeTypeName(int node) {\n         switch (node) {\n             case NodeType.ELSE:\n                 return \"ELSE\";\ndiff --git a/src/main/java/org/mvel/TemplateInterpreter.java b/src/main/java/org/mvel/TemplateInterpreter.java\nindex 7d1043f..55fa312 100644\n--- a/src/main/java/org/mvel/TemplateInterpreter.java\n+++ b/src/main/java/org/mvel/TemplateInterpreter.java\n@@ -252,7 +252,7 @@ public class TemplateInterpreter {\n     public static Object parse(File file, Object ctx, Map<String, Object> tokens) throws IOException {\n         return parse(file, ctx, tokens, null);\n     }\n-    \n+\n     public static Object parse(File file, Object ctx, Map<String, Object> tokens, TemplateRegistry registry) throws IOException {\n         if (!file.exists())\n             throw new CompileException(\"cannot find file: \" + file.getName());\n@@ -294,6 +294,7 @@ public class TemplateInterpreter {\n     public static Object parse(CharSequence expression, Object ctx, Map<String, Object> vars) {\n         return parse(expression, ctx, vars, null);\n     }\n+\n     public static Object parse(CharSequence expression, Object ctx, Map<String, Object> vars, TemplateRegistry registry) {\n         if (expression == null) return null;\n         return new TemplateInterpreter(expression).execute(ctx, vars);\n@@ -302,7 +303,7 @@ public class TemplateInterpreter {\n     public static Object parse(String expression, Object ctx, Map<String, Object> vars) {\n         return parse(expression, ctx, vars, null);\n     }\n-    \n+\n     public static Object parse(String expression, Object ctx, Map<String, Object> vars, TemplateRegistry registry) {\n         if (expression == null) return null;\n \n@@ -312,7 +313,7 @@ public class TemplateInterpreter {\n     public Object execute(Object ctx, Map tokens) {\n         return execute(ctx, tokens, null);\n     }\n-    \n+\n     public Object execute(Object ctx, Map tokens, TemplateRegistry registry) {\n         if (nodes == null) {\n             return new String(expression);\n@@ -460,19 +461,19 @@ public class TemplateInterpreter {\n                     }\n                     case INCLUDE_BY_REF: {\n                         IncludeRef includeRef = (IncludeRef) nodes[node].getRegister();\n-                        \n+\n                         IncludeRefParam[] params = includeRef.getParams();\n                         Map vars = new HashMap(params.length * 2);\n                         for (int i = 0; i < params.length; i++) {\n                             vars.put(params[i].getIdentifier(), MVEL.eval(params[i].getValue(), ctx, tokens));\n                         }\n-                        \n-                        if ( registry == null ) {\n+\n+                        if (registry == null) {\n                             throw new CompileException(\"No TemplateRegistry specified, cannot load template='\" + includeRef.getName() + \"'\");\n                         }\n-                        String template = registry.getTemplate( includeRef.getName() );\n-                        \n-                        if ( template == null ) {\n+                        String template = registry.getTemplate(includeRef.getName());\n+\n+                        if (template == null) {\n                             throw new CompileException(\"Template does not exist in the TemplateRegistry, cannot load template='\" + includeRef.getName() + \"'\");\n                         }\n \n@@ -514,7 +515,7 @@ public class TemplateInterpreter {\n     }\n \n     private void exitContext() {\n-        node = nodes[node].getEndNode();\n+        node = nodes[node].getEndNode() - 1;\n     }\n \n     public void forwardAndPush() {\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/ParserUnitTest.java b/src/test/java/org/mvel/tests/main/ParserUnitTest.java\nindex 3ec6a02..652d944 100644\n--- a/src/test/java/org/mvel/tests/main/ParserUnitTest.java\n+++ b/src/test/java/org/mvel/tests/main/ParserUnitTest.java\n@@ -2,10 +2,9 @@ package org.mvel.tests.main;\n \n import junit.framework.TestCase;\n import org.mvel.MVEL;\n-\n import org.mvel.MVELTemplateRegistry;\n-import org.mvel.TemplateRegistry;\n import org.mvel.TemplateInterpreter;\n+import org.mvel.TemplateRegistry;\n import org.mvel.tests.main.res.Bar;\n import org.mvel.tests.main.res.Base;\n import org.mvel.tests.main.res.Foo;\n@@ -665,28 +664,32 @@ public class ParserUnitTest extends TestCase {\n     }\n \n     public void testIncludeByRef() {\n-        TemplateRegistry registry = new MVELTemplateRegistry();        \n-        registry.registerTemplate( \"templateName\", \"@{var1}@{var2}\" );\n-        \n+        TemplateRegistry registry = new MVELTemplateRegistry();\n+        registry.registerTemplate(\"templateName\", \"@{var1}@{var2}\");\n+\n         assertEquals(\"xvalue1catx\", parse(\"x@includeByRef{templateName(var1 = \\\"value1\\\", var2 = c)}x\", registry));\n     }\n \n     public void testRegisterTemplateGroup() {\n-        StringReader reader = new StringReader( \"myTemplate1() ::=<<@{var1}>>=::  myTemplate2() ::=<<@{var2}>>=::\");        \n+        StringReader reader = new StringReader(\"myTemplate1() ::=<<@{var1}>>=::  myTemplate2() ::=<<@{var2}>>=::\");\n         TemplateRegistry registry = new MVELTemplateRegistry();\n-        registry.registerTemplate( reader );\n+        registry.registerTemplate(reader);\n \n         assertEquals(\"xvalue1catx\", parse(\"x@includeByRef{myTemplate1(var1 = \\\"value1\\\")}@includeByRef{myTemplate2(var2 = c)}x\", registry));\n     }\n \n     public void testRecursiveRegisterTemplateGroup() {\n-        StringReader reader = new StringReader( \"myTemplate1() ::=<<@{var1}@includeByRef{myTemplate2(var2 = var2)}>>=::  myTemplate2() ::=<<@{var2}>>=::\");        \n+        StringReader reader = new StringReader(\"myTemplate1() ::=<<@{var1}@includeByRef{myTemplate2(var2 = var2)}>>=::  myTemplate2() ::=<<@{var2}>>=::\");\n         TemplateRegistry registry = new MVELTemplateRegistry();\n-        registry.registerTemplate( reader );\n+        registry.registerTemplate(reader);\n \n         assertEquals(\"xvalue1catx\", parse(\"x@includeByRef{myTemplate1(var1 = \\\"value1\\\", var2 = c)}x\", registry));\n     }\n \n+    public void testIfLoopInTemplate() {\n+        assertEquals(\"ONETWOTHREE\", parse(\"@foreach{things}@if{item.name=='Bob'}ONE@elseif{item.name=='Smith'}TWO@elseif{item.name=='Cow'}THREE@end{}@end{}\"));\n+    }\n+\n     public void testStringEscaping() {\n         assertEquals(\"\\\"Mike Brock\\\"\", parse(\"@{\\\"\\\\\\\"Mike Brock\\\\\\\"\\\"}\"));\n     }\n@@ -746,7 +749,7 @@ public class ParserUnitTest extends TestCase {\n     public Object parse(String ex, TemplateRegistry registry) {\n         return TemplateInterpreter.parse(ex, base, map, registry);\n     }\n-    \n+\n     public Object parse(String ex) {\n         return TemplateInterpreter.parse(ex, base, map);\n     }\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T19:46:37.737398Z", "commit_hash": "9755efac1272929403cdfc1d76455e2fe5bb9150", "commit_message": "bugfix\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/Interpreter.java b/src/main/java/org/mvel/Interpreter.java\nindex 164e0f5..e759351 100644\n--- a/src/main/java/org/mvel/Interpreter.java\n+++ b/src/main/java/org/mvel/Interpreter.java\n@@ -20,29 +20,20 @@\n package org.mvel;\n \n import static org.mvel.NodeType.*;\n-\n import org.mvel.TemplateCompiler.IncludeRef;\n import org.mvel.TemplateCompiler.IncludeRefParam;\n import org.mvel.util.ExecutionStack;\n import org.mvel.util.StringAppender;\n \n import java.io.*;\n-\n-import static java.lang.Character.isWhitespace;\n import static java.lang.String.valueOf;\n import static java.lang.System.arraycopy;\n import java.nio.ByteBuffer;\n import static java.nio.ByteBuffer.allocateDirect;\n import java.nio.channels.ReadableByteChannel;\n-import java.util.Collection;\n+import java.util.*;\n import static java.util.Collections.synchronizedMap;\n \n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.Map;\n-import java.util.WeakHashMap;\n-\n /**\n  * The MVEL Template Interpreter.  Naming this an \"Interpreter\" is not inaccurate.   All template expressions\n  * are pre-compiled by the the {@link TemplateCompiler} prior to being processed by this interpreter.<br/>\n@@ -145,7 +136,7 @@ public class Interpreter {\n     private static final Map<CharSequence, char[]> EX_PRECACHE;\n     private static final Map<Object, Node[]> EX_NODE_CACHE;\n     private static final Map<Object, Serializable> EX_PRECOMP_CACHE;\n-    \n+\n     private static final Map<String, String> EX_TEMPLATE_REGISTRY;\n \n     static {\n@@ -153,7 +144,7 @@ public class Interpreter {\n             EX_PRECACHE = synchronizedMap(new WeakHashMap<CharSequence, char[]>());\n             EX_NODE_CACHE = synchronizedMap(new WeakHashMap<Object, Node[]>());\n             EX_PRECOMP_CACHE = synchronizedMap(new WeakHashMap<Object, Serializable>());\n-            EX_TEMPLATE_REGISTRY = synchronizedMap( new HashMap() );\n+            EX_TEMPLATE_REGISTRY = synchronizedMap(new HashMap());\n         }\n         else {\n             EX_PRECACHE = (new WeakHashMap<CharSequence, char[]>());\n@@ -214,7 +205,7 @@ public class Interpreter {\n \n         }\n         cloneAllNodes();\n-    }    \n+    }\n \n     private void cloneAllNodes() {\n         try {\n@@ -230,10 +221,10 @@ public class Interpreter {\n     public Interpreter(char[] expression) {\n         this.expression = expression;\n     }\n-    \n+\n     public static void registryTemplate(String name, String template) {\n-        EX_TEMPLATE_REGISTRY.put( name, template );\n-    }    \n+        EX_TEMPLATE_REGISTRY.put(name, template);\n+    }\n \n     public boolean isDebug() {\n         return debug;\n@@ -320,6 +311,9 @@ public class Interpreter {\n             return new String(expression);\n         }\n         else if (nodes.length == 2) {\n+            /**\n+             * This is an optimization for property expressions.\n+             */\n             switch (nodes[0].getToken()) {\n                 case PROPERTY_EX:\n                     //noinspection unchecked\n@@ -346,18 +340,7 @@ public class Interpreter {\n                     }\n                 case LITERAL:\n                     return new String(expression);\n-                case INCLUDE_BY_REF: {\n-                    IncludeRef includeRef = (IncludeRef) nodes[0].getRegister();\n-                    String template = EX_TEMPLATE_REGISTRY.get( includeRef.getName() );\n-                    \n-                    IncludeRefParam[] params = includeRef.getParams();\n-                    Map vars = new HashMap( params.length );\n-                    for ( int i = 0; i < params.length; i++ ) {\n-                        vars.put( params[i].getIdentifier(), parse(params[i].getValue(), ctx, tokens));\n-                    }\n-                    \n-                    return Interpreter.parse( template, ctx, vars );                    \n-                }                    \n+\n             }\n \n             return new String(expression);\n@@ -402,20 +385,21 @@ public class Interpreter {\n                         break;\n                     }\n                     case FOREACH: {\n-                        ForeachContext foreachContext = ( ForeachContext ) currNode.getRegister();\n-                        if ( foreachContext.getItererators() == null ) {\n+                        ForeachContext foreachContext = (ForeachContext) currNode.getRegister();\n+                        if (foreachContext.getItererators() == null) {\n                             try {\n-                                String[] lists = getForEachSegment(currNode).split( \",\" );\n+                                String[] lists = getForEachSegment(currNode).split(\",\");\n                                 Iterator[] iters = new Iterator[lists.length];\n-                                for( int i = 0; i < lists.length; i++ ) {\n+                                for (int i = 0; i < lists.length; i++) {\n                                     Object listObject = new ExpressionParser(lists[i], ctx, tokens).parse();\n-                                    if ( listObject instanceof Object[]) {\n-                                        listObject = Arrays.asList( (Object[]) listObject );\n-                                    }    \n-                                    iters[i] = ((Collection)listObject).iterator() ;\n+                                    if (listObject instanceof Object[]) {\n+                                        listObject = Arrays.asList((Object[]) listObject);\n+                                    }\n+                                    iters[i] = ((Collection) listObject).iterator();\n                                 }\n-                                foreachContext.setIterators( iters );\n-                            } catch (ClassCastException e) {\n+                                foreachContext.setIterators(iters);\n+                            }\n+                            catch (ClassCastException e) {\n                                 throw new CompileException(\"expression for collections does not return a collections object: \" + new String(getSegment(currNode)));\n                             }\n                             catch (NullPointerException e) {\n@@ -424,30 +408,30 @@ public class Interpreter {\n                         }\n \n                         Iterator[] iters = foreachContext.getItererators();\n-                        String[] alias = currNode.getAlias().split( \",\" );\n+                        String[] alias = currNode.getAlias().split(\",\");\n                         // must trim vars\n-                        for ( int i = 0; i < alias.length; i++ ) {\n+                        for (int i = 0; i < alias.length; i++) {\n                             alias[i] = alias[i].trim();\n-                        }                         \n-                        \n+                        }\n+\n                         if (iters[0].hasNext()) {\n                             push();\n \n                             //noinspection unchecked\n-                            for ( int i = 0; i < iters.length; i++ ) {\n+                            for (int i = 0; i < iters.length; i++) {\n                                 tokens.put(alias[i], iters[i].next());\n                             }\n-                            if ( foreachContext.getCount() != 0 ) {\n-                                sbuf.append( foreachContext.getSeperator() );\n+                            if (foreachContext.getCount() != 0) {\n+                                sbuf.append(foreachContext.getSeperator());\n                             }\n-                            foreachContext.setCount( foreachContext.getCount( ) + 1 );\n+                            foreachContext.setCount(foreachContext.getCount() + 1);\n                         }\n                         else {\n-                            for ( int i = 0; i < iters.length; i++ ) {\n+                            for (int i = 0; i < iters.length; i++) {\n                                 tokens.remove(alias[i]);\n-                            }      \n-                            foreachContext.setIterators( null );\n-                            foreachContext.setCount( 0 );\n+                            }\n+                            foreachContext.setIterators(null);\n+                            foreachContext.setCount(0);\n                             exitContext();\n                         }\n                         break;\n@@ -467,6 +451,18 @@ public class Interpreter {\n                             return sbuf.toString();\n                         }\n                     }\n+                    case INCLUDE_BY_REF: {\n+                        IncludeRef includeRef = (IncludeRef) nodes[node].getRegister();\n+                        String template = EX_TEMPLATE_REGISTRY.get(includeRef.getName());\n+\n+                        IncludeRefParam[] params = includeRef.getParams();\n+                        Map vars = new HashMap(params.length * 2);\n+                        for (int i = 0; i < params.length; i++) {\n+                            vars.put(params[i].getIdentifier(), MVEL.eval(params[i].getValue(), ctx, tokens));\n+                        }\n+\n+                        sbuf.append(Interpreter.parse(template, ctx, vars));\n+                    }\n                 }\n \n                 forwardAndPush();\n@@ -484,7 +480,7 @@ public class Interpreter {\n             throw new CompileException(\"unhandled fatal exception (node:\" + node + \")\", e);\n         }\n     }\n-    \n+\n     private void initStack() {\n         stack = new ExecutionStack();\n     }\ndiff --git a/src/main/java/org/mvel/MVEL.java b/src/main/java/org/mvel/MVEL.java\nindex 4be525c..ccd908c 100644\n--- a/src/main/java/org/mvel/MVEL.java\n+++ b/src/main/java/org/mvel/MVEL.java\n@@ -24,7 +24,7 @@ import org.mvel.integration.VariableResolverFactory;\n import org.mvel.integration.impl.MapVariableResolverFactory;\n import org.mvel.optimizers.impl.refl.GetterAccessor;\n import org.mvel.optimizers.impl.refl.ReflectiveAccessorOptimizer;\n-import org.mvel.util.ParseTools;\n+import static org.mvel.util.ParseTools.handleParserEgress;\n \n import java.io.Serializable;\n import static java.lang.String.valueOf;\n@@ -33,7 +33,7 @@ import java.util.Map;\n public class MVEL {\n     public static final String NAME = \"MVEL (MVFLEX Expression Language)\";\n     public static final String VERSION = \"1.2\";\n-    public static final String VERSION_SUB = \"beta13\";\n+    public static final String VERSION_SUB = \"beta15\";\n     public static final String CODENAME = \"horizon\";\n \n     static boolean THREAD_SAFE = Boolean.getBoolean(\"mvel.threadsafety\");\n@@ -169,7 +169,7 @@ public class MVEL {\n             return ((ExecutableStatement) compiledExpression).getValue(ctx, new MapVariableResolverFactory(vars));\n         }\n         catch (EndWithValue end) {\n-            return ParseTools.handleParserEgress(end.getValue(), false);\n+            return handleParserEgress(end.getValue(), false);\n         }\n     }\n \n@@ -178,7 +178,7 @@ public class MVEL {\n             return ((ExecutableStatement) compiledExpression).getValue(ctx, resolverFactory);\n         }\n         catch (EndWithValue end) {\n-            return ParseTools.handleParserEgress(end.getValue(), false);\n+            return handleParserEgress(end.getValue(), false);\n         }\n     }\n \n@@ -195,7 +195,7 @@ public class MVEL {\n             return ((ExecutableStatement) compiledExpression).getValue(null, factory);\n         }\n         catch (EndWithValue end) {\n-            return ParseTools.handleParserEgress(end.getValue(), false);\n+            return handleParserEgress(end.getValue(), false);\n         }\n     }\n \n@@ -212,7 +212,7 @@ public class MVEL {\n             return ((ExecutableStatement) compiledExpression).getValue(ctx, null);\n         }\n         catch (EndWithValue end) {\n-            return ParseTools.handleParserEgress(end.getValue(), false);\n+            return handleParserEgress(end.getValue(), false);\n         }\n     }\n \n@@ -230,7 +230,7 @@ public class MVEL {\n             return ((ExecutableStatement) compiledExpression).getValue(null, new MapVariableResolverFactory(vars));\n         }\n         catch (EndWithValue end) {\n-            return ParseTools.handleParserEgress(end.getValue(), false);\n+            return handleParserEgress(end.getValue(), false);\n         }\n     }\n \n@@ -249,7 +249,7 @@ public class MVEL {\n             return convert(executeExpression(compiledExpression, ctx, vars), toType);\n         }\n         catch (EndWithValue end) {\n-            return convert(ParseTools.handleParserEgress(end.getValue(), false), toType);\n+            return convert(handleParserEgress(end.getValue(), false), toType);\n         }\n     }\n \n@@ -267,7 +267,7 @@ public class MVEL {\n             return convert(executeExpression(compiledExpression, vars), toType);\n         }\n         catch (EndWithValue end) {\n-            return convert(ParseTools.handleParserEgress(end.getValue(), false), toType);\n+            return convert(handleParserEgress(end.getValue(), false), toType);\n         }\n     }\n \n@@ -284,7 +284,7 @@ public class MVEL {\n             return convert(executeExpression(compiledExpression, ctx), toType);\n         }\n         catch (EndWithValue end) {\n-            return convert(ParseTools.handleParserEgress(end.getValue(), false), toType);\n+            return convert(handleParserEgress(end.getValue(), false), toType);\n         }\n     }\n \n@@ -304,7 +304,7 @@ public class MVEL {\n             return convert(new ExpressionParser(expression, ctx, vars).parse(), toType);\n         }\n         catch (EndWithValue end) {\n-            return convert(ParseTools.handleParserEgress(end.getValue(), false), toType);\n+            return convert(handleParserEgress(end.getValue(), false), toType);\n         }\n     }\n \n@@ -314,7 +314,7 @@ public class MVEL {\n             return convert(new ExpressionParser(expression, ctx).parse(), toType);\n         }\n         catch (EndWithValue end) {\n-            return convert(ParseTools.handleParserEgress(end.getValue(), false), toType);\n+            return convert(handleParserEgress(end.getValue(), false), toType);\n         }\n     }\n \n@@ -324,7 +324,7 @@ public class MVEL {\n             return convert(new ExpressionParser(expression, ctx).parse(), toType);\n         }\n         catch (EndWithValue end) {\n-            return convert(ParseTools.handleParserEgress(end.getValue(), false), toType);\n+            return convert(handleParserEgress(end.getValue(), false), toType);\n         }\n     }\n \n@@ -334,7 +334,7 @@ public class MVEL {\n             return convert(new ExpressionParser(expression, ctx, vars).parse(), toType);\n         }\n         catch (EndWithValue end) {\n-            return convert(ParseTools.handleParserEgress(end.getValue(), false), toType);\n+            return convert(handleParserEgress(end.getValue(), false), toType);\n         }\n     }\n \n@@ -344,7 +344,7 @@ public class MVEL {\n             return convert(new ExpressionParser(expression, ctx, vars).parse(), toType);\n         }\n         catch (EndWithValue end) {\n-            return convert(ParseTools.handleParserEgress(end.getValue(), false), toType);\n+            return convert(handleParserEgress(end.getValue(), false), toType);\n         }\n     }\n \n@@ -354,7 +354,7 @@ public class MVEL {\n             return convert(new ExpressionParser(expression, ctx, vars).parse(), toType);\n         }\n         catch (EndWithValue end) {\n-            return convert(ParseTools.handleParserEgress(end.getValue(), false), toType);\n+            return convert(handleParserEgress(end.getValue(), false), toType);\n         }\n     }\n \n@@ -365,7 +365,7 @@ public class MVEL {\n             return convert(new ExpressionParser(expression, null, vars).parse(), toType);\n         }\n         catch (EndWithValue end) {\n-            return convert(ParseTools.handleParserEgress(end.getValue(), false), toType);\n+            return convert(handleParserEgress(end.getValue(), false), toType);\n         }\n     }\n \n@@ -375,7 +375,7 @@ public class MVEL {\n             return convert(new ExpressionParser(expression, null, vars).parse(), toType);\n         }\n         catch (EndWithValue end) {\n-            return convert(ParseTools.handleParserEgress(end.getValue(), false), toType);\n+            return convert(handleParserEgress(end.getValue(), false), toType);\n         }\n     }\n \n@@ -386,7 +386,7 @@ public class MVEL {\n             return convert(new ExpressionParser(expression, null, vars).parse(), toType);\n         }\n         catch (EndWithValue end) {\n-            return convert(ParseTools.handleParserEgress(end.getValue(), false), toType);\n+            return convert(handleParserEgress(end.getValue(), false), toType);\n         }\n     }\n \n@@ -396,7 +396,7 @@ public class MVEL {\n             return new ExpressionParser(expression, ctx, vars).parse();\n         }\n         catch (EndWithValue end) {\n-            return ParseTools.handleParserEgress(end.getValue(), false);\n+            return handleParserEgress(end.getValue(), false);\n         }\n     }\n \n@@ -405,7 +405,7 @@ public class MVEL {\n             return valueOf(eval(expression, ctx));\n         }\n         catch (EndWithValue end) {\n-            return valueOf(ParseTools.handleParserEgress(end.getValue(), false));\n+            return valueOf(handleParserEgress(end.getValue(), false));\n         }\n     }\n \n@@ -420,7 +420,7 @@ public class MVEL {\n             return valueOf(eval(expression, ctx, vars));\n         }\n         catch (EndWithValue end) {\n-            return valueOf(ParseTools.handleParserEgress(end.getValue(), false));\n+            return valueOf(handleParserEgress(end.getValue(), false));\n         }\n     }\n \ndiff --git a/src/main/java/org/mvel/TemplateCompiler.java b/src/main/java/org/mvel/TemplateCompiler.java\nindex a83a2d4..faed4eb 100644\n--- a/src/main/java/org/mvel/TemplateCompiler.java\n+++ b/src/main/java/org/mvel/TemplateCompiler.java\n@@ -1,4 +1,3 @@\n-\n /**\n  * MVEL (The MVFLEX Expression Language)\n  *\n@@ -21,6 +20,7 @@\n package org.mvel;\n \n import static org.mvel.NodeType.*;\n+import static org.mvel.util.ParseTools.*;\n import org.mvel.util.StringAppender;\n \n import static java.lang.Boolean.getBoolean;\n@@ -28,7 +28,6 @@ import static java.lang.Character.isWhitespace;\n import static java.lang.String.copyValueOf;\n import static java.lang.System.arraycopy;\n import java.util.ArrayList;\n-import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n \n@@ -72,7 +71,6 @@ public class TemplateCompiler {\n                     continue;\n                 }\n \n-\n                 exStr = structuredCaptureArray(1);\n \n                 if (token.length() != 0) {\n@@ -94,16 +92,13 @@ public class TemplateCompiler {\n                     }\n                     else if (\"end\".equals(token)) {\n                         depth--;\n-                        \n-//                        if (exStr.length > 0)\n-//                            throw new CompileException(\"$end token cannot contain an expression (use $end{}) near: \" + showCodeNearError());\n-\n                         ex.setToken(END);\n-                        ex.setRegister( exStr );\n+                        ex.setRegister(exStr);\n                     }\n-                    else if (\"includeByRef\".equals( token )) {\n-                        ex.setToken( INCLUDE_BY_REF );\n-                        ex.setRegister( buildIncludeRef(exStr) );\n+                    else if (\"includeByRef\".equals(token)) {\n+                        ex.setToken(INCLUDE_BY_REF);\n+                        ex.setRegister(buildIncludeRef(exStr));\n+                        System.out.println(ex.getRegister());\n                     }\n                     else {\n                         throw new CompileException(\"unknown token: \" + token);\n@@ -118,7 +113,7 @@ public class TemplateCompiler {\n                     for (int i = 0; i < exStr.length; i++) {\n                         switch (exStr[i]) {\n                             case' ':\n-                                if (capture == -1 && ((i + 3) < exStr.length) \n+                                if (capture == -1 && ((i + 3) < exStr.length)\n                                         && exStr[i + 1] == 'a' && exStr[i + 2] == 's'\n                                         && exStr[i + 3] == ' ') {\n \n@@ -219,25 +214,33 @@ public class TemplateCompiler {\n                                     break;\n                             }\n                         }\n-                    } else if (e.getToken() == FOREACH) {\n-                        char[] props = ( char[] ) expressions[i].getRegister();\n-                        if ( props != null && props.length > 0 ) {\n-                            int j = 0;                                                                      \n+                    }\n+                    else if (e.getToken() == FOREACH) {\n+                        char[] props = (char[]) expressions[i].getRegister();\n+                        if (props != null && props.length > 0) {\n+                            int j = 0;\n                             // skip white space\n-                            while (j < props.length && isWhitespace(props[j])) {j++;};                                    \n-                            if ( props[j] != '\"' ) { //&& props[i+2] !='\\\"') {\n-                                throw new CompileException(\"seperator is not correctly specified \\\"\" + props + \"\\\"\" );\n-                            }                \n-\n-                            int k = props.length-1;      \n-                            while (k < props.length && props[k] != '\"') {k--;};                                    \n-                            if ( props[k] != '\"' ) { //&& props[i+2] !='\\\"') {\n-                                throw new CompileException(\"seperator is not correctly specified \\\"\" + props + \"\\\"\" );\n+                            while (j < props.length && isWhitespace(props[j])) {\n+                                j++;\n+                            }\n+                            ;\n+                            if (props[j] != '\"') { //&& props[i+2] !='\\\"') {\n+                                throw new CompileException(\"seperator is not correctly specified \\\"\" + props + \"\\\"\");\n                             }\n-                            \n-                            e.setRegister( new ForeachContext( new String( props, j+1, k-j-1 ) ) );                            \n-                        } else {\n-                            e.setRegister( new ForeachContext( \"\" ) );\n+\n+                            int k = props.length - 1;\n+                            while (k < props.length && props[k] != '\"') {\n+                                k--;\n+                            }\n+                            ;\n+                            if (props[k] != '\"') { //&& props[i+2] !='\\\"') {\n+                                throw new CompileException(\"seperator is not correctly specified \\\"\" + props + \"\\\"\");\n+                            }\n+\n+                            e.setRegister(new ForeachContext(new String(props, j + 1, k - j - 1)));\n+                        }\n+                        else {\n+                            e.setRegister(new ForeachContext(\"\"));\n                         }\n                     }\n \n@@ -263,7 +266,7 @@ public class TemplateCompiler {\n                         depth--;\n                 }\n \n-                System.out.println(indent(depth) + \" + Node [\" + e.getNode() + \"] \" + e.getToken()\n+                System.out.println(indent(depth) + \" + Node (\" + e.getNode() + \") [\" + getNodeTypeName(e.getNodeType()) + \"] \" + e.getToken()\n                         + \" {\" + e.getStartPos() + \",\" + e.getEndPos() + \"} --> \" + e.getEndNode());\n \n                 switch (e.getToken()) {\n@@ -281,90 +284,97 @@ public class TemplateCompiler {\n \n         return expressions;\n     }\n-    \n+\n+    private static String getNodeTypeName(int node) {\n+        switch (node) {\n+            case NodeType.ELSE:\n+                return \"ELSE\";\n+            case NodeType.ELSEIF:\n+                return \"ELSE_IF\";\n+            case NodeType.END:\n+                return \"END\";\n+            case NodeType.FOREACH:\n+                return \"FOREACH\";\n+            case NodeType.GOTO:\n+                return \"GOTO\";\n+            case NodeType.IF:\n+                return \"IF\";\n+            case NodeType.INCLUDE_BY_REF:\n+                return \"INCLUDE_BY_REF\";\n+            case NodeType.LITERAL:\n+                return \"LITERAL\";\n+            case NodeType.OPERATOR:\n+                return \"OPERATOR\";\n+            case NodeType.PROPERTY_EX:\n+                return \"EXPRESSION\";\n+            case NodeType.TERMINUS:\n+                return \"TERMINUS\";\n+        }\n+        return \"UNKNOWN\";\n+    }\n+\n     private IncludeRef buildIncludeRef(char[] text) {\n         int i = 0;\n-                \n+\n         // skip leading white spaces\n-        while (isWhitespace(text[i++])) ;\n+        while (isWhitespace(text[i])) i++;\n+\n         int start = i;\n-        \n-        // scan to the first (\n-        while(text[i++] != '(' ) ;\n-        String name = new String( text, start-1, i - start );\n-        \n-        List params = new ArrayList();\n-        \n-        while ( true ) {\n-            start = i;\n-            while(i < text.length && text[i++] != ',' );\n-            params.add( new IncludeRefParam( text, start, i - 1 ) );\n-            if ( i == text.length) {\n-                break;\n-            }            \n+\n+        while (text[i] != '(') i++;\n+\n+        int end = i;\n+\n+        String name = new String(text, start, end - start);\n+\n+        Map<String, String> parmVars = parseParameters(subset(text, end, balancedCapture(text, i, ')') - end));\n+        List<IncludeRefParam> params = new ArrayList<IncludeRefParam>();\n+\n+        for (String k : parmVars.keySet()) {\n+            params.add(new IncludeRefParam(k, parmVars.get(k)));\n         }\n-        \n-        return new IncludeRef( name, (IncludeRefParam[]) params.toArray( new IncludeRefParam[ params.size()] ) );\n-        \n-        \n+\n+        return new IncludeRef(name, params.toArray(new IncludeRefParam[params.size()]));\n+\n     }\n \n     public static class IncludeRef {\n         private String name;\n         private IncludeRefParam[] params;\n-        \n+\n         public IncludeRef(String name,\n                           IncludeRefParam[] params) {\n             this.name = name;\n             this.params = params;\n         }\n-        \n+\n         public String getName() {\n             return name;\n         }\n-        \n+\n         public IncludeRefParam[] getParams() {\n             return params;\n-        }                       \n+        }\n     }\n \n     public static class IncludeRefParam {\n         private String identifier;\n         private String value;\n-        \n-        public IncludeRefParam(char[] text, int start, int end) {\n-            int i = start;\n-            \n-            // skip leading white spaces\n-            while (isWhitespace(text[i++])) ;            \n-            int startName = i-1;\n-            \n-            // scan the identifier\n-            while( text[i] != ' ' && text[i] != '=') {i++;};\n-            this.identifier = new String(text, startName, i-startName);            \n-            \n-            // scan to find the start of the value\n-            while( text[i] == ' ' ||  text[i] == '=') {i++;};\n-            this.value = \"@{\" + new String(text, i-1, end-i+1) + \"}\";\n-            \n-                      \n-        }\n-        \n-        public IncludeRefParam(String identifier,\n-                               String value) {\n+\n+        public IncludeRefParam(String identifier, String value) {\n             this.identifier = identifier;\n             this.value = value;\n         }\n-        \n+\n         public String getIdentifier() {\n             return identifier;\n         }\n-        \n+\n         public String getValue() {\n             return value;\n-        }                                \n+        }\n     }\n-    \n+\n     private static String indent(final int depth) {\n         final StringAppender sb = new StringAppender();\n         for (int i = depth; i >= 0; i--) {\ndiff --git a/src/main/java/org/mvel/util/ParseTools.java b/src/main/java/org/mvel/util/ParseTools.java\nindex 0672b6f..e439fa7 100644\n--- a/src/main/java/org/mvel/util/ParseTools.java\n+++ b/src/main/java/org/mvel/util/ParseTools.java\n@@ -27,7 +27,7 @@ public class ParseTools {\n         try {\n             double version = parseDouble(System.getProperty(\"java.version\").substring(0, 3));\n             if (version == 1.4) {\n-                                                                        \n+\n                 MATH_PROCESSOR = (MathProcessor) forName(\"org.mvel.math.JDK14CompatabilityMath\").newInstance();\n             }\n             else if (version > 1.4) {\n@@ -696,4 +696,89 @@ public class ParseTools {\n             throw new CompileException(\"unable to increment type: \" + (o != null ? o.getClass().getName() : \"null\"));\n         }\n     }\n+\n+    public static void main(String[] args) {\n+        parseParameters(\"test=poo, john=caca,bob=smith\".toCharArray());\n+    }\n+\n+    public static Map<String, String> parseParameters(char[] parms) {\n+        Map<String, String> allParms = new HashMap<String, String>();\n+\n+        boolean capture = false;\n+        int start = 0;\n+\n+        String parmName = null;\n+        int i = 0;\n+        for (; i < parms.length; i++) {\n+            switch (parms[i]) {\n+                case'=':\n+                    i++;\n+                    parmName = new String(parms, start, i - start - 1).trim();\n+                    capture = true;\n+                    start = i;\n+                    break;\n+\n+                case',':\n+                    if (capture) {\n+                        allParms.put(parmName, new String(parms, start, i - start).trim());\n+                        start = i;\n+                        capture = false;\n+                        break;\n+                    }\n+                default:\n+                    if (!capture && isWhitespace(parms[i])) {\n+                        start++;\n+                    }\n+            }\n+        }\n+\n+        if (capture) {\n+            allParms.put(parmName, new String(parms, start, i - start).trim());\n+        }\n+\n+        for (String parm : allParms.keySet()) {\n+            System.out.println(\"[\" + parm + \"]==[\" + allParms.get(parm) + \"]\");\n+        }\n+\n+        return allParms;\n+    }\n+\n+\n+    public static int balancedCapture(char[] chars, int start, char type) {\n+        int depth = 1;\n+        char term = type;\n+        switch (type) {\n+            case'[':\n+                term = ']';\n+                break;\n+            case'{':\n+                term = '}';\n+                break;\n+            case'(':\n+                term = ')';\n+                break;\n+        }\n+\n+        if (type == term) {\n+            for (start++; start < chars.length; start++) {\n+                if (chars[start] == type) {\n+                    return start;\n+                }\n+\n+            }\n+        }\n+        else {\n+            for (start++; start < chars.length; start++) {\n+                if (chars[start] == type) {\n+                    depth++;\n+                }\n+                else if (chars[start] == term && --depth == 0) {\n+                    return start;\n+                }\n+            }\n+        }\n+\n+        return -1;\n+    }\n+\n }\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/main/ParserUnitTest.java b/src/test/java/org/mvel/tests/main/ParserUnitTest.java\nindex c1d25dc..c3c53ae 100644\n--- a/src/test/java/org/mvel/tests/main/ParserUnitTest.java\n+++ b/src/test/java/org/mvel/tests/main/ParserUnitTest.java\n@@ -256,7 +256,7 @@ public class ParserUnitTest extends TestCase {\n                                 \"@end{}\"\n                 ));\n     }\n-    \n+\n     public void testControlLoopArray() {\n         assertEquals(\"HappyHappy!JoyJoy!\",\n                 parse(\n@@ -264,67 +264,67 @@ public class ParserUnitTest extends TestCase {\n                                 \"@{fun}\" +\n                                 \"@end{}\"\n                 ));\n-    }    \n-    \n+    }\n+\n     public void testMultiCollectionControlLoop() {\n         assertEquals(\"HappyHappyHappy!Happy!JoyJoyJoy!Joy!\",\n-                     parse(\n-                             \"@foreach{list, array as listItem, arrayItem}\" +\n-                                     \"@{listItem}@{arrayItem}\" +\n-                                     \"@end{}\"\n-                     ));        \n+                parse(\n+                        \"@foreach{list, array as listItem, arrayItem}\" +\n+                                \"@{listItem}@{arrayItem}\" +\n+                                \"@end{}\"\n+                ));\n     }\n-    \n+\n     public void testMultiCollectionWithSingleCharSeperatorControlLoop() {\n         assertEquals(\"HappyHappy,Happy!Happy!,JoyJoy,Joy!Joy!\",\n-                     parse(\n-                             \"@foreach{list, array as listItem, arrayItem}\" +\n-                                     \"@{listItem}@{arrayItem}\" +\n-                                     \"@end{\\\",\\\"  }\"\n-                     ));        \n-    }  \n-    \n+                parse(\n+                        \"@foreach{list, array as listItem, arrayItem}\" +\n+                                \"@{listItem}@{arrayItem}\" +\n+                                \"@end{\\\",\\\"  }\"\n+                ));\n+    }\n+\n     public void testMultiCollectionWithMultipleCharSeperatorControlLoop() {\n         assertEquals(\"HappyHappy,|Happy!Happy!,|JoyJoy,|Joy!Joy!\",\n-                     parse(\n-                             \"@foreach{list, array as listItem, arrayItem}\" +\n-                                     \"@{listItem}@{arrayItem}\" +\n-                                     \"@end{\\\",|\\\"  }\"\n-                     ));        \n-    }    \n+                parse(\n+                        \"@foreach{list, array as listItem, arrayItem}\" +\n+                                \"@{listItem}@{arrayItem}\" +\n+                                \"@end{\\\",|\\\"  }\"\n+                ));\n+    }\n \n     public void testControlLoopListMultiple() {\n         for (int i = 0; i < 100; i++) {\n             testControlLoopList();\n         }\n     }\n-    \n+\n     public void testControlLoopArrayMultiple() {\n         for (int i = 0; i < 100; i++) {\n             testControlLoopArray();\n         }\n-    }    \n-    \n+    }\n+\n     public void testMultiCollectionControlLoopMultiple() {\n         for (int i = 0; i < 100; i++) {\n             testMultiCollectionControlLoop();\n         }\n-    }       \n+    }\n+\n \n-    \n     public void testMultiCollectionWithSingleCharSeperatorControlLoopMultiple() {\n         for (int i = 0; i < 100; i++) {\n             testMultiCollectionWithSingleCharSeperatorControlLoop();\n         }\n-    }  \n-    \n+    }\n+\n     public void testMultiCollectionWithMultipleCharSeperatorControlLoopMultiple() {\n         for (int i = 0; i < 100; i++) {\n             testMultiCollectionWithMultipleCharSeperatorControlLoop();\n         }\n-    }  \n-        \n-    \n+    }\n+\n+\n     public void testControlLoop2() {\n         assertEquals(\"HappyHappy!JoyJoy!\",\n                 parse(\n@@ -661,8 +661,8 @@ public class ParserUnitTest extends TestCase {\n     }\n \n     public void testIncludeByRef() {\n-        Interpreter.registryTemplate( \"templateName\", \"@{var1}@{var2}\" );\n-        assertEquals(\"value1cat\", parse(\"@includeByRef{templateName(var1 = \\\"value1\\\", var2 = c)}\"));\n+        Interpreter.registryTemplate(\"templateName\", \"@{var1}@{var2}\");\n+        assertEquals(\"xvalue1catx\", parse(\"x@includeByRef{templateName(var1 = \\\"value1\\\", var2 = c)}x\"));\n     }\n \n \n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T20:00:27.574444Z", "commit_hash": "be5ee58a3174ec74ee40d9624c9508f65e258856", "commit_message": "BUGFIX: MVEL now properly unwinding the execution stack at fatal points in boolean expressions.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/compiled/CompiledAccessor.java b/src/main/java/org/mvel/compiled/CompiledAccessor.java\nindex f1b46aa..bb59bb9 100644\n--- a/src/main/java/org/mvel/compiled/CompiledAccessor.java\n+++ b/src/main/java/org/mvel/compiled/CompiledAccessor.java\n@@ -38,6 +38,8 @@ public class CompiledAccessor {\n \n     private static final Object[] EMPTYARG = new Object[0];\n \n+    private boolean first = true;\n+\n \n     public CompiledAccessor() {\n     }\n@@ -81,6 +83,8 @@ public class CompiledAccessor {\n                     case DONE:\n                         break;\n                 }\n+\n+                first = false;\n             }\n \n             return curr;\n@@ -153,7 +157,14 @@ public class CompiledAccessor {\n         Class cls = (ctx instanceof Class ? ((Class) ctx) : ctx != null ? ctx.getClass() : null);\n         Member member = cls != null ? PropertyTools.getFieldOrAccessor(cls, property) : null;\n \n-        if (member instanceof Field) {\n+        if (first && variableFactory != null && variableFactory.isResolveable(property)) {\n+            VariableAccessor accessor = new VariableAccessor(property, variableFactory);\n+\n+            addAccessorNode(accessor);\n+\n+            return variableFactory.getVariableResolver(property).getValue();\n+        }\n+        else if (member instanceof Field) {\n             FieldAccessor accessor = new FieldAccessor();\n             accessor.setField((Field) member);\n \n@@ -182,13 +193,6 @@ public class CompiledAccessor {\n \n             return this.ctx;\n         }\n-        else if (variableFactory != null && variableFactory.isResolveable(property)) {\n-            VariableAccessor accessor = new VariableAccessor(property, variableFactory);\n-\n-            addAccessorNode(accessor);\n-\n-            return variableFactory.getVariableResolver(property).getValue();\n-        }\n         else if (Token.LITERALS.containsKey(property)) {\n             StaticReferenceAccessor accessor = new StaticReferenceAccessor();\n             accessor.setLiteral(Token.LITERALS.get(property));\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/CompiledUnitTest.java b/src/test/java/org/mvel/tests/CompiledUnitTest.java\nindex 4cfd9c9..3edfe49 100644\n--- a/src/test/java/org/mvel/tests/CompiledUnitTest.java\n+++ b/src/test/java/org/mvel/tests/CompiledUnitTest.java\n@@ -81,6 +81,9 @@ public class CompiledUnitTest extends TestCase {\n         assertEquals(188.4, parseDirect(\"pi * hour\"));\n     }\n \n+    public void testComplexExpression() {\n+        assertEquals(\"bar\", parseDirect(\"a = 'foo'; b = 'bar'; c = 'jim'; list = {a,b,c}; list[1]\"));\n+    }\n \n     public void testComplexAnd() {\n         assertEquals(true, parseDirect(\"(pi * hour) > 0 && foo.happy() == 'happyBar'\"));\n@@ -472,9 +475,13 @@ public class CompiledUnitTest extends TestCase {\n \n     public Object compiledExecute(String ex) {\n         Serializable compiled = ExpressionParser.compileExpression(ex);\n-        return ExpressionParser.executeExpression(compiled, base, map);\n+        Object first = ExpressionParser.executeExpression(compiled, base, map);\n+        Object second = ExpressionParser.executeExpression(compiled, base, map);\n+        assertEquals(first, second);\n+        return second;\n     }\n \n+\n     public void testSimplePropertyAccess() {\n         final String expr = \"c\";\n         Serializable compiled = ExpressionParser.compileExpression(expr);\ndiff --git a/src/test/java/org/mvel/tests/ParserUnitTest.java b/src/test/java/org/mvel/tests/ParserUnitTest.java\nindex 7caae8f..8df2ee7 100644\n--- a/src/test/java/org/mvel/tests/ParserUnitTest.java\n+++ b/src/test/java/org/mvel/tests/ParserUnitTest.java\n@@ -383,6 +383,7 @@ public class ParserUnitTest extends TestCase {\n     public void testTokenMethodAccess() {\n         assertEquals(String.class, parse(\"@{a = 'foo'; a.getClass()}\"));\n     }\n+\n     \n     public void testCacheAggressivelyReAssignmentAllowed() {\n     \tInterpreter.setCacheAggressively(true);\n@@ -435,7 +436,7 @@ public class ParserUnitTest extends TestCase {\n     }\n \n     public void testStaticCalls() {\n-        assertTrue(Math.abs(1.1d) == ((Double) parse(\"@{Math.abs(1.1)}\")));\n+        assertEquals(Math.toDegrees(1.5), parseDirect(\"Math.toDegrees(1.5)\"));\n     }\n \n     public void testMethodCallsEtc() {\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T20:01:15.484399Z", "commit_hash": "8bf27f93feba55ea76b3f856022ff3225aac692b", "commit_message": "BUGFIX: MVEL now properly unwinding the execution stack at fatal points in boolean expressions.\n", "related_issues": "", "bug_patch": "diff --git a/buildp-old.xml b/buildp-old.xml\nindex a2f8078..d62260f 100644\n--- a/buildp-old.xml\n+++ b/buildp-old.xml\n@@ -3,7 +3,7 @@\n         MVFLEX Expression Language\r\n     </description>\r\n \r\n-    <property name=\"version\" value=\"1.1.3\"/>\r\n+    <property name=\"version\" value=\"1.1.4\"/>\r\n \r\n     <property name=\"src\" location=\"src\"/>\r\n     <property name=\"build\" location=\"build\"/>\r\ndiff --git a/src/main/java/org/mvel/TemplateCompiler.java b/src/main/java/org/mvel/TemplateCompiler.java\nindex 751af97..1ccd534 100644\n--- a/src/main/java/org/mvel/TemplateCompiler.java\n+++ b/src/main/java/org/mvel/TemplateCompiler.java\n@@ -89,7 +89,8 @@ public class TemplateCompiler {\n                     for (int i = 0; i < exStr.length; i++) {\n                         switch (exStr[i]) {\n                             case' ':\n-                                if (capture == -1 && exStr[i + 1] == 'a' && exStr[i + 2] == 's'\n+                                if (capture == -1 && ((i + 3) < exStr.length) \n+                                        && exStr[i + 1] == 'a' && exStr[i + 2] == 's'\n                                         && exStr[i + 3] == ' ') {\n \n                                     ex.setName(new String(exStr, 0, i));\n@@ -109,6 +110,12 @@ public class TemplateCompiler {\n                                     while (i < exStr.length && !isWhitespace(exStr[i++])) ;\n \n                                     ex.setAlias(copyValueOf(exStr, capture, i - capture));\n+\n+                                    /**\n+                                     * Scan to skip any excess whitespace.\n+                                     */\n+                                    //noinspection StatementWithEmptyBody\n+                                    while (i < exStr.length && !isWhitespace(exStr[i++])) ;\n                                 }\n                                 break;\n                         }\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/ParserUnitTest.java b/src/test/java/org/mvel/tests/ParserUnitTest.java\nindex 71400d3..b7e674a 100644\n--- a/src/test/java/org/mvel/tests/ParserUnitTest.java\n+++ b/src/test/java/org/mvel/tests/ParserUnitTest.java\n@@ -208,6 +208,16 @@ public class ParserUnitTest extends TestCase {\n                 ));\n     }\n \n+    public void testControlLoop3() {\n+        assertEquals(\"HappyHappy!JoyJoy!\",\n+                parse(\n+                        \"@foreach{ list }\" +\n+                                \"@{item}\" +\n+                                \"@end{}\"\n+                ));\n+    }\n+\n+\n     public void testIfStatement() {\n         assertEquals(\"sarah\", parse(\"@if{'fun' == 'fun'}sarah@end{}\"));\n     }\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T20:02:03.213770Z", "commit_hash": "a7872a376ff3b6f1d1181ea5ca5dc5dbbb159262", "commit_message": "BUGFIX: MVEL now properly unwinding the execution stack at fatal points in boolean expressions.\n", "related_issues": "", "bug_patch": "diff --git a/buildp-old.xml b/buildp-old.xml\nindex 0844d94..a2f8078 100644\n--- a/buildp-old.xml\n+++ b/buildp-old.xml\n@@ -10,7 +10,7 @@\n     <property name=\"dist\" location=\"dist\"/>\r\n \r\n \r\n-    <property name=\"deploy_to\" location=\"c:\\projects\\rwhoist\\WEB-INF\\lib\"/>\r\n+    <property name=\"deploy_to\" location=\"c:\\projects\\webcat\\WEB-INF\\lib\"/>\r\n \r\n     <target name=\"init\">\r\n         <!-- Create the time stamp -->\r\n@@ -56,7 +56,7 @@\n \r\n \r\n     <target name=\"deploy\" depends=\"release\">\r\n-        <copy file=\"mvel-${version}-java${java.version}.jar\" todir=\"../rwhoist/WEB-INF/lib/\" />\r\n+        <copy file=\"mvel-${version}-java${java.version}.jar\" tofile=\"../webcat/WEB-INF/lib/mvel.jar\" />\r\n     </target>\r\n \r\n     <target name=\"release\" depends=\"clean,compile,el-tests\"\r\ndiff --git a/src/main/java/org/mvel/PropertyAccessor.java b/src/main/java/org/mvel/PropertyAccessor.java\nindex 9c8223b..46ba02f 100644\n--- a/src/main/java/org/mvel/PropertyAccessor.java\n+++ b/src/main/java/org/mvel/PropertyAccessor.java\n@@ -4,6 +4,7 @@ import static org.mvel.DataConversion.canConvert;\n import static org.mvel.DataConversion.convert;\n import static org.mvel.ExpressionParser.executeExpression;\n import org.mvel.integration.VariableResolverFactory;\n+import org.mvel.util.ArrayTools;\n import static org.mvel.util.ParseTools.getBestCanadidate;\n import static org.mvel.util.ParseTools.parseParameterList;\n import static org.mvel.util.PropertyTools.getFieldOrAccessor;\n@@ -160,7 +161,7 @@ public class PropertyAccessor {\n             throw new PropertyAccessException(\"array or collection index out of bounds (property: \" + new String(property) + \")\", e);\n         }\n         catch (PropertyAccessException e) {\n-            throw new PropertyAccessException(\"failed to access property: <<\" + new String(property) + \">> in: \" + (ctx!=null?ctx.getClass():null), e);\n+            throw new PropertyAccessException(\"failed to access property: <<\" + new String(property) + \">> in: \" + (ctx != null ? ctx.getClass() : null), e);\n         }\n         catch (CompileException e) {\n             throw e;\n@@ -177,12 +178,13 @@ public class PropertyAccessor {\n         curr = ctx;\n \n         try {\n-            String tk = null;\n-            while (cursor < length) {\n-                tk = captureNext();\n-                if (!hasMore()) break;\n-                curr = getBeanProperty(curr, tk);\n-            }\n+            int oLength = length;\n+            length = ArrayTools.findLast('.', property);\n+            curr = get();\n+\n+            length = oLength;\n+\n+            String tk = captureNext();\n \n             Member member = checkWriteCache(curr.getClass(), tk == null ? 0 : tk.hashCode());\n             if (member == null) {\n@@ -525,7 +527,7 @@ public class PropertyAccessor {\n          */\n         Class cls = ctx instanceof Class ? (Class) ctx : ctx.getClass();\n \n-    //    Integer signature = ;\n+        //    Integer signature = ;\n \n         /**\n          * Check to see if we have already cached this method;\n@@ -598,7 +600,7 @@ public class PropertyAccessor {\n                 for (int i = 0; i < args.length; i++)\n                     args[i] = convert(args[i], parameterTypes[i]);\n             }\n-            \n+\n             /**\n              * Invoke the target method and return the response.\n              */\ndiff --git a/src/main/java/org/mvel/util/ArrayTools.java b/src/main/java/org/mvel/util/ArrayTools.java\nindex 7157adc..5278b18 100644\n--- a/src/main/java/org/mvel/util/ArrayTools.java\n+++ b/src/main/java/org/mvel/util/ArrayTools.java\n@@ -205,4 +205,12 @@ public class ArrayTools {\n         }\n         return -1;\n     }\n+\n+    public static int findLast(char c, char[] array) {\n+        for (int i = array.length - 1; i >= 0; i--) {\n+            if (array[i] == c) return i;\n+        }\n+        return -1;\n+    }\n+\n }\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/PropertyAccessUnitTest.java b/src/test/java/org/mvel/tests/PropertyAccessUnitTest.java\nindex ce08b3d..dcbbe25 100644\n--- a/src/test/java/org/mvel/tests/PropertyAccessUnitTest.java\n+++ b/src/test/java/org/mvel/tests/PropertyAccessUnitTest.java\n@@ -23,7 +23,8 @@ public class PropertyAccessUnitTest extends TestCase {\n     }\n \n     public void testCollectionsAccess() {\n-        assertEquals(\"dog\", PropertyAccessor.get(\"funMap['foo'].bar.name\", base));\n+        PropertyAccessor.set(base, \"funMap['foo'].bar.name\", \"cat\");\n+        assertEquals(\"cat\", PropertyAccessor.get(\"funMap['foo'].bar.name\", base));\n     }\n \n     public void testMethodInvoke() {\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T20:02:50.248776Z", "commit_hash": "c3d53f4afa99b52822e1723c6c6838cc01fa5f45", "commit_message": "BUGFIX: MVEL now properly unwinding the execution stack at fatal points in boolean expressions.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/Interpreter.java b/src/main/java/org/mvel/Interpreter.java\nindex a4098ee..af11110 100644\n--- a/src/main/java/org/mvel/Interpreter.java\n+++ b/src/main/java/org/mvel/Interpreter.java\n@@ -146,12 +146,19 @@ public class Interpreter {\n     public Interpreter(CharSequence template) {\n         if (!EX_PRECACHE.containsKey(template)) {\n             EX_PRECACHE.put(template, this.expression = template.toString().toCharArray());\n-             nodes = new TemplateCompiler(this).compileExpression();\n+            nodes = new TemplateCompiler(this).compileExpression();\n             EX_NODE_CACHE.put(template, nodes.clone());\n         }\n         else {\n             this.expression = EX_PRECACHE.get(template);\n-            this.nodes = EX_NODE_CACHE.get(template).clone();\n+            try {\n+                this.nodes = EX_NODE_CACHE.get(expression).clone();\n+            }\n+            catch (NullPointerException e) {\n+                EX_NODE_CACHE.remove(expression);\n+                nodes = new TemplateCompiler(this).compileExpression();\n+                EX_NODE_CACHE.put(expression, nodes.clone());\n+            }\n \n         }\n         cloneAllNodes();\n@@ -166,7 +173,14 @@ public class Interpreter {\n         }\n         else {\n             this.expression = EX_PRECACHE.get(expression);\n-            this.nodes = EX_NODE_CACHE.get(expression).clone();\n+            try {\n+                this.nodes = EX_NODE_CACHE.get(expression).clone();\n+            }\n+            catch (NullPointerException e) {\n+                EX_NODE_CACHE.remove(expression);\n+                nodes = new TemplateCompiler(this).compileExpression();\n+                EX_NODE_CACHE.put(expression, nodes.clone());\n+            }\n \n         }\n         cloneAllNodes();\ndiff --git a/src/main/java/org/mvel/TemplateCompiler.java b/src/main/java/org/mvel/TemplateCompiler.java\nindex 773eeb7..751af97 100644\n--- a/src/main/java/org/mvel/TemplateCompiler.java\n+++ b/src/main/java/org/mvel/TemplateCompiler.java\n@@ -1,4 +1,3 @@\n-\n package org.mvel;\n \n import static org.mvel.NodeType.*;\n@@ -37,14 +36,20 @@ public class TemplateCompiler {\n         Node ex;\n         int node = 0;\n         for (; cursor < length; cursor++) {\n-            if (expressionArray[cursor] == '$' || expressionArray[cursor] == '@') {\n+            if ((expressionArray[cursor] == '$' || expressionArray[cursor] == '@')) {\n                 if (literalRange != 0) {\n                     aList.add(new Node(node++, LITERAL, cursor - literalRange, literalRange, node));\n                     literalRange = 0;\n                 }\n \n                 ex = new Node(cursor);\n-                token = captureTo('{');\n+\n+                if ((token = captureTo('{')) == null) {\n+                    literalRange++;\n+                    continue;\n+                }\n+\n+\n                 exStr = structuredCaptureArray(1);\n \n                 if (token.length() != 0) {\n@@ -142,7 +147,7 @@ public class TemplateCompiler {\n \n         arraycopy(aList.toArray(), 0, expressions = new Node[aList.size()], 0, expressions.length);\n         ArrayList<Node> stk = new ArrayList<Node>(10);\n-        \n+\n         for (int i = 0; i < expressions.length; i++) {\n             switch (expressions[i].getToken()) {\n                 case GOTO:\n@@ -254,16 +259,16 @@ public class TemplateCompiler {\n      */\n     private char[] structuredCaptureArray(int depth) {\n         int start = cursor++ + 1;\n-       // int depth = 1;\n+        // int depth = 1;\n \n-      //  cursor++;\n+        //  cursor++;\n         while (cursor < (length) && depth != 0) {\n             switch (expressionArray[cursor++]) {\n                 case'@':\n                 case'$':\n                     if (expressionArray[cursor] == '{') {\n                         cursor++;\n-                        depth++;   \n+                        depth++;\n                     }\n                     break;\n                 case'}':\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/ParserUnitTest.java b/src/test/java/org/mvel/tests/ParserUnitTest.java\nindex 551b890..71400d3 100644\n--- a/src/test/java/org/mvel/tests/ParserUnitTest.java\n+++ b/src/test/java/org/mvel/tests/ParserUnitTest.java\n@@ -39,6 +39,10 @@ public class ParserUnitTest extends TestCase {\n         assertEquals(\"poopy\", parse(\"poopy\"));\n     }\n \n+    public void testPassThru2() {\n+        assertEquals(\"foo@bar.com\", Interpreter.eval(\"foo@bar.com\", map));\n+    }\n+\n     public void testMethodOnValue() {\n         assertEquals(\"DOG\", parse(\"@{foo.bar.name.toUpperCase()}\"));\n     }\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T20:03:40.506541Z", "commit_hash": "a824e1513adae7d7f25bfcba33be3aa4f48b2ab2", "commit_message": "BUGFIX: MVEL now properly unwinding the execution stack at fatal points in boolean expressions.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/ExpressionParser.java b/src/main/java/org/mvel/ExpressionParser.java\nindex c35320c..c7d3958 100644\n--- a/src/main/java/org/mvel/ExpressionParser.java\n+++ b/src/main/java/org/mvel/ExpressionParser.java\n@@ -393,17 +393,12 @@ public class ExpressionParser {\n             case AND:\n                 if (stk.peek() instanceof Boolean && !((Boolean) valueOnly(stk.peek()))) {\n                     fields |= Token.DO_NOT_REDUCE;\n-                    unwindStatement();\n-                //    nextToken();\n-                    return 0;\n+                    return unwindStatement() ? -1 : 0;\n                 }\n                 break;\n             case OR:\n                 if (stk.peek() instanceof Boolean && ((Boolean) valueOnly(stk.peek()))) {\n-                    unwindStatement();\n-                  //   nextToken();\n-                    //return -1;\n-                    return 0;\n+                    return unwindStatement() ? -1 : 0;\n                 }\n                 break;\n \n@@ -1569,13 +1564,14 @@ public class ExpressionParser {\n         while (isWhitespace(expr[cursor])) cursor++;\n     }\n \n-    private void unwindStatement() {\n+    private boolean unwindStatement() {\n         Token tk;\n         fields |= Token.CAPTURE_ONLY;\n         while ((tk = nextToken()) != null && !(tk.isOperator() && tk.getOperator() == Operator.END_OF_STMT)) {\n            //nothing\n         }\n         setFieldFalse(Token.CAPTURE_ONLY);\n+        return tk == null;\n     }\n \n     public ExpressionParser setExpression(String expression) {\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/CompiledUnitTest.java b/src/test/java/org/mvel/tests/CompiledUnitTest.java\nindex b9982fa..4cfd9c9 100644\n--- a/src/test/java/org/mvel/tests/CompiledUnitTest.java\n+++ b/src/test/java/org/mvel/tests/CompiledUnitTest.java\n@@ -16,620 +16,632 @@ import java.util.List;\n import java.util.Map;\n \n public class CompiledUnitTest extends TestCase {\n-       Foo foo = new Foo();\n-       Map<String, Object> map = new HashMap<String, Object>();\n-       Base base = new Base();\n+    Foo foo = new Foo();\n+    Map<String, Object> map = new HashMap<String, Object>();\n+    Base base = new Base();\n+\n+    public CompiledUnitTest() {\n+        foo.setBar(new Bar());\n+        map.put(\"foo\", foo);\n+        map.put(\"a\", null);\n+        map.put(\"b\", null);\n+        map.put(\"c\", \"cat\");\n+        map.put(\"BWAH\", \"\");\n+\n+        map.put(\"misc\", new MiscTestClass());\n+\n+        map.put(\"pi\", \"3.14\");\n+        map.put(\"hour\", \"60\");\n+        map.put(\"zero\", 0);\n+    }\n+\n \n-       public CompiledUnitTest() {\n-           foo.setBar(new Bar());\n-           map.put(\"foo\", foo);\n-           map.put(\"a\", null);\n-           map.put(\"b\", null);\n-           map.put(\"c\", \"cat\");\n-           map.put(\"BWAH\", \"\");\n+    public void testMethodOnValue() {\n+        assertEquals(\"DOG\", parseDirect(\"foo.bar.name.toUpperCase()\"));\n+    }\n+\n+    public void testSimpleProperty() {\n+        assertEquals(\"dog\", parseDirect(\"foo.bar.name\"));\n+    }\n \n-           map.put(\"misc\", new MiscTestClass());\n \n-           map.put(\"pi\", \"3.14\");\n-           map.put(\"hour\", \"60\");\n-           map.put(\"zero\", 0);\n-       }\n+    public void testBooleanOperator() {\n+        assertEquals(true, parseDirect(\"foo.bar.woof == true\"));\n+    }\n+\n+    public void testBooleanOperator2() {\n+        assertEquals(false, parseDirect(\"foo.bar.woof == false\"));\n+    }\n+\n+    public void testTextComparison() {\n+        assertEquals(true, parseDirect(\"foo.bar.name == 'dog'\"));\n+    }\n \n+    public void testNETextComparison() {\n+        assertEquals(true, parseDirect(\"foo.bar.name != 'foo'\"));\n+    }\n \n-       public void testMethodOnValue() {\n-           assertEquals(\"DOG\", parseDirect(\"foo.bar.name.toUpperCase()\"));\n-       }\n+    public void testChor() {\n+        assertEquals(\"cat\", parseDirect(\"a or b or c\"));\n+    }\n \n-       public void testSimpleProperty() {\n-           assertEquals(\"dog\", parseDirect(\"foo.bar.name\"));\n-       }\n+    public void testChorWithLiteral() {\n+        assertEquals(\"fubar\", parseDirect(\"a or 'fubar'\"));\n+    }\n \n+    public void testNullCompare() {\n+        assertEquals(true, parseDirect(\"c != null\"));\n+    }\n \n-       public void testBooleanOperator() {\n-           assertEquals(true, parseDirect(\"foo.bar.woof == true\"));\n-       }\n+    public void testAnd() {\n+        assertEquals(true, parseDirect(\"c != null && foo.bar.name == 'dog' && foo.bar.woof\"));\n+    }\n \n-       public void testBooleanOperator2() {\n-           assertEquals(false, parseDirect(\"foo.bar.woof == false\"));\n-       }\n+    public void testMath() {\n+        assertEquals(188.4, parseDirect(\"pi * hour\"));\n+    }\n \n-       public void testTextComparison() {\n-           assertEquals(true, parseDirect(\"foo.bar.name == 'dog'\"));\n-       }\n \n-       public void testNETextComparison() {\n-           assertEquals(true, parseDirect(\"foo.bar.name != 'foo'\"));\n-       }\n+    public void testComplexAnd() {\n+        assertEquals(true, parseDirect(\"(pi * hour) > 0 && foo.happy() == 'happyBar'\"));\n+    }\n \n-       public void testChor() {\n-           assertEquals(\"cat\", parseDirect(\"a or b or c\"));\n-       }\n+    public void testShortPathExpression() {\n+        assertEquals(null, parseDirect(\"3 > 4 && foo.toUC('test'); foo.register\"));\n+    }\n \n-       public void testChorWithLiteral() {\n-           assertEquals(\"fubar\", parseDirect(\"a or 'fubar'\"));\n-       }\n+    public void testShortPathExpression2() {\n+        assertEquals(true, parseDirect(\"4 > 3 || foo.toUC('test')\"));\n+    }\n \n-       public void testNullCompare() {\n-           assertEquals(true, parseDirect(\"c != null\"));\n-       }\n+    public void testShortPathExpression3() {\n+        assertEquals(false, parseDirect(\"defnull != null  && defnull.length() > 0\"));\n+    }\n \n-       public void testAnd() {\n-           assertEquals(true, parseDirect(\"c != null && foo.bar.name == 'dog' && foo.bar.woof\"));\n-       }\n+    public void testModulus() {\n+        assertEquals(38392 % 2,\n+                parseDirect(\"38392 % 2\"));\n+    }\n \n-       public void testMath() {\n-           assertEquals(188.4, parseDirect(\"pi * hour\"));\n-       }\n \n+    public void testLessThan() {\n+        assertEquals(true, parseDirect(\"pi < 3.15\"));\n+        assertEquals(true, parseDirect(\"pi <= 3.14\"));\n+        assertEquals(false, parseDirect(\"pi > 3.14\"));\n+        assertEquals(true, parseDirect(\"pi >= 3.14\"));\n+    }\n \n-       public void testComplexAnd() {\n-           assertEquals(true, parseDirect(\"(pi * hour) > 0 && foo.happy() == 'happyBar'\"));\n-       }\n+    public void testMethodAccess() {\n+        assertEquals(\"happyBar\", parseDirect(\"foo.happy()\"));\n+    }\n \n-       public void testModulus() {\n-           assertEquals(38392 % 2,\n-                   parseDirect(\"38392 % 2\"));\n-       }\n+    public void testMethodAccess2() {\n+        assertEquals(\"FUBAR\", parseDirect(\"foo.toUC('fubar')\"));\n+    }\n \n+    public void testMethodAccess3() {\n+        assertEquals(true, parseDirect(\"equalityCheck(c, 'cat')\"));\n+    }\n \n-       public void testLessThan() {\n-           assertEquals(true, parseDirect(\"pi < 3.15\"));\n-           assertEquals(true, parseDirect(\"pi <= 3.14\"));\n-           assertEquals(false, parseDirect(\"pi > 3.14\"));\n-           assertEquals(true, parseDirect(\"pi >= 3.14\"));\n-       }\n+    public void testMethodAccess4() {\n+        assertEquals(null, parseDirect(\"readBack(null)\"));\n+    }\n \n-       public void testMethodAccess() {\n-           assertEquals(\"happyBar\", parseDirect(\"foo.happy()\"));\n-       }\n+    public void testMethodAccess5() {\n+        assertEquals(\"nulltest\", parseDirect(\"appendTwoStrings(null, 'test')\"));\n+    }\n \n-       public void testMethodAccess2() {\n-           assertEquals(\"FUBAR\", parseDirect(\"foo.toUC('fubar')\"));\n-       }\n+    public void testNegation() {\n+        assertEquals(true, parseDirect(\"!fun && !fun\"));\n+    }\n \n-       public void testMethodAccess3() {\n-           assertEquals(true, parseDirect(\"equalityCheck(c, 'cat')\"));\n-       }\n+    public void testNegation2() {\n+        assertEquals(false, parseDirect(\"fun && !fun\"));\n+    }\n \n-       public void testMethodAccess4() {\n-           assertEquals(null, parseDirect(\"readBack(null)\"));\n-       }\n+    public void testNegation3() {\n+        assertEquals(true, parseDirect(\"!(fun && fun)\"));\n+    }\n \n-       public void testMethodAccess5() {\n-           assertEquals(\"nulltest\", parseDirect(\"appendTwoStrings(null, 'test')\"));\n-       }\n+    public void testNegation4() {\n+        assertEquals(false, parseDirect(\"(fun && fun)\"));\n+    }\n \n-       public void testNegation() {\n-           assertEquals(true, parseDirect(\"!fun && !fun\"));\n-       }\n+    public void testMultiStatement() {\n+        assertEquals(true, parseDirect(\"populate(); barfoo == 'sarah'\"));\n+    }\n \n-       public void testNegation2() {\n-           assertEquals(false, parseDirect(\"fun && !fun\"));\n-       }\n+    public void testAssignment() {\n+        assertEquals(true, parseDirect(\"populate(); blahfoo = 'sarah'; blahfoo == 'sarah'\"));\n+    }\n \n-       public void testNegation3() {\n-           assertEquals(true, parseDirect(\"!(fun && fun)\"));\n-       }\n+    public void testAssignment2() {\n+        assertEquals(\"sarah\", parseDirect(\"populate(); blahfoo = barfoo\"));\n+    }\n \n-       public void testNegation4() {\n-           assertEquals(false, parseDirect(\"(fun && fun)\"));\n-       }\n+    public void testOr() {\n+        assertEquals(true, parseDirect(\"fun || true\"));\n+    }\n \n-       public void testMultiStatement() {\n-           assertEquals(true, parseDirect(\"populate(); barfoo == 'sarah'\"));\n-       }\n+    public void testLiteralPassThrough() {\n+        assertEquals(true, parseDirect(\"true\"));\n+    }\n \n-       public void testAssignment() {\n-           assertEquals(true, parseDirect(\"populate(); blahfoo = 'sarah'; blahfoo == 'sarah'\"));\n-       }\n+    public void testLiteralPassThrough2() {\n+        assertEquals(false, parseDirect(\"false\"));\n+    }\n \n-       public void testAssignment2() {\n-           assertEquals(\"sarah\", parseDirect(\"populate(); blahfoo = barfoo\"));\n-       }\n+    public void testLiteralPassThrough3() {\n+        assertEquals(null, parseDirect(\"null\"));\n+    }\n \n-       public void testOr() {\n-           assertEquals(true, parseDirect(\"fun || true\"));\n-       }\n \n-       public void testLiteralPassThrough() {\n-           assertEquals(true, parseDirect(\"true\"));\n-       }\n+    public void testRegEx() {\n+        assertEquals(true, parseDirect(\"foo.bar.name ~= '[a-z].+'\"));\n+    }\n \n-       public void testLiteralPassThrough2() {\n-           assertEquals(false, parseDirect(\"false\"));\n-       }\n+    public void testRegExNegate() {\n+        assertEquals(false, parseDirect(\"!(foo.bar.name ~= '[a-z].+')\"));\n+    }\n \n-       public void testLiteralPassThrough3() {\n-           assertEquals(null, parseDirect(\"null\"));\n-       }\n+    public void testRegEx2() {\n+        assertEquals(true, parseDirect(\"foo.bar.name ~= '[a-z].+' && foo.bar.name != null\"));\n+    }\n \n+    public void testBlank() {\n+        assertEquals(true, parseDirect(\"'' == empty\"));\n+    }\n \n-       public void testRegEx() {\n-           assertEquals(true, parseDirect(\"foo.bar.name ~= '[a-z].+'\"));\n-       }\n+    public void testBlank2() {\n+        assertEquals(true, parseDirect(\"BWAH == empty\"));\n+    }\n \n-       public void testRegExNegate() {\n-           assertEquals(false, parseDirect(\"!(foo.bar.name ~= '[a-z].+')\"));\n-       }\n+    public void testBooleanModeOnly() {\n+        assertEquals(true, (Object) evalToBoolean(\"!BWAH\", base, map));\n+    }\n \n-       public void testRegEx2() {\n-           assertEquals(true, parseDirect(\"foo.bar.name ~= '[a-z].+' && foo.bar.name != null\"));\n-       }\n+    public void testBooleanModeOnly2() {\n+        assertEquals(false, (Object) evalToBoolean(\"BWAH\", base, map));\n+    }\n \n-       public void testBlank() {\n-           assertEquals(true, parseDirect(\"'' == empty\"));\n-       }\n+    public void testBooleanModeOnly3() {\n+        assertEquals(true, (Object) evalToBoolean(\"!zero\", base, map));\n+    }\n \n-       public void testBlank2() {\n-           assertEquals(true, parseDirect(\"BWAH == empty\"));\n-       }\n+    public void testBooleanModeOnly4() {\n+        assertEquals(true, (Object) evalToBoolean(\"hour == (hour + 0)\", base, map));\n+    }\n \n-       public void testBooleanModeOnly() {\n-           assertEquals(true, (Object) evalToBoolean(\"!BWAH\", base, map));\n-       }\n+    public void testTernary() {\n+        assertEquals(\"foobie\", parseDirect(\"zero==0?'foobie':zero\"));\n+    }\n \n-       public void testBooleanModeOnly2() {\n-           assertEquals(false, (Object) evalToBoolean(\"BWAH\", base, map));\n-       }\n+    public void testTernary2() {\n+        assertEquals(\"blimpie\", parseDirect(\"zero==1?'foobie':'blimpie'\"));\n+    }\n \n-       public void testBooleanModeOnly3() {\n-           assertEquals(true, (Object) evalToBoolean(\"!zero\", base, map));\n-       }\n+    public void testTernary3() {\n+        assertEquals(\"foobiebarbie\", parseDirect(\"zero==1?'foobie':'foobie'+'barbie'\"));\n+    }\n \n-       public void testBooleanModeOnly4() {\n-           assertEquals(true, (Object) evalToBoolean(\"hour == (hour + 0)\", base, map));\n-       }\n+    public void testStrAppend() {\n+        assertEquals(\"foobarcar\", parseDirect(\"'foo' + 'bar' + 'car'\"));\n+    }\n \n-       public void testTernary() {\n-           assertEquals(\"foobie\", parseDirect(\"zero==0?'foobie':zero\"));\n-       }\n+    public void testStrAppend2() {\n+        assertEquals(\"foobarcar1\", parseDirect(\"'foobar' + 'car' + 1\"));\n+    }\n \n-       public void testTernary2() {\n-           assertEquals(\"blimpie\", parseDirect(\"zero==1?'foobie':'blimpie'\"));\n-       }\n+    public void testInstanceCheck1() {\n+        assertEquals(true, parseDirect(\"c is 'java.lang.String'\"));\n+    }\n \n-       public void testTernary3() {\n-           assertEquals(\"foobiebarbie\", parseDirect(\"zero==1?'foobie':'foobie'+'barbie'\"));\n-       }\n+    public void testInstanceCheck2() {\n+        assertEquals(false, parseDirect(\"pi is 'java.lang.Integer'\"));\n+    }\n \n-       public void testStrAppend() {\n-           assertEquals(\"foobarcar\", parseDirect(\"'foo' + 'bar' + 'car'\"));\n-       }\n+    public void testBitwiseOr1() {\n+        assertEquals(6, parseDirect(\"2 | 4\"));\n+    }\n \n-       public void testStrAppend2() {\n-           assertEquals(\"foobarcar1\", parseDirect(\"'foobar' + 'car' + 1\"));\n-       }\n+    public void testBitwiseOr2() {\n+        assertEquals(true, parseDirect(\"(2 | 1) > 0\"));\n+    }\n \n-       public void testInstanceCheck1() {\n-           assertEquals(true, parseDirect(\"c is 'java.lang.String'\"));\n-       }\n+    public void testBitwiseOr3() {\n+        assertEquals(true, parseDirect(\"(2 | 1) == 3\"));\n+    }\n \n-       public void testInstanceCheck2() {\n-           assertEquals(false, parseDirect(\"pi is 'java.lang.Integer'\"));\n-       }\n+    public void testBitwiseAnd1() {\n+        assertEquals(2, parseDirect(\"2 & 3\"));\n+    }\n \n-       public void testBitwiseOr1() {\n-           assertEquals(6, parseDirect(\"2 | 4\"));\n-       }\n+    public void testShiftLeft() {\n+        assertEquals(4, parseDirect(\"2 << 1\"));\n+    }\n \n-       public void testBitwiseOr2() {\n-           assertEquals(true, parseDirect(\"(2 | 1) > 0\"));\n-       }\n+    public void testUnsignedShiftLeft() {\n+        assertEquals(2, parseDirect(\"-2 <<< 0\"));\n+    }\n \n-       public void testBitwiseOr3() {\n-           assertEquals(true, parseDirect(\"(2 | 1) == 3\"));\n-       }\n+    public void testShiftRight() {\n+        assertEquals(128, parseDirect(\"256 >> 1\"));\n+    }\n \n-       public void testBitwiseAnd1() {\n-           assertEquals(2, parseDirect(\"2 & 3\"));\n-       }\n+    public void testXOR() {\n+        assertEquals(3, parseDirect(\"1 ^ 2\"));\n+    }\n \n-       public void testShiftLeft() {\n-           assertEquals(4, parseDirect(\"2 << 1\"));\n-       }\n+    public void testContains1() {\n+        assertEquals(true, parseDirect(\"list contains 'Happy!'\"));\n+    }\n \n-       public void testUnsignedShiftLeft() {\n-           assertEquals(2, parseDirect(\"-2 <<< 0\"));\n-       }\n+    public void testContains2() {\n+        assertEquals(false, parseDirect(\"list contains 'Foobie'\"));\n+    }\n \n-       public void testShiftRight() {\n-           assertEquals(128, parseDirect(\"256 >> 1\"));\n-       }\n+    public void testContains3() {\n+        assertEquals(true, parseDirect(\"sentence contains 'fox'\"));\n+    }\n \n-       public void testXOR() {\n-           assertEquals(3, parseDirect(\"1 ^ 2\"));\n-       }\n+    public void testContains4() {\n+        assertEquals(false, parseDirect(\"sentence contains 'mike'\"));\n+    }\n \n-       public void testContains1() {\n-           assertEquals(true, parseDirect(\"list contains 'Happy!'\"));\n-       }\n+    public void testContains5() {\n+        assertEquals(true, parseDirect(\"!(sentence contains 'mike')\"));\n+    }\n \n-       public void testContains2() {\n-           assertEquals(false, parseDirect(\"list contains 'Foobie'\"));\n-       }\n+    public void testInvert() {\n+        assertEquals(~10, parseDirect(\"~10\"));\n+    }\n \n-       public void testContains3() {\n-           assertEquals(true, parseDirect(\"sentence contains 'fox'\"));\n-       }\n+    public void testInvert2() {\n+        assertEquals(~(10 + 1), parseDirect(\"~(10 + 1)\"));\n+    }\n \n-       public void testContains4() {\n-           assertEquals(false, parseDirect(\"sentence contains 'mike'\"));\n-       }\n+    public void testInvert3() {\n+        assertEquals(~10 + (1 + ~50), parseDirect(\"~10 + (1 + ~50)\"));\n+    }\n \n-       public void testContains5() {\n-           assertEquals(true, parseDirect(\"!(sentence contains 'mike')\"));\n-       }\n \n-       public void testInvert() {\n-           assertEquals(~10, parseDirect(\"~10\"));\n-       }\n+    public void testListCreation2() {\n+        assertEquals(ArrayList.class, parseDirect(\"[\\\"test\\\"]\").getClass());\n+    }\n \n-       public void testInvert2() {\n-           assertEquals(~(10 + 1), parseDirect(\"~(10 + 1)\"));\n-        }\n+    public void testListCreation3() {\n+        assertEquals(ArrayList.class, parseDirect(\"[66]\").getClass());\n+    }\n+\n+    public void testListCreation4() {\n+        List ar = (List) parseDirect(\"[   66   , \\\"test\\\"   ]\");\n+        assertEquals(2, ar.size());\n+        assertEquals(new BigDecimal(66), ar.get(0));\n+        assertEquals(\"test\", ar.get(1));\n+    }\n+\n+\n+    public void testListCreationWithCall() {\n+        assertEquals(1, parseDirect(\"[\\\"apple\\\"].size()\"));\n+    }\n+\n+    public void testArrayCreationWithLength() {\n+        assertEquals(2, parseDirect(\"Array.getLength({'foo', 'bar'})\"));\n+    }\n+\n+    public void testArrayCreation() {\n+        assertEquals(0, parseDirect(\"arrayTest = {{1, 2, 3}, {2, 1, 0}}; arrayTest[1][2]\"));\n+    }\n+\n+    public void testMapCreation() {\n+        assertEquals(\"sarah\", parseDirect(\"map = ['mike':'sarah','tom':'jacquelin']; map['mike']\"));\n+    }\n+\n+    public void testMapCreation2() {\n+        assertEquals(\"sarah\", parseDirect(\"map = ['mike' :'sarah'  ,'tom'  :'jacquelin'  ]; map['mike']\"));\n+    }\n+\n+    public void testProjectionSupport() {\n+        assertEquals(true, parseDirect(\"(name in things) contains 'Bob'\"));\n+    }\n+\n+    public void testProjectionSupport2() {\n+        assertEquals(3, parseDirect(\"(('name') in things).size()\"));\n+    }\n+\n+\n+    public void testStaticMethodFromLiteral() {\n+        assertEquals(String.class.getName(), parseDirect(\"String.valueOf(Class.forName('java.lang.String').getName())\"));\n+    }\n+\n+    public void testStaticCalls() {\n+        assertTrue(Math.abs(1.1f) == ((Float) parseDirect(\"Math.abs(1.1)\")));\n+    }\n+\n+    public void testMethodCallsEtc() {\n+        parseDirect(\"title = 1; \" +\n+                \"frame = new javax.swing.JFrame; \" +\n+                \"label = new javax.swing.JLabel; \" +\n+                \"title = title + 1;\" +\n+                \"frame.setTitle(title);\" +\n+                \"label.setText('this is a test of mvel');\" +\n+                \"frame.setVisible(true);\");\n+    }\n+\n+    public void testObjectInstantiation() {\n+        parseDirect(\"new java.lang.String('foobie')\");\n+    }\n+\n+    public void testObjectInstantiationWithMethodCall() {\n+        parseDirect(\"new String('foobie').toString()\");\n+    }\n+\n+    public void testObjectInstantiation2() {\n+        parseDirect(\"new String() is String\");\n+    }\n+\n+    public void testObjectInstantiation3() {\n+        parseDirect(\"new java.text.SimpleDateFormat('yyyy').format(new java.util.Date(System.currentTimeMillis()))\");\n+    }\n+\n+    public void testArrayCoercion() {\n+        assertEquals(\"gonk\", parseDirect(\"funMethod( {'gonk', 'foo'} )\"));\n+    }\n+\n+    public void testArrayCoercion2() {\n+        assertEquals(10, parseDirect(\"sum({2,2,2,2,2})\"));\n+    }\n \n-       public void testInvert3()  {\n-           assertEquals(~10 + (1 + ~50), parseDirect(\"~10 + (1 + ~50)\"));\n+    public void testMapAccess() {\n+        assertEquals(\"dog\", parseDirect(\"funMap['foo'].bar.name\"));\n     }\n \n+    public void testMapAccess2() {\n+        assertEquals(\"dog\", parseDirect(\"funMap.foo.bar.name\"));\n+    }\n \n-       public void testListCreation2() {\n-           assertEquals(ArrayList.class, parseDirect(\"[\\\"test\\\"]\").getClass());\n-       }\n+    public void testSoundex() {\n+        assertTrue((Boolean) parseDirect(\"'foobar' soundslike 'fubar'\"));\n+    }\n+\n+    public void testSoundex2() {\n+        assertFalse((Boolean) parseDirect(\"'flexbar' soundslike 'fubar'\"));\n+    }\n+\n+    public void testThisReference() {\n+        assertEquals(true, parseDirect(\"this\") instanceof Base);\n+    }\n+\n+    public void testThisReference2() {\n+        assertEquals(true, parseDirect(\"this.funMap\") instanceof Map);\n+    }\n \n-       public void testListCreation3() {\n-           assertEquals(ArrayList.class, parseDirect(\"[66]\").getClass());\n-       }\n+    public void testThisReference3() {\n+        assertEquals(true, parseDirect(\"this is 'org.mvel.tests.res.Base'\"));\n+    }\n \n-       public void testListCreation4() {\n-           List ar = (List) parseDirect(\"[   66   , \\\"test\\\"   ]\");\n-           assertEquals(2, ar.size());\n-           assertEquals(new BigDecimal(66), ar.get(0));\n-           assertEquals(\"test\", ar.get(1));\n-       }\n \n+    public void testStringEscaping() {\n+        assertEquals(\"\\\"Mike Brock\\\"\", parseDirect(\"\\\"\\\\\\\"Mike Brock\\\\\\\"\\\"\"));\n+    }\n \n-       public void testListCreationWithCall() {\n-           assertEquals(1, parseDirect(\"[\\\"apple\\\"].size()\"));\n-       }\n+    public void testStringEscaping2() {\n+        assertEquals(\"MVEL's Parser is Fast\", parseDirect(\"'MVEL\\\\'s Parser is Fast'\"));\n+    }\n \n-       public void testArrayCreationWithLength() {\n-           assertEquals(2, parseDirect(\"Array.getLength({'foo', 'bar'})\"));\n-       }\n+    public void testEvalToBoolean() {\n+        assertEquals(true, (boolean) ExpressionParser.evalToBoolean(\"true \", \"true\"));\n+        assertEquals(true, (boolean) ExpressionParser.evalToBoolean(\"true \", \"true\"));\n+    }\n \n-       public void testArrayCreation() {\n-           assertEquals(0, parseDirect(\"arrayTest = {{1, 2, 3}, {2, 1, 0}}; arrayTest[1][2]\"));\n-       }\n+    //    public void testCompiledListStructures() {\n+    //        Serializable compiled = ExpressionParser.compileExpression(\"[\\\"test\\\", \\\"yeolpass\\\"] contains \\\"yeolpass\\\"\");\n+    //        assertEquals(true, ExpressionParser.executeExpression(compiled));\n+    //    }\n \n-       public void testMapCreation() {\n-           assertEquals(\"sarah\", parseDirect(\"map = ['mike':'sarah','tom':'jacquelin']; map['mike']\"));\n-       }\n+    public void testCompiledMapStructures() {\n+        Serializable compiled = ExpressionParser.compileExpression(\"['foo':'bar'] contains 'foo'\");\n+        ExpressionParser.executeExpression(compiled, null, null, Boolean.class);\n+    }\n \n-       public void testMapCreation2() {\n-           assertEquals(\"sarah\", parseDirect(\"map = ['mike' :'sarah'  ,'tom'  :'jacquelin'  ]; map['mike']\"));\n-       }\n+    public void testSubListInMap() {\n+        assertEquals(\"pear\", parseDirect(\"map = ['test' : 'poo', 'foo' : [c, 'pear']]; map['foo'][1]\"));\n+    }\n \n-       public void testProjectionSupport() {\n-           assertEquals(true, parseDirect(\"(name in things) contains 'Bob'\"));\n-       }\n+    public void testCompiledMethodCall() {\n+        Serializable compiled = ExpressionParser.compileExpression(\"c.getClass()\");\n+        assertEquals(String.class, ExpressionParser.executeExpression(compiled, base, map));\n+    }\n \n-       public void testProjectionSupport2() {\n-           assertEquals(3, parseDirect(\"(('name') in things).size()\"));\n-       }\n+    public void testStaticNamespaceCall() {\n+        assertEquals(java.util.ArrayList.class, parseDirect(\"java.util.ArrayList\"));\n+    }\n \n+    public void testStaticNamespaceClassWithMethod() {\n+        assertEquals(\"FooBar\", parseDirect(\"java.lang.String.valueOf('FooBar')\"));\n+    }\n \n-       public void testStaticMethodFromLiteral() {\n-           assertEquals(String.class.getName(), parseDirect(\"String.valueOf(Class.forName('java.lang.String').getName())\"));\n-       }\n+    public void testThisReferenceInMethodCall() {\n+        assertEquals(101, parseDirect(\"Integer.parseInt(this.number)\"));\n+    }\n \n-       public void testStaticCalls() {\n-           assertTrue(Math.abs(1.1f) == ((Float) parseDirect(\"Math.abs(1.1)\")));\n-       }\n \n-       public void testMethodCallsEtc() {\n-           parseDirect(\"title = 1; \" +\n-                   \"frame = new javax.swing.JFrame; \" +\n-                   \"label = new javax.swing.JLabel; \" +\n-                   \"title = title + 1;\" +\n-                   \"frame.setTitle(title);\" +\n-                   \"label.setText('this is a test of mvel');\" +\n-                   \"frame.setVisible(true);\");\n-       }\n+    public Object parseDirect(String ex) {\n+        return compiledExecute(ex);\n+    }\n \n-       public void testObjectInstantiation() {\n-           parseDirect(\"new java.lang.String('foobie')\");\n-       }\n+    public Object compiledExecute(String ex) {\n+        Serializable compiled = ExpressionParser.compileExpression(ex);\n+        return ExpressionParser.executeExpression(compiled, base, map);\n+    }\n \n-       public void testObjectInstantiationWithMethodCall() {\n-           parseDirect(\"new String('foobie').toString()\");\n-       }\n+    public void testSimplePropertyAccess() {\n+        final String expr = \"c\";\n+        Serializable compiled = ExpressionParser.compileExpression(expr);\n \n-       public void testObjectInstantiation2() {\n-           parseDirect(\"new String() is String\");\n-       }\n+        for (int i = 0; i < 100000; i++) {\n+            ExpressionParser.executeExpression(compiled, map);\n+        }\n+    }\n \n-       public void testObjectInstantiation3() {\n-           parseDirect(\"new java.text.SimpleDateFormat('yyyy').format(new java.util.Date(System.currentTimeMillis()))\");\n-       }\n+    public void testMathPerformance() {\n+        final String expr = \"10 + 1 + 3\";\n+        Serializable compiled = ExpressionParser.compileExpression(expr);\n \n-       public void testArrayCoercion() {\n-           assertEquals(\"gonk\", parseDirect(\"funMethod( {'gonk', 'foo'} )\"));\n-       }\n+        for (int i = 0; i < 10000; i++) {\n+            ExpressionParser.executeExpression(compiled, map);\n+        }\n+    }\n \n-       public void testArrayCoercion2() {\n-           assertEquals(10, parseDirect(\"sum({2,2,2,2,2})\"));\n-       }\n+    public void testDifferentImplSameCompile() {\n+        Serializable compiled = ExpressionParser.compileExpression(\"a.funMap.hello\");\n \n-       public void testMapAccess() {\n-           assertEquals(\"dog\", parseDirect(\"funMap['foo'].bar.name\"));\n-       }\n+        Map testMap = new HashMap();\n \n-       public void testMapAccess2() {\n-           assertEquals(\"dog\", parseDirect(\"funMap.foo.bar.name\"));\n-       }\n+        for (int i = 0; i < 100; i++) {\n+            Base b = new Base();\n+            b.funMap.put(\"hello\", \"dog\");\n+            testMap.put(\"a\", b);\n \n-       public void testSoundex() {\n-           assertTrue((Boolean) parseDirect(\"'foobar' soundslike 'fubar'\"));\n-       }\n \n-       public void testSoundex2() {\n-           assertFalse((Boolean) parseDirect(\"'flexbar' soundslike 'fubar'\"));\n-       }\n+            assertEquals(\"dog\", ExpressionParser.executeExpression(compiled, testMap));\n \n-       public void testThisReference() {\n-           assertEquals(true, parseDirect(\"this\") instanceof Base);\n-       }\n+            b = new Base();\n+            b.funMap.put(\"hello\", \"cat\");\n+            testMap.put(\"a\", b);\n \n-       public void testThisReference2() {\n-           assertEquals(true, parseDirect(\"this.funMap\") instanceof Map);\n-       }\n+            assertEquals(\"cat\", ExpressionParser.executeExpression(compiled, testMap));\n+        }\n+    }\n \n-       public void testThisReference3() {\n-           assertEquals(true, parseDirect(\"this is 'org.mvel.tests.res.Base'\"));\n-       }\n+    public void testToListBenchmark() {\n+        String text = \"misc.toList(foo.bar.name, 'hello', 42, ['key1' : 'value1', c : [ foo.bar.age, 'car', 42 ]], [42, [c : 'value1']] )\";\n+        Serializable compiled = ExpressionParser.compileExpression(text);\n \n+        MapVariableResolverFactory variableTable = new MapVariableResolverFactory(map);\n+        variableTable.pack();\n \n-       public void testStringEscaping() {\n-           assertEquals(\"\\\"Mike Brock\\\"\", parseDirect(\"\\\"\\\\\\\"Mike Brock\\\\\\\"\\\"\"));\n-       }\n+        for (int i = 0; i < 100000; i++) {\n+            ExpressionParser.executeExpression(compiled, variableTable);\n+        }\n+    }\n \n-       public void testStringEscaping2() {\n-           assertEquals(\"MVEL's Parser is Fast\", parseDirect(\"'MVEL\\\\'s Parser is Fast'\"));\n-       }\n+    public void testToListBenchmark2() {\n+        testToListBenchmark();\n+    }\n \n-       public void testEvalToBoolean() {\n-           assertEquals(true, (boolean) ExpressionParser.evalToBoolean(\"true \", \"true\"));\n-           assertEquals(true, (boolean) ExpressionParser.evalToBoolean(\"true \", \"true\"));\n-       }\n+    public void testToListBenchmark3() {\n+        testToListBenchmark();\n+    }\n \n-   //    public void testCompiledListStructures() {\n-   //        Serializable compiled = ExpressionParser.compileExpression(\"[\\\"test\\\", \\\"yeolpass\\\"] contains \\\"yeolpass\\\"\");\n-   //        assertEquals(true, ExpressionParser.executeExpression(compiled));\n-   //    }\n+    public void testToList() {\n+        String text = \"misc.toList(foo.bar.name, 'hello', 42, ['key1' : 'value1', c : [ foo.bar.age, 'car', 42 ]], [42, [c : 'value1']] )\";\n+        List list = (List) parseDirect(text);\n+        assertSame(\"dog\", list.get(0));\n+        assertEquals(\"hello\", list.get(1));\n+        assertEquals(new Integer(42), list.get(2));\n+        Map map = (Map) list.get(3);\n+        assertEquals(\"value1\", map.get(\"key1\"));\n+\n+        List nestedList = (List) map.get(\"cat\");\n+        assertEquals(new BigDecimal(14), nestedList.get(0));\n+        assertEquals(\"car\", nestedList.get(1));\n+        assertEquals(new BigDecimal(42), nestedList.get(2));\n+\n+        nestedList = (List) list.get(4);\n+        assertEquals(new BigDecimal(42), nestedList.get(0));\n+        map = (Map) nestedList.get(1);\n+        assertEquals(\"value1\", map.get(\"cat\"));\n+    }\n \n-       public void testCompiledMapStructures() {\n-           Serializable compiled = ExpressionParser.compileExpression(\"['foo':'bar'] contains 'foo'\");\n-           ExpressionParser.executeExpression(compiled, null, null, Boolean.class);\n-       }\n+    public void testToList2() {\n+        for (int i = 0; i < 10; i++) {\n+            testToList();\n+        }\n+    }\n \n-       public void testSubListInMap() {\n-           assertEquals(\"pear\", parseDirect(\"map = ['test' : 'poo', 'foo' : [c, 'pear']]; map['foo'][1]\"));\n-       }\n+    public class MiscTestClass {\n+        public List toList(Object object1, String string, int integer, Map map, List list) {\n+            List l = new ArrayList();\n+            l.add(object1);\n+            l.add(string);\n+            l.add(new Integer(integer));\n+            l.add(map);\n+            l.add(list);\n+            return l;\n+        }\n+    }\n \n-       public void testCompiledMethodCall() {\n-           Serializable compiled = ExpressionParser.compileExpression(\"c.getClass()\");\n-           assertEquals(String.class, ExpressionParser.executeExpression(compiled, base, map));\n-       }\n-\n-       public void testStaticNamespaceCall() {\n-           assertEquals(java.util.ArrayList.class, parseDirect(\"java.util.ArrayList\"));\n-       }\n-\n-       public void testStaticNamespaceClassWithMethod() {\n-           assertEquals(\"FooBar\", parseDirect(\"java.lang.String.valueOf('FooBar')\"));\n-       }\n-\n-       public void testThisReferenceInMethodCall() {\n-           assertEquals(101, parseDirect(\"Integer.parseInt(this.number)\"));\n-       }\n-\n-\n-       public Object parseDirect(String ex) {\n-           return compiledExecute(ex);\n-       }\n-\n-       public Object compiledExecute(String ex) {\n-           Serializable compiled = ExpressionParser.compileExpression(ex);\n-           return ExpressionParser.executeExpression(compiled, base, map);\n-       }\n-\n-       public void testSimplePropertyAccess() {\n-           final String expr = \"c\";\n-           Serializable compiled = ExpressionParser.compileExpression(expr);\n-\n-           for (int i = 0; i < 100000; i++) {\n-               ExpressionParser.executeExpression(compiled, map);\n-           }\n-       }\n-\n-       public void testMathPerformance() {\n-           final String expr = \"10 + 1 + 3\";\n-           Serializable compiled = ExpressionParser.compileExpression(expr);\n-\n-           for (int i = 0; i < 10000; i++) {\n-               ExpressionParser.executeExpression(compiled, map);\n-           }\n-       }\n-\n-       public void testDifferentImplSameCompile() {\n-           Serializable compiled = ExpressionParser.compileExpression(\"a.funMap.hello\");\n-\n-           Map testMap = new HashMap();\n-\n-           for (int i = 0; i < 100; i++) {\n-               Base b = new Base();\n-               b.funMap.put(\"hello\", \"dog\");\n-               testMap.put(\"a\", b);\n-\n-\n-               assertEquals(\"dog\", ExpressionParser.executeExpression(compiled, testMap));\n-\n-               b = new Base();\n-               b.funMap.put(\"hello\", \"cat\");\n-               testMap.put(\"a\", b);\n-\n-               assertEquals(\"cat\", ExpressionParser.executeExpression(compiled, testMap));\n-           }\n-       }\n-\n-       public void testToListBenchmark() {\n-           String text = \"misc.toList(foo.bar.name, 'hello', 42, ['key1' : 'value1', c : [ foo.bar.age, 'car', 42 ]], [42, [c : 'value1']] )\";\n-           Serializable compiled = ExpressionParser.compileExpression(text);\n-\n-           MapVariableResolverFactory variableTable = new MapVariableResolverFactory(map);\n-           variableTable.pack();\n-\n-           for (int i = 0; i < 100000; i++) {\n-               ExpressionParser.executeExpression(compiled, variableTable);\n-           }\n-       }\n-\n-       public void testToListBenchmark2() {\n-           testToListBenchmark();\n-       }\n-\n-       public void testToListBenchmark3() {\n-           testToListBenchmark();\n-       }\n-\n-       public void testToList() {\n-           String text = \"misc.toList(foo.bar.name, 'hello', 42, ['key1' : 'value1', c : [ foo.bar.age, 'car', 42 ]], [42, [c : 'value1']] )\";\n-           List list = (List) parseDirect(text);\n-           assertSame(\"dog\", list.get(0));\n-           assertEquals(\"hello\", list.get(1));\n-           assertEquals(new Integer(42), list.get(2));\n-           Map map = (Map) list.get(3);\n-           assertEquals(\"value1\", map.get(\"key1\"));\n-\n-           List nestedList = (List) map.get(\"cat\");\n-           assertEquals(new BigDecimal(14), nestedList.get(0));\n-           assertEquals(\"car\", nestedList.get(1));\n-           assertEquals(new BigDecimal(42), nestedList.get(2));\n-\n-           nestedList = (List) list.get(4);\n-           assertEquals(new BigDecimal(42), nestedList.get(0));\n-           map = (Map) nestedList.get(1);\n-           assertEquals(\"value1\", map.get(\"cat\"));\n-       }\n-\n-       public void testToList2() {\n-           for (int i = 0; i < 10; i++) {\n-               testToList();\n-           }\n-       }\n-\n-       public class MiscTestClass {\n-           public List toList(Object object1, String string, int integer, Map map, List list) {\n-               List l = new ArrayList();\n-               l.add(object1);\n-               l.add(string);\n-               l.add(new Integer(integer));\n-               l.add(map);\n-               l.add(list);\n-               return l;\n-           }\n-       }\n-\n-     /**\n-      * Start JDFI Here\n-                  */\n- //      public void testJFDIToList()  throws Exception {\n- //        String text = \"misc.toList(foo.bar.name, 'hello', 42, {'key1' => 'value1', c => [ foo.bar.age, 'car', 42 ]}, [42, {c => 'value1'}] )\";\n- //\n- //        JFDIParser parser = createParser( text );\n- //        this.factory.setVariables( map );\n- //        Expr expr = (Expr) parser.atom();\n- //\n- //        List list = null;\n- //        int count = 100000000;\n- //        long start = System.currentTimeMillis();\n- //        for ( int i = 0; i < count; i++ ) {\n- //            list = (List)  expr.getValue();\n- //        }\n- //        long end = System.currentTimeMillis();\n- //        System.out.println( end  - start);\n- //\n- //        assertSame( \"dog\", list.compileGetChain( 0 ) );\n- //        assertEquals( \"hello\", list.compileGetChain( 1 ) );\n- //        assertEquals( new Integer( 42 ), list.compileGetChain( 2 ) );\n- //        Map map = ( Map ) list.compileGetChain( 3 );\n- //        assertEquals( \"value1\", map.compileGetChain( \"key1\" ) );\n- //\n- //        List nestedList = ( List ) map.compileGetChain(  \"cat\" );\n- //        assertEquals( new Integer( 14 ), nestedList.compileGetChain( 0 )  );\n- //        assertEquals( \"car\", nestedList.compileGetChain( 1 )  );\n- //        assertEquals( new Integer(42), nestedList.compileGetChain( 2 )  );\n- //\n- //        nestedList  = (List) list.compileGetChain( 4 );\n- //        assertEquals( new Integer( 42 ), nestedList.compileGetChain( 0 )  );\n- //        map = ( Map ) nestedList.compileGetChain( 1 );\n- //        assertEquals( \"value1\", map.compileGetChain( \"cat\" )  );\n- //    }\n- //\n- //    private DefaultValueHandlerFactory factory;\n- //    private ClassTypeResolver typeResolver;\n- //\n- //\n- //    protected JFDIParser createParser(String text) throws IOException {\n- //        this.factory = new DefaultValueHandlerFactory( new ClassTypeResolver() );\n- //        this.typeResolver = new ClassTypeResolver();\n- //\n- //        JFDIParser parser = new JFDIParser( createTokenStream( text ) );\n- //        parser.setValueHandlerFactory( factory );\n- //        parser.setTypeResolver( typeResolver );\n- //        return parser;\n- //    }\n- //\n- //    private TokenStream createTokenStream(String text) throws IOException {\n- //        return new CommonTokenStream( createLexer( text ) );\n- //    }\n- //\n- //    private org.codehaus.jfdi.parser.JFDILexer createLexer(String text) throws IOException {\n- //        org.codehaus.jfdi.parser.JFDILexer lexer = new org.codehaus.jfdi.parser.JFDILexer( createStream( text ) );\n- //        return lexer;\n- //    }\n- //\n- //    private CharStream createStream(String text) throws IOException {\n- //        if ( text.endsWith( \".jfdi\" ) ) {\n- //            return new ANTLRReaderStream( createReader( text ) );\n- //        }\n- //\n- //        return new ANTLRStringStream( text );\n- //    }\n- //\n- //    private Reader createReader(String text) {\n- //        InputStream in = getClass().getResourceAsStream( text );\n- //        return new InputStreamReader( in );\n- //    }\n+    /**\n+     * Start JDFI Here\n+     */\n+    //      public void testJFDIToList()  throws Exception {\n+    //        String text = \"misc.toList(foo.bar.name, 'hello', 42, {'key1' => 'value1', c => [ foo.bar.age, 'car', 42 ]}, [42, {c => 'value1'}] )\";\n+    //\n+    //        JFDIParser parser = createParser( text );\n+    //        this.factory.setVariables( map );\n+    //        Expr expr = (Expr) parser.atom();\n+    //\n+    //        List list = null;\n+    //        int count = 100000000;\n+    //        long start = System.currentTimeMillis();\n+    //        for ( int i = 0; i < count; i++ ) {\n+    //            list = (List)  expr.getValue();\n+    //        }\n+    //        long end = System.currentTimeMillis();\n+    //        System.out.println( end  - start);\n+    //\n+    //        assertSame( \"dog\", list.compileGetChain( 0 ) );\n+    //        assertEquals( \"hello\", list.compileGetChain( 1 ) );\n+    //        assertEquals( new Integer( 42 ), list.compileGetChain( 2 ) );\n+    //        Map map = ( Map ) list.compileGetChain( 3 );\n+    //        assertEquals( \"value1\", map.compileGetChain( \"key1\" ) );\n+    //\n+    //        List nestedList = ( List ) map.compileGetChain(  \"cat\" );\n+    //        assertEquals( new Integer( 14 ), nestedList.compileGetChain( 0 )  );\n+    //        assertEquals( \"car\", nestedList.compileGetChain( 1 )  );\n+    //        assertEquals( new Integer(42), nestedList.compileGetChain( 2 )  );\n+    //\n+    //        nestedList  = (List) list.compileGetChain( 4 );\n+    //        assertEquals( new Integer( 42 ), nestedList.compileGetChain( 0 )  );\n+    //        map = ( Map ) nestedList.compileGetChain( 1 );\n+    //        assertEquals( \"value1\", map.compileGetChain( \"cat\" )  );\n+    //    }\n+    //\n+    //    private DefaultValueHandlerFactory factory;\n+    //    private ClassTypeResolver typeResolver;\n+    //\n+    //\n+    //    protected JFDIParser createParser(String text) throws IOException {\n+    //        this.factory = new DefaultValueHandlerFactory( new ClassTypeResolver() );\n+    //        this.typeResolver = new ClassTypeResolver();\n+    //\n+    //        JFDIParser parser = new JFDIParser( createTokenStream( text ) );\n+    //        parser.setValueHandlerFactory( factory );\n+    //        parser.setTypeResolver( typeResolver );\n+    //        return parser;\n+    //    }\n+    //\n+    //    private TokenStream createTokenStream(String text) throws IOException {\n+    //        return new CommonTokenStream( createLexer( text ) );\n+    //    }\n+    //\n+    //    private org.codehaus.jfdi.parser.JFDILexer createLexer(String text) throws IOException {\n+    //        org.codehaus.jfdi.parser.JFDILexer lexer = new org.codehaus.jfdi.parser.JFDILexer( createStream( text ) );\n+    //        return lexer;\n+    //    }\n+    //\n+    //    private CharStream createStream(String text) throws IOException {\n+    //        if ( text.endsWith( \".jfdi\" ) ) {\n+    //            return new ANTLRReaderStream( createReader( text ) );\n+    //        }\n+    //\n+    //        return new ANTLRStringStream( text );\n+    //    }\n+    //\n+    //    private Reader createReader(String text) {\n+    //        InputStream in = getClass().getResourceAsStream( text );\n+    //        return new InputStreamReader( in );\n+    //    }\n \n }\ndiff --git a/src/test/java/org/mvel/tests/ParserUnitTest.java b/src/test/java/org/mvel/tests/ParserUnitTest.java\nindex 738f1f5..551b890 100644\n--- a/src/test/java/org/mvel/tests/ParserUnitTest.java\n+++ b/src/test/java/org/mvel/tests/ParserUnitTest.java\n@@ -67,6 +67,10 @@ public class ParserUnitTest extends TestCase {\n         assertEquals(null, parseDirect(\"3 > 4 && foo.toUC('test'); foo.register\"));\n     }\n \n+    public void testShortPathExpression2() {\n+        assertEquals(true, parseDirect(\"4 > 3 || foo.toUC('test')\"));\n+    }\n+\n     public void testChor() {\n         assertEquals(\"cat\", parse(\"@{a or b or c}\"));\n     }\ndiff --git a/src/test/java/org/mvel/tests/res/Base.java b/src/test/java/org/mvel/tests/res/Base.java\nindex e30c778..3618680 100644\n--- a/src/test/java/org/mvel/tests/res/Base.java\n+++ b/src/test/java/org/mvel/tests/res/Base.java\n@@ -20,6 +20,8 @@ public class Base {\n \n     public String barfoo;\n \n+    public String defnull = null;\n+\n     public Object[] testArray = new Object[] { new Foo(), new Bar() };\n \n     public Base() {\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T20:04:27.103732Z", "commit_hash": "d573aee2eb19ddac3e809306b6d763f2a11f7a37", "commit_message": "BUGFIX: MVEL now properly unwinding the execution stack at fatal points in boolean expressions.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/ExpressionParser.java b/src/main/java/org/mvel/ExpressionParser.java\nindex c31cdd4..c35320c 100644\n--- a/src/main/java/org/mvel/ExpressionParser.java\n+++ b/src/main/java/org/mvel/ExpressionParser.java\n@@ -7,8 +7,7 @@ import org.mvel.integration.impl.LocalVariableResolverFactory;\n import org.mvel.integration.impl.MapVariableResolverFactory;\n import org.mvel.util.ExecutionStack;\n import org.mvel.util.ParseTools;\n-import static org.mvel.util.ParseTools.captureContructorAndResidual;\n-import static org.mvel.util.ParseTools.containsCheck;\n+import static org.mvel.util.ParseTools.*;\n import org.mvel.util.PropertyTools;\n import static org.mvel.util.PropertyTools.*;\n import org.mvel.util.Stack;\n@@ -393,14 +392,18 @@ public class ExpressionParser {\n         switch (o) {\n             case AND:\n                 if (stk.peek() instanceof Boolean && !((Boolean) valueOnly(stk.peek()))) {\n-                    nextToken();\n-                    return -1;\n+                    fields |= Token.DO_NOT_REDUCE;\n+                    unwindStatement();\n+                //    nextToken();\n+                    return 0;\n                 }\n                 break;\n             case OR:\n                 if (stk.peek() instanceof Boolean && ((Boolean) valueOnly(stk.peek()))) {\n-                    nextToken();\n-                    return -1;\n+                    unwindStatement();\n+                  //   nextToken();\n+                    //return -1;\n+                    return 0;\n                 }\n                 break;\n \n@@ -477,7 +480,7 @@ public class ExpressionParser {\n \n                     String[] name = captureContructorAndResidual(fastExecuteMode ? nextCompiledToken().getName() : nextToken().getName());\n \n-                    stk.push(ParseTools.constructObject(name[0], ctx, variableFactory));\n+                    stk.push(constructObject(name[0], ctx, variableFactory));\n                     setFieldFalse(Token.CAPTURE_ONLY);\n \n                     if (name.length == 2) {\n@@ -1351,12 +1354,9 @@ public class ExpressionParser {\n \n                     default:\n                         cursor++;\n-\n                 }\n-\n         }\n \n-\n         return createToken(expr, start, cursor, fields);\n     }\n \n@@ -1569,6 +1569,15 @@ public class ExpressionParser {\n         while (isWhitespace(expr[cursor])) cursor++;\n     }\n \n+    private void unwindStatement() {\n+        Token tk;\n+        fields |= Token.CAPTURE_ONLY;\n+        while ((tk = nextToken()) != null && !(tk.isOperator() && tk.getOperator() == Operator.END_OF_STMT)) {\n+           //nothing\n+        }\n+        setFieldFalse(Token.CAPTURE_ONLY);\n+    }\n+\n     public ExpressionParser setExpression(String expression) {\n         if (expression != null && !\"\".equals(expression)) {\n             if (!EX_PRECACHE.containsKey(expression)) {\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/ParserUnitTest.java b/src/test/java/org/mvel/tests/ParserUnitTest.java\nindex 18a12bb..738f1f5 100644\n--- a/src/test/java/org/mvel/tests/ParserUnitTest.java\n+++ b/src/test/java/org/mvel/tests/ParserUnitTest.java\n@@ -63,6 +63,10 @@ public class ParserUnitTest extends TestCase {\n         assertEquals(true, parse(\"@{foo.bar.name != 'foo'}\"));\n     }\n \n+    public void testShortPathExpression() {\n+        assertEquals(null, parseDirect(\"3 > 4 && foo.toUC('test'); foo.register\"));\n+    }\n+\n     public void testChor() {\n         assertEquals(\"cat\", parse(\"@{a or b or c}\"));\n     }\ndiff --git a/src/test/java/org/mvel/tests/res/Foo.java b/src/test/java/org/mvel/tests/res/Foo.java\nindex 35a85e1..9cb228e 100644\n--- a/src/test/java/org/mvel/tests/res/Foo.java\n+++ b/src/test/java/org/mvel/tests/res/Foo.java\n@@ -1,10 +1,10 @@\n package org.mvel.tests.res;\n \n public class Foo {\n-    private Bar bar =  new Bar();\n+    private Bar bar = new Bar();\n+    public String register;\n \n     public void abc() {\n-        \n     }\n \n     public Bar getBar() {\n@@ -20,8 +20,8 @@ public class Foo {\n     }\n \n     public String toUC(String s) {\n+        register = s;\n+        System.out.println(\"toUC('\" + s + \"')\");\n         return s.toUpperCase();\n     }\n-\n-\n }\n"}
{"repository": "mvel/mvel", "clone_url": "https://github.com/mvel/mvel.git", "timestamp": "2023-06-01T20:06:03.291389Z", "commit_hash": "c5a29c60643a275e757e5ea6e6c42a6adff81c18", "commit_message": "BUGFIX: this reference in subexpressions\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/mvel/compiled/CompiledAccessor.java b/src/main/java/org/mvel/compiled/CompiledAccessor.java\nindex 51b6e0b..de9fce6 100644\n--- a/src/main/java/org/mvel/compiled/CompiledAccessor.java\n+++ b/src/main/java/org/mvel/compiled/CompiledAccessor.java\n@@ -1,8 +1,11 @@\n package org.mvel.compiled;\n \n import org.mvel.*;\n+import static org.mvel.ExpressionParser.compileExpression;\n+import static org.mvel.ExpressionParser.executeExpression;\n import org.mvel.integration.VariableResolverFactory;\n import org.mvel.util.ParseTools;\n+import static org.mvel.util.ParseTools.parseParameterList;\n import org.mvel.util.PropertyTools;\n \n import java.io.Serializable;\n@@ -132,7 +135,6 @@ public class CompiledAccessor {\n     }\n \n     public void addAccessorNode(AccessorNode an) {\n-\n         if (currNode == null)\n             rootNode = currNode = an;\n         else {\n@@ -174,19 +176,13 @@ public class CompiledAccessor {\n \n             addAccessorNode(accessor);\n \n-            return ctx;\n+            return this.ctx;\n         }\n         else if (variableFactory != null && variableFactory.isResolveable(property)) {\n-//            DefaultPropertyMapAccessor accessor = new DefaultPropertyMapAccessor();\n-//            accessor.setProperty(property);\n-//\n-//            addAccessorNode(accessor);\n             VariableAccessor accessor = new VariableAccessor(property, variableFactory);\n \n             addAccessorNode(accessor);\n \n-//            System.out.println(\"property = \" + property);\n-//            System.out.println(\"vr = \" + variableFactory.getVariableResolver(property));\n             return variableFactory.getVariableResolver(property).getValue();\n         }\n         else if (Token.LITERALS.containsKey(property)) {\n@@ -369,18 +365,18 @@ public class CompiledAccessor {\n                 es = SUBEXPRESSION_CACHE.get(tk);\n                 args = new Object[es.length];\n                 for (int i = 0; i < es.length; i++) {\n-                    args[i] = ExpressionParser.executeExpression(es[i], ctx, variableFactory);\n+                    args[i] = executeExpression(es[i], ctx, variableFactory);\n                 }\n \n             }\n             else {\n-                String[] subtokens = ParseTools.parseParameterList(tk.toCharArray(), 0, -1);\n+                String[] subtokens = parseParameterList(tk.toCharArray(), 0, -1);\n \n                 es = new Serializable[subtokens.length];\n                 args = new Object[subtokens.length];\n                 for (int i = 0; i < subtokens.length; i++) {\n-                    es[i] = ExpressionParser.compileExpression(subtokens[i]);\n-                    args[i] = ExpressionParser.executeExpression(es[i], ctx, variableFactory);\n+                    es[i] = compileExpression(subtokens[i]);\n+                    args[i] = executeExpression(es[i], this.ctx, variableFactory);\n                     ((CompiledExpression) es[i]).setKnownEgressType(args[i] != null ? args[i].getClass() : null);\n                 }\n \ndiff --git a/src/main/java/org/mvel/compiled/ThisValueAccessor.java b/src/main/java/org/mvel/compiled/ThisValueAccessor.java\nindex f43c390..60740ac 100644\n--- a/src/main/java/org/mvel/compiled/ThisValueAccessor.java\n+++ b/src/main/java/org/mvel/compiled/ThisValueAccessor.java\n@@ -1,17 +1,11 @@\n package org.mvel.compiled;\n \n import org.mvel.AccessorNode;\n-import org.mvel.ExpressionParser;\n import org.mvel.integration.VariableResolverFactory;\n \n-import java.lang.reflect.Method;\n-import java.io.Serializable;\n-import java.util.Map;\n-\n public class ThisValueAccessor implements AccessorNode {\n     private AccessorNode nextNode;\n \n-\n     public Object getValue(Object ctx, Object elCtx, VariableResolverFactory vars) throws Exception {\n         if (nextNode != null) {\n             return this.nextNode.getValue(\n", "test_patch": "diff --git a/src/test/java/org/mvel/tests/Base.java b/src/test/java/org/mvel/tests/Base.java\nindex 5745f92..f8736e1 100644\n--- a/src/test/java/org/mvel/tests/Base.java\n+++ b/src/test/java/org/mvel/tests/Base.java\n@@ -1,12 +1,13 @@\n package org.mvel.tests;\n \n-import java.util.List;\n import java.util.ArrayList;\n-import java.util.Map;\n import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n \n public class Base {\n     public String data = \"cat\";\n+    public String number = \"101\";\n     public List<String> list;\n     public List<Thing> things;\n     public Boolean fun =  false;\ndiff --git a/src/test/java/org/mvel/tests/CompiledTest.java b/src/test/java/org/mvel/tests/CompiledTest.java\nindex c52c457..efc656d 100644\n--- a/src/test/java/org/mvel/tests/CompiledTest.java\n+++ b/src/test/java/org/mvel/tests/CompiledTest.java\n@@ -428,6 +428,10 @@ public class CompiledTest extends TestCase {\n         assertEquals(\"FooBar\", parseDirect(\"java.lang.String.valueOf('FooBar')\"));\n     }\n \n+    public void testThisReferenceInMethodCall() {\n+        assertEquals(101, parseDirect(\"Integer.parseInt(this.number)\"));\n+    }\n+\n \n     public Object parseDirect(String ex) {\n         return compiledExecute(ex);\n@@ -451,7 +455,7 @@ public class CompiledTest extends TestCase {\n         final String expr = \"10 + 1 + 3\";\n         Serializable compiled = ExpressionParser.compileExpression(expr);\n \n-        for (int i = 0; i < 10000000; i++) {\n+        for (int i = 0; i < 10000; i++) {\n             ExpressionParser.executeExpression(compiled, map);\n         }\n     }\n@@ -463,7 +467,7 @@ public class CompiledTest extends TestCase {\n         MapVariableResolverFactory variableTable = new MapVariableResolverFactory(map);\n         variableTable.pack();\n \n-        for (int i = 0; i < 1000000; i++) {\n+        for (int i = 0; i < 10000; i++) {\n             ExpressionParser.executeExpression(compiled, variableTable);\n         }\n     }\n"}
