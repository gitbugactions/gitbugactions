{"repository": "pedrovgs/Algorithms", "clone_url": "https://github.com/pedrovgs/Algorithms.git", "timestamp": "2023-05-31T18:27:24.145522Z", "commit_hash": "ed6f8a49948c09a21bfeb7bc38b4f24141795e38", "commit_message": "fix quick sort partition for special inputs and update testcase (#52)\n\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/com/github/pedrovgs/problem80/QuickSort.java b/src/main/java/com/github/pedrovgs/problem80/QuickSort.java\nindex ca2899f..af8d162 100644\n--- a/src/main/java/com/github/pedrovgs/problem80/QuickSort.java\n+++ b/src/main/java/com/github/pedrovgs/problem80/QuickSort.java\n@@ -57,19 +57,13 @@ public class QuickSort extends SortingAlgorithm {\n \n   private int partition(int[] numbers, int left, int right) {\n     int pivot = numbers[right];\n-    while (left < right) {\n-      while (numbers[left] < pivot) {\n-        left++;\n-      }\n-      while (numbers[right] > pivot) {\n-        right--;\n-      }\n-      if (left <= right) {\n-        int temp = numbers[left];\n-        numbers[left] = numbers[right];\n-        numbers[right] = temp;\n+    int i = left - 1;\n+    for (int j = left; j < right; ++j) {\n+      if (numbers[j] <= pivot) {\n+        swap(numbers, ++i, j);\n       }\n     }\n-    return left; //pivot index\n+    swap(numbers, ++i, right);\n+    return i;\n   }\n }\n", "test_patch": "diff --git a/src/test/java/com/github/pedrovgs/sortingalgorithms/SortingAlgorithmTest.java b/src/test/java/com/github/pedrovgs/sortingalgorithms/SortingAlgorithmTest.java\nindex f57e22d..59e70cb 100644\n--- a/src/test/java/com/github/pedrovgs/sortingalgorithms/SortingAlgorithmTest.java\n+++ b/src/test/java/com/github/pedrovgs/sortingalgorithms/SortingAlgorithmTest.java\n@@ -79,4 +79,15 @@ public abstract class SortingAlgorithmTest {\n     int[] expectedArray = { 1, 2, 3, 4 };\n     assertArrayEquals(expectedArray, input);\n   }\n+\n+  @Test(timeout = 5 * 1000)\n+  public void shouldSortSpecialArray() {\n+    int[] input = {12, -37, -5, 43, 62, 45, -95, -70, -55, -62, -24, -14,\n+            -75, 43, 9, 58, -62, -22, -55};\n+\n+    sortingAlgorithm.sort(input);\n+\n+    int[] expectedArray = {-95, -75, -70, -62, -62, -55, -55, -37, -24, -22, -14, -5, 9, 12, 43, 43, 45, 58, 62};\n+    assertArrayEquals(expectedArray, input);\n+  }\n }\n"}
{"repository": "pedrovgs/Algorithms", "clone_url": "https://github.com/pedrovgs/Algorithms.git", "timestamp": "2023-05-31T18:33:33.436629Z", "commit_hash": "9ae21a5c070c9a97e05ef56b2d1f6d764b609f9e", "commit_message": "Two bugs fix + two typo + one test (#38)\n\n* Fix bottom increasement instead of decrement in SquareRoot\r\n\r\n* Fix typo\r\n\r\n* Fix typo\r\n\r\n* Add moveSorting test and fix swap condition in it's implementation\r\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/com/github/pedrovgs/problem10/RemoveDuplicates.java b/src/main/java/com/github/pedrovgs/problem10/RemoveDuplicates.java\nindex e9b0ab7..aaf1a93 100644\n--- a/src/main/java/com/github/pedrovgs/problem10/RemoveDuplicates.java\n+++ b/src/main/java/com/github/pedrovgs/problem10/RemoveDuplicates.java\n@@ -26,7 +26,7 @@ import java.util.Set;\n  * Given an array full of integers, can you write a method returning other array without duplicated\n  * elements? The elements order doesn't care. For example:\n  *\n- * Input: [1,2,3,1] Output: [1,1,12]\n+ * Input: [1,2,3,1] Output: [1,2,3]\n  * Input: [1,1,1,1,1] Output: [1]\n  *\n  * @author Pedro Vicente G\u00f3mez S\u00e1nchez.\ndiff --git a/src/main/java/com/github/pedrovgs/problem12/MoveZerosInArray.java b/src/main/java/com/github/pedrovgs/problem12/MoveZerosInArray.java\nindex a8e942a..ab63ed3 100644\n--- a/src/main/java/com/github/pedrovgs/problem12/MoveZerosInArray.java\n+++ b/src/main/java/com/github/pedrovgs/problem12/MoveZerosInArray.java\n@@ -39,7 +39,7 @@ public class MoveZerosInArray {\n     while (swap) {\n       swap = false;\n       for (int i = 0; i < array.length - 1; i++) {\n-        if ((array[i] < array[i + 1] && array[i + 1] > 0)) {\n+        if (array[i] == 0 && array[i + 1] != 0) {\n           swap(array, i, i + 1);\n           swap = true;\n         }\ndiff --git a/src/main/java/com/github/pedrovgs/problem13/BinaryTreeByLevel.java b/src/main/java/com/github/pedrovgs/problem13/BinaryTreeByLevel.java\nindex bf01de5..b0ef379 100644\n--- a/src/main/java/com/github/pedrovgs/problem13/BinaryTreeByLevel.java\n+++ b/src/main/java/com/github/pedrovgs/problem13/BinaryTreeByLevel.java\n@@ -31,7 +31,7 @@ public class BinaryTreeByLevel {\n \n   /**\n    * Add implementation based on an additional data structure, one queue which implementation is a\n-   * LinkedList. We we are going to do is add elements of the tree to the queue and one by one\n+   * LinkedList. What we are going to do is add elements of the tree to the queue and one by one\n    * evaluate it adding more binary nodes to the queue if exist. The complexity order in time terms\n    * is O(N) where N is the number of elements in the tree. The complexity order in space terms is\n    * O(N) where N is the number of elements in the tree because we are going to store every node in\ndiff --git a/src/main/java/com/github/pedrovgs/problem4/SquareRoot.java b/src/main/java/com/github/pedrovgs/problem4/SquareRoot.java\nindex 809da1e..aac4394 100644\n--- a/src/main/java/com/github/pedrovgs/problem4/SquareRoot.java\n+++ b/src/main/java/com/github/pedrovgs/problem4/SquareRoot.java\n@@ -61,7 +61,7 @@ public class SquareRoot {\n       if (result > number) {\n         top -= 0.1f;\n       } else {\n-        bottom -= 0.1f;\n+        bottom += 0.1f;\n       }\n       newCandidate = (top + bottom) / 2;\n       result = newCandidate * newCandidate;\n", "test_patch": "diff --git a/src/test/java/com/github/pedrovgs/problem12/MoveZerosInArrayTest.java b/src/test/java/com/github/pedrovgs/problem12/MoveZerosInArrayTest.java\nindex 2865ed0..99f8562 100644\n--- a/src/test/java/com/github/pedrovgs/problem12/MoveZerosInArrayTest.java\n+++ b/src/test/java/com/github/pedrovgs/problem12/MoveZerosInArrayTest.java\n@@ -44,6 +44,14 @@ public class MoveZerosInArrayTest {\n     assertArrayEquals(new int[0], array);\n   }\n \n+  @Test public void shouldWorkWithPositiveNegativeZerosArraySorting() {\n+    int[] array = {-1, 0, 2, 4, 0, -3, -5, 0, 6, -3, 0};\n+\n+    moveZeros.moveSorting(array);\n+\n+    assertZerosAtRight(array);\n+  }\n+\n   @Test public void shouldOrganizeAnArrayFullOfZerosSorting() {\n     int[] array = { 0, 0, 0, 0, 0 };\n \n"}
{"repository": "pedrovgs/Algorithms", "clone_url": "https://github.com/pedrovgs/Algorithms.git", "timestamp": "2023-05-31T18:47:17.000849Z", "commit_hash": "44ce61beeb8bb5c5c1289db02f1da53f6bff6d8a", "commit_message": "Merge pull request #24 from tm4s/master\n\nFibonnaci fix", "related_issues": "", "bug_patch": "diff --git a/src/main/java/com/github/pedrovgs/problem7/FibonacciNumbers.java b/src/main/java/com/github/pedrovgs/problem7/FibonacciNumbers.java\nindex bd0033f..6d19093 100644\n--- a/src/main/java/com/github/pedrovgs/problem7/FibonacciNumbers.java\n+++ b/src/main/java/com/github/pedrovgs/problem7/FibonacciNumbers.java\n@@ -41,9 +41,9 @@ public class FibonacciNumbers {\n    * terms, the complexity order of this algorithm is O(1) because we are not using any auxiliary\n    * data structure to solve this problem.\n    */\n-  public int getRecursive(int n) {\n+  public long getRecursive(long n) {\n     validateInput(n);\n-    if (n == 0 || n == 1) {\n+    if (n == 1 || n == 2) {\n       return 1;\n     } else {\n       return getRecursive(n - 1) + getRecursive(n - 2);\n@@ -54,16 +54,16 @@ public class FibonacciNumbers {\n    * Iterative approach. The complexity order in this algorithm is O(N) where N is the integer used\n    * as parameter. In space terms, the complexity order of this algorithm is again O(1).\n    */\n-  public int getIterative(int n) {\n+  public long getIterative(long n) {\n     validateInput(n);\n \n-    if (n <= 1) {\n+    if (n <= 2) {\n       return 1;\n     }\n-    int previous = 1;\n-    int current = 1;\n-    int element = 0;\n-    for (int i = 2; i <= n; i++) {\n+    long previous = 1;\n+    long current = 1;\n+    long element = 0;\n+    for (long i = 3; i <= n; i++) {\n       element = previous + current;\n       previous = current;\n       current = element;\n@@ -71,7 +71,7 @@ public class FibonacciNumbers {\n     return element;\n   }\n \n-  private static int[] elements = new int[1000];\n+  private static long[] elements = new long[1000];\n \n   /**\n    * This version of the recursive algorithm is better in performance terms because we are caching\n@@ -85,19 +85,19 @@ public class FibonacciNumbers {\n    * the one used for the previous algorithms. In this case, we have O(N) because we are using an\n    * additional data structure to store partial results.\n    */\n-  public int getRecursiveWithCaching(int n) {\n+  public long getRecursiveWithCaching(int n) {\n     validateInput(n);\n \n-    if (n <= 1) {\n+    if (n <= 2) {\n       return 1;\n-    } else if (elements[n] != 0) {\n-      return elements[n];\n+    } else if (elements[n - 3] != 0) {\n+      return elements[n - 3];\n     }\n-    elements[n] = getRecursiveWithCaching(n - 1) + getRecursiveWithCaching(n - 2);\n-    return elements[n];\n+    elements[n - 3] = getRecursiveWithCaching(n - 1) + getRecursiveWithCaching(n - 2);\n+    return elements[n - 3];\n   }\n \n-  private void validateInput(int n) {\n+  private void validateInput(long n) {\n     if (n < 0) {\n       throw new IllegalArgumentException(\"You can't use negative values as parameter.\");\n     }\n", "test_patch": "diff --git a/src/test/java/com/github/pedrovgs/problem7/FibonacciNumbersTest.java b/src/test/java/com/github/pedrovgs/problem7/FibonacciNumbersTest.java\nindex 64facd7..7bdc256 100644\n--- a/src/test/java/com/github/pedrovgs/problem7/FibonacciNumbersTest.java\n+++ b/src/test/java/com/github/pedrovgs/problem7/FibonacciNumbersTest.java\n@@ -41,11 +41,11 @@ public class FibonacciNumbersTest {\n   }\n \n   @Test public void fourthNumberInFibonacciSequenceIsThreeRecursive() {\n-    assertEquals(5, fibonacciNumbers.getRecursive(4));\n+    assertEquals(5, fibonacciNumbers.getRecursive(5));\n   }\n \n   @Test public void eleventhNumberInFibonacciSequenceIsRecursive() {\n-    assertEquals(144, fibonacciNumbers.getRecursive(11));\n+    assertEquals(144, fibonacciNumbers.getRecursive(12));\n   }\n \n   @Test(expected = IllegalArgumentException.class)\n@@ -58,11 +58,11 @@ public class FibonacciNumbersTest {\n   }\n \n   @Test public void fourthNumberInFibonacciSequenceIsThreeIterative() {\n-    assertEquals(5, fibonacciNumbers.getIterative(4));\n+    assertEquals(5, fibonacciNumbers.getIterative(5));\n   }\n \n   @Test public void eleventhNumberInFibonacciSequenceIsIterative() {\n-    assertEquals(144, fibonacciNumbers.getIterative(11));\n+    assertEquals(144, fibonacciNumbers.getIterative(12));\n   }\n \n   @Test(expected = IllegalArgumentException.class)\n@@ -71,10 +71,10 @@ public class FibonacciNumbersTest {\n   }\n \n   @Test public void fourthNumberInFibonacciSequenceIsThreeRecursiveWithCatching() {\n-    assertEquals(5, fibonacciNumbers.getRecursiveWithCaching(4));\n+    assertEquals(5, fibonacciNumbers.getRecursiveWithCaching(5));\n   }\n \n   @Test public void eleventhNumberInFibonacciSequenceIsRecursiveWithCatching() {\n-    assertEquals(144, fibonacciNumbers.getRecursiveWithCaching(11));\n+    assertEquals(144, fibonacciNumbers.getRecursiveWithCaching(12));\n   }\n }\n"}
{"repository": "pedrovgs/Algorithms", "clone_url": "https://github.com/pedrovgs/Algorithms.git", "timestamp": "2023-05-31T18:59:43.440131Z", "commit_hash": "bceffabe0d850ea9c67c93a9fb578d2ca8600022", "commit_message": "Merge pull request #14 from ajinkyakolhe112/master\n\nFixed build failures", "related_issues": "", "bug_patch": "diff --git a/src/main/java/com/github/pedrovgs/problem3/SumBinaryNumbers.java b/src/main/java/com/github/pedrovgs/problem3/SumBinaryNumbers.java\nindex d13ba07..f5570cd 100644\n--- a/src/main/java/com/github/pedrovgs/problem3/SumBinaryNumbers.java\n+++ b/src/main/java/com/github/pedrovgs/problem3/SumBinaryNumbers.java\n@@ -9,126 +9,111 @@ package com.github.pedrovgs.problem3;\n  */\n public class SumBinaryNumbers {\n \n-  /**\n-   * To solve this problem we are using 'Integer.parseInt(number,base)' method which complexity\n-   * order is linear O(N) two times. Then, we are going to calculate the sum of this parsed data\n-   * and use 'Integer.toBinaryString' which complexity order is also O(N). In both cases, N\n-   * represents the number of digits of input number in binary representation.\n-   *\n-   * This implementation is working and is valid but we have to take into the execution time used\n-   * to calculate this sum.\n-   */\n-  public String sumBinaryNumbersCheating(String n1, String n2) {\n-    validateInput(n1, n2);\n+    /**\n+     * To solve this problem we are using 'Integer.parseInt(number,base)' method which complexity\n+     * order is linear O(N) two times. Then, we are going to calculate the sum of this parsed data\n+     * and use 'Integer.toBinaryString' which complexity order is also O(N). In both cases, N\n+     * represents the number of digits of input number in binary representation.\n+     *\n+     * This implementation is working and is valid but we have to take into the execution time used\n+     * to calculate this sum.\n+     */\n+    public String sumBinaryNumbersCheating(String n1, String n2) {\n+        validateInput(n1, n2);\n \n-    int number1, number2;\n-    try {\n-      number1 = Integer.parseInt(n1, 2);\n-      number2 = Integer.parseInt(n2, 2);\n-    } catch (NumberFormatException e) {\n-      throw new IllegalArgumentException(\n-          \"Error parsing input data, review your parameters, should be a valid binary number!\");\n+        int number1, number2;\n+        try {\n+            number1 = Integer.parseInt(n1, 2);\n+            number2 = Integer.parseInt(n2, 2);\n+        } catch (NumberFormatException e) {\n+            throw new IllegalArgumentException(\n+                    \"Error parsing input data, review your parameters, should be a valid binary number!\");\n+        }\n+        int result = number1 + number2;\n+        return Integer.toBinaryString(result);\n     }\n-    int result = number1 + number2;\n-    return Integer.toBinaryString(result);\n-  }\n \n-  /**\n-   * To improve the execution time of the previous algorithm we are going to  use how an integer is\n-   * represented in binary. We are going to go through the binary number calculating the number\n-   * value and at the same time getting the result. This solution is based on the binary number\n-   * structure where 101 = 1*2^2 + 0*2^1 + 1*2^0 = 5. With this solution we are not going to use\n-   * Integer.parseInt(..) method to parse input data.\n-   *\n-   * The complexity order of this solution is O(N) in time terms where N is the number of digits in\n-   * the binary number. Is the same complexity order we had, but the execution time is lower.\n-   *\n-   * With this solution we are still using 'Integer.toBinaryString(result)' to get the binary\n-   * representation.\n-   */\n-  public String sumBinaryNumbersBasedOnPowersOfTwo(String n1, String n2) {\n-    validateInput(n1, n2);\n+    /**\n+     * To improve the execution time of the previous algorithm we are going to  use how an integer is\n+     * represented in binary. We are going to go through the binary number calculating the number\n+     * value and at the same time getting the result. This solution is based on the binary number\n+     * structure where 101 = 1*2^2 + 0*2^1 + 1*2^0 = 5. With this solution we are not going to use\n+     * Integer.parseInt(..) method to parse input data.\n+     *\n+     * The complexity order of this solution is O(N) in time terms where N is the number of digits in\n+     * the binary number. Is the same complexity order we had, but the execution time is lower.\n+     *\n+     * With this solution we are still using 'Integer.toBinaryString(result)' to get the binary\n+     * representation.\n+     */\n+    public String sumBinaryNumbersBasedOnPowersOfTwo(String n1, String n2) {\n+        validateInput(n1, n2);\n \n-    int result = 0;\n-    int length = Math.max(n1.length(), n2.length());\n-    for (int i = 0; i < length; i++) {\n-      result += getValueAt(n1, i) * Math.pow(2, length - i - 1);\n-      result += getValueAt(n2, i) * Math.pow(2, length - i - 1);\n+        int result = 0;\n+        int length = Math.max(n1.length(), n2.length());\n+        for (int i = 0; i < length; i++) {\n+            result += getValueAt(n1, i) * Math.pow(2, length - i - 1);\n+            result += getValueAt(n2, i) * Math.pow(2, length - i - 1);\n+        }\n+        return Integer.toBinaryString(result);\n     }\n-    return Integer.toBinaryString(result);\n-  }\n \n-  /**\n-   * We are going to subtract 48 to the char to get the number value from the String. This is\n-   * going to work because the char set we are using is ASCII.\n-   */\n-  private static int getValueAt(String binaryNumber, int index) {\n-    int value = binaryNumber.charAt(index) - 48;\n-    if (value < 0 || value > 1) {\n-      throw new IllegalArgumentException(\n-          \"Error parsing input data, review your parameters, should be a valid binary number!\");\n+    /**\n+     * We are going to subtract 48 to the char to get the number value from the String. This is\n+     * going to work because the char set we are using is ASCII.\n+     */\n+    private static int getValueAt(String binaryNumber, int index) {\n+        int value = binaryNumber.charAt(index) - 48;\n+        if (value < 0 || value > 1) {\n+            throw new IllegalArgumentException(\n+                    \"Error parsing input data, review your parameters, should be a valid binary number!\");\n+        }\n+        return value;\n     }\n-    return value;\n-  }\n \n-  /**\n-   * This solution is the faster I've found. It's similar to how a human sum two binary numbers.\n-   *\n-   * The complexity order of this algorithm is O(N) where N is the number of digits of the biggest\n-   * binary number. This is the faster implementation because we are not parsing data from binary\n-   * to integer and then from integer to binary.\n-   *\n-   * To solve this problem is needed go through the String from right to left, and take always\n-   * into account the accumulated value of the sum.\n-   */\n-  public String sumBinaryNumbersBasedOnCount(String n1, String n2) {\n-    validateInput(n1, n2);\n+    /**\n+     * This solution is the faster I've found. It's similar to how a human sum two binary numbers.\n+     *\n+     * The complexity order of this algorithm is O(N) where N is the number of digits of the biggest\n+     * binary number. This is the faster implementation because we are not parsing data from binary\n+     * to integer and then from integer to binary.\n+     *\n+     * To solve this problem is needed go through the String from right to left, and take always\n+     * into account the accumulated value of the sum and carry.\n+     */\n+    public String sumBinaryNumbersBasedOnCount(String n1, String n2) {\n+        validateInput(n1, n2);\n \n-    StringBuilder result = new StringBuilder();\n-    int lengthVal1 = n1.length();\n-    int lengthVal2 = n2.length();\n-    int length = Math.max(lengthVal1, lengthVal2);\n-    int acc = 0;\n-    for (int i = 0; i < length; i++) {\n-      //This is a beautiful trick to avoid IndexOutOfBoundExceptions.\n-      char c1 = i >= lengthVal1 ? '0' : n1.charAt(lengthVal1 - i - 1);\n-      char c2 = i >= lengthVal2 ? '0' : n2.charAt(lengthVal2 - i - 1);\n+        StringBuilder result = new StringBuilder();\n+        int lengthVal1 = n1.length();\n+        int lengthVal2 = n2.length();\n+        int length = Math.max(lengthVal1, lengthVal2);\n+        int carry = 0;\n+        int sum = 0;\n+        int remainder = 0;\n+        for (int i = 0; i < length; i++) {\n+            //This is a beautiful trick to avoid IndexOutOfBoundExceptions.\n+            int digit1 = i >= lengthVal1 ? 0 : n1.charAt(lengthVal1 - i - 1) - '0';\n+            int digit2 = i >= lengthVal2 ? 0 : n2.charAt(lengthVal2 - i - 1) - '0';\n \n-      //Check every different combination taking into account the accumulated value.\n-      if (c1 == '0' && c2 == '0') {\n-        if (acc == 0) {\n-          result.append(0);\n-        } else {\n-          result.append(1);\n+            if (digit1 < 2 && digit2 < 2) {\n+                sum = digit1 + digit2 + carry;\n+                carry = sum / 2;\n+                remainder = sum % 2;\n+                result.append((char) (remainder + '0'));\n+            } else {\n+                throw new IllegalArgumentException(\n+                        \"Error parsing input data, review your parameters, should be a valid binary number!\");\n+            }\n         }\n-        acc = 0;\n-      } else if (c1 == '0' && c2 == '1' || c1 == '1' && c2 == '0') {\n-        if (acc == 0) {\n-          result.append(1);\n-          acc = 0;\n-        } else {\n-          result.append(0);\n-          acc = 1;\n-        }\n-      } else if (c1 == '1' && c2 == '1') {\n-        if (acc == 0) {\n-          result.append(0);\n-        } else {\n-          result.append(1);\n-        }\n-        acc = 1;\n-      } else {\n-        throw new IllegalArgumentException(\n-            \"Error parsing input data, review your parameters, should be a valid binary number!\");\n-      }\n+        if (carry != 0)\n+            result.append((char) (carry + '0'));\n+        return result.reverse().toString();\n     }\n-    result.append(acc);\n-    return result.reverse().toString();\n-  }\n \n-  private void validateInput(String n1, String n2) {\n-    if (n1 == null || n2 == null) {\n-      throw new IllegalArgumentException(\"n1 and n2 parameters can't be null\");\n+    private void validateInput(String n1, String n2) {\n+        if (n1 == null || n2 == null) {\n+            throw new IllegalArgumentException(\"n1 and n2 parameters can't be null\");\n+        }\n     }\n-  }\n }\ndiff --git a/src/main/java/com/github/pedrovgs/problem4/SquareRoot.java b/src/main/java/com/github/pedrovgs/problem4/SquareRoot.java\nindex 34c11f0..96751bf 100644\n--- a/src/main/java/com/github/pedrovgs/problem4/SquareRoot.java\n+++ b/src/main/java/com/github/pedrovgs/problem4/SquareRoot.java\n@@ -33,8 +33,12 @@ public class SquareRoot {\n    *\n    * The complexity order in space terms of this algorithm is O(1) because we are not using any\n    * additional data structure. The complexity order in time terms is more difficult to calculate\n-   * O(sqrt(N)) + O(binarySearch) = O(sqrt(N)) the binary search complexity order depends on the\n-   * number of decimals the solution contains.\n+   * T(N) = T(N/2) + c  where as N is step length. Which is 1 initially. 0.5 after that. 0.25 after that\n+   * Stopping condition of this recurrence relation is dependant on delta. If it is 0, then time complexity is infinite\n+   * So we won't be able to calculate the exact time complexity using master's theorem.\n+   * As square root is an irrational number for non square numbers.\n+   * But here, it will be function of delta and precision of the variables used. Which is difficult to calculate.\n+   *\n    */\n   public float calculateSquareRootIterative(int number) {\n     //Search first candidate\n@@ -68,7 +72,7 @@ public class SquareRoot {\n    * Tail recursive approach to resolve this problem. This algorithm is based on a binary search,\n    * as\n    * the previous one, but implemented using a tail recursive approach. In space terms, the\n-   * complexity order of this solution is O(1) and in time terms is O(log(N)), similar to the other\n+   * complexity order of this solution is O(1) and in time terms is similar to the other\n    * implementation.\n    *\n    * This public method uses a private method to hide the algorithm implementation.\ndiff --git a/src/main/java/com/github/pedrovgs/problem8/SplitArray.java b/src/main/java/com/github/pedrovgs/problem8/SplitArray.java\nindex 66bbf84..dcdbfd7 100644\n--- a/src/main/java/com/github/pedrovgs/problem8/SplitArray.java\n+++ b/src/main/java/com/github/pedrovgs/problem8/SplitArray.java\n@@ -33,7 +33,7 @@ public class SplitArray {\n    *\n    * The complexity order in this O(N^2) where N is number of elements in the array. Is even worst\n    * than the bubble sorting algorithm because to check if we have to swap any element is really\n-   * expensive. In time terms, the complexity order of this algorithm is O(1) because we are not\n+   * expensive. In space terms, the complexity order of this algorithm is O(1) because we are not\n    * using any additional data structure.\n    */\n   public void splitSorting(int[] array) {\n", "test_patch": "diff --git a/src/test/java/com/github/pedrovgs/problem3/SumBinaryNumberTest.java b/src/test/java/com/github/pedrovgs/problem3/SumBinaryNumberTest.java\nindex 66861f3..9ecb134 100644\n--- a/src/test/java/com/github/pedrovgs/problem3/SumBinaryNumberTest.java\n+++ b/src/test/java/com/github/pedrovgs/problem3/SumBinaryNumberTest.java\n@@ -156,7 +156,7 @@ public class SumBinaryNumberTest {\n \n     String result = sumBinaryNumbers.sumBinaryNumbersBasedOnCount(n1, n2);\n \n-    assertEquals(\"010\", result);\n+    assertEquals(\"10\", result);\n   }\n \n   @Test public void zeroPlusTwoEqualsTwoBasedOnCount() {\n"}
