{"repository": "vanilladb/vanillacore", "clone_url": "https://github.com/vanilladb/vanillacore.git", "timestamp": "2023-05-31T18:27:36.238153Z", "commit_hash": "130b616328a032eeb5956c2a287dfe6198535364", "commit_message": "Merge pull request #102 from vanilladb/hotfix-planner\n\nFix bug in MultiBufferProductScan", "related_issues": "", "bug_patch": "diff --git a/.gitignore b/.gitignore\nindex 138fbe2..e4b9cee 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -1,3 +1,5 @@\n+### IntelliJ ###\n+.idea/\n \n ### Eclipse ###\n .settings/\ndiff --git a/src/main/java/org/vanilladb/core/query/algebra/multibuffer/MultiBufferProductScan.java b/src/main/java/org/vanilladb/core/query/algebra/multibuffer/MultiBufferProductScan.java\nindex 286c789..3b637a6 100644\n--- a/src/main/java/org/vanilladb/core/query/algebra/multibuffer/MultiBufferProductScan.java\n+++ b/src/main/java/org/vanilladb/core/query/algebra/multibuffer/MultiBufferProductScan.java\n@@ -59,7 +59,7 @@ public class MultiBufferProductScan implements Scan {\n \t */\r\n \t@Override\r\n \tpublic void beforeFirst() {\r\n-\t\tnextBlkNum = 0;\r\n+\t\tnextBlkNum = 1; // Record page starts from page 1 since page 0 is reserved for file header\r\n \t\tuseNextChunk();\r\n \t}\r\n \r\n", "test_patch": "diff --git a/src/test/java/org/vanilladb/core/query/planner/BasicQueryPlannerTest.java b/src/test/java/org/vanilladb/core/query/planner/BasicQueryPlannerTest.java\nindex 3f77987..c957364 100644\n--- a/src/test/java/org/vanilladb/core/query/planner/BasicQueryPlannerTest.java\n+++ b/src/test/java/org/vanilladb/core/query/planner/BasicQueryPlannerTest.java\n@@ -15,9 +15,7 @@\n  *******************************************************************************/\r\n package org.vanilladb.core.query.planner;\r\n \r\n-import static org.junit.Assert.assertEquals;\r\n-import static org.junit.Assert.assertTrue;\r\n-import static org.junit.Assert.fail;\r\n+import static org.junit.Assert.*;\r\n \r\n import java.sql.Connection;\r\n import java.util.logging.Level;\r\ndiff --git a/src/test/java/org/vanilladb/core/query/planner/opt/HeuristicQueryPlannerTest.java b/src/test/java/org/vanilladb/core/query/planner/opt/HeuristicQueryPlannerTest.java\nindex 2bfec41..524e853 100644\n--- a/src/test/java/org/vanilladb/core/query/planner/opt/HeuristicQueryPlannerTest.java\n+++ b/src/test/java/org/vanilladb/core/query/planner/opt/HeuristicQueryPlannerTest.java\n@@ -15,8 +15,8 @@\n  *******************************************************************************/\r\n package org.vanilladb.core.query.planner.opt;\r\n \r\n-import static org.junit.Assert.assertEquals;\r\n-import static org.junit.Assert.assertTrue;\r\n+import static org.junit.Assert.*;\r\n+import static org.junit.Assert.assertNotNull;\r\n import static org.vanilladb.core.sql.Type.BIGINT;\r\n import static org.vanilladb.core.sql.Type.INTEGER;\r\n import static org.vanilladb.core.sql.Type.VARCHAR;\r\n@@ -77,7 +77,56 @@ public class HeuristicQueryPlannerTest {\n \tpublic void finishTx() {\r\n \t\ttx.commit();\r\n \t}\r\n-\t\r\n+\r\n+\t@Test\r\n+\tpublic void testImplicitJoin() {\r\n+\t\tCatalogMgr catalog = VanillaDb.catalogMgr();\r\n+\r\n+\t\tSchema tableASchema = new Schema();\r\n+\t\tSchema tableBSchema = new Schema();\r\n+\r\n+\t\ttableASchema.addField(\"id_a\", INTEGER);\r\n+\t\ttableBSchema.addField(\"id_b\", INTEGER);\r\n+\r\n+\t\tcatalog.createTable(\"table_a\", tableASchema, tx);\r\n+\t\tcatalog.createTable(\"table_b\", tableBSchema, tx);\r\n+\r\n+\t\tTableInfo aInfo = catalog.getTableInfo(\"table_a\", tx);\r\n+\t\tassertNotNull(aInfo);\r\n+\t\tTableInfo bInfo = catalog.getTableInfo(\"table_b\", tx);\r\n+\t\tassertNotNull(bInfo);\r\n+\r\n+\t\tRecordFile aRecordFile = aInfo.open(tx, true);\r\n+\t\tRecordFile bRecordFile = bInfo.open(tx, true);\r\n+\r\n+\t\taRecordFile.insert();\r\n+\t\taRecordFile.setVal(\"id_a\", new IntegerConstant(1));\r\n+\t\tbRecordFile.insert();\r\n+\t\tbRecordFile.setVal(\"id_b\", new IntegerConstant(2));\r\n+\r\n+\t\taRecordFile.close();\r\n+\t\tbRecordFile.close();\r\n+\r\n+\t\tString selectQuery = \"SELECT id_a, id_b FROM table_a, table_b;\";\r\n+\t\tParser parsedQuery = new Parser(selectQuery);\r\n+\t\tQueryData data = parsedQuery.queryCommand();\r\n+\r\n+\t\tPlan p = new HeuristicQueryPlanner().createPlan(data, tx);\r\n+\t\tScan s = p.open();\r\n+\r\n+\t\ts.beforeFirst();\r\n+\r\n+\t\tint numRecords = 0;\r\n+\t\twhile (s.next()) {\r\n+\t\t\tassertEquals(new IntegerConstant(1), s.getVal(\"id_a\"));\r\n+\t\t\tassertEquals(new IntegerConstant(2), s.getVal(\"id_b\"));\r\n+\t\t\t++numRecords;\r\n+\t\t}\r\n+\t\tassertEquals(1, numRecords);\r\n+\r\n+\t\ts.close();\r\n+\t}\r\n+\r\n \t@Test\r\n \tpublic void testQuery() {\r\n \t\tString qry = \"select sid, sname, majorid from student, dept \"\r\n"}
{"repository": "vanilladb/vanillacore", "clone_url": "https://github.com/vanilladb/vanillacore.git", "timestamp": "2023-05-31T18:42:52.012463Z", "commit_hash": "a8b29e9fc36935a9c2587c20113d12780de5c0ea", "commit_message": "Fix bug in MultiBufferProductScan\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/vanilladb/core/query/algebra/multibuffer/MultiBufferProductScan.java b/src/main/java/org/vanilladb/core/query/algebra/multibuffer/MultiBufferProductScan.java\nindex 286c789..3b637a6 100644\n--- a/src/main/java/org/vanilladb/core/query/algebra/multibuffer/MultiBufferProductScan.java\n+++ b/src/main/java/org/vanilladb/core/query/algebra/multibuffer/MultiBufferProductScan.java\n@@ -59,7 +59,7 @@ public class MultiBufferProductScan implements Scan {\n \t */\r\n \t@Override\r\n \tpublic void beforeFirst() {\r\n-\t\tnextBlkNum = 0;\r\n+\t\tnextBlkNum = 1; // Record page starts from page 1 since page 0 is reserved for file header\r\n \t\tuseNextChunk();\r\n \t}\r\n \r\n", "test_patch": "diff --git a/src/test/java/org/vanilladb/core/query/planner/opt/HeuristicQueryPlannerTest.java b/src/test/java/org/vanilladb/core/query/planner/opt/HeuristicQueryPlannerTest.java\nindex 17b7205..524e853 100644\n--- a/src/test/java/org/vanilladb/core/query/planner/opt/HeuristicQueryPlannerTest.java\n+++ b/src/test/java/org/vanilladb/core/query/planner/opt/HeuristicQueryPlannerTest.java\n@@ -82,29 +82,32 @@ public class HeuristicQueryPlannerTest {\n \tpublic void testImplicitJoin() {\r\n \t\tCatalogMgr catalog = VanillaDb.catalogMgr();\r\n \r\n-\t\tSchema tableSchema = new Schema();\r\n-\t\ttableSchema.addField(\"id\", INTEGER);\r\n+\t\tSchema tableASchema = new Schema();\r\n+\t\tSchema tableBSchema = new Schema();\r\n \r\n-\t\tcatalog.createTable(\"a\", tableSchema, tx);\r\n-\t\tcatalog.createTable(\"b\", tableSchema, tx);\r\n+\t\ttableASchema.addField(\"id_a\", INTEGER);\r\n+\t\ttableBSchema.addField(\"id_b\", INTEGER);\r\n \r\n-\t\tTableInfo aInfo = catalog.getTableInfo(\"a\", tx);\r\n+\t\tcatalog.createTable(\"table_a\", tableASchema, tx);\r\n+\t\tcatalog.createTable(\"table_b\", tableBSchema, tx);\r\n+\r\n+\t\tTableInfo aInfo = catalog.getTableInfo(\"table_a\", tx);\r\n \t\tassertNotNull(aInfo);\r\n-\t\tTableInfo bInfo = catalog.getTableInfo(\"b\", tx);\r\n+\t\tTableInfo bInfo = catalog.getTableInfo(\"table_b\", tx);\r\n \t\tassertNotNull(bInfo);\r\n \r\n \t\tRecordFile aRecordFile = aInfo.open(tx, true);\r\n \t\tRecordFile bRecordFile = bInfo.open(tx, true);\r\n \r\n \t\taRecordFile.insert();\r\n-\t\taRecordFile.setVal(\"id\", new IntegerConstant(1));\r\n+\t\taRecordFile.setVal(\"id_a\", new IntegerConstant(1));\r\n \t\tbRecordFile.insert();\r\n-\t\tbRecordFile.setVal(\"id\", new IntegerConstant(2));\r\n+\t\tbRecordFile.setVal(\"id_b\", new IntegerConstant(2));\r\n \r\n \t\taRecordFile.close();\r\n \t\tbRecordFile.close();\r\n \r\n-\t\tString selectQuery = \"SELECT id FROM a, b;\";\r\n+\t\tString selectQuery = \"SELECT id_a, id_b FROM table_a, table_b;\";\r\n \t\tParser parsedQuery = new Parser(selectQuery);\r\n \t\tQueryData data = parsedQuery.queryCommand();\r\n \r\n@@ -115,6 +118,8 @@ public class HeuristicQueryPlannerTest {\n \r\n \t\tint numRecords = 0;\r\n \t\twhile (s.next()) {\r\n+\t\t\tassertEquals(new IntegerConstant(1), s.getVal(\"id_a\"));\r\n+\t\t\tassertEquals(new IntegerConstant(2), s.getVal(\"id_b\"));\r\n \t\t\t++numRecords;\r\n \t\t}\r\n \t\tassertEquals(1, numRecords);\r\n"}
{"repository": "vanilladb/vanillacore", "clone_url": "https://github.com/vanilladb/vanillacore.git", "timestamp": "2023-05-31T19:43:22.516829Z", "commit_hash": "a3f91467d9a5392d6cd5dc07dcb51ed699ccdc88", "commit_message": "Merge pull request #44 from vanilladb/bugfix\n\nA few bugfixes for B-Trees and Stored Procedures", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/vanilladb/core/remote/storedprocedure/SpResultSet.java b/src/main/java/org/vanilladb/core/remote/storedprocedure/SpResultSet.java\nindex 216f2f0..4dc1988 100644\n--- a/src/main/java/org/vanilladb/core/remote/storedprocedure/SpResultSet.java\n+++ b/src/main/java/org/vanilladb/core/remote/storedprocedure/SpResultSet.java\n@@ -29,6 +29,7 @@ public class SpResultSet implements Serializable {\n \tprivate Record[] records;\r\n \r\n \tpublic SpResultSet(boolean isCommitted, Schema schema, Record... records) {\r\n+\t\tthis.isCommitted = isCommitted;\r\n \t\tthis.records = records;\r\n \t\tthis.schema = schema;\r\n \t}\r\ndiff --git a/src/main/java/org/vanilladb/core/sql/Type.java b/src/main/java/org/vanilladb/core/sql/Type.java\nindex 5cf4bf2..02500ee 100644\n--- a/src/main/java/org/vanilladb/core/sql/Type.java\n+++ b/src/main/java/org/vanilladb/core/sql/Type.java\n@@ -29,28 +29,6 @@ public abstract class Type {\n \t};\r\n \r\n \t/**\r\n-\t * Constructs a new instance corresponding to the specified SQL type.\r\n-\t * \r\n-\t * @param sqlType\r\n-\t *            the corresponding SQL type\r\n-\t * @return a new instance corresponding to the specified SQL type\r\n-\t */\r\n-\tpublic static Type newInstance(int sqlType) {\r\n-\t\tswitch (sqlType) {\r\n-\t\tcase (java.sql.Types.INTEGER):\r\n-\t\t\treturn INTEGER;\r\n-\t\tcase (java.sql.Types.BIGINT):\r\n-\t\t\treturn BIGINT;\r\n-\t\tcase (java.sql.Types.DOUBLE):\r\n-\t\t\treturn DOUBLE;\r\n-\t\tcase (java.sql.Types.VARCHAR):\r\n-\t\t\treturn VARCHAR;\r\n-\t\t}\r\n-\t\tthrow new UnsupportedOperationException(\"Unspported SQL type: \"\r\n-\t\t\t\t+ sqlType);\r\n-\t}\r\n-\r\n-\t/**\r\n \t * Constructs a new instance corresponding to the specified SQL type and\r\n \t * argument.\r\n \t * \r\ndiff --git a/src/main/java/org/vanilladb/core/sql/storedprocedure/ManuallyAbortException.java b/src/main/java/org/vanilladb/core/sql/storedprocedure/ManuallyAbortException.java\nnew file mode 100644\nindex 0000000..f79dc32\n--- /dev/null\n+++ b/src/main/java/org/vanilladb/core/sql/storedprocedure/ManuallyAbortException.java\n@@ -0,0 +1,15 @@\n+package org.vanilladb.core.sql.storedprocedure;\n+\n+public class ManuallyAbortException extends RuntimeException {\n+\n+\tprivate static final long serialVersionUID = 20200211001L;\n+\t\n+\tpublic ManuallyAbortException() {\n+\t\tsuper();\n+\t}\n+\t\n+\tpublic ManuallyAbortException(String message) {\n+\t\tsuper(message);\n+\t}\n+\n+}\ndiff --git a/src/main/java/org/vanilladb/core/sql/storedprocedure/SampleStoredProcedureFactory.java b/src/main/java/org/vanilladb/core/sql/storedprocedure/SampleStoredProcedureFactory.java\nindex 689e33d..e7ce8ce 100644\n--- a/src/main/java/org/vanilladb/core/sql/storedprocedure/SampleStoredProcedureFactory.java\n+++ b/src/main/java/org/vanilladb/core/sql/storedprocedure/SampleStoredProcedureFactory.java\n@@ -18,7 +18,7 @@ package org.vanilladb.core.sql.storedprocedure;\n public class SampleStoredProcedureFactory implements StoredProcedureFactory {\r\n \r\n \t@Override\r\n-\tpublic StoredProcedure getStroredProcedure(int pid) {\r\n+\tpublic StoredProcedure<?> getStroredProcedure(int pid) {\r\n \t\tthrow new UnsupportedOperationException();\r\n \t}\r\n \r\ndiff --git a/src/main/java/org/vanilladb/core/sql/storedprocedure/SpResultRecord.java b/src/main/java/org/vanilladb/core/sql/storedprocedure/SpResultRecord.java\nindex 543ca7e..079f86a 100644\n--- a/src/main/java/org/vanilladb/core/sql/storedprocedure/SpResultRecord.java\n+++ b/src/main/java/org/vanilladb/core/sql/storedprocedure/SpResultRecord.java\n@@ -48,14 +48,17 @@ public class SpResultRecord implements Record, Serializable {\n \r\n \t@Override\r\n \tpublic String toString() {\r\n-\t\tStringBuilder sb = new StringBuilder(\"[\");\r\n-\t\tSet<String> flds = new TreeSet<String>(fldValueMap.keySet());\r\n-\t\tfor (String fld : flds)\r\n-\t\t\tsb.append(fld).append(\"=\").append(fldValueMap.get(fld))\r\n-\t\t\t\t\t.append(\", \");\r\n-\t\tint end = sb.length();\r\n-\t\tsb.replace(end - 2, end, \"] \");\r\n-\t\treturn sb.toString();\r\n+\t\tif (fldValueMap.size() > 0) {\r\n+\t\t\tStringBuilder sb = new StringBuilder(\"[\");\r\n+\t\t\tSet<String> flds = new TreeSet<String>(fldValueMap.keySet());\r\n+\t\t\tfor (String fld : flds)\r\n+\t\t\t\tsb.append(fld).append(\"=\").append(fldValueMap.get(fld))\r\n+\t\t\t\t\t\t.append(\", \");\r\n+\t\t\tint end = sb.length();\r\n+\t\t\tsb.replace(end - 2, end, \"] \");\r\n+\t\t\treturn sb.toString();\r\n+\t\t} else\r\n+\t\t\treturn \"[]\";\r\n \t}\r\n \r\n \t@Override\r\n@@ -86,6 +89,7 @@ public class SpResultRecord implements Record, Serializable {\n \t\t\tbyte[] bytes = val.asBytes();\r\n \t\t\tout.writeObject(fld);\r\n \t\t\tout.writeInt(val.getType().getSqlType());\r\n+\t\t\tout.writeInt(val.getType().getArgument());\r\n \t\t\tout.writeInt(bytes.length);\r\n \t\t\tout.write(bytes);\r\n \t\t}\r\n@@ -101,10 +105,11 @@ public class SpResultRecord implements Record, Serializable {\n \t\tfor (int i = 0; i < numFlds; i++) {\r\n \t\t\tString fld = (String) in.readObject();\r\n \t\t\tint sqlType = in.readInt();\r\n+\t\t\tint sqlArg = in.readInt();\r\n \t\t\tbyte[] bytes = new byte[in.readInt()];\r\n \t\t\tin.read(bytes);\r\n-\t\t\tConstant val = Constant.newInstance(Type.newInstance(sqlType),\r\n-\t\t\t\t\tbytes);\r\n+\t\t\tConstant val = Constant.newInstance(\r\n+\t\t\t\t\tType.newInstance(sqlType, sqlArg), bytes);\r\n \t\t\tfldValueMap.put(fld, val);\r\n \t\t}\r\n \r\ndiff --git a/src/main/java/org/vanilladb/core/sql/storedprocedure/StoredProcedure.java b/src/main/java/org/vanilladb/core/sql/storedprocedure/StoredProcedure.java\nindex 76f26b1..f54fbf2 100644\n--- a/src/main/java/org/vanilladb/core/sql/storedprocedure/StoredProcedure.java\n+++ b/src/main/java/org/vanilladb/core/sql/storedprocedure/StoredProcedure.java\n@@ -19,6 +19,7 @@ import java.sql.Connection;\n import java.util.logging.Level;\r\n import java.util.logging.Logger;\r\n \r\n+import org.vanilladb.core.query.planner.BadSemanticException;\r\n import org.vanilladb.core.remote.storedprocedure.SpResultSet;\r\n import org.vanilladb.core.server.VanillaDb;\r\n import org.vanilladb.core.storage.tx.Transaction;\r\n@@ -52,25 +53,37 @@ public abstract class StoredProcedure<H extends StoredProcedureParamHelper> {\n \t}\r\n \t\r\n \tpublic SpResultSet execute() {\r\n+\t\tboolean isCommitted = false;\r\n+\t\t\r\n \t\ttry {\r\n \t\t\texecuteSql();\r\n \t\t\t\r\n \t\t\t// The transaction finishes normally\r\n \t\t\ttx.commit();\r\n-\t\t\tparamHelper.setCommitted(true);\r\n+\t\t\tisCommitted = true;\r\n \t\t\t\r\n \t\t} catch (LockAbortException lockAbortEx) {\r\n \t\t\tif (logger.isLoggable(Level.WARNING))\r\n \t\t\t\tlogger.warning(lockAbortEx.getMessage());\r\n \t\t\ttx.rollback();\r\n-\t\t\tparamHelper.setCommitted(false);\r\n+\t\t} catch (ManuallyAbortException me) {\r\n+\t\t\tif (logger.isLoggable(Level.WARNING))\r\n+\t\t\t\tlogger.warning(\"Manually aborted by the procedure: \" + me.getMessage());\r\n+\t\t\ttx.rollback();\r\n+\t\t} catch (BadSemanticException be) {\r\n+\t\t\tif (logger.isLoggable(Level.SEVERE))\r\n+\t\t\t\tlogger.warning(\"Semantic error: \" + be.getMessage());\r\n+\t\t\ttx.rollback();\r\n \t\t} catch (Exception e) {\r\n \t\t\te.printStackTrace();\r\n \t\t\ttx.rollback();\r\n-\t\t\tparamHelper.setCommitted(false);\r\n \t\t}\r\n \r\n-\t\treturn paramHelper.createResultSet();\r\n+\t\treturn new SpResultSet(\r\n+\t\t\tisCommitted,\r\n+\t\t\tparamHelper.getResultSetSchema(),\r\n+\t\t\tparamHelper.newResultSetRecord()\r\n+\t\t);\r\n \t}\r\n \t\r\n \tprotected abstract void executeSql();\r\n@@ -82,4 +95,12 @@ public abstract class StoredProcedure<H extends StoredProcedureParamHelper> {\n \tprotected Transaction getTransaction() {\r\n \t\treturn tx;\r\n \t}\r\n+\t\r\n+\tprotected void abort() {\r\n+\t\tthrow new ManuallyAbortException();\r\n+\t}\r\n+\t\r\n+\tprotected void abort(String message) {\r\n+\t\tthrow new ManuallyAbortException(message);\r\n+\t}\r\n }\n\\ No newline at end of file\ndiff --git a/src/main/java/org/vanilladb/core/sql/storedprocedure/StoredProcedureFactory.java b/src/main/java/org/vanilladb/core/sql/storedprocedure/StoredProcedureFactory.java\nindex a36a27d..7eb31d5 100644\n--- a/src/main/java/org/vanilladb/core/sql/storedprocedure/StoredProcedureFactory.java\n+++ b/src/main/java/org/vanilladb/core/sql/storedprocedure/StoredProcedureFactory.java\n@@ -17,6 +17,6 @@ package org.vanilladb.core.sql.storedprocedure;\n \r\n public interface StoredProcedureFactory {\r\n \t\r\n-\tStoredProcedure getStroredProcedure(int pid);\r\n+\tStoredProcedure<?> getStroredProcedure(int pid);\r\n \t\r\n }\r\ndiff --git a/src/main/java/org/vanilladb/core/sql/storedprocedure/StoredProcedureParamHelper.java b/src/main/java/org/vanilladb/core/sql/storedprocedure/StoredProcedureParamHelper.java\nindex 1986c8c..4dfaec4 100644\n--- a/src/main/java/org/vanilladb/core/sql/storedprocedure/StoredProcedureParamHelper.java\n+++ b/src/main/java/org/vanilladb/core/sql/storedprocedure/StoredProcedureParamHelper.java\n@@ -15,42 +15,43 @@\n  *******************************************************************************/\r\n package org.vanilladb.core.sql.storedprocedure;\r\n \r\n-import org.vanilladb.core.remote.storedprocedure.SpResultSet;\r\n import org.vanilladb.core.sql.Schema;\r\n \r\n public abstract class StoredProcedureParamHelper {\r\n \r\n-\tprotected boolean isCommitted = true;\r\n-\tprivate boolean isReadOnly = false;\r\n-\r\n-\t/**\r\n-\t * Prepare parameters for this stored procedure.\r\n-\t * \r\n-\t * @param pars\r\n-\t *            An object array contains all parameter for this stored\r\n-\t *            procedure.\r\n-\t */\r\n-\tpublic abstract void prepareParameters(Object... pars);\r\n-\r\n-\tpublic abstract SpResultSet createResultSet();\r\n-\r\n-\tpublic static StoredProcedureParamHelper DefaultParamHelper() {\r\n+\tpublic static StoredProcedureParamHelper newDefaultParamHelper() {\r\n \t\treturn new StoredProcedureParamHelper() {\r\n-\r\n \t\t\t@Override\r\n \t\t\tpublic void prepareParameters(Object... pars) {\r\n \t\t\t\t// do nothing\r\n \t\t\t}\r\n+\t\t\t\r\n+\t\t\t@Override\r\n+\t\t\tpublic Schema getResultSetSchema() {\r\n+\t\t\t\treturn new Schema();\r\n+\t\t\t}\r\n \r\n \t\t\t@Override\r\n-\t\t\tpublic SpResultSet createResultSet() {\r\n-\t\t\t\t// Return the result\r\n-\t\t\t\tSchema sch = new Schema();\r\n-\t\t\t\tSpResultRecord rec = new SpResultRecord();\r\n-\t\t\t\treturn new SpResultSet(isCommitted, sch, rec);\r\n+\t\t\tpublic SpResultRecord newResultSetRecord() {\r\n+\t\t\t\treturn new SpResultRecord();\r\n \t\t\t}\r\n \t\t};\r\n \t}\r\n+\r\n+\tprivate boolean isReadOnly = false;\r\n+\r\n+\t/**\r\n+\t * Prepare parameters for this stored procedure.\r\n+\t * \r\n+\t * @param pars\r\n+\t *            An object array contains all parameter for this stored\r\n+\t *            procedure.\r\n+\t */\r\n+\tpublic abstract void prepareParameters(Object... pars);\r\n+\t\r\n+\tpublic abstract Schema getResultSetSchema();\r\n+\t\r\n+\tpublic abstract SpResultRecord newResultSetRecord();\r\n \t\r\n \tprotected void setReadOnly(boolean isReadOnly) {\r\n \t\tthis.isReadOnly = isReadOnly;\r\n@@ -59,12 +60,4 @@ public abstract class StoredProcedureParamHelper {\n \tpublic boolean isReadOnly() {\r\n \t\treturn isReadOnly;\r\n \t}\r\n-\r\n-\tpublic void setCommitted(boolean b) {\r\n-\t\tisCommitted = b;\r\n-\t}\r\n-\r\n-\tpublic boolean isCommitted() {\r\n-\t\treturn isCommitted;\r\n-\t}\r\n }\r\ndiff --git a/src/main/java/org/vanilladb/core/storage/buffer/Buffer.java b/src/main/java/org/vanilladb/core/storage/buffer/Buffer.java\nindex 5a749b3..420d508 100644\n--- a/src/main/java/org/vanilladb/core/storage/buffer/Buffer.java\n+++ b/src/main/java/org/vanilladb/core/storage/buffer/Buffer.java\n@@ -85,6 +85,9 @@ public class Buffer {\n \tpublic Constant getVal(int offset, Type type) {\r\n \t\tinternalLock.readLock().lock();\r\n \t\ttry {\r\n+\t\t\tif (offset < 0 || offset >= BUFFER_SIZE)\r\n+\t\t\t\tthrow new IndexOutOfBoundsException(\"\" + offset);\r\n+\t\t\t\t\r\n \t\t\treturn contents.getVal(DATA_START_OFFSET + offset, type);\r\n \t\t} finally {\r\n \t\t\tinternalLock.readLock().unlock();\r\n@@ -94,6 +97,9 @@ public class Buffer {\n \tvoid setVal(int offset, Constant val) {\r\n \t\tinternalLock.writeLock().lock();\r\n \t\ttry {\r\n+\t\t\tif (offset < 0 || offset >= BUFFER_SIZE)\r\n+\t\t\t\tthrow new IndexOutOfBoundsException(\"\" + offset);\r\n+\t\t\t\r\n \t\t\tcontents.setVal(DATA_START_OFFSET + offset, val);\r\n \t\t} finally {\r\n \t\t\tinternalLock.writeLock().unlock();\r\n@@ -119,6 +125,9 @@ public class Buffer {\n \tpublic void setVal(int offset, Constant val, long txNum, LogSeqNum lsn) {\r\n \t\tinternalLock.writeLock().lock();\r\n \t\ttry {\r\n+\t\t\tif (offset < 0 || offset >= BUFFER_SIZE)\r\n+\t\t\t\tthrow new IndexOutOfBoundsException(\"\" + offset);\r\n+\t\t\t\r\n \t\t\tisModified = true;\r\n \t\t\tif (lsn != null && lsn.compareTo(lastLsn) > 0)\r\n \t\t\t\tlastLsn = lsn;\r\ndiff --git a/src/main/java/org/vanilladb/core/storage/index/btree/BTreeDir.java b/src/main/java/org/vanilladb/core/storage/index/btree/BTreeDir.java\nindex f783a11..e66aa6e 100644\n--- a/src/main/java/org/vanilladb/core/storage/index/btree/BTreeDir.java\n+++ b/src/main/java/org/vanilladb/core/storage/index/btree/BTreeDir.java\n@@ -202,10 +202,16 @@ public class BTreeDir {\n \t}\r\n \r\n \tpublic DirEntry insert(DirEntry e) {\r\n-\t\tint newslot = 1 + findSlotBefore(e.key());\r\n-\t\tinsert(newslot, e.key(), e.blockNumber());\r\n+\t\t// Find a slot for the entry\r\n+\t\tint newSlot = 0;\r\n+\t\tif (currentPage.getNumRecords() > 0)\r\n+\t\t\tnewSlot = findMatchingSlot(e.key()) + 1;\r\n+\t\t\r\n+\t\t// Insert the entry to the slot (the data in the slot will be moved to the next slot) \r\n+\t\tinsert(newSlot, e.key(), e.blockNumber());\r\n \t\tif (!currentPage.isFull())\r\n \t\t\treturn null;\r\n+\t\t\r\n \t\t// split full page\r\n \t\tint splitPos = currentPage.getNumRecords() / 2;\r\n \t\tSearchKey splitVal = getKey(currentPage, splitPos, keyType.length());\r\n@@ -317,26 +323,27 @@ public class BTreeDir {\n \t}\r\n \r\n \tprivate long findChildBlockNumber(SearchKey searchKey) {\r\n-\t\tint slot = findSlotBefore(searchKey);\r\n-\t\tif (getKey(currentPage, slot + 1, keyType.length()).equals(searchKey))\r\n-\t\t\tslot++;\r\n+\t\tint slot = findMatchingSlot(searchKey);\r\n \t\treturn getChildBlockNumber(currentPage, slot);\r\n \t}\r\n \r\n \t/**\r\n-\t * Calculates the slot right before the one having the specified search key.\r\n+\t * Finds the slot that contains a key that equals to or is smaller than the\r\n+\t * specified search key while the key in the next slot is larger than the \r\n+\t * search key or there is no more slot behind.\r\n \t * \r\n \t * @param searchKey\r\n-\t *            the search key\r\n-\t * @return the position before where the search key goes\r\n+\t *            the key to search the slot\r\n+\t * @return the id of the matching slot\r\n \t */\r\n-\tprivate int findSlotBefore(SearchKey searchKey) {\r\n+\tprivate int findMatchingSlot(SearchKey searchKey) {\r\n+\t\t// Sequential search\r\n \t\t/*\r\n \t\t * int slot = 0; while (slot < contents.getNumRecords() &&\r\n \t\t * getKey(contents, slot).compareTo(searchKey) < 0) slot++; return slot\r\n \t\t * - 1;\r\n \t\t */\r\n-\t\t// Optimization: Use binary search rather than sequential search\r\n+\t\t// Optimization: Use binary search, instead of sequential search\r\n \t\tint startSlot = 0, endSlot = currentPage.getNumRecords() - 1;\r\n \t\tint middleSlot = (startSlot + endSlot) / 2;\r\n \r\n@@ -351,15 +358,12 @@ public class BTreeDir {\n \t\t\t\tmiddleSlot = (startSlot + endSlot) / 2;\r\n \t\t\t}\r\n \r\n-\t\t\tif (getKey(currentPage, endSlot, keyType.length()).compareTo(searchKey) < 0)\r\n+\t\t\tif (getKey(currentPage, endSlot, keyType.length()).compareTo(searchKey) <= 0)\r\n \t\t\t\treturn endSlot;\r\n-\t\t\telse if (getKey(currentPage, startSlot, keyType.length())\r\n-\t\t\t\t\t.compareTo(searchKey) < 0)\r\n-\t\t\t\treturn startSlot;\r\n \t\t\telse\r\n-\t\t\t\treturn startSlot - 1;\r\n+\t\t\t\treturn startSlot;\r\n \t\t} else\r\n-\t\t\treturn -1;\r\n+\t\t\treturn 0;\r\n \t}\r\n \r\n \tprivate void insert(int slot, SearchKey key, long blkNum) {\r\ndiff --git a/src/main/java/org/vanilladb/core/storage/index/btree/BTreeLeaf.java b/src/main/java/org/vanilladb/core/storage/index/btree/BTreeLeaf.java\nindex 564b5fb..bf649cf 100644\n--- a/src/main/java/org/vanilladb/core/storage/index/btree/BTreeLeaf.java\n+++ b/src/main/java/org/vanilladb/core/storage/index/btree/BTreeLeaf.java\n@@ -300,7 +300,7 @@ public class BTreeLeaf {\n \t\t\tsetSiblingFlag(currentPage, newBlkNum);\r\n \t\t\treturn new DirEntry(splitKey, newBlkNum);\r\n \t\t}\r\n-\t\t\r\n+\r\n \t\tif (!currentPage.isFull())\r\n \t\t\treturn null;\r\n \t\t\r\ndiff --git a/src/main/java/org/vanilladb/core/storage/index/btree/BTreePage.java b/src/main/java/org/vanilladb/core/storage/index/btree/BTreePage.java\nindex 3883f49..61c8468 100644\n--- a/src/main/java/org/vanilladb/core/storage/index/btree/BTreePage.java\n+++ b/src/main/java/org/vanilladb/core/storage/index/btree/BTreePage.java\n@@ -18,6 +18,7 @@ package org.vanilladb.core.storage.index.btree;\n import static org.vanilladb.core.sql.Type.BIGINT;\r\n import static org.vanilladb.core.sql.Type.INTEGER;\r\n \r\n+import java.nio.BufferOverflowException;\r\n import java.util.HashMap;\r\n import java.util.Map;\r\n \r\n@@ -46,7 +47,7 @@ public class BTreePage {\n \tprivate BlockId blk;\r\n \tprivate Schema schema;\r\n \tprivate Transaction tx;\r\n-\tprivate int slotSize, headerSize;\r\n+\tprivate int slotSize, headerSize, numberOfSlots, numberOfFlags;\r\n \tprivate Buffer currentBuff;\r\n \tprivate Map<String, Integer> myOffsetMap;\r\n \t// Optimization: Materialize the number of records of B-Tree Page.\r\n@@ -101,13 +102,17 @@ public class BTreePage {\n \t * @return the size of a record, in bytes\r\n \t */\r\n \tpublic static int slotSize(Schema sch) {\r\n-\t\tint pos = 0;\r\n+\t\tint size = 0;\r\n \t\tfor (String fldname : sch.fields())\r\n-\t\t\tpos += Page.maxSize(sch.type(fldname));\r\n-\t\treturn pos;\r\n+\t\t\tsize += Page.maxSize(sch.type(fldname));\r\n+\t\t\r\n+\t\tif (size > Buffer.BUFFER_SIZE || size < 0)\r\n+\t\t\tthrow new RuntimeException(\"Slot size overflow: \" + size + \", schema: \" + sch);\r\n+\t\t\r\n+\t\treturn size;\r\n \t}\r\n \r\n-\tpublic static int maxNumOfSlots(int numOfFlags, Schema sch) {\r\n+\tpublic static int numOfSlots(int numOfFlags, Schema sch) {\r\n \t\tint slotSize = slotSize(sch);\r\n \t\tint flagSize = numOfFlags * Type.BIGINT.maxSize();\r\n \t\treturn (Buffer.BUFFER_SIZE - flagSize) / slotSize;\r\n@@ -132,9 +137,14 @@ public class BTreePage {\n \t\tcurrentBuff = tx.bufferMgr().pin(blk);\r\n \r\n \t\tslotSize = slotSize(schema);\r\n+\t\t// Slot: a place to hold a record. The number of slots are fixed.\r\n+\t\t// Record: a record that contains meaningful information for index.\r\n+\t\t// Note that a slot may not have a record. It could be empty.\r\n+\t\tnumberOfRecords = -1; // Cache number of records. Lazily evaluated.\r\n+\t\tnumberOfFlags = numFlags;\r\n+\t\tnumberOfSlots = numOfSlots(numFlags, schema);\r\n \t\theaderSize = Page.maxSize(INTEGER) + Page.maxSize(BIGINT) * numFlags;\r\n \t\tmyOffsetMap = offsetMap(schema);\r\n-\t\tnumberOfRecords = -1;\r\n \t}\r\n \r\n \t/**\r\n@@ -175,6 +185,11 @@ public class BTreePage {\n \t}\r\n \r\n \tpublic Constant getVal(int slot, String fldName) {\r\n+\t\tif (slot >= getNumRecords())\r\n+\t\t\tthrow new IndexOutOfBoundsException(\r\n+\t\t\t\t\tString.format(\"Cannot get value at slot %d \"\r\n+\t\t\t\t\t\t\t+ \"from BTreePage %s (which has only %d slot)\",\r\n+\t\t\t\t\t\t\tslot, blk, getNumRecords()));\r\n \t\tType type = schema.type(fldName);\r\n \t\treturn getVal(fieldPosition(slot, fldName), type);\r\n \t}\r\n@@ -190,9 +205,18 @@ public class BTreePage {\n \t *            the new value\r\n \t */\r\n \tpublic void setVal(int slot, String fldName, Constant val) {\r\n-\t\tType type = schema.type(fldName);\r\n-\t\tConstant v = val.castTo(type);\r\n-\t\tsetVal(fieldPosition(slot, fldName), v);\r\n+\t\tif (slot >= numberOfSlots) {\r\n+\t\t\tthrow new IndexOutOfBoundsException(\r\n+\t\t\t\t\tString.format(\"Cannot set value at slot %d \"\r\n+\t\t\t\t\t\t\t+ \"in BTreePage %s (which can only have %d slot)\",\r\n+\t\t\t\t\t\t\tslot, blk, numberOfSlots));\r\n+\t\t} else if (slot >= numberOfRecords) {\r\n+\t\t\tthrow new IndexOutOfBoundsException(\r\n+\t\t\t\tString.format(\"Cannot set value at slot %d \"\r\n+\t\t\t\t\t\t+ \"in BTreePage %s because there are only %d records\",\r\n+\t\t\t\t\t\tslot, blk, numberOfRecords));\r\n+\t\t}\r\n+\t\tsetValUnchecked(slot, fldName, val);\r\n \t}\r\n \r\n \t/**\r\n@@ -225,6 +249,15 @@ public class BTreePage {\n \tpublic void insert(int slot) {\r\n \t\tcurrentBuff.lockFlushing();\r\n \t\ttry {\r\n+\t\t\tif (slot >= numberOfSlots) {\r\n+\t\t\t\tthrow new IndexOutOfBoundsException(\r\n+\t\t\t\t\t\tString.format(\"Cannot insert a record at slot %d \"\r\n+\t\t\t\t\t\t\t\t+ \"in BTreePage %s because there are only %d slots\",\r\n+\t\t\t\t\t\t\t\tslot, blk, numberOfSlots));\r\n+\t\t\t} else if (numberOfRecords + 1 > numberOfSlots) {\r\n+\t\t\t\tthrow new BufferOverflowException();\r\n+\t\t\t}\r\n+\t\t\t\r\n \t\t\tfor (int i = getNumRecords(); i > slot; i--)\r\n \t\t\t\tcopyRecordWithoutLogging(i - 1, i);\r\n \t\t\tsetNumRecordsWithoutLogging(getNumRecords() + 1);\r\n@@ -316,7 +349,7 @@ public class BTreePage {\n \t\t// Copy the records from the source page to the destination page\r\n \t\tfor (int i = 0; i < num; i++)\r\n \t\t\tfor (String fld : schema.fields())\r\n-\t\t\t\tdest.setVal(destStart + i, fld, getVal(start + i, fld));\r\n+\t\t\t\tdest.setValUnchecked(destStart + i, fld, getVal(start + i, fld));\r\n \r\n \t\t// Move the rest records in the source page for deletion\r\n \t\tfor (int i = 0; i < getNumRecords() - 1 - num; i++)\r\n@@ -344,6 +377,44 @@ public class BTreePage {\n \t\t\tnumberOfRecords = (Integer) getVal(0, INTEGER).asJavaVal();\r\n \t\treturn numberOfRecords;\r\n \t}\r\n+\t\r\n+\t@Override\r\n+\tpublic String toString() {\r\n+\t\tStringBuilder sb = new StringBuilder(\"{\");\r\n+\t\t\r\n+\t\t// Record count\r\n+\t\tint recordCount = getNumRecords();\r\n+\t\tsb.append(\"# of records: \");\r\n+\t\tsb.append(recordCount);\r\n+\t\tsb.append(\", \");\r\n+\t\t\r\n+\t\t// Flags\r\n+\t\tsb.append(\"flags: [\");\r\n+\t\tfor (int i = 0; i < numberOfFlags; i++) {\r\n+\t\t\tsb.append(getFlag(i));\r\n+\t\t\tif (i < numberOfFlags - 1)\r\n+\t\t\t\tsb.append(\", \");\r\n+\t\t}\r\n+\t\tsb.append(\"], \");\r\n+\t\t\r\n+\t\t// Records\r\n+\t\tsb.append(\"records: [\");\r\n+\t\tfor (int i = 0; i < recordCount; i++) {\r\n+\t\t\tsb.append(\"{\");\r\n+\t\t\tfor (String fld : schema.fields()) {\r\n+\t\t\t\tsb.append(fld);\r\n+\t\t\t\tsb.append(\": \");\r\n+\t\t\t\tsb.append(getVal(i, fld));\r\n+\t\t\t\tsb.append(\", \");\r\n+\t\t\t}\r\n+\t\t\tsb.delete(sb.length() - 2, sb.length());\r\n+\t\t\tif (i < recordCount - 1)\r\n+\t\t\t\tsb.append(\"}, \");\r\n+\t\t}\r\n+\t\tsb.append(\"}]}\");\r\n+\t\t\r\n+\t\treturn sb.toString();\r\n+\t}\r\n \r\n \tprivate void setNumRecords(int n) {\r\n \t\tConstant v = new IntegerConstant(n);\r\n@@ -361,7 +432,7 @@ public class BTreePage {\n \r\n \tprivate void copyRecord(int from, int to) {\r\n \t\tfor (String fldname : schema.fields())\r\n-\t\t\tsetVal(to, fldname, getVal(from, fldname));\r\n+\t\t\tsetValUnchecked(to, fldname, getVal(from, fldname));\r\n \t}\r\n \r\n \tprivate void copyRecordWithoutLogging(int from, int to) {\r\n@@ -385,6 +456,12 @@ public class BTreePage {\n \t\ttx.bufferMgr().unpin(buff);\r\n \t\treturn buff.block();\r\n \t}\r\n+\t\r\n+\tprivate void setValUnchecked(int slot, String fldName, Constant val) {\r\n+\t\tType type = schema.type(fldName);\r\n+\t\tConstant v = val.castTo(type);\r\n+\t\tsetVal(fieldPosition(slot, fldName), v);\r\n+\t}\r\n \r\n \tprivate void setVal(int offset, Constant val) {\r\n \t\tLogSeqNum lsn = tx.recoveryMgr().logSetVal(currentBuff, offset, val);\r\ndiff --git a/src/main/java/org/vanilladb/core/storage/tx/Transaction.java b/src/main/java/org/vanilladb/core/storage/tx/Transaction.java\nindex 638f19c..a6cf7d7 100644\n--- a/src/main/java/org/vanilladb/core/storage/tx/Transaction.java\n+++ b/src/main/java/org/vanilladb/core/storage/tx/Transaction.java\n@@ -114,10 +114,8 @@ public class Transaction {\n \t * all locks, and unpins any pinned blocks.\r\n \t */\r\n \tpublic void rollback() {\r\n-\t\tfor (TransactionLifecycleListener l : lifecycleListeners) {\r\n-\r\n+\t\tfor (TransactionLifecycleListener l : lifecycleListeners)\r\n \t\t\tl.onTxRollback(this);\r\n-\t\t}\r\n \r\n \t\tif (logger.isLoggable(Level.FINE))\r\n \t\t\tlogger.fine(\"transaction \" + txNum + \" rolled back\");\r\ndiff --git a/src/main/java/org/vanilladb/core/storage/tx/recovery/IndexDeleteEndRecord.java b/src/main/java/org/vanilladb/core/storage/tx/recovery/IndexDeleteEndRecord.java\nindex e4ec20a..9b6021f 100644\n--- a/src/main/java/org/vanilladb/core/storage/tx/recovery/IndexDeleteEndRecord.java\n+++ b/src/main/java/org/vanilladb/core/storage/tx/recovery/IndexDeleteEndRecord.java\n@@ -65,7 +65,8 @@ public class IndexDeleteEndRecord extends LogicalEndRecord implements LogRecord \n \t\tConstant[] vals = new Constant[keyLen];\r\n \t\tfor (int i = 0; i < keyLen; i++) {\r\n \t\t\tint type = (Integer) rec.nextVal(INTEGER).asJavaVal();\r\n-\t\t\tvals[i] = rec.nextVal(Type.newInstance(type));\r\n+\t\t\tint argument = (Integer) rec.nextVal(INTEGER).asJavaVal();\r\n+\t\t\tvals[i] = rec.nextVal(Type.newInstance(type, argument));\r\n \t\t}\r\n \t\tsearchKey = new SearchKey(vals);\r\n \t\t\r\n@@ -141,6 +142,7 @@ public class IndexDeleteEndRecord extends LogicalEndRecord implements LogRecord \n \t\tfor (int i = 0; i < searchKey.length(); i++) {\r\n \t\t\tConstant val = searchKey.get(i);\r\n \t\t\trec.add(new IntegerConstant(val.getType().getSqlType()));\r\n+\t\t\trec.add(new IntegerConstant(val.getType().getArgument()));\r\n \t\t\trec.add(val);\r\n \t\t}\r\n \t\t\r\ndiff --git a/src/main/java/org/vanilladb/core/storage/tx/recovery/IndexInsertEndRecord.java b/src/main/java/org/vanilladb/core/storage/tx/recovery/IndexInsertEndRecord.java\nindex fd4fbfd..1ed09e7 100644\n--- a/src/main/java/org/vanilladb/core/storage/tx/recovery/IndexInsertEndRecord.java\n+++ b/src/main/java/org/vanilladb/core/storage/tx/recovery/IndexInsertEndRecord.java\n@@ -65,7 +65,8 @@ public class IndexInsertEndRecord extends LogicalEndRecord implements LogRecord \n \t\tConstant[] vals = new Constant[keyLen];\r\n \t\tfor (int i = 0; i < keyLen; i++) {\r\n \t\t\tint type = (Integer) rec.nextVal(INTEGER).asJavaVal();\r\n-\t\t\tvals[i] = rec.nextVal(Type.newInstance(type));\r\n+\t\t\tint argument = (Integer) rec.nextVal(INTEGER).asJavaVal();\r\n+\t\t\tvals[i] = rec.nextVal(Type.newInstance(type, argument));\r\n \t\t}\r\n \t\tsearchKey = new SearchKey(vals);\r\n \t\t\r\n@@ -142,6 +143,7 @@ public class IndexInsertEndRecord extends LogicalEndRecord implements LogRecord \n \t\tfor (int i = 0; i < searchKey.length(); i++) {\r\n \t\t\tConstant val = searchKey.get(i);\r\n \t\t\trec.add(new IntegerConstant(val.getType().getSqlType()));\r\n+\t\t\trec.add(new IntegerConstant(val.getType().getArgument()));\r\n \t\t\trec.add(val);\r\n \t\t}\r\n \t\t\r\ndiff --git a/src/main/java/org/vanilladb/core/storage/tx/recovery/IndexPageDeleteRecord.java b/src/main/java/org/vanilladb/core/storage/tx/recovery/IndexPageDeleteRecord.java\nindex ad2d4af..985aa45 100644\n--- a/src/main/java/org/vanilladb/core/storage/tx/recovery/IndexPageDeleteRecord.java\n+++ b/src/main/java/org/vanilladb/core/storage/tx/recovery/IndexPageDeleteRecord.java\n@@ -63,7 +63,8 @@ public class IndexPageDeleteRecord implements LogRecord {\n \t\tType[] types = new Type[keyLen];\r\n \t\tfor (int i = 0; i < keyLen; i++) {\r\n \t\t\tint type = (Integer) rec.nextVal(INTEGER).asJavaVal();\r\n-\t\t\ttypes[i] = Type.newInstance(type);\r\n+\t\t\tint argument = (Integer) rec.nextVal(INTEGER).asJavaVal();\r\n+\t\t\ttypes[i] = Type.newInstance(type, argument);\r\n \t\t}\r\n \t\tkeyType = new SearchKeyType(types);\r\n \t\t\r\n@@ -103,7 +104,7 @@ public class IndexPageDeleteRecord implements LogRecord {\n \t\tif (isDirPage) {\r\n \t\t\tBlockBuff = tx.bufferMgr().pin(indexBlkId);\r\n \r\n-\t\t\tif (this.lsn.compareTo(BlockBuff.lastLsn()) == 1) {\r\n+\t\t\tif (this.lsn.compareTo(BlockBuff.lastLsn()) < 0) {\r\n \t\t\t\tBTreeDir.insertASlot(tx, indexBlkId, keyType, slotId);\r\n \t\t\t\tLogSeqNum lsn = tx.recoveryMgr().logIndexPageInsertionClr(\r\n \t\t\t\t\t\ttxNum, indexBlkId, isDirPage, keyType, slotId, this.lsn);\r\n@@ -111,7 +112,7 @@ public class IndexPageDeleteRecord implements LogRecord {\n \t\t\t}\r\n \t\t} else {\r\n \t\t\tBlockBuff = tx.bufferMgr().pin(indexBlkId);\r\n-\t\t\tif (this.lsn.compareTo(BlockBuff.lastLsn()) == 1) {\r\n+\t\t\tif (this.lsn.compareTo(BlockBuff.lastLsn()) < 0) {\r\n \t\t\t\tBTreeLeaf.insertASlot(tx, indexBlkId, keyType, slotId);\r\n \t\t\t\tLogSeqNum lsn = tx.recoveryMgr().logIndexPageInsertionClr(\r\n \t\t\t\t\t\ttxNum, indexBlkId, isDirPage, keyType, slotId, this.lsn);\r\n@@ -128,12 +129,12 @@ public class IndexPageDeleteRecord implements LogRecord {\n \t\tif (isDirPage) {\r\n \t\t\tBlockBuff = tx.bufferMgr().pin(indexBlkId);\r\n \r\n-\t\t\tif (this.lsn.compareTo(BlockBuff.lastLsn()) == 1) {\r\n+\t\t\tif (this.lsn.compareTo(BlockBuff.lastLsn()) > 0) {\r\n \t\t\t\tBTreeDir.deleteASlot(tx, indexBlkId, keyType, slotId);\r\n \t\t\t}\r\n \t\t} else {\r\n \t\t\tBlockBuff = tx.bufferMgr().pin(indexBlkId);\r\n-\t\t\tif (this.lsn.compareTo(BlockBuff.lastLsn()) == 1) {\r\n+\t\t\tif (this.lsn.compareTo(BlockBuff.lastLsn()) > 0) {\r\n \t\t\t\tBTreeLeaf.deleteASlot(tx, indexBlkId, keyType, slotId);\r\n \t\t\t}\r\n \t\t}\r\n@@ -159,6 +160,7 @@ public class IndexPageDeleteRecord implements LogRecord {\n \t\tfor (int i = 0; i < keyType.length(); i++) {\r\n \t\t\tType type = keyType.get(i);\r\n \t\t\trec.add(new IntegerConstant(type.getSqlType()));\r\n+\t\t\trec.add(new IntegerConstant(type.getArgument()));\r\n \t\t}\r\n \t\t\r\n \t\trec.add(new VarcharConstant(indexBlkId.fileName()));\r\ndiff --git a/src/main/java/org/vanilladb/core/storage/tx/recovery/IndexPageInsertRecord.java b/src/main/java/org/vanilladb/core/storage/tx/recovery/IndexPageInsertRecord.java\nindex c6ae8cc..bb0e0e8 100644\n--- a/src/main/java/org/vanilladb/core/storage/tx/recovery/IndexPageInsertRecord.java\n+++ b/src/main/java/org/vanilladb/core/storage/tx/recovery/IndexPageInsertRecord.java\n@@ -47,6 +47,8 @@ public class IndexPageInsertRecord implements LogRecord {\n \r\n \tpublic IndexPageInsertRecord(long txNum, BlockId indexBlkId, boolean isDirPage,\r\n \t\t\tSearchKeyType keyType, int slotId) {\r\n+//\t\tSystem.out.println(String.format(\"Tx.%d logs inserts on %s\", txNum, indexBlkId));\r\n+\t\t\r\n \t\tthis.txNum = txNum;\r\n \t\tthis.isDirPage = isDirPage;\r\n \t\tthis.keyType = keyType;\r\n@@ -63,7 +65,8 @@ public class IndexPageInsertRecord implements LogRecord {\n \t\tType[] types = new Type[keyLen];\r\n \t\tfor (int i = 0; i < keyLen; i++) {\r\n \t\t\tint type = (Integer) rec.nextVal(INTEGER).asJavaVal();\r\n-\t\t\ttypes[i] = Type.newInstance(type);\r\n+\t\t\tint argument = (Integer) rec.nextVal(INTEGER).asJavaVal();\r\n+\t\t\ttypes[i] = Type.newInstance(type, argument);\r\n \t\t}\r\n \t\tkeyType = new SearchKeyType(types);\r\n \t\t\r\n@@ -93,16 +96,18 @@ public class IndexPageInsertRecord implements LogRecord {\n \r\n \t@Override\r\n \tpublic void undo(Transaction tx) {\r\n+//\t\tSystem.out.println(String.format(\"Tx.%d undo inserting slot %d to %s\", tx.getTransactionNumber(), slotId, indexBlkId));\r\n+\t\t\r\n \t\t// Note that UndoNextLSN should be set to this log record's lsn in order\r\n \t\t// to let RecoveryMgr to skip this log record. Since this record should\r\n \t\t// be undo by the Clr append there.\r\n \t\t// Since Clr is Undo's redo log , here we should log\r\n \t\t// \"IndexPageDeletionClr\" to make this undo procedure be redo during\r\n \t\t// repeat history\r\n-\t\tBuffer BlockBuff;\r\n+\t\tBuffer buff;\r\n \t\tif (isDirPage) {\r\n-\t\t\tBlockBuff = tx.bufferMgr().pin(indexBlkId);\r\n-\t\t\tif (this.lsn.compareTo(BlockBuff.lastLsn()) == 1) {\r\n+\t\t\tbuff = tx.bufferMgr().pin(indexBlkId);\r\n+\t\t\tif (this.lsn.compareTo(buff.lastLsn()) < 0) {\r\n \t\t\t\tBTreeDir.deleteASlot(tx, indexBlkId, keyType, slotId);\r\n \t\t\t\tLogSeqNum lsn = tx.recoveryMgr().logIndexPageDeletionClr(\r\n \t\t\t\t\t\ttxNum, indexBlkId, isDirPage, keyType, slotId, this.lsn);\r\n@@ -110,15 +115,15 @@ public class IndexPageInsertRecord implements LogRecord {\n \t\t\t}\r\n \r\n \t\t} else {\r\n-\t\t\tBlockBuff = tx.bufferMgr().pin(indexBlkId);\r\n-\t\t\tif (this.lsn.compareTo(BlockBuff.lastLsn()) == 1) {\r\n+\t\t\tbuff = tx.bufferMgr().pin(indexBlkId);\r\n+\t\t\tif (this.lsn.compareTo(buff.lastLsn()) < 0) {\r\n \t\t\t\tBTreeLeaf.deleteASlot(tx, indexBlkId, keyType, slotId);\r\n \t\t\t\tLogSeqNum lsn = tx.recoveryMgr().logIndexPageDeletionClr(\r\n \t\t\t\t\t\ttxNum, indexBlkId, isDirPage, keyType, slotId, this.lsn);\r\n \t\t\t\tVanillaDb.logMgr().flush(lsn);\r\n \t\t\t}\r\n \t\t}\r\n-\t\ttx.bufferMgr().unpin(BlockBuff);\r\n+\t\ttx.bufferMgr().unpin(buff);\r\n \r\n \t}\r\n \r\n@@ -128,12 +133,12 @@ public class IndexPageInsertRecord implements LogRecord {\n \t\tif (isDirPage) {\r\n \t\t\tBlockBuff = tx.bufferMgr().pin(indexBlkId);\r\n \r\n-\t\t\tif (this.lsn.compareTo(BlockBuff.lastLsn()) == 1) {\r\n+\t\t\tif (this.lsn.compareTo(BlockBuff.lastLsn()) > 0) {\r\n \t\t\t\tBTreeDir.insertASlot(tx, indexBlkId, keyType, slotId);\r\n \t\t\t}\r\n \t\t} else {\r\n \t\t\tBlockBuff = tx.bufferMgr().pin(indexBlkId);\r\n-\t\t\tif (this.lsn.compareTo(BlockBuff.lastLsn()) == 1) {\r\n+\t\t\tif (this.lsn.compareTo(BlockBuff.lastLsn()) > 0) {\r\n \t\t\t\tBTreeLeaf.insertASlot(tx, indexBlkId, keyType, slotId);\r\n \t\t\t}\r\n \t\t}\r\n@@ -160,6 +165,7 @@ public class IndexPageInsertRecord implements LogRecord {\n \t\tfor (int i = 0; i < keyType.length(); i++) {\r\n \t\t\tType type = keyType.get(i);\r\n \t\t\trec.add(new IntegerConstant(type.getSqlType()));\r\n+\t\t\trec.add(new IntegerConstant(type.getArgument()));\r\n \t\t}\r\n \t\t\r\n \t\trec.add(new VarcharConstant(indexBlkId.fileName()));\r\ndiff --git a/src/main/java/org/vanilladb/core/storage/tx/recovery/SetValueRecord.java b/src/main/java/org/vanilladb/core/storage/tx/recovery/SetValueRecord.java\nindex 763aaeb..de9975b 100644\n--- a/src/main/java/org/vanilladb/core/storage/tx/recovery/SetValueRecord.java\n+++ b/src/main/java/org/vanilladb/core/storage/tx/recovery/SetValueRecord.java\n@@ -37,7 +37,7 @@ import org.vanilladb.core.storage.tx.Transaction;\n class SetValueRecord implements LogRecord {\r\n \tprivate long txNum;\r\n \tprivate int offset;\r\n-\tprivate int type;\r\n+\tprivate Type type;\r\n \tprivate Constant val;\r\n \tprivate Constant newVal;\r\n \tprivate BlockId blk;\r\n@@ -61,7 +61,7 @@ class SetValueRecord implements LogRecord {\n \t\tthis.txNum = txNum;\r\n \t\tthis.blk = blk;\r\n \t\tthis.offset = offset;\r\n-\t\tthis.type = val.getType().getSqlType();\r\n+\t\tthis.type = val.getType();\r\n \t\tthis.val = val;\r\n \t\tthis.newVal = newVal;\r\n \t\tthis.lsn = null;\r\n@@ -79,9 +79,11 @@ class SetValueRecord implements LogRecord {\n \t\ttxNum = (Long) rec.nextVal(BIGINT).asJavaVal();\r\n \t\tblk = new BlockId((String) rec.nextVal(VARCHAR).asJavaVal(), (Long) rec.nextVal(BIGINT).asJavaVal());\r\n \t\toffset = (Integer) rec.nextVal(INTEGER).asJavaVal();\r\n-\t\ttype = (Integer) rec.nextVal(INTEGER).asJavaVal();\r\n-\t\tval = rec.nextVal(Type.newInstance(type));\r\n-\t\tnewVal = rec.nextVal(Type.newInstance(type));\r\n+\t\tint sqlType = (Integer) rec.nextVal(INTEGER).asJavaVal();\r\n+\t\tint sqlArg = (Integer) rec.nextVal(INTEGER).asJavaVal();\r\n+\t\ttype = Type.newInstance(sqlType, sqlArg);\r\n+\t\tval = rec.nextVal(type);\r\n+\t\tnewVal = rec.nextVal(type);\r\n \t\tlsn = rec.getLSN();\r\n \t}\r\n \r\n@@ -163,7 +165,8 @@ class SetValueRecord implements LogRecord {\n \t\trec.add(new VarcharConstant(blk.fileName()));\r\n \t\trec.add(new BigIntConstant(blk.number()));\r\n \t\trec.add(new IntegerConstant(offset));\r\n-\t\trec.add(new IntegerConstant(type));\r\n+\t\trec.add(new IntegerConstant(type.getSqlType()));\r\n+\t\trec.add(new IntegerConstant(type.getArgument()));\r\n \t\trec.add(val);\r\n \t\trec.add(newVal);\r\n \t\treturn rec;\r\ndiff --git a/src/test/java/org/vanilladb/core/storage/index/btree/BTreeIndexConcurrentTest.java b/src/test/java/org/vanilladb/core/storage/index/btree/BTreeIndexConcurrentTest.java\nnew file mode 100644\nindex 0000000..2bc2fb6\n--- /dev/null\n+++ b/src/test/java/org/vanilladb/core/storage/index/btree/BTreeIndexConcurrentTest.java\n@@ -0,0 +1,165 @@\n+package org.vanilladb.core.storage.index.btree;\n+\n+import static org.junit.Assert.fail;\n+\n+import java.lang.Thread.UncaughtExceptionHandler;\n+import java.sql.Connection;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.vanilladb.core.query.planner.Planner;\n+import org.vanilladb.core.server.ServerInit;\n+import org.vanilladb.core.server.VanillaDb;\n+import org.vanilladb.core.sql.Constant;\n+import org.vanilladb.core.sql.Type;\n+import org.vanilladb.core.sql.VarcharConstant;\n+import org.vanilladb.core.storage.file.BlockId;\n+import org.vanilladb.core.storage.index.Index;\n+import org.vanilladb.core.storage.index.SearchKey;\n+import org.vanilladb.core.storage.metadata.index.IndexInfo;\n+import org.vanilladb.core.storage.record.RecordId;\n+import org.vanilladb.core.storage.tx.Transaction;\n+import org.vanilladb.core.storage.tx.concurrency.LockAbortException;\n+\n+public class BTreeIndexConcurrentTest {\n+\tprivate static Logger logger = Logger.getLogger(BTreeIndexConcurrentTest.class.getName());\n+\n+\tprivate static final Type ID_TYPE = Type.VARCHAR(33);\n+\tprivate static final int THREAD_COUNT = 100;\n+\t\n+\tprivate static AtomicInteger nextInsertId = new AtomicInteger(1);\n+\tprivate static Throwable exception = null;\n+\t\n+\t@BeforeClass\n+\tpublic static void init() {\n+\t\tServerInit.init(BTreeIndexConcurrentTest.class);\n+\t\tcreateIndex();\n+\t\t\n+\t\tif (logger.isLoggable(Level.INFO))\n+\t\t\tlogger.info(\"BEGIN B-TREE CONCURRENCY TEST\");\n+\t}\n+\t\n+\t@AfterClass\n+\tpublic static void finish() {\n+\t\tif (logger.isLoggable(Level.INFO))\n+\t\t\tlogger.info(\"FINISH B-TREE CONCURRENCY TEST\");\n+\t}\n+\t\n+\tprivate static void createIndex() {\n+\t\tTransaction tx = VanillaDb.txMgr().newTransaction(\n+\t\t\t\tConnection.TRANSACTION_SERIALIZABLE, false);\n+\t\tPlanner planner = VanillaDb.newPlanner();\n+\t\t\n+\t\t// Create a table\n+\t\tplanner.executeUpdate(\"CREATE TABLE test (id VARCHAR(33), val INT)\", tx);\n+\t\t\n+\t\t// Create a B-Tree index\n+\t\tplanner.executeUpdate(\"CREATE INDEX test_idx ON test (id) USING BTREE\", tx);\n+\t\t\n+\t\ttx.commit();\n+\t\t\n+\t\tif (logger.isLoggable(Level.INFO))\n+\t\t\tlogger.info(\"TESTING DATA CREATED\");\n+\t}\n+\t\n+\t@Test\n+\tpublic void testConcurrentInsert() {\n+\t\tList<Thread> threads = new ArrayList<Thread>(100);\n+\t\t\n+\t\tfor (int i = 0; i < THREAD_COUNT; i++) {\n+\t\t\tThread thread = new Thread(new Insertor());\n+\t\t\tthread.setUncaughtExceptionHandler(new ExceptionCatcher());\n+\t\t\tthread.start();\n+\t\t\tthreads.add(thread);\n+\t\t}\n+\t\t\n+\t\tThread r = new Thread(new Rollbacker());\n+\t\tr.setUncaughtExceptionHandler(new ExceptionCatcher());\n+\t\tr.start();\n+\t\t\n+\t\tfor (Thread t : threads) {\n+\t\t\ttry {\n+\t\t\t\tt.join();\n+\t\t\t} catch (InterruptedException e) {\n+\t\t\t\te.printStackTrace();\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\ttry {\n+\t\t\tr.join();\n+\t\t} catch (InterruptedException e) {\n+\t\t\te.printStackTrace();\n+\t\t}\n+\t\t\n+\t\tif (exception != null) {\n+\t\t\texception.printStackTrace();\n+\t\t\tfail(\"Found exception: \" + exception);\n+\t\t}\n+\t}\n+\t\n+\tstatic class ExceptionCatcher implements UncaughtExceptionHandler {\n+\n+\t\t@Override\n+\t\tpublic void uncaughtException(Thread t, Throwable e) {\n+\t\t\texception = e;\n+\t\t}\n+\t\t\n+\t}\n+\t\n+\tstatic class Insertor implements Runnable {\n+\n+\t\t@Override\n+\t\tpublic void run() {\n+\t\t\tTransaction tx = VanillaDb.txMgr().newTransaction(\n+\t\t\t\t\tConnection.TRANSACTION_SERIALIZABLE, false);\n+\t\t\t\n+\t\t\ttry {\n+\t\t\t\tIndexInfo ii = VanillaDb.catalogMgr().getIndexInfo(\"test\", \"id\", tx).get(0);\n+\t\t\t\tIndex idx = ii.open(tx);\n+\t\t\t\t\n+\t\t\t\tint insertId = nextInsertId.getAndIncrement();\n+\t\t\t\tString idStr = String.format(\"%033d\", insertId);\n+\t\t\t\tConstant idCon = new VarcharConstant(idStr, ID_TYPE);\n+\t\t\t\tRecordId fakeRid = new RecordId(new BlockId(\"test\", insertId), 1);\n+\t\t\t\t\n+\t\t\t\tidx.insert(new SearchKey(idCon), fakeRid, true);\n+\t\t\t\t\n+\t\t\t\ttx.commit();\n+\t\t\t} catch (LockAbortException l) {\n+\t\t\t\ttx.rollback();\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\tstatic class Rollbacker implements Runnable {\n+\n+\t\t@Override\n+\t\tpublic void run() {\n+\t\t\tTransaction tx = VanillaDb.txMgr().newTransaction(\n+\t\t\t\t\tConnection.TRANSACTION_SERIALIZABLE, false);\n+\t\t\t\n+\t\t\ttry {\n+\t\t\t\tIndexInfo ii = VanillaDb.catalogMgr().getIndexInfo(\"test\", \"id\", tx).get(0);\n+\t\t\t\tIndex idx = ii.open(tx);\n+\t\t\t\t\n+\t\t\t\tint insertId = nextInsertId.getAndIncrement();\n+\t\t\t\tString idStr = String.format(\"%033d\", insertId);\n+\t\t\t\tConstant idCon = new VarcharConstant(idStr, ID_TYPE);\n+\t\t\t\tRecordId fakeRid = new RecordId(new BlockId(\"test\", insertId), 1);\n+\t\t\t\t\n+\t\t\t\tidx.insert(new SearchKey(idCon), fakeRid, true);\n+\t\t\t\t\n+\t\t\t\ttx.rollback();\n+\t\t\t} catch (LockAbortException l) {\n+\t\t\t\ttx.rollback();\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t}\n+}\ndiff --git a/src/test/java/org/vanilladb/core/storage/tx/recovery/BTreeIndexRecoveryTest.java b/src/test/java/org/vanilladb/core/storage/tx/recovery/BTreeIndexRecoveryTest.java\nnew file mode 100644\nindex 0000000..266d40c\n--- /dev/null\n+++ b/src/test/java/org/vanilladb/core/storage/tx/recovery/BTreeIndexRecoveryTest.java\n@@ -0,0 +1,78 @@\n+package org.vanilladb.core.storage.tx.recovery;\n+\n+import java.sql.Connection;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.vanilladb.core.query.planner.Planner;\n+import org.vanilladb.core.server.ServerInit;\n+import org.vanilladb.core.server.VanillaDb;\n+import org.vanilladb.core.sql.Constant;\n+import org.vanilladb.core.sql.Type;\n+import org.vanilladb.core.sql.VarcharConstant;\n+import org.vanilladb.core.storage.file.BlockId;\n+import org.vanilladb.core.storage.index.Index;\n+import org.vanilladb.core.storage.index.SearchKey;\n+import org.vanilladb.core.storage.metadata.index.IndexInfo;\n+import org.vanilladb.core.storage.record.RecordId;\n+import org.vanilladb.core.storage.tx.Transaction;\n+\n+public class BTreeIndexRecoveryTest {\n+\tprivate static Logger logger = Logger.getLogger(BTreeIndexRecoveryTest.class.getName());\n+\n+\tprivate static final Type ID_TYPE = Type.VARCHAR(33);\n+\t\n+\t@BeforeClass\n+\tpublic static void init() {\n+\t\tServerInit.init(BTreeIndexRecoveryTest.class);\n+\t\tcreateIndex();\n+\t\t\n+\t\tif (logger.isLoggable(Level.INFO))\n+\t\t\tlogger.info(\"BEGIN B-TREE RECOVERY TEST\");\n+\t}\n+\t\n+\t@AfterClass\n+\tpublic static void finish() {\n+\t\tif (logger.isLoggable(Level.INFO))\n+\t\t\tlogger.info(\"FINISH B-TREE RECOVERY TEST\");\n+\t}\n+\t\n+\tprivate static void createIndex() {\n+\t\tTransaction tx = VanillaDb.txMgr().newTransaction(\n+\t\t\t\tConnection.TRANSACTION_SERIALIZABLE, false);\n+\t\tPlanner planner = VanillaDb.newPlanner();\n+\t\t\n+\t\t// Create a table\n+\t\tplanner.executeUpdate(\"CREATE TABLE test (id VARCHAR(33), val INT)\", tx);\n+\t\t\n+\t\t// Create a B-Tree index\n+\t\tplanner.executeUpdate(\"CREATE INDEX test_idx ON test (id) USING BTREE\", tx);\n+\t\t\n+\t\ttx.commit();\n+\t\t\n+\t\tif (logger.isLoggable(Level.INFO))\n+\t\t\tlogger.info(\"TESTING DATA CREATED\");\n+\t}\n+\t\n+\t@Test\n+\tpublic void testVarcharIdRollback() {\n+\t\tTransaction tx = VanillaDb.txMgr().newTransaction(\n+\t\t\t\tConnection.TRANSACTION_SERIALIZABLE, false);\n+\t\t\n+\t\tIndexInfo ii = VanillaDb.catalogMgr().getIndexInfo(\"test\", \"id\", tx).get(0);\n+\t\tIndex idx = ii.open(tx);\n+\t\t\n+\t\tint insertId = 1;\n+\t\tString idStr = String.format(\"%033d\", insertId);\n+\t\tConstant idCon = new VarcharConstant(idStr, ID_TYPE);\n+\t\tRecordId fakeRid = new RecordId(new BlockId(\"test\", insertId), 1);\n+\t\t\n+\t\tidx.insert(new SearchKey(idCon), fakeRid, true);\n+\t\t\n+\t\ttx.rollback();\n+\t}\n+\n+}\n", "test_patch": "diff --git a/src/test/java/org/vanilladb/core/StorageTestSuite.java b/src/test/java/org/vanilladb/core/StorageTestSuite.java\nindex 69b3a33..e92f8e5 100644\n--- a/src/test/java/org/vanilladb/core/StorageTestSuite.java\n+++ b/src/test/java/org/vanilladb/core/StorageTestSuite.java\n@@ -36,6 +36,7 @@ import org.vanilladb.core.storage.record.RecordTest;\n import org.vanilladb.core.storage.tx.TxTest;\r\n import org.vanilladb.core.storage.tx.concurrency.ConcurrencyTest;\r\n import org.vanilladb.core.storage.tx.concurrency.LockTableTest;\r\n+import org.vanilladb.core.storage.tx.recovery.BTreeIndexRecoveryTest;\r\n import org.vanilladb.core.storage.tx.recovery.RecoveryBasicTest;\r\n \r\n @RunWith(IsolatedClassLoaderSuite.class)\r\n@@ -71,7 +72,7 @@ import org.vanilladb.core.storage.tx.recovery.RecoveryBasicTest;\n \tConcurrencyTest.class, LockTableTest.class,\r\n \t\r\n \t// storage.tx.recovery\r\n-\tRecoveryBasicTest.class,\r\n+\tRecoveryBasicTest.class, BTreeIndexRecoveryTest.class,\r\n })\r\n @IsolationRoot(VanillaDb.class)\r\n public class StorageTestSuite {\r\ndiff --git a/src/test/java/org/vanilladb/core/storage/index/btree/BTreeIndexTest.java b/src/test/java/org/vanilladb/core/storage/index/btree/BTreeIndexTest.java\nindex b86998d..0e5b483 100644\n--- a/src/test/java/org/vanilladb/core/storage/index/btree/BTreeIndexTest.java\n+++ b/src/test/java/org/vanilladb/core/storage/index/btree/BTreeIndexTest.java\n@@ -15,6 +15,7 @@\n  *******************************************************************************/\r\n package org.vanilladb.core.storage.index.btree;\r\n \r\n+import static org.junit.Assert.assertEquals;\r\n import static org.junit.Assert.assertTrue;\r\n import static org.vanilladb.core.sql.Type.BIGINT;\r\n import static org.vanilladb.core.sql.Type.INTEGER;\r\n@@ -243,67 +244,67 @@ public class BTreeIndexTest {\n \tpublic void testBTreeIndex() {\r\n \t\tList<IndexInfo> idxList = catMgr.getIndexInfo(DATA_TABLE_NAME, \"deptid\", tx);\r\n \t\tIndex index = idxList.get(0).open(tx);\r\n-\t\tBlockId blk = new BlockId(DATA_TABLE_NAME + \".tbl\", 0);\r\n-\t\tBlockId blk1 = new BlockId(DATA_TABLE_NAME + \".tbl\", 23);\r\n+\t\tBlockId blk0 = new BlockId(DATA_TABLE_NAME + \".tbl\", 0);\r\n+\t\tBlockId blk23 = new BlockId(DATA_TABLE_NAME + \".tbl\", 23);\r\n \t\tint maxValue = 300;\r\n \t\tint repeat = 200;\r\n-\t\tfor (int k = 0; k < maxValue; k++) {\r\n+\t\t\r\n+\t\t// Insert data set (maxValue x repeat)\r\n+\t\tfor (int fieldVal = 0; fieldVal < maxValue; fieldVal++) {\r\n \t\t\tfor (int i = 0; i < repeat; i++) {\r\n-\t\t\t\tSearchKey key = new SearchKey(new BigIntConstant(k));\r\n-\t\t\t\tindex.insert(key, new RecordId(blk, k * repeat + i), false);\r\n+\t\t\t\tSearchKey key = new SearchKey(new BigIntConstant(fieldVal));\r\n+\t\t\t\tindex.insert(key, new RecordId(blk0, fieldVal * repeat + i), false);\r\n \t\t\t}\r\n \t\t}\r\n-\r\n-\t\tint count = 0;\r\n+\t\t\r\n+\t\t// Insert 500 records with the same key (integer 7)\r\n \t\tSearchKey int7 = new SearchKey(new IntegerConstant(7));\r\n-\t\twhile (count < 500) {\r\n-\t\t\tindex.insert(int7, new RecordId(blk1, 2500 + count), false);\r\n-\t\t\tcount++;\r\n-\t\t}\r\n+\t\tfor (int count = 0; count < 500; count++)\r\n+\t\t\tindex.insert(int7, new RecordId(blk23, 2500 + count), false);\r\n \r\n-\t\t// test larger than 50\r\n+\t\t// Search for the records each of which key is large than 50\r\n \t\tConstantRange range = ConstantRange.newInstance(new IntegerConstant(50),\r\n \t\t\t\tfalse, null, false);\r\n \t\tindex.beforeFirst(new SearchRange(range));\r\n-\t\tint j = 0;\r\n+\t\tint count = 0;\r\n \t\twhile (index.next())\r\n-\t\t\tj++;\r\n-\t\tassertTrue(\"*****BTreeIndexTest: bad > selection\", j == (maxValue - 51)\r\n-\t\t\t\t* repeat);\r\n+\t\t\tcount++;\r\n+\t\tassertEquals(\"*****BTreeIndexTest: bad > selection\", (maxValue - 51)\r\n+\t\t\t\t* repeat, count);\r\n \r\n \t\tConstant int5con = new IntegerConstant(5);\r\n \t\t// test less than\r\n \t\trange = ConstantRange.newInstance(null, false, int5con, false);\r\n \t\tindex.beforeFirst(new SearchRange(range));\r\n-\t\tj = 0;\r\n+\t\tcount = 0;\r\n \t\twhile (index.next())\r\n-\t\t\tj++;\r\n-\t\tassertTrue(\"*****BTreeIndexTest: bad < selection\", j == (5 * repeat));\r\n+\t\t\tcount++;\r\n+\t\tassertEquals(\"*****BTreeIndexTest: bad < selection\", 5 * repeat, count);\r\n \r\n \t\t// test equality\r\n \t\tindex.beforeFirst(new SearchRange(new SearchKey(int5con)));\r\n-\t\tj = 0;\r\n+\t\tcount = 0;\r\n \t\twhile (index.next())\r\n-\t\t\tj++;\r\n-\t\tassertTrue(\"*****BTreeIndexTest: bad equal with\", j == repeat);\r\n+\t\t\tcount++;\r\n+\t\tassertEquals(\"*****BTreeIndexTest: bad equal with\", repeat, count);\r\n \r\n \t\t// test delete\r\n \t\tfor (int k = 0; k < maxValue; k++) {\r\n \t\t\tfor (int i = 0; i < repeat; i++) {\r\n \t\t\t\tSearchKey key = new SearchKey(new BigIntConstant(k));\r\n-\t\t\t\tindex.delete(key, new RecordId(blk, k * repeat + i), false);\r\n+\t\t\t\tindex.delete(key, new RecordId(blk0, k * repeat + i), false);\r\n \t\t\t}\r\n \t\t}\r\n \t\tindex.beforeFirst(new SearchRange(new SearchKey(int5con)));\r\n-\t\tassertTrue(\"*****BTreeIndexTest: bad delete\", index.next() == false);\r\n+\t\tassertEquals(\"*****BTreeIndexTest: bad delete\", false, index.next());\r\n \r\n \t\tcount = 0;\r\n \t\twhile (count < 500) {\r\n-\t\t\tindex.delete(int7, new RecordId(blk1, 2500 + count), false);\r\n+\t\t\tindex.delete(int7, new RecordId(blk23, 2500 + count), false);\r\n \t\t\tcount++;\r\n \t\t}\r\n \t\tindex.beforeFirst(new SearchRange(int7));\r\n-\t\tassertTrue(\"*****BTreeIndexTest: bad delete\", index.next() == false);\r\n+\t\tassertEquals(\"*****BTreeIndexTest: bad delete\", false, index.next());\r\n \r\n \t\tindex.close();\r\n \t}\r\n"}
{"repository": "vanilladb/vanillacore", "clone_url": "https://github.com/vanilladb/vanillacore.git", "timestamp": "2023-05-31T21:12:30.951720Z", "commit_hash": "25adea85d3c0072c8d7d86440733cc46e9a26a85", "commit_message": "Fix RecoveryBasicTest and a bug\n\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/org/vanilladb/core/storage/tx/recovery/IndexDeleteEndRecord.java b/src/main/java/org/vanilladb/core/storage/tx/recovery/IndexDeleteEndRecord.java\nindex 5fc0122..ee6a3ea 100644\n--- a/src/main/java/org/vanilladb/core/storage/tx/recovery/IndexDeleteEndRecord.java\n+++ b/src/main/java/org/vanilladb/core/storage/tx/recovery/IndexDeleteEndRecord.java\n@@ -17,6 +17,7 @@ package org.vanilladb.core.storage.tx.recovery;\n \n import static org.vanilladb.core.sql.Type.BIGINT;\n import static org.vanilladb.core.sql.Type.INTEGER;\n+import static org.vanilladb.core.sql.Type.VARCHAR;\n \n import java.util.LinkedList;\n import java.util.List;\n@@ -57,6 +58,7 @@ public class IndexDeleteEndRecord extends LogicalEndRecord implements LogRecord \n \n \tpublic IndexDeleteEndRecord(BasicLogRecord rec) {\n \t\ttxNum = (Long) rec.nextVal(BIGINT).asJavaVal();\n+\t\tindexName = (String) rec.nextVal(VARCHAR).asJavaVal();\n \n \t\t// Search Key\n \t\tint keyLen = (Integer) rec.nextVal(INTEGER).asJavaVal();\n", "test_patch": "diff --git a/src/test/java/org/vanilladb/core/storage/tx/recovery/RecoveryBasicTest.java b/src/test/java/org/vanilladb/core/storage/tx/recovery/RecoveryBasicTest.java\nindex 0584bb5..96ca198 100644\n--- a/src/test/java/org/vanilladb/core/storage/tx/recovery/RecoveryBasicTest.java\n+++ b/src/test/java/org/vanilladb/core/storage/tx/recovery/RecoveryBasicTest.java\n@@ -19,11 +19,10 @@ import static org.junit.Assert.assertTrue;\n import static org.vanilladb.core.sql.Type.BIGINT;\n import static org.vanilladb.core.sql.Type.INTEGER;\n import static org.vanilladb.core.sql.Type.VARCHAR;\n-import static org.vanilladb.core.storage.index.Index.IDX_BTREE;\n \n import java.sql.Connection;\n import java.util.LinkedList;\n-import java.util.Map;\n+import java.util.List;\n import java.util.concurrent.BrokenBarrierException;\n import java.util.concurrent.CyclicBarrier;\n import java.util.logging.Level;\n@@ -36,7 +35,6 @@ import org.junit.Test;\n import org.vanilladb.core.server.ServerInit;\n import org.vanilladb.core.server.VanillaDb;\n import org.vanilladb.core.sql.Constant;\n-import org.vanilladb.core.sql.ConstantRange;\n import org.vanilladb.core.sql.IntegerConstant;\n import org.vanilladb.core.sql.Schema;\n import org.vanilladb.core.sql.VarcharConstant;\n@@ -44,6 +42,9 @@ import org.vanilladb.core.storage.buffer.Buffer;\n import org.vanilladb.core.storage.buffer.BufferMgr;\n import org.vanilladb.core.storage.file.BlockId;\n import org.vanilladb.core.storage.index.Index;\n+import org.vanilladb.core.storage.index.IndexType;\n+import org.vanilladb.core.storage.index.SearchKey;\n+import org.vanilladb.core.storage.index.SearchRange;\n import org.vanilladb.core.storage.log.LogSeqNum;\n import org.vanilladb.core.storage.metadata.CatalogMgr;\n import org.vanilladb.core.storage.metadata.index.IndexInfo;\n@@ -73,7 +74,10 @@ public class RecoveryBasicTest {\n \t\tschema.addField(\"title\", VARCHAR(20));\n \t\tschema.addField(\"majorid\", BIGINT);\n \t\tmd.createTable(dataTableName, schema, tx);\n-\t\tmd.createIndex(\"index_cid\", dataTableName, \"cid\", IDX_BTREE, tx);\n+\t\t\n+\t\tList<String> idxFlds = new LinkedList<String>();\n+\t\tidxFlds.add(\"cid\");\n+\t\tmd.createIndex(\"index_cid\", dataTableName, idxFlds, IndexType.BTREE, tx);\n \n \t\ttx.commit();\n \n@@ -476,14 +480,14 @@ public class RecoveryBasicTest {\n \t}\n \t@Test\n \tpublic void testBTreeIndexRecovery() {\n-\n+\t\t// The first tx inserts records to the index\n \t\tTransaction tx = VanillaDb.txMgr().newTransaction(Connection.TRANSACTION_SERIALIZABLE, false);\n-\t\tMap<String, IndexInfo> idxmap = md.getIndexInfo(dataTableName, tx);\n+\t\tIndexInfo ii = md.getIndexInfo(dataTableName, \"cid\", tx).get(0);\n \n-\t\tIndex cidIndex = idxmap.get(\"cid\").open(tx);\n+\t\tIndex cidIndex = ii.open(tx);\n \t\tRecordId[] records = new RecordId[10];\n \t\tBlockId blk = new BlockId(dataTableName + \".tbl\", 0);\n-\t\tConstant int5 = new IntegerConstant(5);\n+\t\tSearchKey int5 = new SearchKey(new IntegerConstant(5));\n \n \t\tfor (int i = 0; i < 10; i++) {\n \t\t\trecords[i] = new RecordId(blk, i);\n@@ -491,51 +495,57 @@ public class RecoveryBasicTest {\n \t\t}\n \n \t\tRecordId rid2 = new RecordId(blk, 19);\n-\t\tConstant int7 = new IntegerConstant(7);\n+\t\tSearchKey int7 = new SearchKey(new IntegerConstant(7));\n \t\tcidIndex.insert(int7, rid2, true);\n \n \t\tcidIndex.close();\n \t\ttx.commit();\n-\n+\t\t\n+\t\t// The second tx does recovery (redo)\n \t\ttx = VanillaDb.txMgr().newTransaction(Connection.TRANSACTION_SERIALIZABLE, false);\n \t\tRecoveryMgr.recover(tx);\n \t\ttx.commit();\n-\n+\t\t\n+\t\t// The third tx checks the records\n \t\ttx = VanillaDb.txMgr().newTransaction(Connection.TRANSACTION_SERIALIZABLE, true);\n-\t\tidxmap = md.getIndexInfo(dataTableName, tx);\n-\t\tcidIndex = idxmap.get(\"cid\").open(tx);\n-\t\tcidIndex.beforeFirst(ConstantRange.newInstance(int5));\n+\t\t\n+\t\tii = md.getIndexInfo(dataTableName, \"cid\", tx).get(0);\n+\t\tcidIndex = ii.open(tx);\n+\t\tcidIndex.beforeFirst(new SearchRange(int5));\n \t\tint k = 0;\n \t\twhile (cidIndex.next())\n \t\t\tk++;\n \n \t\tassertTrue(\"*****RecoveryTest: bad index insertion recovery\", k == 10);\n \n-\t\tcidIndex.beforeFirst(ConstantRange.newInstance(int7));\n+\t\tcidIndex.beforeFirst(new SearchRange(int7));\n \t\tcidIndex.next();\n \t\tassertTrue(\"*****RecoveryTest: bad index insertion recovery\", cidIndex.getDataRecordId().equals(rid2));\n \n \t\tcidIndex.close();\n \t\ttx.commit();\n \n-\t\t// test roll back deletion on index\n+\t\t// The fourth tx tests roll back deletion on index\n \t\ttx = VanillaDb.txMgr().newTransaction(Connection.TRANSACTION_SERIALIZABLE, false);\n-\t\tidxmap = md.getIndexInfo(dataTableName, tx);\n-\t\tcidIndex = idxmap.get(\"cid\").open(tx);\n+\t\tii = md.getIndexInfo(dataTableName, \"cid\", tx).get(0);\n+\t\tcidIndex = ii.open(tx);\n \t\tcidIndex.delete(int7, rid2, true);\n \n \t\tRecordId rid3 = new RecordId(blk, 999);\n-\t\tConstant int777 = new IntegerConstant(777);\n+\t\tSearchKey int777 = new SearchKey(new IntegerConstant(777));\n \t\tcidIndex.insert(int777, rid3, true);\n \t\tcidIndex.close();\n \t\ttx.rollback();\n-\n+\t\t\n+\t\t// The fifth tx checks the result\n \t\ttx = VanillaDb.txMgr().newTransaction(Connection.TRANSACTION_SERIALIZABLE, true);\n-\t\tcidIndex.beforeFirst(ConstantRange.newInstance(int7));\n+\t\tii = md.getIndexInfo(dataTableName, \"cid\", tx).get(0);\n+\t\tcidIndex = ii.open(tx);\n+\t\tcidIndex.beforeFirst(new SearchRange(int7));\n \t\tcidIndex.next();\n \t\tassertTrue(\"*****RecoveryTest: bad index deletion rollback\", cidIndex.getDataRecordId().equals(rid2));\n \n-\t\tcidIndex.beforeFirst(ConstantRange.newInstance(int777));\n+\t\tcidIndex.beforeFirst(new SearchRange(int777));\n \t\tcidIndex.next();\n \t\tassertTrue(\"*****RecoveryTest: bad index insertion rollback\", !cidIndex.next());\n \t\tcidIndex.close();\n"}
