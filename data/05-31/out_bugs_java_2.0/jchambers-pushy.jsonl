{"repository": "jchambers/pushy", "clone_url": "https://github.com/jchambers/pushy.git", "timestamp": "2023-05-31T20:34:53.583323Z", "commit_hash": "bdd5faa2c41dcf5df1534bfc6fbe26dee7d72ab0", "commit_message": "Expect timestamps in milliseconds (fixes #237).\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/com/relayrides/pushy/apns/ApnsClientHandler.java b/src/main/java/com/relayrides/pushy/apns/ApnsClientHandler.java\nindex 7916428..f82a066 100644\n--- a/src/main/java/com/relayrides/pushy/apns/ApnsClientHandler.java\n+++ b/src/main/java/com/relayrides/pushy/apns/ApnsClientHandler.java\n@@ -67,7 +67,7 @@ class ApnsClientHandler<T extends ApnsPushNotification> extends Http2ConnectionH\n     private static final int STREAM_ID_RESET_THRESHOLD = Integer.MAX_VALUE - 1;\n \n     private static final Gson gson = new GsonBuilder()\n-            .registerTypeAdapter(Date.class, new DateAsSecondsSinceEpochTypeAdapter())\n+            .registerTypeAdapter(Date.class, new DateAsMillisecondsSinceEpochTypeAdapter())\n             .create();\n \n     private static final Charset UTF8 = Charset.forName(\"UTF-8\");\ndiff --git a/src/main/java/com/relayrides/pushy/apns/DateAsMillisecondsSinceEpochTypeAdapter.java b/src/main/java/com/relayrides/pushy/apns/DateAsMillisecondsSinceEpochTypeAdapter.java\nnew file mode 100644\nindex 0000000..b588f93\n--- /dev/null\n+++ b/src/main/java/com/relayrides/pushy/apns/DateAsMillisecondsSinceEpochTypeAdapter.java\n@@ -0,0 +1,64 @@\n+/* Copyright (c) 2013-2016 RelayRides\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE. */\n+\n+package com.relayrides.pushy.apns;\n+\n+import java.lang.reflect.Type;\n+import java.util.Date;\n+\n+import com.google.gson.JsonDeserializationContext;\n+import com.google.gson.JsonDeserializer;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonNull;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.JsonSerializationContext;\n+import com.google.gson.JsonSerializer;\n+\n+class DateAsMillisecondsSinceEpochTypeAdapter implements JsonSerializer<Date>, JsonDeserializer<Date> {\n+\n+    @Override\n+    public Date deserialize(final JsonElement json, final Type typeOfT, final JsonDeserializationContext context) throws JsonParseException {\n+        final Date date;\n+\n+        if (json.isJsonPrimitive()) {\n+            date = new Date(json.getAsLong());\n+        } else if (json.isJsonNull()) {\n+            date = null;\n+        } else {\n+            throw new JsonParseException(\"Dates represented as seconds since the epoch must either be numbers or null.\");\n+        }\n+\n+        return date;\n+    }\n+\n+    @Override\n+    public JsonElement serialize(final Date src, final Type typeOfSrc, final JsonSerializationContext context) {\n+        final JsonElement element;\n+\n+        if (src != null) {\n+            element = new JsonPrimitive(src.getTime());\n+        } else {\n+            element = JsonNull.INSTANCE;\n+        }\n+\n+        return element;\n+    }\n+}\ndiff --git a/src/main/java/com/relayrides/pushy/apns/DateAsSecondsSinceEpochTypeAdapter.java b/src/main/java/com/relayrides/pushy/apns/DateAsSecondsSinceEpochTypeAdapter.java\ndeleted file mode 100644\nindex 7f81918..0000000\n--- a/src/main/java/com/relayrides/pushy/apns/DateAsSecondsSinceEpochTypeAdapter.java\n+++ /dev/null\n@@ -1,64 +0,0 @@\n-/* Copyright (c) 2013-2016 RelayRides\n- *\n- * Permission is hereby granted, free of charge, to any person obtaining a copy\n- * of this software and associated documentation files (the \"Software\"), to deal\n- * in the Software without restriction, including without limitation the rights\n- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n- * copies of the Software, and to permit persons to whom the Software is\n- * furnished to do so, subject to the following conditions:\n- *\n- * The above copyright notice and this permission notice shall be included in\n- * all copies or substantial portions of the Software.\n- *\n- * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n- * THE SOFTWARE. */\n-\n-package com.relayrides.pushy.apns;\n-\n-import java.lang.reflect.Type;\n-import java.util.Date;\n-\n-import com.google.gson.JsonDeserializationContext;\n-import com.google.gson.JsonDeserializer;\n-import com.google.gson.JsonElement;\n-import com.google.gson.JsonNull;\n-import com.google.gson.JsonParseException;\n-import com.google.gson.JsonPrimitive;\n-import com.google.gson.JsonSerializationContext;\n-import com.google.gson.JsonSerializer;\n-\n-class DateAsSecondsSinceEpochTypeAdapter implements JsonSerializer<Date>, JsonDeserializer<Date> {\n-\n-    @Override\n-    public Date deserialize(final JsonElement json, final Type typeOfT, final JsonDeserializationContext context) throws JsonParseException {\n-        final Date date;\n-\n-        if (json.isJsonPrimitive()) {\n-            date = new Date(json.getAsLong() * 1000);\n-        } else if (json.isJsonNull()) {\n-            date = null;\n-        } else {\n-            throw new JsonParseException(\"Dates represented as seconds since the epoch must either be numbers or null.\");\n-        }\n-\n-        return date;\n-    }\n-\n-    @Override\n-    public JsonElement serialize(final Date src, final Type typeOfSrc, final JsonSerializationContext context) {\n-        final JsonElement element;\n-\n-        if (src != null) {\n-            element = new JsonPrimitive(src.getTime() / 1000);\n-        } else {\n-            element = JsonNull.INSTANCE;\n-        }\n-\n-        return element;\n-    }\n-}\ndiff --git a/src/test/java/com/relayrides/pushy/apns/DateAsMillisecondsSinceEpochTypeAdapterTest.java b/src/test/java/com/relayrides/pushy/apns/DateAsMillisecondsSinceEpochTypeAdapterTest.java\nnew file mode 100644\nindex 0000000..d142e8e\n--- /dev/null\n+++ b/src/test/java/com/relayrides/pushy/apns/DateAsMillisecondsSinceEpochTypeAdapterTest.java\n@@ -0,0 +1,41 @@\n+package com.relayrides.pushy.apns;\n+\n+import static org.junit.Assert.*;\n+\n+import java.util.Date;\n+\n+import org.junit.Test;\n+\n+import com.google.gson.JsonNull;\n+import com.google.gson.JsonPrimitive;\n+\n+public class DateAsMillisecondsSinceEpochTypeAdapterTest {\n+\n+    @Test\n+    public void testDeserialize() {\n+        final DateAsMillisecondsSinceEpochTypeAdapter adapter = new DateAsMillisecondsSinceEpochTypeAdapter();\n+\n+        assertNull(adapter.deserialize(JsonNull.INSTANCE, Date.class, null));\n+\n+        {\n+            final long timestampInSeconds = System.currentTimeMillis();\n+            final Date dateFromTimestamp = new Date(timestampInSeconds);\n+\n+            assertEquals(dateFromTimestamp, adapter.deserialize(new JsonPrimitive(timestampInSeconds), Date.class, null));\n+        }\n+    }\n+\n+    @Test\n+    public void testSerialize() {\n+        final DateAsMillisecondsSinceEpochTypeAdapter adapter = new DateAsMillisecondsSinceEpochTypeAdapter();\n+\n+        assertEquals(JsonNull.INSTANCE, adapter.serialize(null, Date.class, null));\n+\n+        {\n+            final long timestampInSeconds = System.currentTimeMillis();\n+            final Date dateFromTimestamp = new Date(timestampInSeconds);\n+\n+            assertEquals(new JsonPrimitive(timestampInSeconds), adapter.serialize(dateFromTimestamp, Date.class, null));\n+        }\n+    }\n+}\n", "test_patch": "diff --git a/src/test/java/com/relayrides/pushy/apns/ApnsClientTest.java b/src/test/java/com/relayrides/pushy/apns/ApnsClientTest.java\nindex 7b0c0c4..e67d7ad 100644\n--- a/src/test/java/com/relayrides/pushy/apns/ApnsClientTest.java\n+++ b/src/test/java/com/relayrides/pushy/apns/ApnsClientTest.java\n@@ -390,11 +390,9 @@ public class ApnsClientTest {\n     public void testSendNotificationWithExpiredToken() throws Exception {\n         final String testToken = ApnsClientTest.generateRandomToken();\n \n-        // APNs uses timestamps rounded to the nearest second; for ease of comparison, we test with timestamps that\n-        // just happen to fall on whole seconds.\n-        final Date roundedNow = new Date((System.currentTimeMillis() / 1000) * 1000);\n+        final Date now = new Date();\n \n-        this.server.registerToken(DEFAULT_TOPIC, testToken, roundedNow);\n+        this.server.registerToken(DEFAULT_TOPIC, testToken, now);\n \n         final SimpleApnsPushNotification pushNotification = new SimpleApnsPushNotification(testToken, null, \"test-payload\");\n         final PushNotificationResponse<SimpleApnsPushNotification> response =\n@@ -402,7 +400,7 @@ public class ApnsClientTest {\n \n         assertFalse(response.isAccepted());\n         assertEquals(\"Unregistered\", response.getRejectionReason());\n-        assertEquals(roundedNow, response.getTokenInvalidationTimestamp());\n+        assertEquals(now, response.getTokenInvalidationTimestamp());\n     }\n \n     private static SslContext getSslContextForTestClient(final String p12Filename, final String password) throws NoSuchAlgorithmException, KeyStoreException, IOException, CertificateException, UnrecoverableEntryException {\ndiff --git a/src/test/java/com/relayrides/pushy/apns/DateAsSecondsSinceEpochTypeAdapterTest.java b/src/test/java/com/relayrides/pushy/apns/DateAsSecondsSinceEpochTypeAdapterTest.java\ndeleted file mode 100644\nindex 08a55e6..0000000\n--- a/src/test/java/com/relayrides/pushy/apns/DateAsSecondsSinceEpochTypeAdapterTest.java\n+++ /dev/null\n@@ -1,41 +0,0 @@\n-package com.relayrides.pushy.apns;\n-\n-import static org.junit.Assert.*;\n-\n-import java.util.Date;\n-\n-import org.junit.Test;\n-\n-import com.google.gson.JsonNull;\n-import com.google.gson.JsonPrimitive;\n-\n-public class DateAsSecondsSinceEpochTypeAdapterTest {\n-\n-    @Test\n-    public void testDeserialize() {\n-        final DateAsSecondsSinceEpochTypeAdapter adapter = new DateAsSecondsSinceEpochTypeAdapter();\n-\n-        assertNull(adapter.deserialize(JsonNull.INSTANCE, Date.class, null));\n-\n-        {\n-            final long timestampInSeconds = (System.currentTimeMillis() / 1000);\n-            final Date dateFromTimestamp = new Date(timestampInSeconds * 1000);\n-\n-            assertEquals(dateFromTimestamp, adapter.deserialize(new JsonPrimitive(timestampInSeconds), Date.class, null));\n-        }\n-    }\n-\n-    @Test\n-    public void testSerialize() {\n-        final DateAsSecondsSinceEpochTypeAdapter adapter = new DateAsSecondsSinceEpochTypeAdapter();\n-\n-        assertEquals(JsonNull.INSTANCE, adapter.serialize(null, Date.class, null));\n-\n-        {\n-            final long timestampInSeconds = (System.currentTimeMillis() / 1000);\n-            final Date dateFromTimestamp = new Date(timestampInSeconds * 1000);\n-\n-            assertEquals(new JsonPrimitive(timestampInSeconds), adapter.serialize(dateFromTimestamp, Date.class, null));\n-        }\n-    }\n-}\ndiff --git a/src/test/java/com/relayrides/pushy/apns/MockApnsServerHandler.java b/src/test/java/com/relayrides/pushy/apns/MockApnsServerHandler.java\nindex 0c6447e..0ef6406 100644\n--- a/src/test/java/com/relayrides/pushy/apns/MockApnsServerHandler.java\n+++ b/src/test/java/com/relayrides/pushy/apns/MockApnsServerHandler.java\n@@ -50,7 +50,7 @@ class MockApnsServerHandler extends Http2ConnectionHandler implements Http2Frame\n     private static final Pattern TOKEN_PATTERN = Pattern.compile(\"[0-9a-fA-F]{64}\");\n \n     private static final Gson gson = new GsonBuilder()\n-            .registerTypeAdapter(Date.class, new DateAsSecondsSinceEpochTypeAdapter())\n+            .registerTypeAdapter(Date.class, new DateAsMillisecondsSinceEpochTypeAdapter())\n             .create();\n \n     public static final class MockApnsServerHandlerBuilder extends AbstractHttp2ConnectionHandlerBuilder<MockApnsServerHandler, MockApnsServerHandlerBuilder> {\n"}
{"repository": "jchambers/pushy", "clone_url": "https://github.com/jchambers/pushy.git", "timestamp": "2023-05-31T20:40:45.972505Z", "commit_hash": "98818b1cd872676809bb92568f1c28a1d619dbff", "commit_message": "Merge pull request #170 from sunng87/feature/alert-object\n\nFix ApnsPayloadBuilder alert body check when title is included (fixes #168)", "related_issues": "", "bug_patch": "diff --git a/src/main/java/com/relayrides/pushy/apns/util/ApnsPayloadBuilder.java b/src/main/java/com/relayrides/pushy/apns/util/ApnsPayloadBuilder.java\nindex 0a1ea3d..99258bb 100644\n--- a/src/main/java/com/relayrides/pushy/apns/util/ApnsPayloadBuilder.java\n+++ b/src/main/java/com/relayrides/pushy/apns/util/ApnsPayloadBuilder.java\n@@ -519,6 +519,12 @@ public class ApnsPayloadBuilder {\n \t * should be represented as a dictionary\n \t */\n \tprivate boolean shouldRepresentAlertAsString() {\n-\t\treturn this.alertBody != null && this.launchImageFileName == null && this.showActionButton && this.localizedActionButtonKey == null;\n+\t\treturn this.alertBody != null && this.launchImageFileName == null && this.showActionButton\n+\t\t\t\t&& this.localizedActionButtonKey == null\n+\t\t\t\t&& this.alertTitle == null\n+\t\t\t\t&& this.localizedAlertTitleKey == null\n+\t\t\t\t&& this.localizedAlertKey == null\n+\t\t\t\t&& this.localizedAlertArguments == null\n+\t\t\t\t&& this.localizedAlertTitleArguments == null;\n \t}\n }\n", "test_patch": "diff --git a/src/test/java/com/relayrides/pushy/apns/util/ApnsPayloadBuilderTest.java b/src/test/java/com/relayrides/pushy/apns/util/ApnsPayloadBuilderTest.java\nindex 3ffc4e5..9e49f21 100644\n--- a/src/test/java/com/relayrides/pushy/apns/util/ApnsPayloadBuilderTest.java\n+++ b/src/test/java/com/relayrides/pushy/apns/util/ApnsPayloadBuilderTest.java\n@@ -82,6 +82,23 @@ public class ApnsPayloadBuilderTest {\n \t\t}\n \t}\n \n+\t@Test\n+\tpublic void testSetAlertTitleAndBody() throws ParseException {\n+\t\tfinal String alertTitle = \"This is a short alert title\";\n+\t\tfinal String alertBody = \"This is a longer alert body\";\n+\n+\t\tthis.builder.setAlertBody(alertBody);\n+\t\tthis.builder.setAlertTitle(alertTitle);\n+\n+\t\t{\n+\t\t\tfinal JSONObject aps = this.extractApsObjectFromPayloadString(this.builder.buildWithDefaultMaximumLength());\n+\t\t\tfinal JSONObject alert = (JSONObject) aps.get(\"alert\");\n+\n+\t\t\tassertEquals(alertTitle, alert.get(\"title\"));\n+\t\t\tassertEquals(alertBody, alert.get(\"body\"));\n+\t\t}\n+\t}\n+\n \t@SuppressWarnings(\"unchecked\")\n \t@Test\n \tpublic void testSetLocalizedAlertMessage() throws ParseException {\n"}
{"repository": "jchambers/pushy", "clone_url": "https://github.com/jchambers/pushy.git", "timestamp": "2023-05-31T20:47:18.697522Z", "commit_hash": "84f39d30a13a0c8d401204459c2cd6ca3bba779f", "commit_message": "(fix) support iOS 8.2 new property alertTitle in\nshouldRepresentAlertAsString. Hoping to fix [#168]\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/com/relayrides/pushy/apns/util/ApnsPayloadBuilder.java b/src/main/java/com/relayrides/pushy/apns/util/ApnsPayloadBuilder.java\nindex 0a1ea3d..99258bb 100644\n--- a/src/main/java/com/relayrides/pushy/apns/util/ApnsPayloadBuilder.java\n+++ b/src/main/java/com/relayrides/pushy/apns/util/ApnsPayloadBuilder.java\n@@ -519,6 +519,12 @@ public class ApnsPayloadBuilder {\n \t * should be represented as a dictionary\n \t */\n \tprivate boolean shouldRepresentAlertAsString() {\n-\t\treturn this.alertBody != null && this.launchImageFileName == null && this.showActionButton && this.localizedActionButtonKey == null;\n+\t\treturn this.alertBody != null && this.launchImageFileName == null && this.showActionButton\n+\t\t\t\t&& this.localizedActionButtonKey == null\n+\t\t\t\t&& this.alertTitle == null\n+\t\t\t\t&& this.localizedAlertTitleKey == null\n+\t\t\t\t&& this.localizedAlertKey == null\n+\t\t\t\t&& this.localizedAlertArguments == null\n+\t\t\t\t&& this.localizedAlertTitleArguments == null;\n \t}\n }\n", "test_patch": "diff --git a/src/test/java/com/relayrides/pushy/apns/util/ApnsPayloadBuilderTest.java b/src/test/java/com/relayrides/pushy/apns/util/ApnsPayloadBuilderTest.java\nindex 3ffc4e5..9e49f21 100644\n--- a/src/test/java/com/relayrides/pushy/apns/util/ApnsPayloadBuilderTest.java\n+++ b/src/test/java/com/relayrides/pushy/apns/util/ApnsPayloadBuilderTest.java\n@@ -82,6 +82,23 @@ public class ApnsPayloadBuilderTest {\n \t\t}\n \t}\n \n+\t@Test\n+\tpublic void testSetAlertTitleAndBody() throws ParseException {\n+\t\tfinal String alertTitle = \"This is a short alert title\";\n+\t\tfinal String alertBody = \"This is a longer alert body\";\n+\n+\t\tthis.builder.setAlertBody(alertBody);\n+\t\tthis.builder.setAlertTitle(alertTitle);\n+\n+\t\t{\n+\t\t\tfinal JSONObject aps = this.extractApsObjectFromPayloadString(this.builder.buildWithDefaultMaximumLength());\n+\t\t\tfinal JSONObject alert = (JSONObject) aps.get(\"alert\");\n+\n+\t\t\tassertEquals(alertTitle, alert.get(\"title\"));\n+\t\t\tassertEquals(alertBody, alert.get(\"body\"));\n+\t\t}\n+\t}\n+\n \t@SuppressWarnings(\"unchecked\")\n \t@Test\n \tpublic void testSetLocalizedAlertMessage() throws ParseException {\n"}
{"repository": "jchambers/pushy", "clone_url": "https://github.com/jchambers/pushy.git", "timestamp": "2023-05-31T20:54:43.277155Z", "commit_hash": "e3507aefdaac7933252cad3948d18244f5a41b4e", "commit_message": "Fixed more copy constructor mistakes and added some clarifying comments to tests.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/com/relayrides/pushy/apns/ApnsConnectionConfiguration.java b/src/main/java/com/relayrides/pushy/apns/ApnsConnectionConfiguration.java\nindex 10bd20e..50e6cf6 100644\n--- a/src/main/java/com/relayrides/pushy/apns/ApnsConnectionConfiguration.java\n+++ b/src/main/java/com/relayrides/pushy/apns/ApnsConnectionConfiguration.java\n@@ -25,6 +25,7 @@ public class ApnsConnectionConfiguration {\n \tpublic ApnsConnectionConfiguration(final ApnsConnectionConfiguration configuration) {\n \t\tthis.sentNotificationBufferCapacity = configuration.sentNotificationBufferCapacity;\n \t\tthis.closeAfterInactivityTime = configuration.closeAfterInactivityTime;\n+\t\tthis.gracefulShutdownTimeout = configuration.gracefulShutdownTimeout;\n \t}\n \n \t/**\n", "test_patch": "diff --git a/src/test/java/com/relayrides/pushy/apns/ApnsConnectionConfigurationTest.java b/src/test/java/com/relayrides/pushy/apns/ApnsConnectionConfigurationTest.java\nindex c6c265b..948e8f4 100644\n--- a/src/test/java/com/relayrides/pushy/apns/ApnsConnectionConfigurationTest.java\n+++ b/src/test/java/com/relayrides/pushy/apns/ApnsConnectionConfigurationTest.java\n@@ -14,6 +14,7 @@ public class ApnsConnectionConfigurationTest {\n \n \t\tassertTrue(configuration.getSentNotificationBufferCapacity() > 0);\n \t\tassertNull(configuration.getCloseAfterInactivityTime());\n+\t\tassertNull(configuration.getGracefulShutdownTimeout());\n \t}\n \n \t@Test\n@@ -21,6 +22,7 @@ public class ApnsConnectionConfigurationTest {\n \t\tfinal ApnsConnectionConfiguration configuration = new ApnsConnectionConfiguration();\n \t\tconfiguration.setSentNotificationBufferCapacity(17);\n \t\tconfiguration.setCloseAfterInactivityTime(19);\n+\t\tconfiguration.setGracefulShutdownTimeout(23);\n \n \t\tfinal ApnsConnectionConfiguration configurationCopy = new ApnsConnectionConfiguration(configuration);\n \ndiff --git a/src/test/java/com/relayrides/pushy/apns/ApnsConnectionTest.java b/src/test/java/com/relayrides/pushy/apns/ApnsConnectionTest.java\nindex d007132..5d6efa2 100644\n--- a/src/test/java/com/relayrides/pushy/apns/ApnsConnectionTest.java\n+++ b/src/test/java/com/relayrides/pushy/apns/ApnsConnectionTest.java\n@@ -561,6 +561,8 @@ public class ApnsConnectionTest extends BasePushyTest {\n \t\t\t\t\t\tTEST_ENVIRONMENT, SSLTestUtil.createSSLContextForTestClient(), this.getEventLoopGroup(),\n \t\t\t\t\t\tgracefulShutdownTimeoutConfiguration, listener);\n \n+\t\t// We'll pretend that we have a \"dead\" connection; it will be up to the graceful shutdown timeout to close the\n+\t\t// connection.\n \t\tthis.getApnsServer().setShouldSendErrorResponses(false);\n \n \t\tsynchronized (mutex) {\n"}
{"repository": "jchambers/pushy", "clone_url": "https://github.com/jchambers/pushy.git", "timestamp": "2023-05-31T21:01:21.344636Z", "commit_hash": "7814c0fd493c33625ce4f0678c46e566fca1f274", "commit_message": "Fixed a copy constructor goof and updated tests accordingly.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/com/relayrides/pushy/apns/ApnsConnectionConfiguration.java b/src/main/java/com/relayrides/pushy/apns/ApnsConnectionConfiguration.java\nindex 8331321..4889b04 100644\n--- a/src/main/java/com/relayrides/pushy/apns/ApnsConnectionConfiguration.java\n+++ b/src/main/java/com/relayrides/pushy/apns/ApnsConnectionConfiguration.java\n@@ -23,6 +23,7 @@ public class ApnsConnectionConfiguration {\n \t */\n \tpublic ApnsConnectionConfiguration(final ApnsConnectionConfiguration configuration) {\n \t\tthis.sentNotificationBufferCapacity = configuration.sentNotificationBufferCapacity;\n+\t\tthis.closeAfterInactivityTime = configuration.closeAfterInactivityTime;\n \t}\n \n \t/**\n", "test_patch": "diff --git a/src/test/java/com/relayrides/pushy/apns/ApnsConnectionConfigurationTest.java b/src/test/java/com/relayrides/pushy/apns/ApnsConnectionConfigurationTest.java\nindex 0a6382c..c6c265b 100644\n--- a/src/test/java/com/relayrides/pushy/apns/ApnsConnectionConfigurationTest.java\n+++ b/src/test/java/com/relayrides/pushy/apns/ApnsConnectionConfigurationTest.java\n@@ -1,6 +1,8 @@\n package com.relayrides.pushy.apns;\n \n-import static org.junit.Assert.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n \n import org.junit.Test;\n \n@@ -11,12 +13,14 @@ public class ApnsConnectionConfigurationTest {\n \t\tfinal ApnsConnectionConfiguration configuration = new ApnsConnectionConfiguration();\n \n \t\tassertTrue(configuration.getSentNotificationBufferCapacity() > 0);\n+\t\tassertNull(configuration.getCloseAfterInactivityTime());\n \t}\n \n \t@Test\n \tpublic void testApnsConnectionConfigurationApnsConnectionConfiguration() {\n \t\tfinal ApnsConnectionConfiguration configuration = new ApnsConnectionConfiguration();\n \t\tconfiguration.setSentNotificationBufferCapacity(17);\n+\t\tconfiguration.setCloseAfterInactivityTime(19);\n \n \t\tfinal ApnsConnectionConfiguration configurationCopy = new ApnsConnectionConfiguration(configuration);\n \n"}
{"repository": "jchambers/pushy", "clone_url": "https://github.com/jchambers/pushy.git", "timestamp": "2023-05-31T21:08:11.109182Z", "commit_hash": "29108999697debda5d6374f4e753ce09a002e510", "commit_message": "Merge pull request #90 from relayrides/fix_runtime_exception_on_bad_token_string_length\n\nThrow checked exception for odd token string lengths (fixes #88)", "related_issues": "", "bug_patch": "diff --git a/src/main/java/com/relayrides/pushy/apns/util/MalformedTokenStringException.java b/src/main/java/com/relayrides/pushy/apns/util/MalformedTokenStringException.java\nnew file mode 100644\nindex 0000000..70ff828\n--- /dev/null\n+++ b/src/main/java/com/relayrides/pushy/apns/util/MalformedTokenStringException.java\n@@ -0,0 +1,41 @@\n+/* Copyright (c) 2013 RelayRides\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+\n+package com.relayrides.pushy.apns.util;\n+\n+/**\n+ * Signals that a given string was not could not be parsed as an APNs token.\n+ *\n+ * @author <a href=\"mailto:jon@relayrides.com\">Jon Chambers</a>\n+ */\n+public class MalformedTokenStringException extends Exception {\n+\n+\tprivate static final long serialVersionUID = 1L;\n+\n+\t/**\n+\t * Constructs a new malformed token string exception with the given detail message.\n+\t *\n+\t * @param message an explanation of the cause of the exception\n+\t */\n+\tpublic MalformedTokenStringException(final String message) {\n+\t\tsuper(message);\n+\t}\n+}\ndiff --git a/src/main/java/com/relayrides/pushy/apns/util/TokenUtil.java b/src/main/java/com/relayrides/pushy/apns/util/TokenUtil.java\nindex ac77034..1a9b9a7 100644\n--- a/src/main/java/com/relayrides/pushy/apns/util/TokenUtil.java\n+++ b/src/main/java/com/relayrides/pushy/apns/util/TokenUtil.java\n@@ -1,15 +1,15 @@\n /* Copyright (c) 2013 RelayRides\n- * \n+ *\n  * Permission is hereby granted, free of charge, to any person obtaining a copy\n  * of this software and associated documentation files (the \"Software\"), to deal\n  * in the Software without restriction, including without limitation the rights\n  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  * copies of the Software, and to permit persons to whom the Software is\n  * furnished to do so, subject to the following conditions:\n- * \n+ *\n  * The above copyright notice and this permission notice shall be included in\n  * all copies or substantial portions of the Software.\n- * \n+ *\n  * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n@@ -23,7 +23,7 @@ package com.relayrides.pushy.apns.util;\n \n /**\n  * <p>A utility class for converting APNS device tokens between byte arrays and hexadecimal strings.</p>\n- * \n+ *\n  * @author <a href=\"mailto:jon@relayrides.com\">Jon Chambers</a>\n  */\n public class TokenUtil {\n@@ -36,18 +36,29 @@ public class TokenUtil {\n \t * A-F) are ignored in the conversion. Note that this means that\n \t * {@code TokenUtil.tokenBytesToString(TokenUtil.tokenStringToByteArray(tokenString))} may be different from\n \t * {@code tokenString}.</p>\n-\t * \n+\t *\n \t * <p>As an example, a valid token string may look something like this: {@code <740f4707 61bb78ad>}. This method\n \t * would return a byte array with the following values: {@code [0x74 0x0f 0x47 0x07 0x61 0xbb 0x78 0xad]}.</p>\n-\t * \n+\t *\n \t * @param tokenString a string of hexadecimal characters to interpret as a byte array\n-\t * \n+\t *\n \t * @return a byte array containing the values represented in the token string\n+\t *\n+\t * @throws MalformedTokenStringException if the given token string could not be parsed as an APNs token\n+\t * @throws NullPointerException if the given string is {@code null}\n \t */\n-\tpublic static byte[] tokenStringToByteArray(final String tokenString) {\n+\tpublic static byte[] tokenStringToByteArray(final String tokenString) throws MalformedTokenStringException {\n+\n+\t\tif (tokenString == null) {\n+\t\t\tthrow new NullPointerException(\"Token string must not be null.\");\n+\t\t}\n \n \t\tfinal String strippedTokenString = tokenString.replaceAll(NON_HEX_CHARACTER_PATTERN, \"\");\n \n+\t\tif (strippedTokenString.length() % 2 != 0) {\n+\t\t\tthrow new MalformedTokenStringException(\"Token strings must contain an even number of hexadecimal digits.\");\n+\t\t}\n+\n \t\tfinal byte[] tokenBytes = new byte[strippedTokenString.length() / 2];\n \n \t\tfor (int i = 0; i < strippedTokenString.length(); i += 2) {\n@@ -61,12 +72,18 @@ public class TokenUtil {\n \t * <p>Converts an array of bytes into a string of hexadecimal characters representing the values in the array. For\n \t * example, calling this method on a byte array with the values {@code [0x01 0x23 0x45 0x67 0x89 0xab]} would return\n \t * {@code \"0123456789ab\"}. No guarantees are made as to the case of the returned string.</p>\n-\t * \n+\t *\n \t * @param tokenBytes an array of bytes to represent as a string\n-\t * \n+\t *\n \t * @return a string of hexadecimal characters representing the values in the given byte array\n+\t *\n+\t * @throws NullPointerException if the given byte array is {@code null}\n \t */\n \tpublic static String tokenBytesToString(final byte[] tokenBytes) {\n+\t\tif (tokenBytes == null) {\n+\t\t\tthrow new NullPointerException(\"Token byte array must not be null.\");\n+\t\t}\n+\n \t\tfinal StringBuilder builder = new StringBuilder();\n \n \t\tfor (final byte b : tokenBytes) {\n", "test_patch": "diff --git a/src/test/java/com/relayrides/pushy/apns/util/TokenUtilTest.java b/src/test/java/com/relayrides/pushy/apns/util/TokenUtilTest.java\nindex b522a66..3507f5c 100644\n--- a/src/test/java/com/relayrides/pushy/apns/util/TokenUtilTest.java\n+++ b/src/test/java/com/relayrides/pushy/apns/util/TokenUtilTest.java\n@@ -1,15 +1,15 @@\n /* Copyright (c) 2013 RelayRides\n- * \n+ *\n  * Permission is hereby granted, free of charge, to any person obtaining a copy\n  * of this software and associated documentation files (the \"Software\"), to deal\n  * in the Software without restriction, including without limitation the rights\n  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  * copies of the Software, and to permit persons to whom the Software is\n  * furnished to do so, subject to the following conditions:\n- * \n+ *\n  * The above copyright notice and this permission notice shall be included in\n  * all copies or substantial portions of the Software.\n- * \n+ *\n  * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n@@ -29,13 +29,24 @@ import org.junit.Test;\n public class TokenUtilTest {\n \n \t@Test\n-\tpublic void testTokenStringToByteArray() {\n+\tpublic void testTokenStringToByteArray() throws MalformedTokenStringException {\n \t\tfinal String tokenString = \"<740f4707 61bb78ad>\";\n \t\tfinal byte[] expectedTokenBytes = new byte[] { 0x74, 0x0f, 0x47, 0x07, 0x61, (byte) 0xbb, 0x78, (byte) 0xad };\n \n \t\tassertArrayEquals(expectedTokenBytes, TokenUtil.tokenStringToByteArray(tokenString));\n \t}\n \n+\t@Test(expected = MalformedTokenStringException.class)\n+\tpublic void testTokenStringToByteArrayOddStringLength() throws MalformedTokenStringException {\n+\t\tfinal String tokenString = \"<740f4707 61bb78a>\";\n+\t\tTokenUtil.tokenStringToByteArray(tokenString);\n+\t}\n+\n+\t@Test(expected = NullPointerException.class)\n+\tpublic void testTokenStringToByteArrayNullString() throws MalformedTokenStringException {\n+\t\tTokenUtil.tokenStringToByteArray(null);\n+\t}\n+\n \t@Test\n \tpublic void testTokenBytesToString() {\n \t\tfinal byte[] tokenBytes = { 0x01, 0x23, 0x45, 0x67, (byte) 0x89, (byte) 0xab, (byte) 0xcd, (byte) 0xef };\n@@ -43,4 +54,9 @@ public class TokenUtilTest {\n \n \t\tassertTrue(expectedTokenString.equalsIgnoreCase(TokenUtil.tokenBytesToString(tokenBytes)));\n \t}\n+\n+\t@Test(expected = NullPointerException.class)\n+\tpublic void testTokenBytesToStringNullBytes() {\n+\t\tTokenUtil.tokenBytesToString(null);\n+\t}\n }\n"}
{"repository": "jchambers/pushy", "clone_url": "https://github.com/jchambers/pushy.git", "timestamp": "2023-05-31T21:12:33.440583Z", "commit_hash": "4bd16bd52309241b0ba689adcafe34ec94797894", "commit_message": "Fixed a poorly-constructed test; fixed the bug that the corrected test revealed.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/com/relayrides/pushy/apns/PushManager.java b/src/main/java/com/relayrides/pushy/apns/PushManager.java\nindex 6171a06..4858d0f 100644\n--- a/src/main/java/com/relayrides/pushy/apns/PushManager.java\n+++ b/src/main/java/com/relayrides/pushy/apns/PushManager.java\n@@ -468,11 +468,11 @@ public class PushManager<T extends ApnsPushNotification> implements ApnsConnecti\n \tpublic void handleConnectionSuccess(final ApnsConnection<T> connection) {\n \t\tlog.trace(\"Connection succeeded: {}\", connection);\n \n-\t\tif (this.isShutDown()) {\n-\t\t\t// We DON'T want to decrement the counter here; we'll do so when handleConnectionClosure fires later\n-\t\t\tconnection.shutdownImmediately();\n-\t\t} else {\n+\t\tif (this.dispatchThreadShouldContinue) {\n \t\t\tthis.writableConnectionPool.addConnection(connection);\n+\t\t} else {\n+\t\t\t// There's no dispatch thread to use this connection, so shut it down immediately\n+\t\t\tconnection.shutdownImmediately();\n \t\t}\n \t}\n \n", "test_patch": "diff --git a/src/test/java/com/relayrides/pushy/apns/PushManagerTest.java b/src/test/java/com/relayrides/pushy/apns/PushManagerTest.java\nindex b96baa9..5e145d5 100644\n--- a/src/test/java/com/relayrides/pushy/apns/PushManagerTest.java\n+++ b/src/test/java/com/relayrides/pushy/apns/PushManagerTest.java\n@@ -206,10 +206,10 @@ public class PushManagerTest extends BasePushyTest {\n \n \t\tfor (int i = 0; i < iterations; i++) {\n \t\t\tif (i == iterations / 2) {\n-\t\t\t\tthis.getPushManager().getQueue().add(\n+\t\t\t\tnotificationsToSend.add(\n \t\t\t\t\t\tnew SimpleApnsPushNotification(new byte[] {}, \"This is a deliberately malformed notification.\"));\n \t\t\t} else {\n-\t\t\t\tthis.getPushManager().getQueue().add(this.createTestNotification());\n+\t\t\t\tnotificationsToSend.add(this.createTestNotification());\n \t\t\t}\n \t\t}\n \n@@ -219,7 +219,8 @@ public class PushManagerTest extends BasePushyTest {\n \t\tthis.getPushManager().getQueue().add(this.createTestNotification());\n \t\tthis.waitForLatch(firstNotificationLatch);\n \n-\t\tfinal CountDownLatch retryNotificationLatch = this.getApnsServer().getAcceptedNotificationCountDownLatch(notificationsToSend.size());\n+\t\t// We expect one less because one notification should be rejected\n+\t\tfinal CountDownLatch retryNotificationLatch = this.getApnsServer().getAcceptedNotificationCountDownLatch(notificationsToSend.size() - 1);\n \t\tthis.getPushManager().getRetryQueue().addAll(notificationsToSend);\n \t\tthis.getPushManager().shutdown();\n \n"}
{"repository": "jchambers/pushy", "clone_url": "https://github.com/jchambers/pushy.git", "timestamp": "2023-05-31T21:18:21.226476Z", "commit_hash": "035300b630b2f00d47a406c302eaaa5734556330", "commit_message": "Merge pull request #51 from relayrides/connection_failure_listener\n\nConnection failure listener (fixes #32)", "related_issues": "", "bug_patch": "diff --git a/src/main/java/com/relayrides/pushy/apns/FailedConnectionListener.java b/src/main/java/com/relayrides/pushy/apns/FailedConnectionListener.java\nnew file mode 100644\nindex 0000000..662cebe\n--- /dev/null\n+++ b/src/main/java/com/relayrides/pushy/apns/FailedConnectionListener.java\n@@ -0,0 +1,27 @@\n+package com.relayrides.pushy.apns;\n+\n+import javax.net.ssl.SSLHandshakeException;\n+\n+/**\n+ * <p>Listens for failed attempts to connect to an APNs gateway. Generally, a push manager will continue to try to\n+ * connect until it is shut down (under the assumption that failures are temporary).</p>\n+ * \n+ * <p>Some causes of failure are more permanent; generally, an {@link SSLHandshakeException} indicates a problem with\n+ * SSL credentials that is unlikely to be resolved by retrying the connection, and applications using Pushy are\n+ * encouraged to register a listener that shuts down a push manager in the event of a handshake exception.</p>\n+ * \n+ * @author <a href=\"mailto:jon@relayrides.com\">Jon Chambers</a>\n+ * \n+ * @see com.relayrides.pushy.apns.PushManager#registerFailedConnectionListener(FailedConnectionListener)\n+ * @see com.relayrides.pushy.apns.PushManager#unregisterFailedConnectionListener(FailedConnectionListener)\n+ */\n+public interface FailedConnectionListener<T extends ApnsPushNotification> {\n+\n+\t/**\n+\t * Handles a failed attempt to connect to the APNs gateway.\n+\t * \n+\t * @param pushManager the push manager that failed to open a connection\n+\t * @param cause the cause for the connection failure\n+\t */\n+\tvoid handleFailedConnection(PushManager<? extends T> pushManager, Throwable cause);\n+}\ndiff --git a/src/main/java/com/relayrides/pushy/apns/PushManager.java b/src/main/java/com/relayrides/pushy/apns/PushManager.java\nindex d92fe89..8415714 100644\n--- a/src/main/java/com/relayrides/pushy/apns/PushManager.java\n+++ b/src/main/java/com/relayrides/pushy/apns/PushManager.java\n@@ -64,13 +64,16 @@ public class PushManager<T extends ApnsPushNotification> implements ApnsConnecti\n \tprivate final HashSet<ApnsConnection<T>> activeConnections;\n \tprivate final ApnsConnectionPool<T> writableConnectionPool;\n \tprivate final FeedbackServiceClient feedbackServiceClient;\n+\n \tprivate final Vector<RejectedNotificationListener<? super T>> rejectedNotificationListeners;\n+\tprivate final Vector<FailedConnectionListener<? super T>> failedConnectionListeners;\n \n \tprivate Thread dispatchThread;\n \tprivate final NioEventLoopGroup eventLoopGroup;\n \tprivate final boolean shouldShutDownEventLoopGroup;\n \n-\tprivate final ExecutorService rejectedNotificationExecutorService;\n+\tprivate final ExecutorService listenerExecutorService;\n+\tprivate final boolean shouldShutDownListenerExecutorService;\n \n \tprivate boolean started = false;\n \tprivate boolean shutDown = false;\n@@ -112,16 +115,22 @@ public class PushManager<T extends ApnsPushNotification> implements ApnsConnecti\n \t * @param eventLoopGroup the event loop group this push manager should use for its connections to the APNs gateway and\n \t * feedback service; if {@code null}, a new event loop group will be created and will be shut down automatically\n \t * when the push manager is shut down. If not {@code null}, the caller <strong>must</strong> shut down the event\n-\t * loop group after shutting down the push manager\n+\t * loop group after shutting down the push manager.\n+\t * @param listenerExecutorService the executor service this push manager should use to dispatch notifications to\n+\t * registered listeners. If {@code null}, a new single-thread executor service will be created and will be shut\n+\t * down automatically with the push manager is shut down. If not {@code null}, the caller <strong>must</strong>\n+\t * shut down the executor service after shutting down the push manager.\n \t * @param queue the queue to be used to pass new notifications to this push manager\n \t */\n \tprotected PushManager(final ApnsEnvironment environment, final SSLContext sslContext,\n-\t\t\tfinal int concurrentConnectionCount, final NioEventLoopGroup eventLoopGroup, final BlockingQueue<T> queue) {\n+\t\t\tfinal int concurrentConnectionCount, final NioEventLoopGroup eventLoopGroup,\n+\t\t\tfinal ExecutorService listenerExecutorService, final BlockingQueue<T> queue) {\n \n \t\tthis.queue = queue != null ? queue : new LinkedBlockingQueue<T>();\n \t\tthis.retryQueue = new LinkedBlockingQueue<T>();\n \n \t\tthis.rejectedNotificationListeners = new Vector<RejectedNotificationListener<? super T>>();\n+\t\tthis.failedConnectionListeners = new Vector<FailedConnectionListener<? super T>>();\n \n \t\tthis.environment = environment;\n \t\tthis.sslContext = sslContext;\n@@ -138,9 +147,15 @@ public class PushManager<T extends ApnsPushNotification> implements ApnsConnecti\n \t\t\tthis.shouldShutDownEventLoopGroup = true;\n \t\t}\n \n-\t\tthis.feedbackServiceClient = new FeedbackServiceClient(this.environment, this.sslContext, this.eventLoopGroup);\n+\t\tif (listenerExecutorService != null) {\n+\t\t\tthis.listenerExecutorService = listenerExecutorService;\n+\t\t\tthis.shouldShutDownListenerExecutorService = false;\n+\t\t} else {\n+\t\t\tthis.listenerExecutorService = Executors.newSingleThreadExecutor();\n+\t\t\tthis.shouldShutDownListenerExecutorService = true;\n+\t\t}\n \n-\t\tthis.rejectedNotificationExecutorService = Executors.newSingleThreadExecutor();\n+\t\tthis.feedbackServiceClient = new FeedbackServiceClient(this.environment, this.sslContext, this.eventLoopGroup);\n \t}\n \n \t/**\n@@ -290,7 +305,11 @@ public class PushManager<T extends ApnsPushNotification> implements ApnsConnecti\n \t\tthis.dispatchThread.join();\n \n \t\tthis.rejectedNotificationListeners.clear();\n-\t\tthis.rejectedNotificationExecutorService.shutdown();\n+\t\tthis.failedConnectionListeners.clear();\n+\n+\t\tif (this.shouldShutDownListenerExecutorService) {\n+\t\t\tthis.listenerExecutorService.shutdown();\n+\t\t}\n \n \t\tif (this.shouldShutDownEventLoopGroup) {\n \t\t\tif (!this.eventLoopGroup.isShutdown()) {\n@@ -309,9 +328,7 @@ public class PushManager<T extends ApnsPushNotification> implements ApnsConnecti\n \t}\n \n \t/**\n-\t * <p>Registers a listener for notifications rejected by APNs for specific reasons. Note that listeners are stored\n-\t * as strong references; all listeners are automatically un-registered when the push manager is shut down, but\n-\t * failing to unregister a listener manually or to shut down the push manager may cause a memory leak.</p>\n+\t * <p>Registers a listener for notifications rejected by APNs for specific reasons.</p>\n \t *\n \t * @param listener the listener to register\n \t *\n@@ -340,6 +357,35 @@ public class PushManager<T extends ApnsPushNotification> implements ApnsConnecti\n \t}\n \n \t/**\n+\t * <p>Registers a listener for failed attempts to connect to the APNs gateway.</p>\n+\t * \n+\t * @param listener the listener to register\n+\t * \n+\t * @throws IllegalStateException if this push manager has already been shut down\n+\t * \n+\t * @see PushManager#unregisterFailedConnectionListener(FailedConnectionListener)\n+\t */\n+\tpublic void registerFailedConnectionListener(final FailedConnectionListener<? super T> listener) {\n+\t\tif (this.shutDown) {\n+\t\t\tthrow new IllegalStateException(\"Failed connection listeners may not be registered after a push manager has been shut down.\");\n+\t\t}\n+\n+\t\tthis.failedConnectionListeners.add(listener);\n+\t}\n+\n+\t/**\n+\t * <p>Un-registers a connection failure listener.</p>\n+\t * \n+\t * @param listener the listener to un-register\n+\t * \n+\t * @return {@code true} if the given listener was registered with this push manager and removed or {@code false} if\n+\t * the listener was not already registered with this push manager\n+\t */\n+\tpublic boolean unregisterFailedConnectionListener(final FailedConnectionListener<? super T> listener) {\n+\t\treturn this.failedConnectionListeners.remove(listener);\n+\t}\n+\n+\t/**\n \t * <p>Returns the queue of messages to be sent to the APNs gateway. Callers should add notifications to this queue\n \t * directly to send notifications. Notifications will be removed from this queue by Pushy when a send attempt is\n \t * started, but no guarantees are made as to when the notification will actually be sent. Successful delivery is\n@@ -427,11 +473,23 @@ public class PushManager<T extends ApnsPushNotification> implements ApnsConnecti\n \t * @see com.relayrides.pushy.apns.ApnsConnectionListener#handleConnectionFailure(com.relayrides.pushy.apns.ApnsConnection, java.lang.Throwable)\n \t */\n \tpublic void handleConnectionFailure(final ApnsConnection<T> connection, final Throwable cause) {\n-\t\t// TODO Do more to react to specific causes\n \n \t\tthis.removeActiveConnection(connection);\n \n \t\t// We tried to open a connection, but failed. As long as we're not shut down, try to open a new one.\n+\t\tfinal PushManager<T> pushManager = this;\n+\n+\t\tfor (final FailedConnectionListener<? super T> listener : this.failedConnectionListeners) {\n+\n+\t\t\t// Handle connection failures in a separate thread in case a handler takes a long time to run\n+\t\t\tthis.listenerExecutorService.submit(new Runnable() {\n+\t\t\t\tpublic void run() {\n+\t\t\t\t\tlistener.handleFailedConnection(pushManager, cause);\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\n+\t\t// As long as we're not shut down, keep trying to open a replacement connection.\n \t\tif (!this.isShutDown()) {\n \t\t\tthis.startNewConnection();\n \t\t}\n@@ -468,8 +526,7 @@ public class PushManager<T extends ApnsPushNotification> implements ApnsConnecti\n \t\t\tthis.dispatchThread.interrupt();\n \t\t}\n \n-\t\t// TODO Do this in an executor service instead of spawning a new thread\n-\t\tnew Thread(new Runnable() {\n+\t\tthis.listenerExecutorService.execute(new Runnable() {\n \n \t\t\tpublic void run() {\n \t\t\t\ttry {\n@@ -479,7 +536,7 @@ public class PushManager<T extends ApnsPushNotification> implements ApnsConnecti\n \t\t\t\t\tlog.warn(\"Interrupted while waiting for closed connection's pending operations to finish.\");\n \t\t\t\t}\n \t\t\t}\n-\t\t}).start();\n+\t\t});\n \t}\n \n \t/*\n@@ -501,12 +558,14 @@ public class PushManager<T extends ApnsPushNotification> implements ApnsConnecti\n \tpublic void handleRejectedNotification(final ApnsConnection<T> connection, final T rejectedNotification,\n \t\t\tfinal RejectedNotificationReason reason) {\n \n+\t\tfinal PushManager<T> pushManager = this;\n+\n \t\tfor (final RejectedNotificationListener<? super T> listener : this.rejectedNotificationListeners) {\n \n \t\t\t// Handle the notifications in a separate thread in case a listener takes a long time to run\n-\t\t\tthis.rejectedNotificationExecutorService.execute(new Runnable() {\n+\t\t\tthis.listenerExecutorService.execute(new Runnable() {\n \t\t\t\tpublic void run() {\n-\t\t\t\t\tlistener.handleRejectedNotification(rejectedNotification, reason);\n+\t\t\t\t\tlistener.handleRejectedNotification(pushManager, rejectedNotification, reason);\n \t\t\t\t}\n \t\t\t});\n \t\t}\ndiff --git a/src/main/java/com/relayrides/pushy/apns/PushManagerFactory.java b/src/main/java/com/relayrides/pushy/apns/PushManagerFactory.java\nindex a04146e..2f3c811 100644\n--- a/src/main/java/com/relayrides/pushy/apns/PushManagerFactory.java\n+++ b/src/main/java/com/relayrides/pushy/apns/PushManagerFactory.java\n@@ -12,6 +12,7 @@ import java.security.Security;\n import java.security.UnrecoverableKeyException;\n import java.security.cert.CertificateException;\n import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ExecutorService;\n \n import javax.net.ssl.KeyManagerFactory;\n import javax.net.ssl.SSLContext;\n@@ -36,6 +37,7 @@ public class PushManagerFactory<T extends ApnsPushNotification> {\n \tprivate int concurrentConnectionCount = 1;\n \n \tprivate NioEventLoopGroup eventLoopGroup;\n+\tprivate ExecutorService listenerExecutorService;\n \n \tprivate BlockingQueue<T> queue;\n \n@@ -85,8 +87,7 @@ public class PushManagerFactory<T extends ApnsPushNotification> {\n \t * <p>By default, constructed {@code PushManagers} will construct and maintain their own event loop groups.</p>\n \t *\n \t * @param eventLoopGroup the event loop group constructed {@code PushManagers} should use for their connections to\n-\t * the APNs gateway and feedback service; if {@code null}, a new event loop group will be created and will be shut\n-\t * down automatically when the push manager is shut down. If not {@code null}, the caller <strong>must</strong> shut\n+\t * the APNs gateway and feedback service; if not {@code null}, the caller <strong>must</strong> shut\n \t * down the event loop group after shutting down all push managers that use the group\n \t *\n \t * @return a reference to this factory for ease of chaining configuration calls\n@@ -97,6 +98,25 @@ public class PushManagerFactory<T extends ApnsPushNotification> {\n \t}\n \n \t/**\n+\t * <p>Sets a custom executor service to be used by constructed {@code PushManagers} to dispatch notifications to\n+\t * registered listeners. If {@code null}, constructed {@code PushManager} instances will create and maintain their\n+\t * own executor services. If a non-{@code null} executor service is provided, callers <strong>must</strong> shut\n+\t * down the executor service after shutting down all {@code PushManager} instances that use that executor service.</p>\n+\t * \n+\t * <p>By default, constructed {@code PushManagers} will construct and maintain their own executor services.</p>\n+\t * \n+\t * @param listenerExecutorService the executor service to be used by constructed {@code PushManager} instances to\n+\t * dispatch notifications to registered listeners; if not {@code null}, the caller <strong>must</strong> shut down\n+\t * the executor service after shutting down all push managers that use the executor service\n+\t * \n+\t * @return a reference to this factory for ease of chaining configuration calls\n+\t */\n+\tpublic PushManagerFactory<T> setListenerExecutorService(final ExecutorService listenerExecutorService) {\n+\t\tthis.listenerExecutorService = listenerExecutorService;\n+\t\treturn this;\n+\t}\n+\n+\t/**\n \t * <p>Sets the queue to be used to pass new notifications to constructed {@code PushManagers}. If {@code null} (the\n \t * default), constructed push managers will construct their own queues.</p>\n \t *\n@@ -120,6 +140,7 @@ public class PushManagerFactory<T extends ApnsPushNotification> {\n \t\t\t\tthis.sslContext,\n \t\t\t\tthis.concurrentConnectionCount,\n \t\t\t\tthis.eventLoopGroup,\n+\t\t\t\tthis.listenerExecutorService,\n \t\t\t\tthis.queue);\n \t}\n \ndiff --git a/src/main/java/com/relayrides/pushy/apns/RejectedNotificationListener.java b/src/main/java/com/relayrides/pushy/apns/RejectedNotificationListener.java\nindex 187a875..db0398a 100644\n--- a/src/main/java/com/relayrides/pushy/apns/RejectedNotificationListener.java\n+++ b/src/main/java/com/relayrides/pushy/apns/RejectedNotificationListener.java\n@@ -32,14 +32,16 @@ package com.relayrides.pushy.apns;\n  * Binary Interface and Notification Formats</a>\n  * \n  * @see com.relayrides.pushy.apns.PushManager#registerRejectedNotificationListener(RejectedNotificationListener)\n+ * @see com.relayrides.pushy.apns.PushManager#unregisterRejectedNotificationListener(RejectedNotificationListener)\n  */\n public interface RejectedNotificationListener<T extends ApnsPushNotification> {\n \n \t/**\n \t * Handles a permanent push notification rejection.\n \t * \n+\t * @param pushManager the push manager that sent the rejected notification\n \t * @param notification the notification rejected by the APNs server\n \t * @param rejectionReason the reason reported by APNs for the rejection\n \t */\n-\tvoid handleRejectedNotification(T notification, RejectedNotificationReason rejectionReason);\n+\tvoid handleRejectedNotification(PushManager<? extends T> pushManager, T notification, RejectedNotificationReason rejectionReason);\n }\n", "test_patch": "diff --git a/src/test/java/com/relayrides/pushy/apns/PushManagerTest.java b/src/test/java/com/relayrides/pushy/apns/PushManagerTest.java\nindex bbeb602..390e585 100644\n--- a/src/test/java/com/relayrides/pushy/apns/PushManagerTest.java\n+++ b/src/test/java/com/relayrides/pushy/apns/PushManagerTest.java\n@@ -34,10 +34,13 @@ import java.security.UnrecoverableKeyException;\n import java.security.cert.CertificateException;\n import java.util.concurrent.BlockingQueue;\n import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.LinkedBlockingQueue;\n import java.util.concurrent.atomic.AtomicInteger;\n \n import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLHandshakeException;\n \n import org.junit.Test;\n \n@@ -45,11 +48,11 @@ import com.relayrides.pushy.apns.util.SimpleApnsPushNotification;\n \n public class PushManagerTest extends BasePushyTest {\n \n-\tprivate class TestListener implements RejectedNotificationListener<SimpleApnsPushNotification> {\n+\tprivate class TestRejectedNotificationListener implements RejectedNotificationListener<SimpleApnsPushNotification> {\n \n \t\tprivate final AtomicInteger rejectedNotificationCount = new AtomicInteger(0);\n \n-\t\tpublic void handleRejectedNotification(final SimpleApnsPushNotification notification, final RejectedNotificationReason reason) {\n+\t\tpublic void handleRejectedNotification(final PushManager<? extends SimpleApnsPushNotification> pushManager, final SimpleApnsPushNotification notification, final RejectedNotificationReason reason) {\n \t\t\tthis.rejectedNotificationCount.incrementAndGet();\n \t\t}\n \n@@ -58,11 +61,32 @@ public class PushManagerTest extends BasePushyTest {\n \t\t}\n \t}\n \n+\tprivate class TestFailedConnectionListener implements FailedConnectionListener<SimpleApnsPushNotification> {\n+\n+\t\tprivate final Object mutex;\n+\n+\t\tprivate PushManager<? extends SimpleApnsPushNotification> pushManager;\n+\t\tprivate Throwable cause;\n+\n+\t\tpublic TestFailedConnectionListener(final Object mutex) {\n+\t\t\tthis.mutex = mutex;\n+\t\t}\n+\n+\t\tpublic void handleFailedConnection(final PushManager<? extends SimpleApnsPushNotification> pushManager, final Throwable cause) {\n+\t\t\tthis.pushManager = pushManager;\n+\t\t\tthis.cause = cause;\n+\n+\t\t\tsynchronized (this.mutex) {\n+\t\t\t\tthis.mutex.notifyAll();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \t@Test\n \tpublic void testRegisterRejectedNotificationListener() throws InterruptedException {\n \t\tfinal SimpleApnsPushNotification notification = this.createTestNotification();\n \n-\t\tfinal TestListener listener = new TestListener();\n+\t\tfinal TestRejectedNotificationListener listener = new TestRejectedNotificationListener();\n \t\tthis.getPushManager().registerRejectedNotificationListener(listener);\n \n \t\tassertEquals(0, listener.getRejectedNotificationCount());\n@@ -85,7 +109,7 @@ public class PushManagerTest extends BasePushyTest {\n \n \t@Test\n \tpublic void testUnregisterRejectedNotificationListener() {\n-\t\tfinal TestListener listener = new TestListener();\n+\t\tfinal TestRejectedNotificationListener listener = new TestRejectedNotificationListener();\n \n \t\tthis.getPushManager().registerRejectedNotificationListener(listener);\n \n@@ -94,10 +118,45 @@ public class PushManagerTest extends BasePushyTest {\n \t}\n \n \t@Test\n+\tpublic void testRegisterFailedNotificationListener() throws Exception {\n+\n+\t\tfinal PushManagerFactory<SimpleApnsPushNotification> factory =\n+\t\t\t\tnew PushManagerFactory<SimpleApnsPushNotification>(\n+\t\t\t\t\t\tTEST_ENVIRONMENT, SSLTestUtil.createSSLContextForTestClient(\"/pushy-test-client-untrusted.jks\"));\n+\n+\t\tfinal PushManager<SimpleApnsPushNotification> badCredentialManager = factory.buildPushManager();\n+\n+\t\tfinal Object mutex = new Object();\n+\t\tfinal TestFailedConnectionListener listener = new TestFailedConnectionListener(mutex);\n+\n+\t\tbadCredentialManager.registerFailedConnectionListener(listener);\n+\n+\t\tsynchronized (mutex) {\n+\t\t\tbadCredentialManager.start();\n+\t\t\tmutex.wait();\n+\t\t}\n+\n+\t\tbadCredentialManager.shutdown();\n+\n+\t\tassertEquals(badCredentialManager, listener.pushManager);\n+\t\tassertTrue(listener.cause instanceof SSLHandshakeException);\n+\t}\n+\n+\t@Test\n+\tpublic void testUnregisterFailedNotificationListener() {\n+\t\tfinal TestFailedConnectionListener listener = new TestFailedConnectionListener(null);\n+\n+\t\tthis.getPushManager().registerFailedConnectionListener(listener);\n+\n+\t\tassertTrue(this.getPushManager().unregisterFailedConnectionListener(listener));\n+\t\tassertFalse(this.getPushManager().unregisterFailedConnectionListener(listener));\n+\t}\n+\n+\t@Test\n \tpublic void testShutdown() throws InterruptedException, KeyManagementException, NoSuchAlgorithmException, UnrecoverableKeyException, KeyStoreException, CertificateException, IOException {\n \t\t{\n \t\t\tfinal PushManager<ApnsPushNotification> defaultGroupPushManager =\n-\t\t\t\t\tnew PushManager<ApnsPushNotification>(TEST_ENVIRONMENT, SSLTestUtil.createSSLContextForTestClient(), 1, null, null);\n+\t\t\t\t\tnew PushManager<ApnsPushNotification>(TEST_ENVIRONMENT, SSLTestUtil.createSSLContextForTestClient(), 1, null, null, null);\n \n \t\t\tdefaultGroupPushManager.start();\n \t\t\tdefaultGroupPushManager.shutdown();\n@@ -109,7 +168,7 @@ public class PushManagerTest extends BasePushyTest {\n \t\t\tfinal NioEventLoopGroup group = new NioEventLoopGroup(1);\n \n \t\t\tfinal PushManager<ApnsPushNotification> providedGroupPushManager =\n-\t\t\t\t\tnew PushManager<ApnsPushNotification>(TEST_ENVIRONMENT, SSLTestUtil.createSSLContextForTestClient(), 1, group, null);\n+\t\t\t\t\tnew PushManager<ApnsPushNotification>(TEST_ENVIRONMENT, SSLTestUtil.createSSLContextForTestClient(), 1, group, null, null);\n \n \t\t\tprovidedGroupPushManager.start();\n \t\t\tprovidedGroupPushManager.shutdown();\n@@ -119,12 +178,27 @@ public class PushManagerTest extends BasePushyTest {\n \n \t\t\tgroup.shutdownGracefully();\n \t\t}\n+\n+\t\t{\n+\t\t\tfinal ExecutorService listenerExecutorService = Executors.newSingleThreadExecutor();\n+\n+\t\t\tfinal PushManager<ApnsPushNotification> providedExecutorServicePushManager =\n+\t\t\t\t\tnew PushManager<ApnsPushNotification>(TEST_ENVIRONMENT, SSLTestUtil.createSSLContextForTestClient(), 1, null, listenerExecutorService, null);\n+\n+\t\t\tprovidedExecutorServicePushManager.start();\n+\t\t\tprovidedExecutorServicePushManager.shutdown();\n+\n+\t\t\tassertTrue(providedExecutorServicePushManager.isShutDown());\n+\t\t\tassertFalse(listenerExecutorService.isShutdown());\n+\n+\t\t\tlistenerExecutorService.shutdown();\n+\t\t}\n \t}\n \n \t@Test(expected = IllegalStateException.class)\n \tpublic void testDoubleStart() throws KeyManagementException, NoSuchAlgorithmException, UnrecoverableKeyException, KeyStoreException, CertificateException, IOException {\n \t\tfinal PushManager<ApnsPushNotification> doubleStartPushManager =\n-\t\t\t\tnew PushManager<ApnsPushNotification>(TEST_ENVIRONMENT, SSLTestUtil.createSSLContextForTestClient(), 1, null, null);\n+\t\t\t\tnew PushManager<ApnsPushNotification>(TEST_ENVIRONMENT, SSLTestUtil.createSSLContextForTestClient(), 1, null, null, null);\n \n \t\tdoubleStartPushManager.start();\n \t\tdoubleStartPushManager.start();\n@@ -133,7 +207,7 @@ public class PushManagerTest extends BasePushyTest {\n \t@Test(expected = IllegalStateException.class)\n \tpublic void testPrematureShutdown() throws InterruptedException, KeyManagementException, NoSuchAlgorithmException, UnrecoverableKeyException, KeyStoreException, CertificateException, IOException {\n \t\tfinal PushManager<ApnsPushNotification> prematureShutdownPushManager =\n-\t\t\t\tnew PushManager<ApnsPushNotification>(TEST_ENVIRONMENT, SSLTestUtil.createSSLContextForTestClient(), 1, null, null);\n+\t\t\t\tnew PushManager<ApnsPushNotification>(TEST_ENVIRONMENT, SSLTestUtil.createSSLContextForTestClient(), 1, null, null, null);\n \n \t\tprematureShutdownPushManager.shutdown();\n \t}\n@@ -141,7 +215,7 @@ public class PushManagerTest extends BasePushyTest {\n \t@Test\n \tpublic void testRepeatedShutdown() throws InterruptedException, KeyManagementException, NoSuchAlgorithmException, UnrecoverableKeyException, KeyStoreException, CertificateException, IOException {\n \t\tfinal PushManager<ApnsPushNotification> repeatedShutdownPushManager =\n-\t\t\t\tnew PushManager<ApnsPushNotification>(TEST_ENVIRONMENT, SSLTestUtil.createSSLContextForTestClient(), 1, null, null);\n+\t\t\t\tnew PushManager<ApnsPushNotification>(TEST_ENVIRONMENT, SSLTestUtil.createSSLContextForTestClient(), 1, null, null, null);\n \n \t\trepeatedShutdownPushManager.start();\n \t\trepeatedShutdownPushManager.shutdown();\n@@ -307,7 +381,7 @@ public class PushManagerTest extends BasePushyTest {\n \t\t\t\t\tBlockingQueue<SimpleApnsPushNotification> queue,\n \t\t\t\t\tCountDownLatch latch) {\n \n-\t\t\t\tsuper(environment, sslContext, concurrentConnectionCount, eventLoopGroup, queue);\n+\t\t\t\tsuper(environment, sslContext, concurrentConnectionCount, eventLoopGroup, null, queue);\n \n \t\t\t\tthis.latch = latch;\n \t\t\t}\ndiff --git a/src/test/java/com/relayrides/pushy/apns/SSLTestUtil.java b/src/test/java/com/relayrides/pushy/apns/SSLTestUtil.java\nindex 985afae..3104d7d 100644\n--- a/src/test/java/com/relayrides/pushy/apns/SSLTestUtil.java\n+++ b/src/test/java/com/relayrides/pushy/apns/SSLTestUtil.java\n@@ -66,7 +66,7 @@ class SSLTestUtil {\n \t\tfinal InputStream keyStoreInputStream = SSLTestUtil.class.getResourceAsStream(keystoreFileName);\n \n \t\tif (keyStoreInputStream == null) {\n-\t\t\tthrow new RuntimeException(\"Server keystore file not found.\");\n+\t\t\tthrow new RuntimeException(\"Client keystore file not found.\");\n \t\t}\n \n \t\tfinal KeyStore keyStore = KeyStore.getInstance(\"JKS\");\n"}
{"repository": "jchambers/pushy", "clone_url": "https://github.com/jchambers/pushy.git", "timestamp": "2023-05-31T21:44:28.282933Z", "commit_hash": "0320b651c315cba6acb268427f4c164bf4e85a48", "commit_message": "Merge pull request #38 from relayrides/separate_retry_queue\n\nSeparate retry queue (fixes #20)", "related_issues": "", "bug_patch": "diff --git a/README.md b/README.md\nindex 1a1cf08..6c4bc27 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,3 +1,5 @@\n+*Note: this README refers to the current development version of Pushy and may include information and examples that refer to changes that have not yet been released. For notes on the latest release, please visit the [project page](http://relayrides.github.io/pushy/).*\n+\n # pushy\n \n Pushy is a Java library for sending [APNs](http://developer.apple.com/library/mac/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Introduction.html) (iOS and OS X) push notifications. It is written and maintained by the engineers at [RelayRides](https://relayrides.com/) and is built on the [Netty framework](http://netty.io/).\n@@ -43,10 +45,13 @@ try {\n     final KeyStore keyStore = KeyStore.getInstance(\"PKCS12\");\n     keyStore.load(keystoreInputStream, keystorePassword.toCharArray());\n \n-    final PushManager<SimpleApnsPushNotification> pushManager =\n-        new PushManager<SimpleApnsPushNotification>(\n+    final PushManagerFactory<SimpleApnsPushNotification> pushManagerFactory =\n+        new PushManagerFactory<SimpleApnsPushNotification>(\n             ApnsEnvironment.getSandboxEnvironment(), keyStore, keystorePassword);\n-    \n+\n+    final PushManager<SimpleApnsPushNotification> pushManager =\n+        pushManagerFactory.buildPushManager();\n+\n     pushManager.start();\n } finally {\n     keystoreInputStream.close();\n@@ -66,7 +71,7 @@ payloadBuilder.setSoundFileName(\"ring-ring.aiff\");\n \n final String payload = payloadBuilder.buildWithDefaultMaximumLength();\n \n-pushManager.enqueuePushNotification(\n+pushManager.getQueue().put(\n \t\tnew SimpleApnsPushNotification(token, payload));\n ```\n \ndiff --git a/src/main/java/com/relayrides/pushy/apns/ApnsClientThread.java b/src/main/java/com/relayrides/pushy/apns/ApnsClientThread.java\nindex 0c33976..796e1db 100644\n--- a/src/main/java/com/relayrides/pushy/apns/ApnsClientThread.java\n+++ b/src/main/java/com/relayrides/pushy/apns/ApnsClientThread.java\n@@ -43,7 +43,6 @@ import io.netty.util.concurrent.GenericFutureListener;\n import java.nio.charset.Charset;\n import java.util.Date;\n import java.util.List;\n-import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n \n import org.slf4j.Logger;\n@@ -96,7 +95,6 @@ class ApnsClientThread<T extends ApnsPushNotification> extends Thread {\n \tprivate static final long CONNECT_EXCEPTION_WAIT = 200;\n \n \tprivate static final long POLL_TIMEOUT = 50;\n-\tprivate static final TimeUnit POLL_TIME_UNIT = TimeUnit.MILLISECONDS;\n \tprivate static final int BATCH_SIZE = 32;\n \tprivate int writesSinceLastFlush = 0;\n \n@@ -274,7 +272,7 @@ class ApnsClientThread<T extends ApnsPushNotification> extends Thread {\n \n \t\t\t\tcase READY: {\n \t\t\t\t\ttry {\n-\t\t\t\t\t\tthis.sendNextNotification(POLL_TIMEOUT, POLL_TIME_UNIT);\n+\t\t\t\t\t\tthis.sendNextNotification(POLL_TIMEOUT);\n \t\t\t\t\t} catch (InterruptedException e) {\n \t\t\t\t\t\tthis.channel.flush();\n \t\t\t\t\t}\n@@ -527,12 +525,14 @@ class ApnsClientThread<T extends ApnsPushNotification> extends Thread {\n \t\t}\n \t}\n \n-\tprivate void sendNextNotification(final long timeout, final TimeUnit timeUnit) throws InterruptedException {\n-\t\tfinal T notification = this.pushManager.getQueue().poll(timeout, timeUnit);\n+\tprivate void sendNextNotification(final long timeout) throws InterruptedException {\n+\t\tT notification = this.pushManager.getRetryQueue().poll();\n \n-\t\tif (this.isInterrupted()) {\n-\t\t\tthis.pushManager.enqueuePushNotification(notification);\n-\t\t} else if (notification != null) {\n+\t\tif (notification == null) {\n+\t\t\tnotification = this.pushManager.getQueue().poll();\n+\t\t}\n+\n+\t\tif (notification != null) {\n \t\t\tfinal SendableApnsPushNotification<T> sendableNotification =\n \t\t\t\t\tnew SendableApnsPushNotification<T>(notification, this.sequenceNumber++);\n \n@@ -562,7 +562,7 @@ class ApnsClientThread<T extends ApnsPushNotification> extends Thread {\n \t\t\t\t\t\t\t\tsendableNotification.getSequenceNumber());\n \n \t\t\t\t\t\tif (failedNotification != null) {\n-\t\t\t\t\t\t\tpushManager.enqueuePushNotification(failedNotification);\n+\t\t\t\t\t\t\tpushManager.enqueuePushNotificationForRetry(failedNotification);\n \t\t\t\t\t\t}\n \t\t\t\t\t} else {\n \t\t\t\t\t\tif (log.isTraceEnabled()) {\n@@ -584,6 +584,8 @@ class ApnsClientThread<T extends ApnsPushNotification> extends Thread {\n \t\t\t\tthis.channel.flush();\n \t\t\t\tthis.writesSinceLastFlush = 0;\n \t\t\t}\n+\n+\t\t\tThread.sleep(timeout);\n \t\t}\n \t}\n \n@@ -616,7 +618,7 @@ class ApnsClientThread<T extends ApnsPushNotification> extends Thread {\n \n \t\t// In any case, we know that all notifications sent before the rejected notification were processed and NOT\n \t\t// rejected, while all notifications after the rejected one have not been processed and need to be re-sent.\n-\t\tthis.pushManager.enqueueAllNotifications(\n+\t\tthis.pushManager.enqueueAllNotificationsForRetry(\n \t\t\t\tthis.sentNotificationBuffer.getAndRemoveAllNotificationsAfterSequenceNumber(rejectedNotification.getSequenceNumber()));\n \t}\n \ndiff --git a/src/main/java/com/relayrides/pushy/apns/PushManager.java b/src/main/java/com/relayrides/pushy/apns/PushManager.java\nindex a92be1d..3d0147e 100644\n--- a/src/main/java/com/relayrides/pushy/apns/PushManager.java\n+++ b/src/main/java/com/relayrides/pushy/apns/PushManager.java\n@@ -40,17 +40,21 @@ import org.slf4j.LoggerFactory;\n \n /**\n  * <p>A {@code PushManager} is the main public-facing point of interaction with APNs. {@code PushManager}s manage the\n- * queue of outbound push notifications and manage connections to the various APNs servers.</p>\n+ * queue of outbound push notifications and manage connections to the various APNs servers. {@code PushManager}s should\n+ * always be created using the {@link PushManagerFactory} class.</p>\n  *\n  * @author <a href=\"mailto:jon@relayrides.com\">Jon Chambers</a>\n+ * \n+ * @see PushManagerFactory\n  */\n public class PushManager<T extends ApnsPushNotification> {\n \tprivate final BlockingQueue<T> queue;\n+\tprivate final LinkedBlockingQueue<T> retryQueue;\n \n \tprivate final ApnsEnvironment environment;\n \tprivate final KeyStore keyStore;\n \tprivate final char[] keyStorePassword;\n-\tprivate final int concurrentConnections;\n+\tprivate final int concurrentConnectionCount;\n \n \tprivate final ArrayList<ApnsClientThread<T>> clientThreads;\n \n@@ -68,37 +72,6 @@ public class PushManager<T extends ApnsPushNotification> {\n \tprivate final Logger log = LoggerFactory.getLogger(PushManager.class);\n \n \t/**\n-\t * Constructs a new {@code PushManager} that operates in the given environment with the given credentials, a single\n-\t * connection to APNs, and a default event loop group.\n-\t * \n-\t * @param environment the environment in which this {@code PushManager} operates\n-\t * @param keyStore A {@code KeyStore} containing the client key to present during a TLS handshake; may be\n-\t * {@code null} if the environment does not require TLS. The {@code KeyStore} should be loaded before being used\n-\t * here.\n-\t * @param keyStorePassword a password to unlock the given {@code KeyStore}; may be {@code null}\n-\t */\n-\tpublic PushManager(final ApnsEnvironment environment, final KeyStore keyStore, final char[] keyStorePassword) {\n-\t\tthis(environment, keyStore, keyStorePassword, 1);\n-\t}\n-\n-\t/**\n-\t * <p>Constructs a new {@code PushManager} that operates in the given environment with the given credentials, the\n-\t * given number of parallel connections to APNs, and a default event loop group. See\n-\t * <a href=\"http://developer.apple.com/library/mac/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/CommunicatingWIthAPS.html#//apple_ref/doc/uid/TP40008194-CH101-SW6\">\n-\t * Best Practices for Managing Connections</a> for additional information.</p>\n-\t * \n-\t * @param environment the environment in which this {@code PushManager} operates\n-\t * @param keyStore A {@code KeyStore} containing the client key to present during a TLS handshake; may be\n-\t * {@code null} if the environment does not require TLS. The {@code KeyStore} should be loaded before being used\n-\t * here.\n-\t * @param keyStorePassword a password to unlock the given {@code KeyStore}; may be {@code null}\n-\t * @param concurrentConnections the number of parallel connections to open to APNs\n-\t */\n-\tpublic PushManager(final ApnsEnvironment environment, final KeyStore keyStore, final char[] keyStorePassword, final int concurrentConnections) {\n-\t\tthis(environment, keyStore, keyStorePassword, concurrentConnections, null);\n-\t}\n-\n-\t/**\n \t * <p>Constructs a new {@code PushManager} that operates in the given environment with the given credentials and the\n \t * given number of parallel connections to APNs. See\n \t * <a href=\"http://developer.apple.com/library/mac/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/CommunicatingWIthAPS.html#//apple_ref/doc/uid/TP40008194-CH101-SW6\">\n@@ -113,19 +86,23 @@ public class PushManager<T extends ApnsPushNotification> {\n \t * {@code null} if the environment does not require TLS. The {@code KeyStore} should be loaded before being used\n \t * here.\n \t * @param keyStorePassword a password to unlock the given {@code KeyStore}; may be {@code null}\n-\t * @param concurrentConnections the number of parallel connections to open to APNs\n+\t * @param concurrentConnectionCount the number of parallel connections to maintain\n \t * @param workerGroup the event loop group this push manager should use for its connections to the APNs gateway and\n \t * feedback service; if {@code null}, a new event loop group will be created and will be shut down automatically\n \t * when the push manager is shut down. If not {@code null}, the caller <strong>must</strong> shut down the event\n \t * loop group after shutting down the push manager\n+\t * @param queue TODO\n \t */\n-\tpublic PushManager(final ApnsEnvironment environment, final KeyStore keyStore, final char[] keyStorePassword, final int concurrentConnections, final NioEventLoopGroup workerGroup) {\n+\tprotected PushManager(final ApnsEnvironment environment, final KeyStore keyStore, final char[] keyStorePassword,\n+\t\t\tfinal int concurrentConnectionCount, final NioEventLoopGroup workerGroup, final BlockingQueue<T> queue) {\n \n \t\tif (environment.isTlsRequired() && keyStore == null) {\n \t\t\tthrow new IllegalArgumentException(\"Must include a non-null KeyStore for environments that require TLS.\");\n \t\t}\n \n-\t\tthis.queue = new LinkedBlockingQueue<T>();\n+\t\tthis.queue = queue != null ? queue : new LinkedBlockingQueue<T>();\n+\t\tthis.retryQueue = new LinkedBlockingQueue<T>();\n+\n \t\tthis.rejectedNotificationListeners = new Vector<RejectedNotificationListener<T>>();\n \n \t\tthis.environment = environment;\n@@ -133,8 +110,8 @@ public class PushManager<T extends ApnsPushNotification> {\n \t\tthis.keyStore = keyStore;\n \t\tthis.keyStorePassword = keyStorePassword;\n \n-\t\tthis.concurrentConnections = concurrentConnections;\n-\t\tthis.clientThreads = new ArrayList<ApnsClientThread<T>>(this.concurrentConnections);\n+\t\tthis.concurrentConnectionCount = concurrentConnectionCount;\n+\t\tthis.clientThreads = new ArrayList<ApnsClientThread<T>>(this.concurrentConnectionCount);\n \n \t\tthis.rejectedNotificationExecutorService = Executors.newSingleThreadExecutor();\n \n@@ -192,7 +169,7 @@ public class PushManager<T extends ApnsPushNotification> {\n \t\t\tthrow new IllegalStateException(\"Push manager has already been shut down and may not be restarted.\");\n \t\t}\n \n-\t\tfor (int i = 0; i < this.concurrentConnections; i++) {\n+\t\tfor (int i = 0; i < this.concurrentConnectionCount; i++) {\n \t\t\tfinal ApnsClientThread<T> clientThread = new ApnsClientThread<T>(this);\n \n \t\t\tthis.clientThreads.add(clientThread);\n@@ -203,29 +180,31 @@ public class PushManager<T extends ApnsPushNotification> {\n \t}\n \n \t/**\n-\t * <p>Enqueues a push notification for transmission to the APNs service. Notifications may not be sent to APNs\n+\t * <p>Enqueues a push notification for re-transmission to the APNs service. Notifications may not be sent to APNs\n \t * immediately, and delivery is not guaranteed by APNs, but notifications rejected by APNs for specific reasons\n-\t * will be passed to registered {@link RejectedNotificationListener}s.</p>\n+\t * will be passed to registered {@link RejectedNotificationListener}s. Notifications that are to be re-transmitted\n+\t * are given priority over &quot;new&quot; notifications, but are otherwise treated identically.</p>\n \t * \n-\t * @param notification the notification to enqueue\n+\t * @param notification the notification to enqueue for re-transmission\n \t * \n \t * @see PushManager#registerRejectedNotificationListener(RejectedNotificationListener)\n \t */\n-\tpublic void enqueuePushNotification(final T notification) {\n-\t\tthis.queue.add(notification);\n+\tprotected void enqueuePushNotificationForRetry(final T notification) {\n+\t\tthis.retryQueue.add(notification);\n \t}\n \n \t/**\n-\t * <p>Enqueues a collection of push notifications for transmission to the APNs service. Notifications may not be\n+\t * <p>Enqueues a collection of push notifications for re-transmission to the APNs service. Notifications may not be\n \t * sent to APNs immediately, and delivery is not guaranteed by APNs, but notifications rejected by APNs for\n-\t * specific reasons will be passed to registered {@link RejectedNotificationListener}s.</p>\n+\t * specific reasons will be passed to registered {@link RejectedNotificationListener}s. Notifications that are to\n+\t * be re-transmitted are given priority over &quot;new&quot; notifications, but are otherwise treated identically.</p>\n \t * \n-\t * @param notifications the notifications to enqueue\n+\t * @param notifications the notifications to enqueue for re-transmission\n \t * \n \t * @see PushManager#registerRejectedNotificationListener(RejectedNotificationListener)\n \t */\n-\tpublic void enqueueAllNotifications(final Collection<T> notifications) {\n-\t\tthis.queue.addAll(notifications);\n+\tprotected void enqueueAllNotificationsForRetry(final Collection<T> notifications) {\n+\t\tthis.retryQueue.addAll(notifications);\n \t}\n \n \t/**\n@@ -336,7 +315,12 @@ public class PushManager<T extends ApnsPushNotification> {\n \n \t\tthis.shutDownFinished = true;\n \n-\t\treturn new ArrayList<T>(this.queue);\n+\t\tfinal ArrayList<T> unsentNotifications = new ArrayList<T>();\n+\n+\t\tunsentNotifications.addAll(this.retryQueue);\n+\t\tunsentNotifications.addAll(this.getQueue());\n+\n+\t\treturn unsentNotifications;\n \t}\n \n \t/**\n@@ -382,10 +366,29 @@ public class PushManager<T extends ApnsPushNotification> {\n \t\t}\n \t}\n \n-\tprotected BlockingQueue<T> getQueue() {\n+\t/**\n+\t * <p>Returns the queue of messages to be sent to the APNs gateway. Callers should add notifications to this queue\n+\t * directly to send notifications. Notifications will be removed from this queue by Pushy when a send attempt is\n+\t * started, but no guarantees are made as to when the notification will actually be sent. Successful delivery is\n+\t * neither guaranteed nor acknowledged by the APNs gateway. Notifications rejected by APNs for specific reasons\n+\t * will be passed to registered {@link RejectedNotificationListener}s, and notifications that could not be sent due\n+\t * to temporary I/O problems will be scheduled for re-transmission in a separate, internal queue.</p>\n+\t * \n+\t * <p>Notifications in this queue will only be consumed when the {@code PushManager} is running and has active\n+\t * connections and when the internal &quot;retry queue&quot; is empty.</p>\n+\t * \n+\t * @return the queue of new notifications to send to the APNs gateway\n+\t * \n+\t * @see PushManager#registerRejectedNotificationListener(RejectedNotificationListener)\n+\t */\n+\tpublic BlockingQueue<T> getQueue() {\n \t\treturn this.queue;\n \t}\n \n+\tprotected LinkedBlockingQueue<T> getRetryQueue() {\n+\t\treturn this.retryQueue;\n+\t}\n+\n \tprotected NioEventLoopGroup getWorkerGroup() {\n \t\treturn this.workerGroup;\n \t}\ndiff --git a/src/main/java/com/relayrides/pushy/apns/PushManagerFactory.java b/src/main/java/com/relayrides/pushy/apns/PushManagerFactory.java\nnew file mode 100644\nindex 0000000..bf68ab8\n--- /dev/null\n+++ b/src/main/java/com/relayrides/pushy/apns/PushManagerFactory.java\n@@ -0,0 +1,102 @@\n+package com.relayrides.pushy.apns;\n+\n+import io.netty.channel.nio.NioEventLoopGroup;\n+\n+import java.security.KeyStore;\n+import java.util.concurrent.BlockingQueue;\n+\n+/**\n+ * A {@code PushManagerFactory} is used to configure and construct a new {@link PushManager}.\n+ * \n+ * @author <a href=\"mailto:jon@relayrides.com\">Jon Chambers</a>\n+ */\n+public class PushManagerFactory<T extends ApnsPushNotification> {\n+\n+\tprivate final ApnsEnvironment environment;\n+\n+\tprivate final KeyStore keyStore;\n+\tprivate final char[] keyStorePassword;\n+\n+\tprivate int concurrentConnectionCount = 1;\n+\n+\tprivate NioEventLoopGroup eventLoopGroup;\n+\n+\tprivate BlockingQueue<T> queue;\n+\n+\t/**\n+\t * Constructs a new factory that will construct {@link PushManager}s that operate in the given environment with the\n+\t * given credentials.\n+\t * \n+\t * @param environment the environment in which constructed {@code PushManager}s will operate\n+\t * @param keyStore A {@code KeyStore} containing the client key to present during a TLS handshake; may be\n+\t * {@code null} if the environment does not require TLS. The {@code KeyStore} should be loaded before being used\n+\t * here.\n+\t * @param keyStorePassword a password to unlock the given {@code KeyStore}; may be {@code null}\n+\t */\n+\tpublic PushManagerFactory(final ApnsEnvironment environment, final KeyStore keyStore, final char[] keyStorePassword) {\n+\t\tthis.environment = environment;\n+\n+\t\tthis.keyStore = keyStore;\n+\t\tthis.keyStorePassword = keyStorePassword;\n+\t}\n+\n+\t/**\n+\t * <p>Sets the number of concurrent connections constructed {@code PushManagers} should maintain to the APNs\n+\t * gateway. By default, constructed {@code PushManagers} will maintain a single connection to the gateway.</p>\n+\t * \n+\t * @param concurrentConnectionCount the number of parallel connections to maintain\n+\t * \n+\t * @return a reference to this factory for ease of chaining configuration calls\n+\t */\n+\tpublic PushManagerFactory<T> setConcurrentConnectionCount(final int concurrentConnectionCount) {\n+\t\tthis.concurrentConnectionCount = concurrentConnectionCount;\n+\t\treturn this;\n+\t}\n+\n+\t/**\n+\t * <p>Sets a custom event loop group to be used by constructed {@code PushMangers}. If {@code null}, constructed\n+\t * {@code PushManagers} will be create and maintain their own event loop groups. If a non-{@code null} event loop\n+\t * group is provided, callers <strong>must</strong> shut down the event loop group after shutting down all\n+\t * {@code PushManager} instances that use that event loop group.</p>\n+\t * \n+\t * <p>By default, constructed {@code PushManagers} will construct and maintain their own event loop groups.</p>\n+\t * \n+\t * @param eventLoopGroup the event loop group constructed {@code PushManagers} should use for their connections to\n+\t * the APNs gateway and feedback service; if {@code null}, a new event loop group will be created and will be shut\n+\t * down automatically when the push manager is shut down. If not {@code null}, the caller <strong>must</strong> shut\n+\t * down the event loop group after shutting down all push managers that use the group\n+\t * \n+\t * @return a reference to this factory for ease of chaining configuration calls\n+\t */\n+\tpublic PushManagerFactory<T> setEventLoopGroup(final NioEventLoopGroup eventLoopGroup) {\n+\t\tthis.eventLoopGroup = eventLoopGroup;\n+\t\treturn this;\n+\t}\n+\n+\t/**\n+\t * <p>Sets the queue to be used to pass new notifications to constructed {@code PushManagers}. If {@code null} (the\n+\t * default), constructed push managers will construct their own queues.</p>\n+\t * \n+\t * @param queue the queue to be used to pass new notifications to constructed push managers\n+\t * @return\n+\t */\n+\tpublic PushManagerFactory<T> setQueue(final BlockingQueue<T> queue) {\n+\t\tthis.queue = queue;\n+\t\treturn this;\n+\t}\n+\n+\t/**\n+\t * <p>Constructs a new {@link PushManager} with the settings provided to this factory. The returned push manager\n+\t * will not be started automatically.</p>\n+\t * \n+\t * @return a new, configured {@code PushManager}\n+\t */\n+\tpublic PushManager<T> buildPushManager() {\n+\t\treturn new PushManager<T>(this.environment,\n+\t\t\t\tthis.keyStore,\n+\t\t\t\tthis.keyStorePassword,\n+\t\t\t\tthis.concurrentConnectionCount,\n+\t\t\t\tthis.eventLoopGroup,\n+\t\t\t\tthis.queue);\n+\t}\n+}\n", "test_patch": "diff --git a/src/test/java/com/relayrides/pushy/apns/ApnsClientThreadTest.java b/src/test/java/com/relayrides/pushy/apns/ApnsClientThreadTest.java\nindex 12e0b6c..398758c 100644\n--- a/src/test/java/com/relayrides/pushy/apns/ApnsClientThreadTest.java\n+++ b/src/test/java/com/relayrides/pushy/apns/ApnsClientThreadTest.java\n@@ -38,7 +38,7 @@ public class ApnsClientThreadTest extends BasePushyTest {\n \t\tfinal SimpleApnsPushNotification notification = this.createTestNotification();\n \n \t\tfinal CountDownLatch latch = this.getServer().getCountDownLatch(1);\n-\t\tthis.getPushManager().enqueuePushNotification(notification);\n+\t\tthis.getPushManager().getQueue().put(notification);\n \n \t\tthis.waitForLatch(latch);\n \n@@ -56,7 +56,7 @@ public class ApnsClientThreadTest extends BasePushyTest {\n \t\tfinal CountDownLatch latch = this.getServer().getCountDownLatch(iterations);\n \n \t\tfor (int i = 0; i < iterations; i++) {\n-\t\t\tthis.getPushManager().enqueuePushNotification(notification);\n+\t\t\tthis.getPushManager().getQueue().put(notification);\n \t\t}\n \n \t\tthis.waitForLatch(latch);\n@@ -80,7 +80,7 @@ public class ApnsClientThreadTest extends BasePushyTest {\n \t\t\tfinal CountDownLatch latch = this.getServer().getCountDownLatch(iterations);\n \n \t\t\tfor (int i = 0; i < iterations; i++) {\n-\t\t\t\tthis.getPushManager().enqueuePushNotification(notification);\n+\t\t\t\tthis.getPushManager().getQueue().put(notification);\n \t\t\t}\n \n \t\t\tthis.waitForLatch(latch);\n@@ -102,7 +102,7 @@ public class ApnsClientThreadTest extends BasePushyTest {\n \t\tfinal CountDownLatch latch = this.getServer().getCountDownLatch(iterations);\n \n \t\tfor (int i = 0; i < iterations; i++) {\n-\t\t\tthis.getPushManager().enqueuePushNotification(notification);\n+\t\t\tthis.getPushManager().getQueue().put(notification);\n \t\t}\n \n \t\tthis.waitForLatch(latch);\n@@ -127,7 +127,7 @@ public class ApnsClientThreadTest extends BasePushyTest {\n \t\t\tfinal CountDownLatch latch = this.getServer().getCountDownLatch(iterations);\n \n \t\t\tfor (int i = 0; i < iterations; i++) {\n-\t\t\t\tthis.getPushManager().enqueuePushNotification(notification);\n+\t\t\t\tthis.getPushManager().getQueue().put(notification);\n \t\t\t}\n \n \t\t\tthis.waitForLatch(latch);\n@@ -156,14 +156,14 @@ public class ApnsClientThreadTest extends BasePushyTest {\n \t\tfinal CountDownLatch latch = this.getServer().getCountDownLatch(iterations);\n \n \t\tfor (int i = 0; i < iterations; i++) {\n-\t\t\tthis.getPushManager().enqueuePushNotification(notification);\n+\t\t\tthis.getPushManager().getQueue().put(notification);\n \t\t}\n \n \t\tthis.waitForLatch(latch);\n \t\tthis.getClientThread().requestShutdown();\n \n \t\tfor (int i = 0; i < iterations; i++) {\n-\t\t\tthis.getPushManager().enqueuePushNotification(notification);\n+\t\t\tthis.getPushManager().getQueue().put(notification);\n \t\t}\n \n \t\tassertEquals(\ndiff --git a/src/test/java/com/relayrides/pushy/apns/BasePushyTest.java b/src/test/java/com/relayrides/pushy/apns/BasePushyTest.java\nindex 53f1a7a..a2f76a8 100644\n--- a/src/test/java/com/relayrides/pushy/apns/BasePushyTest.java\n+++ b/src/test/java/com/relayrides/pushy/apns/BasePushyTest.java\n@@ -56,7 +56,10 @@ public abstract class BasePushyTest {\n \t\tthis.server = new MockApnsServer(APNS_PORT);\n \t\tthis.server.start();\n \n-\t\tthis.pushManager = new PushManager<SimpleApnsPushNotification>(TEST_ENVIRONMENT, null, null);\n+\t\tfinal PushManagerFactory<SimpleApnsPushNotification> pushManagerFactory =\n+\t\t\t\tnew PushManagerFactory<SimpleApnsPushNotification>(TEST_ENVIRONMENT, null, null);\n+\n+\t\tthis.pushManager = pushManagerFactory.buildPushManager();\n \t\tthis.pushManager.start();\n \n \t\tthis.clientThread = new ApnsClientThread<SimpleApnsPushNotification>(this.pushManager);\ndiff --git a/src/test/java/com/relayrides/pushy/apns/FeedbackServiceClientTest.java b/src/test/java/com/relayrides/pushy/apns/FeedbackServiceClientTest.java\nindex c01c349..e28e566 100644\n--- a/src/test/java/com/relayrides/pushy/apns/FeedbackServiceClientTest.java\n+++ b/src/test/java/com/relayrides/pushy/apns/FeedbackServiceClientTest.java\n@@ -48,9 +48,11 @@ public class FeedbackServiceClientTest {\n \t\tthis.feedbackServer = new MockFeedbackServer(FEEDBACK_PORT);\n \t\tthis.feedbackServer.start();\n \n-\t\tthis.pushManager = new PushManager<SimpleApnsPushNotification>(\n-\t\t\t\tnew ApnsEnvironment(\"127.0.0.1\", APNS_PORT, \"127.0.0.1\", FEEDBACK_PORT, false), null, null);\n+\t\tfinal PushManagerFactory<SimpleApnsPushNotification> pushManagerFactory =\n+\t\t\t\tnew PushManagerFactory<SimpleApnsPushNotification>(\n+\t\t\t\t\t\tnew ApnsEnvironment(\"127.0.0.1\", APNS_PORT, \"127.0.0.1\", FEEDBACK_PORT, false), null, null);\n \n+\t\tthis.pushManager = pushManagerFactory.buildPushManager();\n \t\tthis.pushManager.start();\n \n \t\tthis.feedbackClient = new FeedbackServiceClient(pushManager);\ndiff --git a/src/test/java/com/relayrides/pushy/apns/PushManagerTest.java b/src/test/java/com/relayrides/pushy/apns/PushManagerTest.java\nindex 6d14379..bda50e2 100644\n--- a/src/test/java/com/relayrides/pushy/apns/PushManagerTest.java\n+++ b/src/test/java/com/relayrides/pushy/apns/PushManagerTest.java\n@@ -62,7 +62,7 @@ public class PushManagerTest extends BasePushyTest {\n \t\tfinal CountDownLatch latch = this.getServer().getCountDownLatch(iterations);\n \n \t\tfor (int i = 0; i < iterations; i++) {\n-\t\t\tthis.getPushManager().enqueuePushNotification(notification);\n+\t\t\tthis.getPushManager().getQueue().put(notification);\n \t\t}\n \n \t\tthis.waitForLatch(latch);\n@@ -84,7 +84,7 @@ public class PushManagerTest extends BasePushyTest {\n \tpublic void testShutdown() throws InterruptedException {\n \t\t{\n \t\t\tfinal PushManager<ApnsPushNotification> defaultGroupPushManager =\n-\t\t\t\t\tnew PushManager<ApnsPushNotification>(TEST_ENVIRONMENT, null, null);\n+\t\t\t\t\tnew PushManager<ApnsPushNotification>(TEST_ENVIRONMENT, null, null, 1, null, null);\n \n \t\t\tdefaultGroupPushManager.start();\n \t\t\tdefaultGroupPushManager.shutdown();\n@@ -96,7 +96,7 @@ public class PushManagerTest extends BasePushyTest {\n \t\t\tfinal NioEventLoopGroup group = new NioEventLoopGroup(1);\n \n \t\t\tfinal PushManager<ApnsPushNotification> providedGroupPushManager =\n-\t\t\t\t\tnew PushManager<ApnsPushNotification>(TEST_ENVIRONMENT, null, null, 1, group);\n+\t\t\t\t\tnew PushManager<ApnsPushNotification>(TEST_ENVIRONMENT, null, null, 1, group, null);\n \n \t\t\tprovidedGroupPushManager.start();\n \t\t\tprovidedGroupPushManager.shutdown();\n@@ -111,7 +111,7 @@ public class PushManagerTest extends BasePushyTest {\n \t@Test(expected = IllegalStateException.class)\n \tpublic void testDoubleStart() {\n \t\tfinal PushManager<ApnsPushNotification> doubleStartPushManager =\n-\t\t\t\tnew PushManager<ApnsPushNotification>(TEST_ENVIRONMENT, null, null);\n+\t\t\t\tnew PushManager<ApnsPushNotification>(TEST_ENVIRONMENT, null, null, 1, null, null);\n \n \t\tdoubleStartPushManager.start();\n \t\tdoubleStartPushManager.start();\n@@ -120,7 +120,7 @@ public class PushManagerTest extends BasePushyTest {\n \t@Test(expected = IllegalStateException.class)\n \tpublic void testPrematureShutdown() throws InterruptedException {\n \t\tfinal PushManager<ApnsPushNotification> prematureShutdownPushManager =\n-\t\t\t\tnew PushManager<ApnsPushNotification>(TEST_ENVIRONMENT, null, null);\n+\t\t\t\tnew PushManager<ApnsPushNotification>(TEST_ENVIRONMENT, null, null, 1, null, null);\n \n \t\tprematureShutdownPushManager.shutdown();\n \t}\n@@ -128,7 +128,7 @@ public class PushManagerTest extends BasePushyTest {\n \t@Test\n \tpublic void testRepeatedShutdown() throws InterruptedException {\n \t\tfinal PushManager<ApnsPushNotification> repeatedShutdownPushManager =\n-\t\t\t\tnew PushManager<ApnsPushNotification>(TEST_ENVIRONMENT, null, null);\n+\t\t\t\tnew PushManager<ApnsPushNotification>(TEST_ENVIRONMENT, null, null, 1, null, null);\n \n \t\trepeatedShutdownPushManager.start();\n \t\trepeatedShutdownPushManager.shutdown();\n@@ -143,7 +143,7 @@ public class PushManagerTest extends BasePushyTest {\n \t@Test(expected = IllegalStateException.class)\n \tpublic void testGetExpiredTokensBeforeStart() throws InterruptedException {\n \t\tfinal PushManager<ApnsPushNotification> unstartedPushManager =\n-\t\t\t\tnew PushManager<ApnsPushNotification>(TEST_ENVIRONMENT, null, null);\n+\t\t\t\tnew PushManager<ApnsPushNotification>(TEST_ENVIRONMENT, null, null, 1, null, null);\n \n \t\tunstartedPushManager.getExpiredTokens();\n \t}\n@@ -151,7 +151,7 @@ public class PushManagerTest extends BasePushyTest {\n \t@Test(expected = IllegalStateException.class)\n \tpublic void testGetExpiredTokensAfterShutdown() throws InterruptedException {\n \t\tfinal PushManager<ApnsPushNotification> shutDownPushManager =\n-\t\t\t\tnew PushManager<ApnsPushNotification>(TEST_ENVIRONMENT, null, null);\n+\t\t\t\tnew PushManager<ApnsPushNotification>(TEST_ENVIRONMENT, null, null, 1, null, null);\n \n \t\tshutDownPushManager.start();\n \t\tshutDownPushManager.shutdown();\n@@ -162,7 +162,7 @@ public class PushManagerTest extends BasePushyTest {\n \t@Test\n \tpublic void testIsStarted() throws InterruptedException {\n \t\tfinal PushManager<ApnsPushNotification> testPushManager =\n-\t\t\t\tnew PushManager<ApnsPushNotification>(TEST_ENVIRONMENT, null, null);\n+\t\t\t\tnew PushManager<ApnsPushNotification>(TEST_ENVIRONMENT, null, null, 1, null, null);\n \n \t\tassertFalse(testPushManager.isStarted());\n \n@@ -176,7 +176,7 @@ public class PushManagerTest extends BasePushyTest {\n \t@Test\n \tpublic void testIsShutDown() throws InterruptedException {\n \t\tfinal PushManager<ApnsPushNotification> testPushManager =\n-\t\t\t\tnew PushManager<ApnsPushNotification>(TEST_ENVIRONMENT, null, null);\n+\t\t\t\tnew PushManager<ApnsPushNotification>(TEST_ENVIRONMENT, null, null, 1, null, null);\n \n \t\tassertFalse(testPushManager.isShutDown());\n \n"}
{"repository": "jchambers/pushy", "clone_url": "https://github.com/jchambers/pushy.git", "timestamp": "2023-05-31T22:00:01.328390Z", "commit_hash": "fb232a1dd8da41456668ffcf24528b7f6d98222f", "commit_message": "Merge pull request #19 from relayrides/feedback_client_timeout\n\nFeedback client timeout (fixes #15)", "related_issues": "", "bug_patch": "diff --git a/src/main/java/com/relayrides/pushy/apns/FeedbackServiceClient.java b/src/main/java/com/relayrides/pushy/apns/FeedbackServiceClient.java\nindex 97c327e..4d1a4e3 100644\n--- a/src/main/java/com/relayrides/pushy/apns/FeedbackServiceClient.java\n+++ b/src/main/java/com/relayrides/pushy/apns/FeedbackServiceClient.java\n@@ -33,12 +33,17 @@ import io.netty.channel.socket.SocketChannel;\n import io.netty.channel.socket.nio.NioSocketChannel;\n import io.netty.handler.codec.ReplayingDecoder;\n import io.netty.handler.ssl.SslHandler;\n+import io.netty.handler.timeout.ReadTimeoutException;\n+import io.netty.handler.timeout.ReadTimeoutHandler;\n import io.netty.util.concurrent.Future;\n \n-import java.util.ArrayList;\n import java.util.Date;\n import java.util.List;\n import java.util.Vector;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n  * <p>A client that communicates with the APNs feedback to retrieve expired device tokens. According to Apple's\n@@ -65,10 +70,11 @@ import java.util.Vector;\n  */\n class FeedbackServiceClient {\n \t\n-\tprivate final ApnsEnvironment environment;\n+\tprivate final PushManager<? extends ApnsPushNotification> pushManager;\n+\t\n+\tprivate Vector<ExpiredToken> expiredTokens;\n \t\n-\tprivate final Bootstrap bootstrap;\n-\tprivate final Vector<ExpiredToken> expiredTokens;\n+\tprivate final Logger log = LoggerFactory.getLogger(FeedbackServiceClient.class);\n \t\n \tprivate enum ExpiredTokenDecoderState {\n \t\tEXPIRATION,\n@@ -128,6 +134,16 @@ class FeedbackServiceClient {\n \t\tprotected void channelRead0(final ChannelHandlerContext context, final ExpiredToken expiredToken) {\n \t\t\tthis.feedbackClient.addExpiredToken(expiredToken);\n \t\t}\n+\t\t\n+\t\t@Override\n+\t\tpublic void exceptionCaught(final ChannelHandlerContext context, final Throwable cause) {\n+\t\t\t\n+\t\t\tif (!(cause instanceof ReadTimeoutException)) {\n+\t\t\t\tlog.warn(\"Caught an unexpected exception while waiting for feedback.\", cause);\n+\t\t\t}\n+\t\t\t\n+\t\t\tcontext.close();\n+\t\t}\n \t}\n \t\n \t/**\n@@ -137,31 +153,7 @@ class FeedbackServiceClient {\n \t * @param pushManager the {@code PushManager} in whose environment this client should operate\n \t */\n \tpublic FeedbackServiceClient(final PushManager<? extends ApnsPushNotification> pushManager) {\n-\t\t\n-\t\tthis.environment = pushManager.getEnvironment();\n-\t\t\n-\t\tthis.bootstrap = new Bootstrap();\n-\t\tthis.bootstrap.group(pushManager.getWorkerGroup());\n-\t\tthis.bootstrap.channel(NioSocketChannel.class);\n-\t\t\n-\t\tfinal FeedbackServiceClient feedbackClient = this;\n-\t\tthis.bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n-\n-\t\t\t@Override\n-\t\t\tprotected void initChannel(final SocketChannel channel) throws Exception {\n-\t\t\t\tfinal ChannelPipeline pipeline = channel.pipeline();\n-\t\t\t\t\n-\t\t\t\tif (environment.isTlsRequired()) {\n-\t\t\t\t\tpipeline.addLast(\"ssl\", SslHandlerUtil.createSslHandler(pushManager.getKeyStore(), pushManager.getKeyStorePassword()));\n-\t\t\t\t}\n-\t\t\t\t\n-\t\t\t\tpipeline.addLast(\"decoder\", new ExpiredTokenDecoder());\n-\t\t\t\tpipeline.addLast(\"handler\", new FeedbackClientHandler(feedbackClient));\n-\t\t\t}\n-\t\t\t\n-\t\t});\n-\t\t\n-\t\tthis.expiredTokens = new Vector<ExpiredToken>();\n+\t\tthis.pushManager = pushManager;\n \t}\n \t\n \tprotected void addExpiredToken(final ExpiredToken expiredToken) {\n@@ -176,31 +168,69 @@ class FeedbackServiceClient {\n \t * service, the information it returns lists only the failures that have happened since you last\n \t * connected.</blockquote>\n \t * \n+\t * @param timeout the time after the last received data after which the connection to the feedback service should\n+\t * be closed\n+\t * @param timeoutUnit the unit of time in which the given {@code timeout} is measured\n+\t * \n \t * @return a list of tokens that have expired since the last connection to the feedback service\n \t * \n \t * @throws InterruptedException if interrupted while waiting for a response from the feedback service\n \t */\n-\tpublic synchronized List<ExpiredToken> getExpiredTokens() throws InterruptedException {\n-\t\tthis.expiredTokens.clear();\n+\tpublic synchronized List<ExpiredToken> getExpiredTokens(final long timeout, final TimeUnit timeoutUnit) throws InterruptedException {\n+\t\tthis.expiredTokens = new Vector<ExpiredToken>();\n \t\t\n-\t\tfinal ChannelFuture connectFuture =\n-\t\t\t\tthis.bootstrap.connect(this.environment.getFeedbackHost(), this.environment.getFeedbackPort()).await();\n+\t\tfinal Bootstrap bootstrap = new Bootstrap();\n+\t\tbootstrap.group(pushManager.getWorkerGroup());\n+\t\tbootstrap.channel(NioSocketChannel.class);\n+\t\t\n+\t\tfinal FeedbackServiceClient feedbackClient = this;\n+\t\tbootstrap.handler(new ChannelInitializer<SocketChannel>() {\n+\n+\t\t\t@Override\n+\t\t\tprotected void initChannel(final SocketChannel channel) throws Exception {\n+\t\t\t\tfinal ChannelPipeline pipeline = channel.pipeline();\n+\t\t\t\t\n+\t\t\t\tif (pushManager.getEnvironment().isTlsRequired()) {\n+\t\t\t\t\tpipeline.addLast(\"ssl\", SslHandlerUtil.createSslHandler(pushManager.getKeyStore(), pushManager.getKeyStorePassword()));\n+\t\t\t\t}\n+\t\t\t\t\n+\t\t\t\tpipeline.addLast(\"readTimeoutHandler\", new ReadTimeoutHandler(timeout, timeoutUnit));\n+\t\t\t\tpipeline.addLast(\"decoder\", new ExpiredTokenDecoder());\n+\t\t\t\tpipeline.addLast(\"handler\", new FeedbackClientHandler(feedbackClient));\n+\t\t\t}\n+\t\t\t\n+\t\t});\n+\n+\t\tfinal ChannelFuture connectFuture = bootstrap.connect(\n+\t\t\t\tthis.pushManager.getEnvironment().getFeedbackHost(),\n+\t\t\t\tthis.pushManager.getEnvironment().getFeedbackPort()).await();\n \t\t\n \t\tif (connectFuture.isSuccess()) {\n-\t\t\tif (this.environment.isTlsRequired()) {\n+\t\t\tlog.debug(\"Connected to feedback service.\");\n+\t\t\t\n+\t\t\tif (this.pushManager.getEnvironment().isTlsRequired()) {\n \t\t\t\tfinal Future<Channel> handshakeFuture = connectFuture.channel().pipeline().get(SslHandler.class).handshakeFuture().await();\n \t\t\t\t\n \t\t\t\tif (handshakeFuture.isSuccess()) {\n+\t\t\t\t\tlog.debug(\"Completed TLS handshake with feedback service.\");\n \t\t\t\t\tconnectFuture.channel().closeFuture().await();\n+\t\t\t\t} else if (handshakeFuture.cause() != null) {\n+\t\t\t\t\tlog.warn(\"Failed to complete TLS handshake with feedback service.\", handshakeFuture.cause());\n+\t\t\t\t} else if (handshakeFuture.isCancelled()) {\n+\t\t\t\t\tlog.debug(\"TLS handhsake attempt was cancelled.\");\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tconnectFuture.channel().closeFuture().await();\n \t\t\t}\n+\t\t} else if (connectFuture.cause() != null) {\n+\t\t\tlog.warn(\"Failed to connect to feedback service.\", connectFuture.cause());\n+\t\t} else if (connectFuture.isCancelled()) {\n+\t\t\tlog.debug(\"Attempt to connect to feedback service was cancelled.\");\n \t\t}\n \t\t\n \t\t// The feedback service will send us a list of device tokens as soon as we connect, then hang up. While we're\n \t\t// waiting to sync with the connection closure, we'll be receiving messages from the feedback service from\n \t\t// another thread.\n-\t\treturn new ArrayList<ExpiredToken>(this.expiredTokens);\n+\t\treturn this.expiredTokens;\n \t}\n }\ndiff --git a/src/main/java/com/relayrides/pushy/apns/PushManager.java b/src/main/java/com/relayrides/pushy/apns/PushManager.java\nindex 1cb4a63..20d227f 100644\n--- a/src/main/java/com/relayrides/pushy/apns/PushManager.java\n+++ b/src/main/java/com/relayrides/pushy/apns/PushManager.java\n@@ -33,6 +33,10 @@ import java.util.concurrent.BlockingQueue;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n  * <p>A {@code PushManager} is the main public-facing point of interaction with APNs. {@code PushManager}s manage the\n@@ -57,6 +61,12 @@ public class PushManager<T extends ApnsPushNotification> {\n \t\n \tprivate final ExecutorService rejectedNotificationExecutorService;\n \t\n+\tprivate boolean started = false;\n+\tprivate boolean shutDown = false;\n+\tprivate boolean shutDownFinished = false;\n+\t\n+\tprivate final Logger log = LoggerFactory.getLogger(PushManager.class);\n+\t\n \t/**\n \t * Constructs a new {@code PushManager} that operates in the given environment with the given credentials, a single\n \t * connection to APNs, and a default event loop group.\n@@ -166,16 +176,30 @@ public class PushManager<T extends ApnsPushNotification> {\n \t}\n \t\n \t/**\n-\t * Opens all connections to APNs and prepares to send push notifications. Note that enqueued push notifications\n-\t * will <strong>not</strong> be sent until this method is called.\n+\t * <p>Opens all connections to APNs and prepares to send push notifications. Note that enqueued push notifications\n+\t * will <strong>not</strong> be sent until this method is called.</p>\n+\t * \n+\t * <p>Push managers may only be started once and cannot be reused after being shut down.</p>\n+\t * \n+\t * @throws IllegalStateException if the push manager has already been started or has already been shut down\n \t */\n \tpublic synchronized void start() {\n+\t\tif (this.isStarted()) {\n+\t\t\tthrow new IllegalStateException(\"Push manager has already been started.\");\n+\t\t}\n+\t\t\n+\t\tif (this.isShutDown()) {\n+\t\t\tthrow new IllegalStateException(\"Push manager has already been shut down and may not be restarted.\");\n+\t\t}\n+\t\t\n \t\tfor (int i = 0; i < this.concurrentConnections; i++) {\n \t\t\tfinal ApnsClientThread<T> clientThread = new ApnsClientThread<T>(this);\n \t\t\t\n \t\t\tthis.clientThreads.add(clientThread);\n \t\t\tclientThread.start();\n \t\t}\n+\t\t\n+\t\tthis.started = true;\n \t}\n \t\n \t/**\n@@ -205,12 +229,37 @@ public class PushManager<T extends ApnsPushNotification> {\n \t}\n \t\n \t/**\n+\t * Indicates whether this push manager has been started and not yet shut down.\n+\t * \n+\t * @return {@code true} if this push manager has been started and has not yet been shut down or {@code false}\n+\t * otherwise\n+\t */\n+\tpublic boolean isStarted() {\n+\t\tif (this.shutDown) {\n+\t\t\treturn false;\n+\t\t} else {\n+\t\t\treturn this.started;\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Indicates whether this push manager has been shut down (or is in the process of shutting down).\n+\t * \n+\t * @return {@code true} if this push manager has been shut down or is in the process of shutting down or\n+\t * {@code false} otherwise\n+\t */\n+\tpublic boolean isShutDown() {\n+\t\treturn this.shutDown;\n+\t}\n+\t\n+\t/**\n \t * Disconnects from the APNs and gracefully shuts down all worker threads. This method will block until all client\n \t * threads have shut down gracefully.\n \t * \n \t * @return a list of notifications not sent before the {@code PushManager} shut down\n \t * \n \t * @throws InterruptedException if interrupted while waiting for worker threads to exit cleanly\n+\t * @throws IllegalStateException if this method is called before the push manager has been started\n \t */\n \tpublic synchronized List<T> shutdown() throws InterruptedException {\n \t\treturn this.shutdown(0);\n@@ -227,8 +276,26 @@ public class PushManager<T extends ApnsPushNotification> {\n \t * @return a list of notifications not sent before the {@code PushManager} shut down\n \t * \n \t * @throws InterruptedException if interrupted while waiting for worker threads to exit cleanly\n+\t * @throws IllegalStateException if this method is called before the push manager has been started\n \t */\n \tpublic synchronized List<T> shutdown(long timeout) throws InterruptedException {\n+\t\tif (this.shutDown) {\n+\t\t\tlog.warn(\"Push manager has already been shut down; shutting down multiple times is harmless, but may \"\n+\t\t\t\t\t+ \"indicate a problem elsewhere.\");\n+\t\t}\n+\t\t\n+\t\tif (this.shutDownFinished) {\n+\t\t\t// We COULD throw an IllegalStateException here, but it seems unnecessary when we could just silently return\n+\t\t\t// the same result without harm.\n+\t\t\treturn new ArrayList<T>(this.queue);\n+\t\t}\n+\t\t\n+\t\tif (!this.isStarted()) {\n+\t\t\tthrow new IllegalStateException(\"Push manager has not yet been started and cannot be shut down.\");\n+\t\t}\n+\t\t\n+\t\tthis.shutDown = true;\n+\t\t\n \t\tfor (final ApnsClientThread<T> clientThread : this.clientThreads) {\n \t\t\tclientThread.requestShutdown();\n \t\t}\n@@ -260,10 +327,14 @@ public class PushManager<T extends ApnsPushNotification> {\n \t\tthis.rejectedNotificationExecutorService.shutdown();\n \t\t\n \t\tif (this.shouldShutDownWorkerGroup) {\n-\t\t\tfinal Future<?> workerShutdownFuture = this.workerGroup.shutdownGracefully();\n-\t\t\tworkerShutdownFuture.await();\n+\t\t\tif (!this.workerGroup.isShutdown()) {\n+\t\t\t\tfinal Future<?> workerShutdownFuture = this.workerGroup.shutdownGracefully();\n+\t\t\t\tworkerShutdownFuture.await();\n+\t\t\t}\n \t\t}\n \t\t\n+\t\tthis.shutDownFinished = true;\n+\t\t\n \t\treturn new ArrayList<T>(this.queue);\n \t}\n \t\n@@ -319,18 +390,51 @@ public class PushManager<T extends ApnsPushNotification> {\n \t}\n \t\n \t/**\n-\t * <p>Queries the APNs feedback service for expired tokens. Be warned that this is a <strong>destructive\n-\t * operation</strong>. According to Apple's documentation:</p>\n+\t * <p>Queries the APNs feedback service for expired tokens using a reasonable default timeout. Be warned that this\n+\t * is a <strong>destructive operation</strong>. According to Apple's documentation:</p>\n \t * \n \t * <blockquote>The feedback service\u2019s list is cleared after you read it. Each time you connect to the feedback\n \t * service, the information it returns lists only the failures that have happened since you last\n \t * connected.</blockquote>\n \t * \n+\t * <p>The push manager must be started before calling this method.</p>\n+\t * \n \t * @return a list of tokens that have expired since the last connection to the feedback service\n \t * \n \t * @throws InterruptedException if interrupted while waiting for a response from the feedback service\n \t */\n \tpublic List<ExpiredToken> getExpiredTokens() throws InterruptedException {\n-\t\treturn new FeedbackServiceClient(this).getExpiredTokens();\n+\t\treturn this.getExpiredTokens(1, TimeUnit.SECONDS);\n+\t}\n+\t\n+\t/**\n+\t * <p>Queries the APNs feedback service for expired tokens using the given timeout. Be warned that this is a\n+\t * <strong>destructive operation</strong>. According to Apple's documentation:</p>\n+\t * \n+\t * <blockquote>The feedback service\u2019s list is cleared after you read it. Each time you connect to the feedback\n+\t * service, the information it returns lists only the failures that have happened since you last\n+\t * connected.</blockquote>\n+\t * \n+\t * <p>The push manager must be started before calling this method.</p>\n+\t * \n+\t * @param timeout the time after the last received data after which the connection to the feedback service should\n+\t * be closed\n+\t * @param timeoutUnit the unit of time in which the given {@code timeout} is measured\n+\t * \n+\t * @return a list of tokens that have expired since the last connection to the feedback service\n+\t * \n+\t * @throws InterruptedException if interrupted while waiting for a response from the feedback service\n+\t * @throws IllegalStateException if this push manager has not been started yet or has already been shut down\n+\t */\n+\tpublic List<ExpiredToken> getExpiredTokens(final long timeout, final TimeUnit timeoutUnit) throws InterruptedException {\n+\t\tif (!this.isStarted()) {\n+\t\t\tthrow new IllegalStateException(\"Push manager has not been started yet.\");\n+\t\t}\n+\t\t\n+\t\tif (this.isShutDown()) {\n+\t\t\tthrow new IllegalStateException(\"Push manager has already been shut down.\");\n+\t\t}\n+\t\t\n+\t\treturn new FeedbackServiceClient(this).getExpiredTokens(timeout, timeoutUnit);\n \t}\n }\n", "test_patch": "diff --git a/src/test/java/com/relayrides/pushy/apns/FeedbackServiceClientTest.java b/src/test/java/com/relayrides/pushy/apns/FeedbackServiceClientTest.java\nindex 8fdd2a1..d3c3de0 100644\n--- a/src/test/java/com/relayrides/pushy/apns/FeedbackServiceClientTest.java\n+++ b/src/test/java/com/relayrides/pushy/apns/FeedbackServiceClientTest.java\n@@ -26,6 +26,7 @@ import static org.junit.Assert.assertTrue;\n \n import java.util.Date;\n import java.util.List;\n+import java.util.concurrent.TimeUnit;\n \n import org.junit.After;\n import org.junit.Before;\n@@ -57,7 +58,7 @@ public class FeedbackServiceClientTest {\n \n \t@Test\n \tpublic void testGetExpiredTokens() throws InterruptedException {\n-\t\tassertTrue(feedbackClient.getExpiredTokens().isEmpty());\n+\t\tassertTrue(feedbackClient.getExpiredTokens(1, TimeUnit.SECONDS).isEmpty());\n \t\t\n \t\t// Dates will have some loss of precision since APNS only deals with SECONDS since the epoch; we choose\n \t\t// timestamps that just happen to be on full seconds.\n@@ -67,14 +68,21 @@ public class FeedbackServiceClientTest {\n \t\tthis.feedbackServer.addExpiredToken(firstToken);\n \t\tthis.feedbackServer.addExpiredToken(secondToken);\n \t\t\n-\t\tfinal List<ExpiredToken> expiredTokens = this.feedbackClient.getExpiredTokens();\n+\t\tfinal List<ExpiredToken> expiredTokens = this.feedbackClient.getExpiredTokens(1, TimeUnit.SECONDS);\n \t\t\n \t\tassertEquals(2, expiredTokens.size());\n \t\tassertTrue(expiredTokens.contains(firstToken));\n \t\tassertTrue(expiredTokens.contains(secondToken));\n \t\t\n-\t\tassertTrue(feedbackClient.getExpiredTokens().isEmpty());\n+\t\tassertTrue(feedbackClient.getExpiredTokens(1, TimeUnit.SECONDS).isEmpty());\n \t}\n+\t\n+\t@Test\n+\tpublic void testGetExpiredTokensCloseWhenDone() throws InterruptedException {\n+\t\tthis.feedbackServer.setCloseWhenDone(true);\n+\t\tthis.testGetExpiredTokens();\n+\t}\n+\n \n \t@After\n \tpublic void tearDown() throws InterruptedException {\ndiff --git a/src/test/java/com/relayrides/pushy/apns/MockFeedbackServer.java b/src/test/java/com/relayrides/pushy/apns/MockFeedbackServer.java\nindex ef3eae8..ab786c5 100644\n--- a/src/test/java/com/relayrides/pushy/apns/MockFeedbackServer.java\n+++ b/src/test/java/com/relayrides/pushy/apns/MockFeedbackServer.java\n@@ -24,6 +24,7 @@ package com.relayrides.pushy.apns;\n import io.netty.bootstrap.ServerBootstrap;\n import io.netty.buffer.ByteBuf;\n import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.channel.ChannelInboundHandlerAdapter;\n import io.netty.channel.ChannelInitializer;\n@@ -32,7 +33,6 @@ import io.netty.channel.nio.NioEventLoopGroup;\n import io.netty.channel.socket.SocketChannel;\n import io.netty.channel.socket.nio.NioServerSocketChannel;\n import io.netty.handler.codec.MessageToByteEncoder;\n-import io.netty.util.concurrent.GenericFutureListener;\n \n import java.util.ArrayList;\n import java.util.List;\n@@ -46,6 +46,8 @@ public class MockFeedbackServer {\n \tprivate EventLoopGroup bossGroup;\n \tprivate EventLoopGroup workerGroup;\n \t\n+\tprivate volatile boolean closeWhenDone = false;\n+\t\n \tprivate class ExpiredTokenEncoder extends MessageToByteEncoder<ExpiredToken> {\n \n \t\t@Override\n@@ -72,19 +74,13 @@ public class MockFeedbackServer {\n \t\t\tChannelFuture lastWriteFuture = null;\n \t\t\t\n \t\t\tfor (final ExpiredToken expiredToken : expiredTokens) {\n-\t\t\t\tlastWriteFuture = context.writeAndFlush(expiredToken);\n+\t\t\t\tlastWriteFuture = context.write(expiredToken);\n \t\t\t}\n \t\t\t\n-\t\t\tif (lastWriteFuture != null) {\n-\t\t\t\tlastWriteFuture.addListener(new GenericFutureListener<ChannelFuture>() {\n+\t\t\tcontext.flush();\n \n-\t\t\t\t\tpublic void operationComplete(final ChannelFuture future) {\n-\t\t\t\t\t\tcontext.close();\n-\t\t\t\t\t}\n-\t\t\t\t\t\n-\t\t\t\t});\n-\t\t\t} else {\n-\t\t\t\tcontext.close();\n+\t\t\tif (this.feedbackServer.closeWhenDone && lastWriteFuture != null) {\n+\t\t\t\tlastWriteFuture.addListener(ChannelFutureListener.CLOSE);\n \t\t\t}\n \t\t}\n \t}\n@@ -132,4 +128,8 @@ public class MockFeedbackServer {\n \t\t\n \t\treturn tokensToReturn;\n \t}\n+\t\n+\tpublic void setCloseWhenDone(final boolean closeWhenDone) {\n+\t\tthis.closeWhenDone = closeWhenDone;\n+\t}\n }\ndiff --git a/src/test/java/com/relayrides/pushy/apns/PushManagerTest.java b/src/test/java/com/relayrides/pushy/apns/PushManagerTest.java\nindex 61ce7bf..aa67ec2 100644\n--- a/src/test/java/com/relayrides/pushy/apns/PushManagerTest.java\n+++ b/src/test/java/com/relayrides/pushy/apns/PushManagerTest.java\n@@ -97,4 +97,83 @@ public class PushManagerTest extends BasePushyTest {\n \t\t\tgroup.shutdownGracefully();\n \t\t}\n \t}\n+\t\n+\t@Test(expected = IllegalStateException.class)\n+\tpublic void testDoubleStart() {\n+\t\tfinal PushManager<ApnsPushNotification> doubleStartPushManager =\n+\t\t\t\tnew PushManager<ApnsPushNotification>(TEST_ENVIRONMENT, null, null);\n+\t\t\n+\t\tdoubleStartPushManager.start();\n+\t\tdoubleStartPushManager.start();\n+\t}\n+\t\n+\t@Test(expected = IllegalStateException.class)\n+\tpublic void testPrematureShutdown() throws InterruptedException {\n+\t\tfinal PushManager<ApnsPushNotification> prematureShutdownPushManager =\n+\t\t\t\tnew PushManager<ApnsPushNotification>(TEST_ENVIRONMENT, null, null);\n+\t\t\n+\t\tprematureShutdownPushManager.shutdown();\n+\t}\n+\t\n+\t@Test\n+\tpublic void testRepeatedShutdown() throws InterruptedException {\n+\t\tfinal PushManager<ApnsPushNotification> repeatedShutdownPushManager =\n+\t\t\t\tnew PushManager<ApnsPushNotification>(TEST_ENVIRONMENT, null, null);\n+\t\t\n+\t\trepeatedShutdownPushManager.start();\n+\t\trepeatedShutdownPushManager.shutdown();\n+\t\trepeatedShutdownPushManager.shutdown();\n+\t}\n+\t\n+\t@Test\n+\tpublic void testGetExpiredTokens() throws InterruptedException {\n+\t\tassertTrue(this.getPushManager().getExpiredTokens().isEmpty());\n+\t}\n+\t\n+\t@Test(expected = IllegalStateException.class)\n+\tpublic void testGetExpiredTokensBeforeStart() throws InterruptedException {\n+\t\tfinal PushManager<ApnsPushNotification> unstartedPushManager =\n+\t\t\t\tnew PushManager<ApnsPushNotification>(TEST_ENVIRONMENT, null, null);\n+\t\t\n+\t\tunstartedPushManager.getExpiredTokens();\n+\t}\n+\t\n+\t@Test(expected = IllegalStateException.class)\n+\tpublic void testGetExpiredTokensAfterShutdown() throws InterruptedException {\n+\t\tfinal PushManager<ApnsPushNotification> shutDownPushManager =\n+\t\t\t\tnew PushManager<ApnsPushNotification>(TEST_ENVIRONMENT, null, null);\n+\t\t\n+\t\tshutDownPushManager.start();\n+\t\tshutDownPushManager.shutdown();\n+\t\t\n+\t\tshutDownPushManager.getExpiredTokens();\n+\t}\n+\t\n+\t@Test\n+\tpublic void testIsStarted() throws InterruptedException {\n+\t\tfinal PushManager<ApnsPushNotification> testPushManager =\n+\t\t\t\tnew PushManager<ApnsPushNotification>(TEST_ENVIRONMENT, null, null);\n+\t\t\n+\t\tassertFalse(testPushManager.isStarted());\n+\t\t\n+\t\ttestPushManager.start();\n+\t\tassertTrue(testPushManager.isStarted());\n+\t\t\n+\t\ttestPushManager.shutdown();\n+\t\tassertFalse(testPushManager.isStarted());\n+\t}\n+\t\n+\t@Test\n+\tpublic void testIsShutDown() throws InterruptedException {\n+\t\tfinal PushManager<ApnsPushNotification> testPushManager =\n+\t\t\t\tnew PushManager<ApnsPushNotification>(TEST_ENVIRONMENT, null, null);\n+\t\t\n+\t\tassertFalse(testPushManager.isShutDown());\n+\t\t\n+\t\ttestPushManager.start();\n+\t\tassertFalse(testPushManager.isShutDown());\n+\t\t\n+\t\ttestPushManager.shutdown();\n+\t\tassertTrue(testPushManager.isShutDown());\n+\t}\n }\n"}
{"repository": "jchambers/pushy", "clone_url": "https://github.com/jchambers/pushy.git", "timestamp": "2023-05-31T22:09:02.795189Z", "commit_hash": "4a2b5dae1f2cd10cab09a1fca2ae9bf5d969b03d", "commit_message": "Added tests (and fixed a potential bug) for the shutdown-with-bad-message strategy.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/com/relayrides/pushy/apns/ApnsClientThread.java b/src/main/java/com/relayrides/pushy/apns/ApnsClientThread.java\nindex 84ca39c..bf7ffd4 100644\n--- a/src/main/java/com/relayrides/pushy/apns/ApnsClientThread.java\n+++ b/src/main/java/com/relayrides/pushy/apns/ApnsClientThread.java\n@@ -226,7 +226,9 @@ class ApnsClientThread<T extends ApnsPushNotification> extends Thread {\n \t\t\t\t\ttry {\n \t\t\t\t\t\tfinal T notification = this.pushManager.getQueue().poll(POLL_TIMEOUT, TimeUnit.MILLISECONDS);\n \t\t\t\t\t\t\n-\t\t\t\t\t\tif (notification != null) {\n+\t\t\t\t\t\tif (this.isInterrupted()) {\n+\t\t\t\t\t\t\tthis.pushManager.enqueuePushNotification(notification);\n+\t\t\t\t\t\t} else if (notification != null) {\n \t\t\t\t\t\t\tfinal SendableApnsPushNotification<T> sendableNotification =\n \t\t\t\t\t\t\t\t\tnew SendableApnsPushNotification<T>(notification, this.sequenceNumber++);\n \t\t\t\t\t\t\t\n@@ -395,7 +397,7 @@ class ApnsClientThread<T extends ApnsPushNotification> extends Thread {\n \t\t\t// we don't want to notify listeners of the error (but we still do need to reconnect).\n \t\t\tif (rejectedNotification.getReason() != RejectedNotificationReason.SHUTDOWN) {\n \t\t\t\tthis.pushManager.notifyListenersOfRejectedNotification(\n-\t\t\t\t\t\tthis.getSentNotificationBuffer().getAndRemoveNotificationWithSequenceNumber(\n+\t\t\t\t\t\tthis.sentNotificationBuffer.getAndRemoveNotificationWithSequenceNumber(\n \t\t\t\t\t\t\t\trejectedNotification.getSequenceNumber()), rejectedNotification.getReason());\n \t\t\t}\n \t\t}\n@@ -447,8 +449,4 @@ class ApnsClientThread<T extends ApnsPushNotification> extends Thread {\n \t\t\treturn false;\n \t\t}\n \t}\n-\t\n-\tprotected SentNotificationBuffer<T> getSentNotificationBuffer() {\n-\t\treturn this.sentNotificationBuffer;\n-\t}\n }\ndiff --git a/src/main/java/com/relayrides/pushy/apns/KnownBadPushNotification.java b/src/main/java/com/relayrides/pushy/apns/KnownBadPushNotification.java\nindex 4013fd5..db89344 100644\n--- a/src/main/java/com/relayrides/pushy/apns/KnownBadPushNotification.java\n+++ b/src/main/java/com/relayrides/pushy/apns/KnownBadPushNotification.java\n@@ -24,7 +24,14 @@ package com.relayrides.pushy.apns;\n import java.util.Date;\n \n /**\n- * A deliberately-malformed push notification used to trigger a remote shutdown of an APNs connection.\n+ * <p>A deliberately-malformed push notification used to trigger a remote shutdown of an APNs connection.</p>\n+ * \n+ * <p>The APNs gateway does not acknowledge successful push notifications, and so it is impossible to know for sure\n+ * when a connection can be safely closed from the client side, or the state of messages sent before the connection\n+ * was closed. Because the APNs gateway DOES reject bad notifications, though, we can send a known-bad notification to\n+ * the gateway and wait for the remote host to close the connection. In that case, we know that all notifications sent\n+ * before the known-bad notification have been processed and that all messages after the known-bad notification were\n+ * not.</p>\n  * \n  * @author <a href=\"mailto:jon@relayrides.com\">Jon Chambers</a>\n  */\n", "test_patch": "diff --git a/src/test/java/com/relayrides/pushy/apns/ApnsClientThreadTest.java b/src/test/java/com/relayrides/pushy/apns/ApnsClientThreadTest.java\nindex 7db76be..3ef62ff 100644\n--- a/src/test/java/com/relayrides/pushy/apns/ApnsClientThreadTest.java\n+++ b/src/test/java/com/relayrides/pushy/apns/ApnsClientThreadTest.java\n@@ -143,4 +143,27 @@ public class ApnsClientThreadTest extends BasePushyTest {\n \t\t\tsecondClientThread.shutdown();\n \t\t}\n \t}\n+\t\n+\t@Test\n+\tpublic void testShutdown() throws InterruptedException {\n+\t\tfinal SimpleApnsPushNotification notification = this.createTestNotification();\n+\t\t\n+\t\tfinal int iterations = 100;\n+\t\tfinal CountDownLatch latch = this.getServer().getCountDownLatch(iterations);\n+\t\t\n+\t\tfor (int i = 0; i < iterations; i++) {\n+\t\t\tthis.getPushManager().enqueuePushNotification(notification);\n+\t\t}\n+\t\t\n+\t\tthis.waitForLatch(latch);\n+\t\tthis.getClientThread().shutdown();\n+\t\t\n+\t\tfor (int i = 0; i < iterations; i++) {\n+\t\t\tthis.getPushManager().enqueuePushNotification(notification);\n+\t\t}\n+\t\t\n+\t\tassertEquals(\n+\t\t\t\t2 * iterations,\n+\t\t\t\tthis.getPushManager().shutdown().size() + this.getServer().getReceivedNotifications().size());\n+\t}\n }\n"}
{"repository": "jchambers/pushy", "clone_url": "https://github.com/jchambers/pushy.git", "timestamp": "2023-05-31T22:13:01.008783Z", "commit_hash": "992daa3971f83a6dd194f6a3cc886d7ff3cf8def", "commit_message": "Fixed a bad getter name in RejectedNotificationException.\n", "related_issues": "", "bug_patch": "diff --git a/src/main/java/com/relayrides/pushy/apns/ApnsClientThread.java b/src/main/java/com/relayrides/pushy/apns/ApnsClientThread.java\nindex 0e8a156..0ca61a0 100644\n--- a/src/main/java/com/relayrides/pushy/apns/ApnsClientThread.java\n+++ b/src/main/java/com/relayrides/pushy/apns/ApnsClientThread.java\n@@ -294,11 +294,11 @@ class ApnsClientThread<T extends ApnsPushNotification> extends Thread {\n \t\t// we don't want to notify listeners of the error (but we still do need to reconnect).\n \t\tif (e.getReason() != RejectedNotificationReason.SHUTDOWN) {\n \t\t\tthis.pushManager.notifyListenersOfRejectedNotification(\n-\t\t\t\t\tthis.getSentNotificationBuffer().getAndRemoveNotificationWithSequenceNumber(e.getSequenceNumberId()), e);\n+\t\t\t\t\tthis.getSentNotificationBuffer().getAndRemoveNotificationWithSequenceNumber(e.getSequenceNumber()), e);\n \t\t}\n \t\t\n \t\tthis.pushManager.enqueueAllNotifications(\n-\t\t\t\tthis.sentNotificationBuffer.getAndRemoveAllNotificationsAfterSequenceNumber(e.getSequenceNumberId()));\n+\t\t\t\tthis.sentNotificationBuffer.getAndRemoveAllNotificationsAfterSequenceNumber(e.getSequenceNumber()));\n \t}\n \t\n \tprotected void reconnect() {\ndiff --git a/src/main/java/com/relayrides/pushy/apns/RejectedNotificationException.java b/src/main/java/com/relayrides/pushy/apns/RejectedNotificationException.java\nindex ad1290b..d18415c 100644\n--- a/src/main/java/com/relayrides/pushy/apns/RejectedNotificationException.java\n+++ b/src/main/java/com/relayrides/pushy/apns/RejectedNotificationException.java\n@@ -28,7 +28,7 @@ public class RejectedNotificationException extends Exception {\n \t * \n \t * @return the sequence number of the notification rejected by APNs\n \t */\n-\tpublic int getSequenceNumberId() {\n+\tpublic int getSequenceNumber() {\n \t\treturn this.sequenceNumber;\n \t}\n \t\n", "test_patch": "diff --git a/src/test/java/com/relayrides/pushy/apns/MockApnsServer.java b/src/test/java/com/relayrides/pushy/apns/MockApnsServer.java\nindex 7555e76..d1ee7e0 100644\n--- a/src/test/java/com/relayrides/pushy/apns/MockApnsServer.java\n+++ b/src/test/java/com/relayrides/pushy/apns/MockApnsServer.java\n@@ -152,7 +152,7 @@ public class MockApnsServer {\n \t\tprotected void encode(final ChannelHandlerContext context, final RejectedNotificationException e, final ByteBuf out) {\n \t\t\tout.writeByte(ERROR_COMMAND);\n \t\t\tout.writeByte(e.getReason().getErrorCode());\n-\t\t\tout.writeInt(e.getSequenceNumberId());\n+\t\t\tout.writeInt(e.getSequenceNumber());\n \t\t}\n \t}\n \t\n"}
