{
    "repository": "goshippo/shippo-python-client",
    "clone_url": "https://github.com/goshippo/shippo-python-client.git",
    "timestamp": "2023-05-29T15:37:21.009141Z",
    "clone_success": true,
    "number of actions": 1,
    "number_of_test_actions": 1,
    "actions_successful": false,
    "actions_stdout": "[Python SDK Test/test] \ud83d\ude80  Start image=crawlergpt:latest\n[Python SDK Test/test]   \ud83d\udc33  docker pull image=crawlergpt:latest platform= username= forcePull=false\n[Python SDK Test/test]   \ud83d\udc33  docker create image=crawlergpt:latest platform= entrypoint=[\"tail\" \"-f\" \"/dev/null\"] cmd=[]\n[Python SDK Test/test]   \ud83d\udc33  docker run image=crawlergpt:latest platform= entrypoint=[\"tail\" \"-f\" \"/dev/null\"] cmd=[]\n[Python SDK Test/test]   \ud83d\udc33  docker exec cmd=[chown -R 1012:1000 /tmp/de65f406-fe28-11ed-a890-af2cc187fc11/goshippo-shippo-python-client] user=0 workdir=\n[Python SDK Test/test]   \u2601  git clone 'https://github.com/actions/setup-python' # ref=v3\n[Python SDK Test/test] \ud83e\uddea  Matrix: map[python:3.6]\n[Python SDK Test/test] \u2b50 Run Main actions/checkout@v3\n[Python SDK Test/test]   \u2705  Success - Main actions/checkout@v3\n[Python SDK Test/test] \u2b50 Run Main Setup Python\n[Python SDK Test/test]   \ud83d\udc33  docker cp src=/home/andre-silva/.cache/act/actions-setup-python@v3/ dst=/var/run/act/actions/actions-setup-python@v3/\n[Python SDK Test/test]   \ud83d\udc33  docker exec cmd=[chown -R 1012:1000 /var/run/act/actions/actions-setup-python@v3/] user=0 workdir=\n[Python SDK Test/test]   \ud83d\udc33  docker exec cmd=[node /var/run/act/actions/actions-setup-python@v3/dist/setup/index.js] user= workdir=\n[Python SDK Test/test]   \ud83d\udcac  ::debug::Semantic version spec of 3.6 is 3.6\n[Python SDK Test/test]   \ud83d\udcac  ::debug::isExplicit: \n[Python SDK Test/test]   \ud83d\udcac  ::debug::explicit? false\n[Python SDK Test/test]   \ud83d\udcac  ::debug::isExplicit: 2.7.18\n[Python SDK Test/test]   \ud83d\udcac  ::debug::explicit? true\n[Python SDK Test/test]   \ud83d\udcac  ::debug::isExplicit: 3.5.10\n[Python SDK Test/test]   \ud83d\udcac  ::debug::explicit? true\n[Python SDK Test/test]   \ud83d\udcac  ::debug::isExplicit: 3.6.14\n[Python SDK Test/test]   \ud83d\udcac  ::debug::explicit? true\n[Python SDK Test/test]   \ud83d\udcac  ::debug::isExplicit: 3.7.11\n[Python SDK Test/test]   \ud83d\udcac  ::debug::explicit? true\n[Python SDK Test/test]   \ud83d\udcac  ::debug::isExplicit: 3.8.11\n[Python SDK Test/test]   \ud83d\udcac  ::debug::explicit? true\n[Python SDK Test/test]   \ud83d\udcac  ::debug::isExplicit: 3.9.6\n[Python SDK Test/test]   \ud83d\udcac  ::debug::explicit? true\n[Python SDK Test/test]   \ud83d\udcac  ::debug::evaluating 6 versions\n[Python SDK Test/test]   \ud83d\udcac  ::debug::matched: 3.6.14\n[Python SDK Test/test]   \ud83d\udcac  ::debug::checking cache: /opt/hostedtoolcache/Python/3.6.14/x64\n[Python SDK Test/test]   \ud83d\udcac  ::debug::Found tool in cache Python 3.6.14 x64\n[Python SDK Test/test]   | Successfully setup CPython (3.6.14)\n[Python SDK Test/test]   \u2753 add-matcher /run/act/actions/actions-setup-python@v3/.github/python.json\n[Python SDK Test/test]   \u2705  Success - Main Setup Python\n[Python SDK Test/test]   \u2699  ::set-env:: pythonLocation=/opt/hostedtoolcache/Python/3.6.14/x64\n[Python SDK Test/test]   \u2699  ::set-env:: LD_LIBRARY_PATH=/opt/hostedtoolcache/Python/3.6.14/x64/lib\n[Python SDK Test/test]   \u2699  ::set-output:: python-version=3.6.14\n[Python SDK Test/test]   \u2699  ::add-path:: /opt/hostedtoolcache/Python/3.6.14/x64\n[Python SDK Test/test]   \u2699  ::add-path:: /opt/hostedtoolcache/Python/3.6.14/x64/bin\n[Python SDK Test/test] \u2b50 Run Main Install tox\n[Python SDK Test/test]   \ud83d\udc33  docker exec cmd=[bash --noprofile --norc -e -o pipefail /var/run/act/workflow/2] user= workdir=\n[Python SDK Test/test]   | Collecting tox\n[Python SDK Test/test]   |   Downloading tox-3.28.0-py2.py3-none-any.whl (86 kB)\n[Python SDK Test/test]   | Collecting toml>=0.10.2\n[Python SDK Test/test]   |   Downloading toml-0.10.2-py2.py3-none-any.whl (16 kB)\n[Python SDK Test/test]   | Collecting pluggy>=0.12.0\n[Python SDK Test/test]   |   Downloading pluggy-1.0.0-py2.py3-none-any.whl (13 kB)\n[Python SDK Test/test]   | Collecting importlib-metadata>=0.12\n[Python SDK Test/test]   |   Downloading importlib_metadata-4.8.3-py3-none-any.whl (17 kB)\n[Python SDK Test/test]   | Collecting virtualenv!=20.0.0,!=20.0.1,!=20.0.2,!=20.0.3,!=20.0.4,!=20.0.5,!=20.0.6,!=20.0.7,>=16.0.0\n[Python SDK Test/test]   |   Downloading virtualenv-20.17.1-py3-none-any.whl (8.8 MB)\n[Python SDK Test/test]   | Collecting py>=1.4.17\n[Python SDK Test/test]   |   Downloading py-1.11.0-py2.py3-none-any.whl (98 kB)\n[Python SDK Test/test]   | Collecting six>=1.14.0\n[Python SDK Test/test]   |   Downloading six-1.16.0-py2.py3-none-any.whl (11 kB)\n[Python SDK Test/test]   | Collecting filelock>=3.0.0\n[Python SDK Test/test]   |   Downloading filelock-3.4.1-py3-none-any.whl (9.9 kB)\n[Python SDK Test/test]   | Collecting packaging>=14\n[Python SDK Test/test]   |   Downloading packaging-21.3-py3-none-any.whl (40 kB)\n[Python SDK Test/test]   | Collecting zipp>=0.5\n[Python SDK Test/test]   |   Downloading zipp-3.6.0-py3-none-any.whl (5.3 kB)\n[Python SDK Test/test]   | Collecting typing-extensions>=3.6.4\n[Python SDK Test/test]   |   Downloading typing_extensions-4.1.1-py3-none-any.whl (26 kB)\n[Python SDK Test/test]   | Collecting pyparsing!=3.0.5,>=2.0.2\n[Python SDK Test/test]   |   Downloading pyparsing-3.0.9-py3-none-any.whl (98 kB)\n[Python SDK Test/test]   | Collecting distlib<1,>=0.3.6\n[Python SDK Test/test]   |   Downloading distlib-0.3.6-py2.py3-none-any.whl (468 kB)\n[Python SDK Test/test]   | Collecting importlib-resources>=5.4\n[Python SDK Test/test]   |   Downloading importlib_resources-5.4.0-py3-none-any.whl (28 kB)\n[Python SDK Test/test]   | Collecting platformdirs<3,>=2.4\n[Python SDK Test/test]   |   Downloading platformdirs-2.4.0-py3-none-any.whl (14 kB)\n[Python SDK Test/test]   | Installing collected packages: zipp, typing-extensions, pyparsing, platformdirs, importlib-resources, importlib-metadata, filelock, distlib, virtualenv, toml, six, py, pluggy, packaging, tox\n[Python SDK Test/test]   | Successfully installed distlib-0.3.6 filelock-3.4.1 importlib-metadata-4.8.3 importlib-resources-5.4.0 packaging-21.3 platformdirs-2.4.0 pluggy-1.0.0 py-1.11.0 pyparsing-3.0.9 six-1.16.0 toml-0.10.2 tox-3.28.0 typing-extensions-4.1.1 virtualenv-20.17.1 zipp-3.6.0\n[Python SDK Test/test]   | WARNING: You are using pip version 21.2.4; however, version 21.3.1 is available.\n[Python SDK Test/test]   | You should consider upgrading via the '/opt/hostedtoolcache/Python/3.6.14/x64/bin/python -m pip install --upgrade pip' command.\n[Python SDK Test/test]   \u2705  Success - Main Install tox\n[Python SDK Test/test] \u2b50 Run Main Run the tests for PROD\n[Python SDK Test/test]   \ud83d\udc33  docker exec cmd=[bash --noprofile --norc -e -o pipefail /var/run/act/workflow/test] user= workdir=\n[Python SDK Test/test]   | GLOB sdist-make: /tmp/de65f406-fe28-11ed-a890-af2cc187fc11/goshippo-shippo-python-client/setup.py\n[Python SDK Test/test]   | py create: /tmp/de65f406-fe28-11ed-a890-af2cc187fc11/goshippo-shippo-python-client/.tox/py\n[Python SDK Test/test]   | py installdeps: pytest, unittest2, requests, vcrpy, mock\n[Python SDK Test/test]   | py inst: /tmp/de65f406-fe28-11ed-a890-af2cc187fc11/goshippo-shippo-python-client/.tox/.tmp/package/1/shippo-2.1.3.zip\n[Python SDK Test/test]   | py installed: attrs==22.2.0,certifi==2023.5.7,chardet==5.0.0,charset-normalizer==2.0.12,idna==3.4,importlib-metadata==4.8.3,iniconfig==1.1.1,linecache2==1.0.0,mock==5.0.2,multidict==5.2.0,packaging==21.3,pluggy==1.0.0,py==1.11.0,pyparsing==3.0.9,pytest==7.0.1,PyYAML==6.0,requests==2.27.1,shippo @ file:///tmp/de65f406-fe28-11ed-a890-af2cc187fc11/goshippo-shippo-python-client/.tox/.tmp/package/1/shippo-2.1.3.zip,simplejson==3.17.2,six==1.16.0,tomli==1.2.3,traceback2==1.4.0,typing_extensions==4.1.1,unittest2==1.1.0,urllib3==1.26.16,vcrpy==4.1.1,wrapt==1.15.0,yarl==1.7.2,zipp==3.6.0\n[Python SDK Test/test]   | py run-test-pre: PYTHONHASHSEED='1014584658'\n[Python SDK Test/test]   | py run-test: commands[0] | pytest -v\n[Python SDK Test/test]   | ============================= test session starts ==============================\n[Python SDK Test/test]   | platform linux -- Python 3.6.14, pytest-7.0.1, pluggy-1.0.0 -- /tmp/de65f406-fe28-11ed-a890-af2cc187fc11/goshippo-shippo-python-client/.tox/py/bin/python\n[Python SDK Test/test]   | cachedir: .tox/py/.pytest_cache\n[Python SDK Test/test]   | rootdir: /tmp/de65f406-fe28-11ed-a890-af2cc187fc11/goshippo-shippo-python-client\n[Python SDK Test/test]   | collecting ... collected 86 items\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_address.py::AddressTests::test_create FAILED            [  1%]\n[Python SDK Test/test]   | shippo/test/test_address.py::AddressTests::test_invalid_create FAILED    [  2%]\n[Python SDK Test/test]   | shippo/test/test_address.py::AddressTests::test_invalid_retrieve FAILED  [  3%]\n[Python SDK Test/test]   | shippo/test/test_address.py::AddressTests::test_invalid_validate FAILED  [  4%]\n[Python SDK Test/test]   | shippo/test/test_address.py::AddressTests::test_list_all FAILED          [  5%]\n[Python SDK Test/test]   | shippo/test/test_address.py::AddressTests::test_list_page_size FAILED    [  6%]\n[Python SDK Test/test]   | shippo/test/test_address.py::AddressTests::test_retrieve FAILED          [  8%]\n[Python SDK Test/test]   | shippo/test/test_address.py::AddressTests::test_validate FAILED          [  9%]\n[Python SDK Test/test]   | shippo/test/test_api_requestor.py::APIRequestorTests::test_oauth_token_auth FAILED [ 10%]\n[Python SDK Test/test]   | shippo/test/test_api_requestor.py::APIRequestorTests::test_shippo_token_auth FAILED [ 11%]\n[Python SDK Test/test]   | shippo/test/test_api_requestor.py::APIRequestorTests::test_shippo_user_agent PASSED [ 12%]\n[Python SDK Test/test]   | shippo/test/test_batch.py::BatchTests::test_add FAILED                   [ 13%]\n[Python SDK Test/test]   | shippo/test/test_batch.py::BatchTests::test_create FAILED                [ 15%]\n[Python SDK Test/test]   | shippo/test/test_batch.py::BatchTests::test_invalid_add FAILED           [ 16%]\n[Python SDK Test/test]   | shippo/test/test_batch.py::BatchTests::test_invalid_create FAILED        [ 17%]\n[Python SDK Test/test]   | shippo/test/test_batch.py::BatchTests::test_invalid_purchase FAILED      [ 18%]\n[Python SDK Test/test]   | shippo/test/test_batch.py::BatchTests::test_invalid_remove FAILED        [ 19%]\n[Python SDK Test/test]   | shippo/test/test_batch.py::BatchTests::test_invalid_retrieve FAILED      [ 20%]\n[Python SDK Test/test]   | shippo/test/test_batch.py::BatchTests::test_purchase FAILED              [ 22%]\n[Python SDK Test/test]   | shippo/test/test_batch.py::BatchTests::test_remove FAILED                [ 23%]\n[Python SDK Test/test]   | shippo/test/test_batch.py::BatchTests::test_retrieve FAILED              [ 24%]\n[Python SDK Test/test]   | shippo/test/test_customs_declaration.py::CustomsDeclarationTests::test_create FAILED [ 25%]\n[Python SDK Test/test]   | shippo/test/test_customs_declaration.py::CustomsDeclarationTests::test_invalid_create FAILED [ 26%]\n[Python SDK Test/test]   | shippo/test/test_customs_declaration.py::CustomsDeclarationTests::test_invalid_retrieve FAILED [ 27%]\n[Python SDK Test/test]   | shippo/test/test_customs_declaration.py::CustomsDeclarationTests::test_list_all FAILED [ 29%]\n[Python SDK Test/test]   | shippo/test/test_customs_declaration.py::CustomsDeclarationTests::test_list_page_size FAILED [ 30%]\n[Python SDK Test/test]   | shippo/test/test_customs_declaration.py::CustomsDeclarationTests::test_retrieve FAILED [ 31%]\n[Python SDK Test/test]   | shippo/test/test_customs_item.py::CustomsItemTest::test_create FAILED    [ 32%]\n[Python SDK Test/test]   | shippo/test/test_customs_item.py::CustomsItemTest::test_invalid_create FAILED [ 33%]\n[Python SDK Test/test]   | shippo/test/test_customs_item.py::CustomsItemTest::test_invalid_retrieve FAILED [ 34%]\n[Python SDK Test/test]   | shippo/test/test_customs_item.py::CustomsItemTest::test_list_all FAILED  [ 36%]\n[Python SDK Test/test]   | shippo/test/test_customs_item.py::CustomsItemTest::test_list_page_size FAILED [ 37%]\n[Python SDK Test/test]   | shippo/test/test_customs_item.py::CustomsItemTest::test_retrieve FAILED  [ 38%]\n[Python SDK Test/test]   | shippo/test/test_http_client.py::HttpClientTests::test_new_default_http_client_requests PASSED [ 39%]\n[Python SDK Test/test]   | shippo/test/test_http_client.py::HttpClientTests::test_new_default_http_client_urlfetch PASSED [ 40%]\n[Python SDK Test/test]   | shippo/test/test_http_client.py::RequestsClientTests::test_custom_timeout PASSED [ 41%]\n[Python SDK Test/test]   | shippo/test/test_http_client.py::RequestsClientTests::test_exception PASSED [ 43%]\n[Python SDK Test/test]   | shippo/test/test_http_client.py::RequestsClientTests::test_request PASSED [ 44%]\n[Python SDK Test/test]   | shippo/test/test_http_client.py::UrlFetchClientTests::test_custom_timeout PASSED [ 45%]\n[Python SDK Test/test]   | shippo/test/test_http_client.py::UrlFetchClientTests::test_exception PASSED [ 46%]\n[Python SDK Test/test]   | shippo/test/test_http_client.py::UrlFetchClientTests::test_request PASSED [ 47%]\n[Python SDK Test/test]   | shippo/test/test_manifest.py::ManifestTests::test_create FAILED          [ 48%]\n[Python SDK Test/test]   | shippo/test/test_manifest.py::ManifestTests::test_invalid_create FAILED  [ 50%]\n[Python SDK Test/test]   | shippo/test/test_manifest.py::ManifestTests::test_invalid_retrieve FAILED [ 51%]\n[Python SDK Test/test]   | shippo/test/test_manifest.py::ManifestTests::test_list_all FAILED        [ 52%]\n[Python SDK Test/test]   | shippo/test/test_manifest.py::ManifestTests::test_list_page_size FAILED  [ 53%]\n[Python SDK Test/test]   | shippo/test/test_manifest.py::ManifestTests::test_retrieve FAILED        [ 54%]\n[Python SDK Test/test]   | shippo/test/test_order.py::OrderTests::test_create FAILED                [ 55%]\n[Python SDK Test/test]   | shippo/test/test_order.py::OrderTests::test_invalid_create FAILED        [ 56%]\n[Python SDK Test/test]   | shippo/test/test_order.py::OrderTests::test_invalid_retrieve FAILED      [ 58%]\n[Python SDK Test/test]   | shippo/test/test_order.py::OrderTests::test_list_all FAILED              [ 59%]\n[Python SDK Test/test]   | shippo/test/test_order.py::OrderTests::test_list_page_size FAILED        [ 60%]\n[Python SDK Test/test]   | shippo/test/test_order.py::OrderTests::test_retrieve FAILED              [ 61%]\n[Python SDK Test/test]   | shippo/test/test_parcel.py::ParcelTests::test_create FAILED              [ 62%]\n[Python SDK Test/test]   | shippo/test/test_parcel.py::ParcelTests::test_invalid_create FAILED      [ 63%]\n[Python SDK Test/test]   | shippo/test/test_parcel.py::ParcelTests::test_invalid_retrieve FAILED    [ 65%]\n[Python SDK Test/test]   | shippo/test/test_parcel.py::ParcelTests::test_list_all FAILED            [ 66%]\n[Python SDK Test/test]   | shippo/test/test_parcel.py::ParcelTests::test_list_page_size FAILED      [ 67%]\n[Python SDK Test/test]   | shippo/test/test_parcel.py::ParcelTests::test_retrieve FAILED            [ 68%]\n[Python SDK Test/test]   | shippo/test/test_pickup.py::PickupTests::test_create FAILED              [ 69%]\n[Python SDK Test/test]   | shippo/test/test_rate.py::RateTests::test_invalid_retrieve FAILED        [ 70%]\n[Python SDK Test/test]   | shippo/test/test_rate.py::RateTests::test_retrieve FAILED                [ 72%]\n[Python SDK Test/test]   | shippo/test/test_shipment.py::ShipmentTests::test_create FAILED          [ 73%]\n[Python SDK Test/test]   | shippo/test/test_shipment.py::ShipmentTests::test_get_rate FAILED        [ 74%]\n[Python SDK Test/test]   | shippo/test/test_shipment.py::ShipmentTests::test_get_rates_blocking FAILED [ 75%]\n[Python SDK Test/test]   | shippo/test/test_shipment.py::ShipmentTests::test_invalid_create FAILED  [ 76%]\n[Python SDK Test/test]   | shippo/test/test_shipment.py::ShipmentTests::test_invalid_get_rate FAILED [ 77%]\n[Python SDK Test/test]   | shippo/test/test_shipment.py::ShipmentTests::test_invalid_retrieve FAILED [ 79%]\n[Python SDK Test/test]   | shippo/test/test_shipment.py::ShipmentTests::test_list_all FAILED        [ 80%]\n[Python SDK Test/test]   | shippo/test/test_shipment.py::ShipmentTests::test_list_page_size FAILED  [ 81%]\n[Python SDK Test/test]   | shippo/test/test_shipment.py::ShipmentTests::test_retrieve FAILED        [ 82%]\n[Python SDK Test/test]   | shippo/test/test_track.py::TrackTests::test_create FAILED                [ 83%]\n[Python SDK Test/test]   | shippo/test/test_track.py::TrackTests::test_get_status FAILED            [ 84%]\n[Python SDK Test/test]   | shippo/test/test_track.py::TrackTests::test_invalid_create FAILED        [ 86%]\n[Python SDK Test/test]   | shippo/test/test_track.py::TrackTests::test_invalid_get_status FAILED    [ 87%]\n[Python SDK Test/test]   | shippo/test/test_transaction.py::TransactionTests::test_create FAILED    [ 88%]\n[Python SDK Test/test]   | shippo/test/test_transaction.py::TransactionTests::test_invalid_create FAILED [ 89%]\n[Python SDK Test/test]   | shippo/test/test_transaction.py::TransactionTests::test_invalid_retrieve FAILED [ 90%]\n[Python SDK Test/test]   | shippo/test/test_transaction.py::TransactionTests::test_list_all FAILED  [ 91%]\n[Python SDK Test/test]   | shippo/test/test_transaction.py::TransactionTests::test_list_page_size FAILED [ 93%]\n[Python SDK Test/test]   | shippo/test/test_transaction.py::TransactionTests::test_retrieve FAILED  [ 94%]\n[Python SDK Test/test]   | shippo/test/integration/test_integration.py::FunctionalTests::test_dns_failure PASSED [ 95%]\n[Python SDK Test/test]   | shippo/test/integration/test_integration.py::FunctionalTests::test_get_rates FAILED [ 96%]\n[Python SDK Test/test]   | shippo/test/integration/test_integration.py::FunctionalTests::test_list_accessors FAILED [ 97%]\n[Python SDK Test/test]   | shippo/test/integration/test_integration.py::FunctionalTests::test_run FAILED [ 98%]\n[Python SDK Test/test]   | shippo/test/integration/test_integration.py::FunctionalTests::test_unicode FAILED [100%]\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | =================================== FAILURES ===================================\n[Python SDK Test/test]   | ___________________________ AddressTests.test_create ___________________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b91f64e0>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_address.AddressTests testMethod=test_create>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/address')\n[Python SDK Test/test]   |     def test_create(self):\n[Python SDK Test/test]   | >       address = shippo.Address.create(**DUMMY_ADDRESS)\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_address.py:44: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:187: in create\n[Python SDK Test/test]   |     response, api_key = requestor.request('post', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b91f64e0>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | _______________________ AddressTests.test_invalid_create _______________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b91ee198>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_address.AddressTests testMethod=test_invalid_create>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/address')\n[Python SDK Test/test]   |     def test_invalid_create(self):\n[Python SDK Test/test]   | >       address = shippo.Address.create(**INVALID_ADDRESS)\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_address.py:39: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:187: in create\n[Python SDK Test/test]   |     response, api_key = requestor.request('post', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b91ee198>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | ______________________ AddressTests.test_invalid_retrieve ______________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_address.AddressTests testMethod=test_invalid_retrieve>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/address')\n[Python SDK Test/test]   |     def test_invalid_retrieve(self):\n[Python SDK Test/test]   |         self.assertRaises(shippo.error.APIError, shippo.Address.retrieve,\n[Python SDK Test/test]   | >                         'EXAMPLE_OF_INVALID_ID')\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_address.py:56: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:218: in retrieve\n[Python SDK Test/test]   |     response, api_key = requestor.request('get', url)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | ______________________ AddressTests.test_invalid_validate ______________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8f7b2b0>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_address.AddressTests testMethod=test_invalid_validate>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/address')\n[Python SDK Test/test]   |     def test_invalid_validate(self):\n[Python SDK Test/test]   | >       address = shippo.Address.create(**NOT_POSSIBLE_ADDRESS)\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_address.py:71: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:187: in create\n[Python SDK Test/test]   |     response, api_key = requestor.request('post', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8f7b2b0>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | __________________________ AddressTests.test_list_all __________________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b9262ac8>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_address.AddressTests testMethod=test_list_all>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/address')\n[Python SDK Test/test]   |     def test_list_all(self):\n[Python SDK Test/test]   | >       address_list = shippo.Address.all()\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_address.py:60: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:206: in all\n[Python SDK Test/test]   |     response, api_key = requestor.request('get', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b9262ac8>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | _______________________ AddressTests.test_list_page_size _______________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8f3c7b8>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_address.AddressTests testMethod=test_list_page_size>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/address')\n[Python SDK Test/test]   |     def test_list_page_size(self):\n[Python SDK Test/test]   |         pagesize = 1\n[Python SDK Test/test]   | >       address_list = shippo.Address.all(size=pagesize)\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_address.py:66: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:206: in all\n[Python SDK Test/test]   |     response, api_key = requestor.request('get', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8f3c7b8>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | __________________________ AddressTests.test_retrieve __________________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b91ee1d0>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_address.AddressTests testMethod=test_retrieve>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/address')\n[Python SDK Test/test]   |     def test_retrieve(self):\n[Python SDK Test/test]   | >       address = shippo.Address.create(**DUMMY_ADDRESS)\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_address.py:49: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:187: in create\n[Python SDK Test/test]   |     response, api_key = requestor.request('post', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b91ee1d0>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | __________________________ AddressTests.test_validate __________________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8b950f0>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_address.AddressTests testMethod=test_validate>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/address')\n[Python SDK Test/test]   |     def test_validate(self):\n[Python SDK Test/test]   | >       address = shippo.Address.create(**DUMMY_ADDRESS)\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_address.py:78: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:187: in create\n[Python SDK Test/test]   |     response, api_key = requestor.request('post', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8b950f0>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | ___________________ APIRequestorTests.test_oauth_token_auth ____________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8f46898>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_api_requestor.APIRequestorTests testMethod=test_oauth_token_auth>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def test_oauth_token_auth(self):\n[Python SDK Test/test]   |         config.app_name = 'TestApp'\n[Python SDK Test/test]   |         config.app_version = '1.1.1'\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         mock_client = Mock()\n[Python SDK Test/test]   |         mock_client.name = 'mock_client'\n[Python SDK Test/test]   |         mock_client.request.return_value = ('{\"status\": \"ok\"}', 200)\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         requestor = api_requestor.APIRequestor(\n[Python SDK Test/test]   |             key='oauth.mocktoken.mocksig', client=mock_client)\n[Python SDK Test/test]   | >       requestor.request('GET', '/v1/echo')\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_api_requestor.py:35: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8f46898>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | ___________________ APIRequestorTests.test_shippo_token_auth ___________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b91f61d0>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_api_requestor.APIRequestorTests testMethod=test_shippo_token_auth>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def test_shippo_token_auth(self):\n[Python SDK Test/test]   |         config.app_name = 'TestApp'\n[Python SDK Test/test]   |         config.app_version = '1.1.1'\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         mock_client = Mock()\n[Python SDK Test/test]   |         mock_client.name = 'mock_client'\n[Python SDK Test/test]   |         mock_client.request.return_value = ('{\"status\": \"ok\"}', 200)\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         requestor = api_requestor.APIRequestor(\n[Python SDK Test/test]   |             key='shippo_test_mocktoken', client=mock_client)\n[Python SDK Test/test]   | >       requestor.request('GET', '/v1/echo')\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_api_requestor.py:56: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b91f61d0>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | _____________________________ BatchTests.test_add ______________________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8fff208>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_batch.BatchTests testMethod=test_add>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/batch')\n[Python SDK Test/test]   |     def test_add(self):\n[Python SDK Test/test]   |         BATCH = DUMMY_BATCH.copy()\n[Python SDK Test/test]   | >       batch = shippo.Batch.create(**BATCH)\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_batch.py:79: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:187: in create\n[Python SDK Test/test]   |     response, api_key = requestor.request('post', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8fff208>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | ____________________________ BatchTests.test_create ____________________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8f3cf60>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_batch.BatchTests testMethod=test_create>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/batch')\n[Python SDK Test/test]   |     def test_create(self):\n[Python SDK Test/test]   |         BATCH = DUMMY_BATCH.copy()\n[Python SDK Test/test]   | >       batch = shippo.Batch.create(**BATCH)\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_batch.py:42: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:187: in create\n[Python SDK Test/test]   |     response, api_key = requestor.request('post', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8f3cf60>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | _________________________ BatchTests.test_invalid_add __________________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b91eefd0>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_batch.BatchTests testMethod=test_invalid_add>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/batch')\n[Python SDK Test/test]   |     def test_invalid_add(self):\n[Python SDK Test/test]   |         BATCH = DUMMY_BATCH.copy()\n[Python SDK Test/test]   | >       batch = shippo.Batch.create(**BATCH)\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_batch.py:95: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:187: in create\n[Python SDK Test/test]   |     response, api_key = requestor.request('post', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b91eefd0>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | ________________________ BatchTests.test_invalid_create ________________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_batch.BatchTests testMethod=test_invalid_create>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/batch')\n[Python SDK Test/test]   |     def test_invalid_create(self):\n[Python SDK Test/test]   |         self.assertRaises(shippo.error.InvalidRequestError,\n[Python SDK Test/test]   | >                         shippo.Batch.create)\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_batch.py:48: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:187: in create\n[Python SDK Test/test]   |     response, api_key = requestor.request('post', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | _______________________ BatchTests.test_invalid_purchase _______________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_batch.BatchTests testMethod=test_invalid_purchase>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/batch')\n[Python SDK Test/test]   |     def test_invalid_purchase(self):\n[Python SDK Test/test]   |         self.assertRaises(\n[Python SDK Test/test]   |             shippo.error.APIError,\n[Python SDK Test/test]   |             shippo.Batch.purchase,\n[Python SDK Test/test]   | >           'INVALID_OBJECT_ID'\n[Python SDK Test/test]   |         )\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_batch.py:156: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:625: in purchase\n[Python SDK Test/test]   |     response, api_key = requestor.request('post', url)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | ________________________ BatchTests.test_invalid_remove ________________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b920ba58>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_batch.BatchTests testMethod=test_invalid_remove>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/batch')\n[Python SDK Test/test]   |     def test_invalid_remove(self):\n[Python SDK Test/test]   |         BATCH = DUMMY_BATCH.copy()\n[Python SDK Test/test]   | >       batch = shippo.Batch.create(**BATCH)\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_batch.py:129: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:187: in create\n[Python SDK Test/test]   |     response, api_key = requestor.request('post', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b920ba58>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | _______________________ BatchTests.test_invalid_retrieve _______________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_batch.BatchTests testMethod=test_invalid_retrieve>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/batch')\n[Python SDK Test/test]   |     def test_invalid_retrieve(self):\n[Python SDK Test/test]   |         self.assertRaises(shippo.error.APIError,\n[Python SDK Test/test]   | >                         shippo.Batch.retrieve, 'EXAMPLE_OF_INVALID_ID')\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_batch.py:74: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:555: in retrieve\n[Python SDK Test/test]   |     response, api_key = requestor.request('get', url)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | ___________________________ BatchTests.test_purchase ___________________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8fdf630>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_batch.BatchTests testMethod=test_purchase>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/batch')\n[Python SDK Test/test]   |     def test_purchase(self):\n[Python SDK Test/test]   |         BATCH = DUMMY_BATCH.copy()\n[Python SDK Test/test]   | >       batch = shippo.Batch.create(**BATCH)\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_batch.py:145: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:187: in create\n[Python SDK Test/test]   |     response, api_key = requestor.request('post', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8fdf630>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | ____________________________ BatchTests.test_remove ____________________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8fa2358>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_batch.BatchTests testMethod=test_remove>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/batch')\n[Python SDK Test/test]   |     def test_remove(self):\n[Python SDK Test/test]   |         BATCH = DUMMY_BATCH.copy()\n[Python SDK Test/test]   | >       batch = shippo.Batch.create(**BATCH)\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_batch.py:108: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:187: in create\n[Python SDK Test/test]   |     response, api_key = requestor.request('post', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8fa2358>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | ___________________________ BatchTests.test_retrieve ___________________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8e97c18>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_batch.BatchTests testMethod=test_retrieve>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/batch')\n[Python SDK Test/test]   |     def test_retrieve(self):\n[Python SDK Test/test]   |         BATCH = DUMMY_BATCH.copy()\n[Python SDK Test/test]   | >       batch = shippo.Batch.create(**BATCH)\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_batch.py:59: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:187: in create\n[Python SDK Test/test]   |     response, api_key = requestor.request('post', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8e97c18>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | _____________________ CustomsDeclarationTests.test_create ______________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8a8bd30>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_customs_declaration.CustomsDeclarationTests testMethod=test_create>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/customs-declaration')\n[Python SDK Test/test]   |     def test_create(self):\n[Python SDK Test/test]   | >       customs_item = shippo.CustomsItem.create(**DUMMY_CUSTOMS_ITEM)\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_customs_declaration.py:44: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:187: in create\n[Python SDK Test/test]   |     response, api_key = requestor.request('post', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8a8bd30>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | _________________ CustomsDeclarationTests.test_invalid_create __________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_customs_declaration.CustomsDeclarationTests testMethod=test_invalid_create>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/customs-declaration')\n[Python SDK Test/test]   |     def test_invalid_create(self):\n[Python SDK Test/test]   |         self.assertRaises(shippo.error.InvalidRequestError, shippo.CustomsDeclaration.create,\n[Python SDK Test/test]   | >                         **INVALID_CUSTOMS_DECLARATION)\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_customs_declaration.py:40: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:187: in create\n[Python SDK Test/test]   |     response, api_key = requestor.request('post', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | ________________ CustomsDeclarationTests.test_invalid_retrieve _________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_customs_declaration.CustomsDeclarationTests testMethod=test_invalid_retrieve>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/customs-declaration')\n[Python SDK Test/test]   |     def test_invalid_retrieve(self):\n[Python SDK Test/test]   |         self.assertRaises(\n[Python SDK Test/test]   |             shippo.error.APIError,\n[Python SDK Test/test]   |             shippo.CustomsDeclaration.retrieve,\n[Python SDK Test/test]   | >           'EXAMPLE_OF_INVALID_ID'\n[Python SDK Test/test]   |         )\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_customs_declaration.py:68: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:218: in retrieve\n[Python SDK Test/test]   |     response, api_key = requestor.request('get', url)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | ____________________ CustomsDeclarationTests.test_list_all _____________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8fa2470>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_customs_declaration.CustomsDeclarationTests testMethod=test_list_all>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/customs-declaration')\n[Python SDK Test/test]   |     def test_list_all(self):\n[Python SDK Test/test]   | >       customs_declaration_list = shippo.CustomsDeclaration.all()\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_customs_declaration.py:73: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:206: in all\n[Python SDK Test/test]   |     response, api_key = requestor.request('get', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8fa2470>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | _________________ CustomsDeclarationTests.test_list_page_size __________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8f3cb70>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_customs_declaration.CustomsDeclarationTests testMethod=test_list_page_size>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/customs-declaration')\n[Python SDK Test/test]   |     def test_list_page_size(self):\n[Python SDK Test/test]   |         pagesize = 1\n[Python SDK Test/test]   | >       customs_declaration_list = shippo.CustomsDeclaration.all(size=pagesize)\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_customs_declaration.py:79: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:206: in all\n[Python SDK Test/test]   |     response, api_key = requestor.request('get', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8f3cb70>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | ____________________ CustomsDeclarationTests.test_retrieve _____________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8fb2898>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_customs_declaration.CustomsDeclarationTests testMethod=test_retrieve>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/customs-declaration')\n[Python SDK Test/test]   |     def test_retrieve(self):\n[Python SDK Test/test]   | >       customs_item = shippo.CustomsItem.create(**DUMMY_CUSTOMS_ITEM)\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_customs_declaration.py:53: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:187: in create\n[Python SDK Test/test]   |     response, api_key = requestor.request('post', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8fb2898>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | _________________________ CustomsItemTest.test_create __________________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8a8d1d0>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_customs_item.CustomsItemTest testMethod=test_create>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/customs-item')\n[Python SDK Test/test]   |     def test_create(self):\n[Python SDK Test/test]   | >       customs_item = shippo.CustomsItem.create(**DUMMY_CUSTOMS_ITEM)\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_customs_item.py:42: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:187: in create\n[Python SDK Test/test]   |     response, api_key = requestor.request('post', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8a8d1d0>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | _____________________ CustomsItemTest.test_invalid_create ______________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_customs_item.CustomsItemTest testMethod=test_invalid_create>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/customs-item')\n[Python SDK Test/test]   |     def test_invalid_create(self):\n[Python SDK Test/test]   |         self.assertRaises(shippo.error.InvalidRequestError, shippo.CustomsItem.create,\n[Python SDK Test/test]   | >                         **INVALID_CUSTOMS_ITEM)\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_customs_item.py:38: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:187: in create\n[Python SDK Test/test]   |     response, api_key = requestor.request('post', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | ____________________ CustomsItemTest.test_invalid_retrieve _____________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_customs_item.CustomsItemTest testMethod=test_invalid_retrieve>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/customs-item')\n[Python SDK Test/test]   |     def test_invalid_retrieve(self):\n[Python SDK Test/test]   |         self.assertRaises(shippo.error.APIError,\n[Python SDK Test/test]   | >                         shippo.CustomsItem.retrieve, 'EXAMPLE_OF_INVALID_ID')\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_customs_item.py:54: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:218: in retrieve\n[Python SDK Test/test]   |     response, api_key = requestor.request('get', url)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | ________________________ CustomsItemTest.test_list_all _________________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8b6d438>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_customs_item.CustomsItemTest testMethod=test_list_all>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/customs-item')\n[Python SDK Test/test]   |     def test_list_all(self):\n[Python SDK Test/test]   | >       customs_items_list = shippo.CustomsItem.all()\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_customs_item.py:58: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:206: in all\n[Python SDK Test/test]   |     response, api_key = requestor.request('get', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8b6d438>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | _____________________ CustomsItemTest.test_list_page_size ______________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8f7b860>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_customs_item.CustomsItemTest testMethod=test_list_page_size>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/customs-item')\n[Python SDK Test/test]   |     def test_list_page_size(self):\n[Python SDK Test/test]   |         pagesize = 1\n[Python SDK Test/test]   | >       customs_items_list = shippo.CustomsItem.all(size=pagesize)\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_customs_item.py:64: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:206: in all\n[Python SDK Test/test]   |     response, api_key = requestor.request('get', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8f7b860>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | ________________________ CustomsItemTest.test_retrieve _________________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8fb3358>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_customs_item.CustomsItemTest testMethod=test_retrieve>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/customs-item')\n[Python SDK Test/test]   |     def test_retrieve(self):\n[Python SDK Test/test]   | >       customs_item = shippo.CustomsItem.create(**DUMMY_CUSTOMS_ITEM)\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_customs_item.py:47: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:187: in create\n[Python SDK Test/test]   |     response, api_key = requestor.request('post', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8fb3358>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | __________________________ ManifestTests.test_create ___________________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b920ba20>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_manifest.ManifestTests testMethod=test_create>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/manifest')\n[Python SDK Test/test]   |     def test_create(self):\n[Python SDK Test/test]   | >       transaction = create_mock_transaction()\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_manifest.py:48: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/test/helper.py:385: in create_mock_transaction\n[Python SDK Test/test]   |     shipment = create_mock_shipment(asynchronous)\n[Python SDK Test/test]   | shippo/test/helper.py:360: in create_mock_shipment\n[Python SDK Test/test]   |     to_address = shippo.Address.create(api_key=api_key, **TO_ADDRESS)\n[Python SDK Test/test]   | shippo/resource.py:187: in create\n[Python SDK Test/test]   |     response, api_key = requestor.request('post', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b920ba20>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | ______________________ ManifestTests.test_invalid_create _______________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_manifest.ManifestTests testMethod=test_invalid_create>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/manifest')\n[Python SDK Test/test]   |     def test_invalid_create(self):\n[Python SDK Test/test]   |         self.assertRaises(\n[Python SDK Test/test]   |             shippo.error.InvalidRequestError, shippo.Manifest.create,\n[Python SDK Test/test]   | >           **INVALID_MANIFEST)\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_manifest.py:44: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:187: in create\n[Python SDK Test/test]   |     response, api_key = requestor.request('post', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | _____________________ ManifestTests.test_invalid_retrieve ______________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_manifest.ManifestTests testMethod=test_invalid_retrieve>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/manifest')\n[Python SDK Test/test]   |     def test_invalid_retrieve(self):\n[Python SDK Test/test]   |         self.assertRaises(shippo.error.APIError, shippo.Manifest.retrieve,\n[Python SDK Test/test]   | >                         'EXAMPLE_OF_INVALID_ID')\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_manifest.py:62: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:218: in retrieve\n[Python SDK Test/test]   |     response, api_key = requestor.request('get', url)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | _________________________ ManifestTests.test_list_all __________________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8f7ef98>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_manifest.ManifestTests testMethod=test_list_all>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/manifest')\n[Python SDK Test/test]   |     def test_list_all(self):\n[Python SDK Test/test]   | >       manifest_list = shippo.Manifest.all()\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_manifest.py:66: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:206: in all\n[Python SDK Test/test]   |     response, api_key = requestor.request('get', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8f7ef98>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | ______________________ ManifestTests.test_list_page_size _______________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8e8a208>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_manifest.ManifestTests testMethod=test_list_page_size>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/manifest')\n[Python SDK Test/test]   |     def test_list_page_size(self):\n[Python SDK Test/test]   |         pagesize = 1\n[Python SDK Test/test]   | >       manifest_list = shippo.Manifest.all(size=pagesize)\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_manifest.py:72: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:206: in all\n[Python SDK Test/test]   |     response, api_key = requestor.request('get', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8e8a208>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | _________________________ ManifestTests.test_retrieve __________________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8f0c278>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_manifest.ManifestTests testMethod=test_retrieve>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/manifest')\n[Python SDK Test/test]   |     def test_retrieve(self):\n[Python SDK Test/test]   | >       manifest = create_mock_manifest()\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_manifest.py:55: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/test/helper.py:374: in create_mock_manifest\n[Python SDK Test/test]   |     transaction = create_mock_transaction()\n[Python SDK Test/test]   | shippo/test/helper.py:385: in create_mock_transaction\n[Python SDK Test/test]   |     shipment = create_mock_shipment(asynchronous)\n[Python SDK Test/test]   | shippo/test/helper.py:360: in create_mock_shipment\n[Python SDK Test/test]   |     to_address = shippo.Address.create(api_key=api_key, **TO_ADDRESS)\n[Python SDK Test/test]   | shippo/resource.py:187: in create\n[Python SDK Test/test]   |     response, api_key = requestor.request('post', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8f0c278>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | ____________________________ OrderTests.test_create ____________________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8b6e1d0>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_order.OrderTests testMethod=test_create>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/order')\n[Python SDK Test/test]   |     def test_create(self):\n[Python SDK Test/test]   |         ORDER = DUMMY_ORDER\n[Python SDK Test/test]   |         ORDER['placed_at'] = datetime.now().isoformat() + \"Z\"\n[Python SDK Test/test]   | >       order = shippo.Order.create(**ORDER)\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_order.py:45: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:187: in create\n[Python SDK Test/test]   |     response, api_key = requestor.request('post', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8b6e1d0>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | ________________________ OrderTests.test_invalid_create ________________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_order.OrderTests testMethod=test_invalid_create>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/order')\n[Python SDK Test/test]   |     def test_invalid_create(self):\n[Python SDK Test/test]   |         self.assertRaises(shippo.error.InvalidRequestError,\n[Python SDK Test/test]   | >                         shippo.Order.create)\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_order.py:39: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:187: in create\n[Python SDK Test/test]   |     response, api_key = requestor.request('post', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | _______________________ OrderTests.test_invalid_retrieve _______________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_order.OrderTests testMethod=test_invalid_retrieve>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/order')\n[Python SDK Test/test]   |     def test_invalid_retrieve(self):\n[Python SDK Test/test]   |         self.assertRaises(shippo.error.APIError,\n[Python SDK Test/test]   | >                         shippo.Order.retrieve, 'EXAMPLE_OF_INVALID_ID')\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_order.py:59: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:218: in retrieve\n[Python SDK Test/test]   |     response, api_key = requestor.request('get', url)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | ___________________________ OrderTests.test_list_all ___________________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8b95208>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_order.OrderTests testMethod=test_list_all>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/order')\n[Python SDK Test/test]   |     def test_list_all(self):\n[Python SDK Test/test]   | >       order_list = shippo.Order.all()\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_order.py:63: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:206: in all\n[Python SDK Test/test]   |     response, api_key = requestor.request('get', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8b95208>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | ________________________ OrderTests.test_list_page_size ________________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8a64198>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_order.OrderTests testMethod=test_list_page_size>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/order')\n[Python SDK Test/test]   |     def test_list_page_size(self):\n[Python SDK Test/test]   |         pagesize = 1\n[Python SDK Test/test]   | >       order_list = shippo.Order.all(size=pagesize)\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_order.py:69: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:206: in all\n[Python SDK Test/test]   |     response, api_key = requestor.request('get', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8a64198>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | ___________________________ OrderTests.test_retrieve ___________________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8a21b70>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_order.OrderTests testMethod=test_retrieve>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/order')\n[Python SDK Test/test]   |     def test_retrieve(self):\n[Python SDK Test/test]   |         ORDER = DUMMY_ORDER\n[Python SDK Test/test]   |         ORDER['placed_at'] = datetime.now().isoformat() + \"Z\"\n[Python SDK Test/test]   | >       order = shippo.Order.create(**ORDER)\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_order.py:52: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:187: in create\n[Python SDK Test/test]   |     response, api_key = requestor.request('post', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8a21b70>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | ___________________________ ParcelTests.test_create ____________________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8e84ac8>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_parcel.ParcelTests testMethod=test_create>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/parcel')\n[Python SDK Test/test]   |     def test_create(self):\n[Python SDK Test/test]   | >       parcel = shippo.Parcel.create(**DUMMY_PARCEL)\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_parcel.py:43: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:187: in create\n[Python SDK Test/test]   |     response, api_key = requestor.request('post', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8e84ac8>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | _______________________ ParcelTests.test_invalid_create ________________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_parcel.ParcelTests testMethod=test_invalid_create>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/parcel')\n[Python SDK Test/test]   |     def test_invalid_create(self):\n[Python SDK Test/test]   |         self.assertRaises(shippo.error.InvalidRequestError,\n[Python SDK Test/test]   | >                         shippo.Parcel.create, **INVALID_PARCEL)\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_parcel.py:39: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:187: in create\n[Python SDK Test/test]   |     response, api_key = requestor.request('post', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | ______________________ ParcelTests.test_invalid_retrieve _______________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_parcel.ParcelTests testMethod=test_invalid_retrieve>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/parcel')\n[Python SDK Test/test]   |     def test_invalid_retrieve(self):\n[Python SDK Test/test]   |         self.assertRaises(shippo.error.APIError,\n[Python SDK Test/test]   | >                         shippo.Parcel.retrieve, 'EXAMPLE_OF_INVALID_ID')\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_parcel.py:55: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:218: in retrieve\n[Python SDK Test/test]   |     response, api_key = requestor.request('get', url)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | __________________________ ParcelTests.test_list_all ___________________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8f6f9e8>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_parcel.ParcelTests testMethod=test_list_all>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/parcel')\n[Python SDK Test/test]   |     def test_list_all(self):\n[Python SDK Test/test]   | >       parcel_list = shippo.Parcel.all()\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_parcel.py:59: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:206: in all\n[Python SDK Test/test]   |     response, api_key = requestor.request('get', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8f6f9e8>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | _______________________ ParcelTests.test_list_page_size ________________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8f957b8>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_parcel.ParcelTests testMethod=test_list_page_size>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/parcel')\n[Python SDK Test/test]   |     def test_list_page_size(self):\n[Python SDK Test/test]   |         pagesize = 2\n[Python SDK Test/test]   | >       parcel_list = shippo.Parcel.all(size=pagesize)\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_parcel.py:65: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:206: in all\n[Python SDK Test/test]   |     response, api_key = requestor.request('get', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8f957b8>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | __________________________ ParcelTests.test_retrieve ___________________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8f6fe10>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_parcel.ParcelTests testMethod=test_retrieve>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/parcel')\n[Python SDK Test/test]   |     def test_retrieve(self):\n[Python SDK Test/test]   | >       parcel = shippo.Parcel.create(**DUMMY_PARCEL)\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_parcel.py:48: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:187: in create\n[Python SDK Test/test]   |     response, api_key = requestor.request('post', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8f6fe10>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | ___________________________ PickupTests.test_create ____________________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8f95a58>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_pickup.PickupTests testMethod=test_create>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/pickup')\n[Python SDK Test/test]   |     def test_create(self):\n[Python SDK Test/test]   | >       transaction, carrier_account = create_mock_international_transaction()\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_pickup.py:39: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/test/helper.py:408: in create_mock_international_transaction\n[Python SDK Test/test]   |     shipment = create_mock_shipment(asynchronous)\n[Python SDK Test/test]   | shippo/test/helper.py:360: in create_mock_shipment\n[Python SDK Test/test]   |     to_address = shippo.Address.create(api_key=api_key, **TO_ADDRESS)\n[Python SDK Test/test]   | shippo/resource.py:187: in create\n[Python SDK Test/test]   |     response, api_key = requestor.request('post', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8f95a58>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | _______________________ RateTests.test_invalid_retrieve ________________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_rate.RateTests testMethod=test_invalid_retrieve>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/rate')\n[Python SDK Test/test]   |     def test_invalid_retrieve(self):\n[Python SDK Test/test]   |         self.assertRaises(shippo.error.APIError,\n[Python SDK Test/test]   | >                         shippo.Rate.retrieve, 'EXAMPLE_OF_INVALID_ID')\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_rate.py:47: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:218: in retrieve\n[Python SDK Test/test]   |     response, api_key = requestor.request('get', url)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | ___________________________ RateTests.test_retrieve ____________________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8a9c198>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_rate.RateTests testMethod=test_retrieve>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/rate')\n[Python SDK Test/test]   |     def test_retrieve(self):\n[Python SDK Test/test]   | >       shipment = create_mock_shipment()\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_rate.py:37: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/test/helper.py:360: in create_mock_shipment\n[Python SDK Test/test]   |     to_address = shippo.Address.create(api_key=api_key, **TO_ADDRESS)\n[Python SDK Test/test]   | shippo/resource.py:187: in create\n[Python SDK Test/test]   |     response, api_key = requestor.request('post', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8a9c198>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | __________________________ ShipmentTests.test_create ___________________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8ad30b8>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_shipment.ShipmentTests testMethod=test_create>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/shipment')\n[Python SDK Test/test]   |     def test_create(self):\n[Python SDK Test/test]   | >       shipment = create_mock_shipment()\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_shipment.py:43: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/test/helper.py:360: in create_mock_shipment\n[Python SDK Test/test]   |     to_address = shippo.Address.create(api_key=api_key, **TO_ADDRESS)\n[Python SDK Test/test]   | shippo/resource.py:187: in create\n[Python SDK Test/test]   |     response, api_key = requestor.request('post', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8ad30b8>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | _________________________ ShipmentTests.test_get_rate __________________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60ba230a90>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_shipment.ShipmentTests testMethod=test_get_rate>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/shipment')\n[Python SDK Test/test]   |     def test_get_rate(self):\n[Python SDK Test/test]   | >       shipment = create_mock_shipment()\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_shipment.py:70: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/test/helper.py:360: in create_mock_shipment\n[Python SDK Test/test]   |     to_address = shippo.Address.create(api_key=api_key, **TO_ADDRESS)\n[Python SDK Test/test]   | shippo/resource.py:187: in create\n[Python SDK Test/test]   |     response, api_key = requestor.request('post', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60ba230a90>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | ____________________ ShipmentTests.test_get_rates_blocking _____________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8f3dc50>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_shipment.ShipmentTests testMethod=test_get_rates_blocking>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/shipment')\n[Python SDK Test/test]   |     def test_get_rates_blocking(self):\n[Python SDK Test/test]   | >       shipment = create_mock_shipment()\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_shipment.py:76: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/test/helper.py:360: in create_mock_shipment\n[Python SDK Test/test]   |     to_address = shippo.Address.create(api_key=api_key, **TO_ADDRESS)\n[Python SDK Test/test]   | shippo/resource.py:187: in create\n[Python SDK Test/test]   |     response, api_key = requestor.request('post', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8f3dc50>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | ______________________ ShipmentTests.test_invalid_create _______________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_shipment.ShipmentTests testMethod=test_invalid_create>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/shipment')\n[Python SDK Test/test]   |     def test_invalid_create(self):\n[Python SDK Test/test]   |         self.assertRaises(shippo.error.InvalidRequestError, shippo.Shipment.create,\n[Python SDK Test/test]   | >                         **INVALID_SHIPMENT)\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_shipment.py:39: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:187: in create\n[Python SDK Test/test]   |     response, api_key = requestor.request('post', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | _____________________ ShipmentTests.test_invalid_get_rate ______________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_shipment.ShipmentTests testMethod=test_invalid_get_rate>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/shipment')\n[Python SDK Test/test]   |     def test_invalid_get_rate(self):\n[Python SDK Test/test]   |         # we are testing asynchronous=True in order to test the 2nd API call of the function\n[Python SDK Test/test]   |         self.assertRaises(shippo.error.APIError, shippo.Shipment.get_rates,\n[Python SDK Test/test]   | >                         'EXAMPLE_OF_INVALID_ID', asynchronous=True)\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_shipment.py:85: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:349: in get_rates\n[Python SDK Test/test]   |     response, api_key = requestor.request('get', url)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | _____________________ ShipmentTests.test_invalid_retrieve ______________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_shipment.ShipmentTests testMethod=test_invalid_retrieve>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/shipment')\n[Python SDK Test/test]   |     def test_invalid_retrieve(self):\n[Python SDK Test/test]   |         self.assertRaises(shippo.error.APIError, shippo.Shipment.retrieve,\n[Python SDK Test/test]   | >                         'EXAMPLE_OF_INVALID_ID')\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_shipment.py:55: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:218: in retrieve\n[Python SDK Test/test]   |     response, api_key = requestor.request('get', url)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | _________________________ ShipmentTests.test_list_all __________________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8f95da0>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_shipment.ShipmentTests testMethod=test_list_all>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/shipment')\n[Python SDK Test/test]   |     def test_list_all(self):\n[Python SDK Test/test]   | >       shipment_list = shippo.Shipment.all()\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_shipment.py:59: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:206: in all\n[Python SDK Test/test]   |     response, api_key = requestor.request('get', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8f95da0>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | ______________________ ShipmentTests.test_list_page_size _______________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8fb2f98>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_shipment.ShipmentTests testMethod=test_list_page_size>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/shipment')\n[Python SDK Test/test]   |     def test_list_page_size(self):\n[Python SDK Test/test]   |         pagesize = 1\n[Python SDK Test/test]   | >       shipment_list = shippo.Shipment.all(size=pagesize)\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_shipment.py:65: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:206: in all\n[Python SDK Test/test]   |     response, api_key = requestor.request('get', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8fb2f98>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | _________________________ ShipmentTests.test_retrieve __________________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8a931d0>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_shipment.ShipmentTests testMethod=test_retrieve>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/shipment')\n[Python SDK Test/test]   |     def test_retrieve(self):\n[Python SDK Test/test]   | >       shipment = create_mock_shipment()\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_shipment.py:48: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/test/helper.py:360: in create_mock_shipment\n[Python SDK Test/test]   |     to_address = shippo.Address.create(api_key=api_key, **TO_ADDRESS)\n[Python SDK Test/test]   | shippo/resource.py:187: in create\n[Python SDK Test/test]   |     response, api_key = requestor.request('post', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8a931d0>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | ____________________________ TrackTests.test_create ____________________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b91eeb00>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_track.TrackTests testMethod=test_create>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/track')\n[Python SDK Test/test]   |     def test_create(self):\n[Python SDK Test/test]   |         tracking = shippo.Track.create(\n[Python SDK Test/test]   |             carrier='usps',\n[Python SDK Test/test]   |             tracking_number=self.usps_tracking_no,\n[Python SDK Test/test]   | >           metadata='metadata'\n[Python SDK Test/test]   |         )\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_track.py:62: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:512: in create\n[Python SDK Test/test]   |     return super(Track, cls).create(api_key, **params)\n[Python SDK Test/test]   | shippo/resource.py:187: in create\n[Python SDK Test/test]   |     response, api_key = requestor.request('post', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b91eeb00>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | __________________________ TrackTests.test_get_status __________________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b89e6550>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_track.TrackTests testMethod=test_get_status>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/track')\n[Python SDK Test/test]   |     def test_get_status(self):\n[Python SDK Test/test]   |         carrier_token = 'usps'\n[Python SDK Test/test]   |         tracking = shippo.Track.get_status(\n[Python SDK Test/test]   | >           carrier_token, self.usps_tracking_no)\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_track.py:37: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:489: in get_status\n[Python SDK Test/test]   |     response, api_key = requestor.request('get', url)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b89e6550>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | ________________________ TrackTests.test_invalid_create ________________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_track.TrackTests testMethod=test_invalid_create>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/track')\n[Python SDK Test/test]   |     def test_invalid_create(self):\n[Python SDK Test/test]   |         self.assertRaises(\n[Python SDK Test/test]   |             shippo.error.InvalidRequestError,\n[Python SDK Test/test]   |             shippo.Track.create,\n[Python SDK Test/test]   |             None,\n[Python SDK Test/test]   |             **{\n[Python SDK Test/test]   |                 'carrier': 'EXAMPLE_OF_INVALID_CARRIER',\n[Python SDK Test/test]   |                 'tracking_number': self.usps_tracking_no,\n[Python SDK Test/test]   | >               'metadata': 'metadata'\n[Python SDK Test/test]   |             }\n[Python SDK Test/test]   |         )\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_track.py:77: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:512: in create\n[Python SDK Test/test]   |     return super(Track, cls).create(api_key, **params)\n[Python SDK Test/test]   | shippo/resource.py:187: in create\n[Python SDK Test/test]   |     response, api_key = requestor.request('post', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | ______________________ TrackTests.test_invalid_get_status ______________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_track.TrackTests testMethod=test_invalid_get_status>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/track')\n[Python SDK Test/test]   |     def test_invalid_get_status(self):\n[Python SDK Test/test]   |         self.assertRaises(\n[Python SDK Test/test]   |             shippo.error.InvalidRequestError,\n[Python SDK Test/test]   |             shippo.Track.get_status,\n[Python SDK Test/test]   |             'EXAMPLE_OF_INVALID_CARRIER',\n[Python SDK Test/test]   | >           self.usps_tracking_no\n[Python SDK Test/test]   |         )\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_track.py:48: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:489: in get_status\n[Python SDK Test/test]   |     response, api_key = requestor.request('get', url)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | _________________________ TransactionTests.test_create _________________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8f82390>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_transaction.TransactionTests testMethod=test_create>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/transaction')\n[Python SDK Test/test]   |     def test_create(self):\n[Python SDK Test/test]   | >       shipment = create_mock_shipment()\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_transaction.py:43: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/test/helper.py:360: in create_mock_shipment\n[Python SDK Test/test]   |     to_address = shippo.Address.create(api_key=api_key, **TO_ADDRESS)\n[Python SDK Test/test]   | shippo/resource.py:187: in create\n[Python SDK Test/test]   |     response, api_key = requestor.request('post', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8f82390>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | _____________________ TransactionTests.test_invalid_create _____________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_transaction.TransactionTests testMethod=test_invalid_create>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/transaction')\n[Python SDK Test/test]   |     def test_invalid_create(self):\n[Python SDK Test/test]   |         self.assertRaises(shippo.error.InvalidRequestError,\n[Python SDK Test/test]   | >                         shippo.Transaction.create)\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_transaction.py:39: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:371: in create\n[Python SDK Test/test]   |     return super(Transaction, cls).create(api_key, **params)\n[Python SDK Test/test]   | shippo/resource.py:187: in create\n[Python SDK Test/test]   |     response, api_key = requestor.request('post', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | ____________________ TransactionTests.test_invalid_retrieve ____________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_transaction.TransactionTests testMethod=test_invalid_retrieve>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/transaction')\n[Python SDK Test/test]   |     def test_invalid_retrieve(self):\n[Python SDK Test/test]   |         self.assertRaises(shippo.error.APIError,\n[Python SDK Test/test]   | >                         shippo.Transaction.retrieve, 'EXAMPLE_OF_INVALID_ID')\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_transaction.py:67: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:218: in retrieve\n[Python SDK Test/test]   |     response, api_key = requestor.request('get', url)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | ________________________ TransactionTests.test_list_all ________________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8e57470>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_transaction.TransactionTests testMethod=test_list_all>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/transaction')\n[Python SDK Test/test]   |     def test_list_all(self):\n[Python SDK Test/test]   | >       transaction_list = shippo.Transaction.all()\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_transaction.py:71: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:206: in all\n[Python SDK Test/test]   |     response, api_key = requestor.request('get', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8e57470>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | _____________________ TransactionTests.test_list_page_size _____________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8f36710>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_transaction.TransactionTests testMethod=test_list_page_size>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/transaction')\n[Python SDK Test/test]   |     def test_list_page_size(self):\n[Python SDK Test/test]   |         pagesize = 1\n[Python SDK Test/test]   | >       transaction_list = shippo.Transaction.all(size=pagesize)\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_transaction.py:77: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:206: in all\n[Python SDK Test/test]   |     response, api_key = requestor.request('get', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8f36710>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | ________________________ TransactionTests.test_retrieve ________________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8fdff28>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.test_transaction.TransactionTests testMethod=test_retrieve>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @shippo_vcr.use_cassette(cassette_library_dir='shippo/test/fixtures/transaction')\n[Python SDK Test/test]   |     def test_retrieve(self):\n[Python SDK Test/test]   | >       shipment = create_mock_shipment()\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/test_transaction.py:54: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/test/helper.py:360: in create_mock_shipment\n[Python SDK Test/test]   |     to_address = shippo.Address.create(api_key=api_key, **TO_ADDRESS)\n[Python SDK Test/test]   | shippo/resource.py:187: in create\n[Python SDK Test/test]   |     response, api_key = requestor.request('post', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8fdff28>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | ________________________ FunctionalTests.test_get_rates ________________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8a04be0>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.integration.test_integration.FunctionalTests testMethod=test_get_rates>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def test_get_rates(self):\n[Python SDK Test/test]   |         try:\n[Python SDK Test/test]   | >           shipment = create_mock_shipment()\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/integration/test_integration.py:74: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | asynchronous = False, api_key = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_mock_shipment(asynchronous=False, api_key=None):\n[Python SDK Test/test]   | >       to_address = shippo.Address.create(api_key=api_key, **TO_ADDRESS)\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/helper.py:360: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | cls = <class 'shippo.resource.Address'>, api_key = None\n[Python SDK Test/test]   | params = {'city': 'San Francisco', 'company': 'Initech', 'country': 'US', 'metadata': 'Customer ID 123456', ...}\n[Python SDK Test/test]   | requestor = <shippo.api_requestor.APIRequestor object at 0x7f60b8a04be0>\n[Python SDK Test/test]   | url = 'addresses/'\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @classmethod\n[Python SDK Test/test]   |     def create(cls, api_key=None, **params):\n[Python SDK Test/test]   |         requestor = api_requestor.APIRequestor(api_key)\n[Python SDK Test/test]   |         url = cls.class_url()\n[Python SDK Test/test]   | >       response, api_key = requestor.request('post', url, params)\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/resource.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8a04be0>\n[Python SDK Test/test]   | method = 'post', url = 'addresses/'\n[Python SDK Test/test]   | params = {'city': 'San Francisco', 'company': 'Initech', 'country': 'US', 'metadata': 'Customer ID 123456', ...}\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def request(self, method, url, params=None):\n[Python SDK Test/test]   | >       self._check_ssl_cert()\\\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:68: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b8a04be0>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.integration.test_integration.FunctionalTests testMethod=test_get_rates>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def test_get_rates(self):\n[Python SDK Test/test]   |         try:\n[Python SDK Test/test]   |             shipment = create_mock_shipment()\n[Python SDK Test/test]   |             rates = shippo.Shipment.get_rates(\n[Python SDK Test/test]   |                 shipment.object_id, asynchronous=False)\n[Python SDK Test/test]   |         except shippo.error.InvalidRequestError:\n[Python SDK Test/test]   |             pass\n[Python SDK Test/test]   |         except shippo.error.AuthenticationError:\n[Python SDK Test/test]   |             self.fail('Set your SHIPPO_API_KEY in your os.environ')\n[Python SDK Test/test]   |         except Exception as inst:\n[Python SDK Test/test]   | >           self.fail(\"Test failed with exception %s\" % inst)\n[Python SDK Test/test]   | E           AssertionError: Test failed with exception [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/integration/test_integration.py:82: AssertionError\n[Python SDK Test/test]   | _____________________ FunctionalTests.test_list_accessors ______________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60ba1efba8>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.integration.test_integration.FunctionalTests testMethod=test_list_accessors>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def test_list_accessors(self):\n[Python SDK Test/test]   |         try:\n[Python SDK Test/test]   | >           address = shippo.Address.create(**DUMMY_ADDRESS)\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/integration/test_integration.py:58: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:187: in create\n[Python SDK Test/test]   |     response, api_key = requestor.request('post', url, params)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60ba1efba8>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | ___________________________ FunctionalTests.test_run ___________________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b887fba8>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.integration.test_integration.FunctionalTests testMethod=test_run>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def test_run(self):\n[Python SDK Test/test]   |         try:\n[Python SDK Test/test]   | >           address = shippo.Address.create(**DUMMY_ADDRESS)\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/integration/test_integration.py:47: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | cls = <class 'shippo.resource.Address'>, api_key = None\n[Python SDK Test/test]   | params = {'city': 'San Francisco', 'company': 'Shippo', 'country': 'US', 'metadata': 'Customer ID 123456', ...}\n[Python SDK Test/test]   | requestor = <shippo.api_requestor.APIRequestor object at 0x7f60b887fba8>\n[Python SDK Test/test]   | url = 'addresses/'\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     @classmethod\n[Python SDK Test/test]   |     def create(cls, api_key=None, **params):\n[Python SDK Test/test]   |         requestor = api_requestor.APIRequestor(api_key)\n[Python SDK Test/test]   |         url = cls.class_url()\n[Python SDK Test/test]   | >       response, api_key = requestor.request('post', url, params)\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/resource.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b887fba8>\n[Python SDK Test/test]   | method = 'post', url = 'addresses/'\n[Python SDK Test/test]   | params = {'city': 'San Francisco', 'company': 'Shippo', 'country': 'US', 'metadata': 'Customer ID 123456', ...}\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def request(self, method, url, params=None):\n[Python SDK Test/test]   | >       self._check_ssl_cert()\\\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:68: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.api_requestor.APIRequestor object at 0x7f60b887fba8>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.integration.test_integration.FunctionalTests testMethod=test_run>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def test_run(self):\n[Python SDK Test/test]   |         try:\n[Python SDK Test/test]   |             address = shippo.Address.create(**DUMMY_ADDRESS)\n[Python SDK Test/test]   |             self.assertEqual(address.is_complete, True)\n[Python SDK Test/test]   |             address_validated = shippo.Address.validate(address.object_id)\n[Python SDK Test/test]   |             self.assertEqual(address_validated.is_complete, True)\n[Python SDK Test/test]   |         except shippo.error.AuthenticationError:\n[Python SDK Test/test]   |             self.fail('Set your SHIPPO_API_KEY in your os.environ')\n[Python SDK Test/test]   |         except Exception as inst:\n[Python SDK Test/test]   | >           self.fail(\"Test failed with exception %s\" % inst)\n[Python SDK Test/test]   | E           AssertionError: Test failed with exception [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/integration/test_integration.py:54: AssertionError\n[Python SDK Test/test]   | _________________________ FunctionalTests.test_unicode _________________________\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   | >                   (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:187: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | addr = (None, 443), ssl_version = <_SSLMethod.PROTOCOL_TLS: 2>, ca_certs = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n[Python SDK Test/test]   |         \"\"\"Retrieve the certificate from the server at the specified address,\n[Python SDK Test/test]   |         and return it as a PEM-encoded string.\n[Python SDK Test/test]   |         If 'ca_certs' is specified, validate the server cert against it.\n[Python SDK Test/test]   |         If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = addr\n[Python SDK Test/test]   |         if ca_certs is not None:\n[Python SDK Test/test]   |             cert_reqs = CERT_REQUIRED\n[Python SDK Test/test]   |         else:\n[Python SDK Test/test]   |             cert_reqs = CERT_NONE\n[Python SDK Test/test]   |         context = _create_stdlib_context(ssl_version,\n[Python SDK Test/test]   |                                          cert_reqs=cert_reqs,\n[Python SDK Test/test]   |                                          cafile=ca_certs)\n[Python SDK Test/test]   | >       with  create_connection(addr) as sock:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/ssl.py:1231: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   |                 sock.connect(sa)\n[Python SDK Test/test]   |                 # Break explicitly a reference cycle\n[Python SDK Test/test]   |                 err = None\n[Python SDK Test/test]   |                 return sock\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |             except error as _:\n[Python SDK Test/test]   |                 err = _\n[Python SDK Test/test]   |                 if sock is not None:\n[Python SDK Test/test]   |                     sock.close()\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if err is not None:\n[Python SDK Test/test]   | >           raise err\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:724: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   | address = (None, 443), timeout = <object object at 0x7f60bad722a0>\n[Python SDK Test/test]   | source_address = None\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n[Python SDK Test/test]   |                           source_address=None):\n[Python SDK Test/test]   |         \"\"\"Connect to *address* and return the socket object.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Convenience function.  Connect to *address* (a 2-tuple ``(host,\n[Python SDK Test/test]   |         port)``) and return the socket object.  Passing the optional\n[Python SDK Test/test]   |         *timeout* parameter will set the timeout on the socket instance\n[Python SDK Test/test]   |         before attempting to connect.  If no *timeout* is supplied, the\n[Python SDK Test/test]   |         global default timeout setting returned by :func:`getdefaulttimeout`\n[Python SDK Test/test]   |         is used.  If *source_address* is set it must be a tuple of (host, port)\n[Python SDK Test/test]   |         for the socket to bind as a source address before making the connection.\n[Python SDK Test/test]   |         A host of '' or port 0 tells the OS to use the default.\n[Python SDK Test/test]   |         \"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         host, port = address\n[Python SDK Test/test]   |         err = None\n[Python SDK Test/test]   |         for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n[Python SDK Test/test]   |             af, socktype, proto, canonname, sa = res\n[Python SDK Test/test]   |             sock = None\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 sock = socket(af, socktype, proto)\n[Python SDK Test/test]   |                 if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n[Python SDK Test/test]   |                     sock.settimeout(timeout)\n[Python SDK Test/test]   |                 if source_address:\n[Python SDK Test/test]   |                     sock.bind(source_address)\n[Python SDK Test/test]   | >               sock.connect(sa)\n[Python SDK Test/test]   | E               OSError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | /opt/hostedtoolcache/Python/3.6.14/x64/lib/python3.6/socket.py:713: OSError\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | During handling of the above exception, another exception occurred:\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | self = <shippo.test.integration.test_integration.FunctionalTests testMethod=test_unicode>\n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def test_unicode(self):\n[Python SDK Test/test]   |         # Make sure unicode requests can be sent\n[Python SDK Test/test]   |         self.assertRaises(shippo.error.APIError,\n[Python SDK Test/test]   |                           shippo.Address.retrieve,\n[Python SDK Test/test]   | >                         '\u2603')\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/test/integration/test_integration.py:70: \n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | shippo/resource.py:218: in retrieve\n[Python SDK Test/test]   |     response, api_key = requestor.request('get', url)\n[Python SDK Test/test]   | shippo/api_requestor.py:68: in request\n[Python SDK Test/test]   |     self._check_ssl_cert()\\\n[Python SDK Test/test]   | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n[Python SDK Test/test]   | \n[Python SDK Test/test]   |     def _check_ssl_cert(self):\n[Python SDK Test/test]   |         \"\"\"Preflight the SSL certificate presented by the backend.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         This isn't 100% bulletproof, in that we're not actually validating the\n[Python SDK Test/test]   |         transport used to communicate with Shippo, merely that the first\n[Python SDK Test/test]   |         attempt to does not use a revoked certificate.\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         Unfortunately the interface to OpenSSL doesn't make it easy to check\n[Python SDK Test/test]   |         the certificate before sending potentially sensitive data on the wire.\n[Python SDK Test/test]   |         This approach raises the bar for an attacker significantly.\"\"\"\n[Python SDK Test/test]   |     \n[Python SDK Test/test]   |         if config.verify_ssl_certs and not self._CERTIFICATE_VERIFIED:\n[Python SDK Test/test]   |             uri = urllib.parse.urlparse(config.api_base)\n[Python SDK Test/test]   |             try:\n[Python SDK Test/test]   |                 certificate = ssl.get_server_certificate(\n[Python SDK Test/test]   |                     (uri.hostname, uri.port or 443))\n[Python SDK Test/test]   |                 der_cert = ssl.PEM_cert_to_DER_cert(certificate)\n[Python SDK Test/test]   |             except socket.error as e:\n[Python SDK Test/test]   | >               raise error.APIConnectionError(e)\n[Python SDK Test/test]   | E               shippo.error.APIConnectionError: [Errno 99] Cannot assign requested address\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | shippo/api_requestor.py:190: APIConnectionError\n[Python SDK Test/test]   | =============================== warnings summary ===============================\n[Python SDK Test/test]   | .tox/py/lib/python3.6/site-packages/requests/__init__.py:104\n[Python SDK Test/test]   |   /tmp/de65f406-fe28-11ed-a890-af2cc187fc11/goshippo-shippo-python-client/.tox/py/lib/python3.6/site-packages/requests/__init__.py:104: RequestsDependencyWarning: urllib3 (1.26.16) or chardet (5.0.0)/charset_normalizer (2.0.12) doesn't match a supported version!\n[Python SDK Test/test]   |     RequestsDependencyWarning)\n[Python SDK Test/test]   | \n[Python SDK Test/test]   | -- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html\n[Python SDK Test/test]   | =========================== short test summary info ============================\n[Python SDK Test/test]   | FAILED shippo/test/test_address.py::AddressTests::test_create - shippo.error....\n[Python SDK Test/test]   | FAILED shippo/test/test_address.py::AddressTests::test_invalid_create - shipp...\n[Python SDK Test/test]   | FAILED shippo/test/test_address.py::AddressTests::test_invalid_retrieve - shi...\n[Python SDK Test/test]   | FAILED shippo/test/test_address.py::AddressTests::test_invalid_validate - shi...\n[Python SDK Test/test]   | FAILED shippo/test/test_address.py::AddressTests::test_list_all - shippo.erro...\n[Python SDK Test/test]   | FAILED shippo/test/test_address.py::AddressTests::test_list_page_size - shipp...\n[Python SDK Test/test]   | FAILED shippo/test/test_address.py::AddressTests::test_retrieve - shippo.erro...\n[Python SDK Test/test]   | FAILED shippo/test/test_address.py::AddressTests::test_validate - shippo.erro...\n[Python SDK Test/test]   | FAILED shippo/test/test_api_requestor.py::APIRequestorTests::test_oauth_token_auth\n[Python SDK Test/test]   | FAILED shippo/test/test_api_requestor.py::APIRequestorTests::test_shippo_token_auth\n[Python SDK Test/test]   | FAILED shippo/test/test_batch.py::BatchTests::test_add - shippo.error.APIConn...\n[Python SDK Test/test]   | FAILED shippo/test/test_batch.py::BatchTests::test_create - shippo.error.APIC...\n[Python SDK Test/test]   | FAILED shippo/test/test_batch.py::BatchTests::test_invalid_add - shippo.error...\n[Python SDK Test/test]   | FAILED shippo/test/test_batch.py::BatchTests::test_invalid_create - shippo.er...\n[Python SDK Test/test]   | FAILED shippo/test/test_batch.py::BatchTests::test_invalid_purchase - shippo....\n[Python SDK Test/test]   | FAILED shippo/test/test_batch.py::BatchTests::test_invalid_remove - shippo.er...\n[Python SDK Test/test]   | FAILED shippo/test/test_batch.py::BatchTests::test_invalid_retrieve - shippo....\n[Python SDK Test/test]   | FAILED shippo/test/test_batch.py::BatchTests::test_purchase - shippo.error.AP...\n[Python SDK Test/test]   | FAILED shippo/test/test_batch.py::BatchTests::test_remove - shippo.error.APIC...\n[Python SDK Test/test]   | FAILED shippo/test/test_batch.py::BatchTests::test_retrieve - shippo.error.AP...\n[Python SDK Test/test]   | FAILED shippo/test/test_customs_declaration.py::CustomsDeclarationTests::test_create\n[Python SDK Test/test]   | FAILED shippo/test/test_customs_declaration.py::CustomsDeclarationTests::test_invalid_create\n[Python SDK Test/test]   | FAILED shippo/test/test_customs_declaration.py::CustomsDeclarationTests::test_invalid_retrieve\n[Python SDK Test/test]   | FAILED shippo/test/test_customs_declaration.py::CustomsDeclarationTests::test_list_all\n[Python SDK Test/test]   | FAILED shippo/test/test_customs_declaration.py::CustomsDeclarationTests::test_list_page_size\n[Python SDK Test/test]   | FAILED shippo/test/test_customs_declaration.py::CustomsDeclarationTests::test_retrieve\n[Python SDK Test/test]   | FAILED shippo/test/test_customs_item.py::CustomsItemTest::test_create - shipp...\n[Python SDK Test/test]   | FAILED shippo/test/test_customs_item.py::CustomsItemTest::test_invalid_create\n[Python SDK Test/test]   | FAILED shippo/test/test_customs_item.py::CustomsItemTest::test_invalid_retrieve\n[Python SDK Test/test]   | FAILED shippo/test/test_customs_item.py::CustomsItemTest::test_list_all - shi...\n[Python SDK Test/test]   | FAILED shippo/test/test_customs_item.py::CustomsItemTest::test_list_page_size\n[Python SDK Test/test]   | FAILED shippo/test/test_customs_item.py::CustomsItemTest::test_retrieve - shi...\n[Python SDK Test/test]   | FAILED shippo/test/test_manifest.py::ManifestTests::test_create - shippo.erro...\n[Python SDK Test/test]   | FAILED shippo/test/test_manifest.py::ManifestTests::test_invalid_create - shi...\n[Python SDK Test/test]   | FAILED shippo/test/test_manifest.py::ManifestTests::test_invalid_retrieve - s...\n[Python SDK Test/test]   | FAILED shippo/test/test_manifest.py::ManifestTests::test_list_all - shippo.er...\n[Python SDK Test/test]   | FAILED shippo/test/test_manifest.py::ManifestTests::test_list_page_size - shi...\n[Python SDK Test/test]   | FAILED shippo/test/test_manifest.py::ManifestTests::test_retrieve - shippo.er...\n[Python SDK Test/test]   | FAILED shippo/test/test_order.py::OrderTests::test_create - shippo.error.APIC...\n[Python SDK Test/test]   | FAILED shippo/test/test_order.py::OrderTests::test_invalid_create - shippo.er...\n[Python SDK Test/test]   | FAILED shippo/test/test_order.py::OrderTests::test_invalid_retrieve - shippo....\n[Python SDK Test/test]   | FAILED shippo/test/test_order.py::OrderTests::test_list_all - shippo.error.AP...\n[Python SDK Test/test]   | FAILED shippo/test/test_order.py::OrderTests::test_list_page_size - shippo.er...\n[Python SDK Test/test]   | FAILED shippo/test/test_order.py::OrderTests::test_retrieve - shippo.error.AP...\n[Python SDK Test/test]   | FAILED shippo/test/test_parcel.py::ParcelTests::test_create - shippo.error.AP...\n[Python SDK Test/test]   | FAILED shippo/test/test_parcel.py::ParcelTests::test_invalid_create - shippo....\n[Python SDK Test/test]   | FAILED shippo/test/test_parcel.py::ParcelTests::test_invalid_retrieve - shipp...\n[Python SDK Test/test]   | FAILED shippo/test/test_parcel.py::ParcelTests::test_list_all - shippo.error....\n[Python SDK Test/test]   | FAILED shippo/test/test_parcel.py::ParcelTests::test_list_page_size - shippo....\n[Python SDK Test/test]   | FAILED shippo/test/test_parcel.py::ParcelTests::test_retrieve - shippo.error....\n[Python SDK Test/test]   | FAILED shippo/test/test_pickup.py::PickupTests::test_create - shippo.error.AP...\n[Python SDK Test/test]   | FAILED shippo/test/test_rate.py::RateTests::test_invalid_retrieve - shippo.er...\n[Python SDK Test/test]   | FAILED shippo/test/test_rate.py::RateTests::test_retrieve - shippo.error.APIC...\n[Python SDK Test/test]   | FAILED shippo/test/test_shipment.py::ShipmentTests::test_create - shippo.erro...\n[Python SDK Test/test]   | FAILED shippo/test/test_shipment.py::ShipmentTests::test_get_rate - shippo.er...\n[Python SDK Test/test]   | FAILED shippo/test/test_shipment.py::ShipmentTests::test_get_rates_blocking\n[Python SDK Test/test]   | FAILED shippo/test/test_shipment.py::ShipmentTests::test_invalid_create - shi...\n[Python SDK Test/test]   | FAILED shippo/test/test_shipment.py::ShipmentTests::test_invalid_get_rate - s...\n[Python SDK Test/test]   | FAILED shippo/test/test_shipment.py::ShipmentTests::test_invalid_retrieve - s...\n[Python SDK Test/test]   | FAILED shippo/test/test_shipment.py::ShipmentTests::test_list_all - shippo.er...\n[Python SDK Test/test]   | FAILED shippo/test/test_shipment.py::ShipmentTests::test_list_page_size - shi...\n[Python SDK Test/test]   | FAILED shippo/test/test_shipment.py::ShipmentTests::test_retrieve - shippo.er...\n[Python SDK Test/test]   | FAILED shippo/test/test_track.py::TrackTests::test_create - shippo.error.APIC...\n[Python SDK Test/test]   | FAILED shippo/test/test_track.py::TrackTests::test_get_status - shippo.error....\n[Python SDK Test/test]   | FAILED shippo/test/test_track.py::TrackTests::test_invalid_create - shippo.er...\n[Python SDK Test/test]   | FAILED shippo/test/test_track.py::TrackTests::test_invalid_get_status - shipp...\n[Python SDK Test/test]   | FAILED shippo/test/test_transaction.py::TransactionTests::test_create - shipp...\n[Python SDK Test/test]   | FAILED shippo/test/test_transaction.py::TransactionTests::test_invalid_create\n[Python SDK Test/test]   | FAILED shippo/test/test_transaction.py::TransactionTests::test_invalid_retrieve\n[Python SDK Test/test]   | FAILED shippo/test/test_transaction.py::TransactionTests::test_list_all - shi...\n[Python SDK Test/test]   | FAILED shippo/test/test_transaction.py::TransactionTests::test_list_page_size\n[Python SDK Test/test]   | FAILED shippo/test/test_transaction.py::TransactionTests::test_retrieve - shi...\n[Python SDK Test/test]   | FAILED shippo/test/integration/test_integration.py::FunctionalTests::test_get_rates\n[Python SDK Test/test]   | FAILED shippo/test/integration/test_integration.py::FunctionalTests::test_list_accessors\n[Python SDK Test/test]   | FAILED shippo/test/integration/test_integration.py::FunctionalTests::test_run\n[Python SDK Test/test]   | FAILED shippo/test/integration/test_integration.py::FunctionalTests::test_unicode\n[Python SDK Test/test]   | =================== 76 failed, 10 passed, 1 warning in 7.75s ===================\n[Python SDK Test/test]   | ERROR: InvocationError for command /tmp/de65f406-fe28-11ed-a890-af2cc187fc11/goshippo-shippo-python-client/.tox/py/bin/pytest -v (exited with code 1)\n[Python SDK Test/test]   | ___________________________________ summary ____________________________________\n[Python SDK Test/test]   | ERROR:   py: commands failed\n[Python SDK Test/test]   \u274c  Failure - Main Run the tests for PROD\n[Python SDK Test/test] exitcode '1': failure\n[Python SDK Test/test] \u2b50 Run Main Send a Slack notification saying if tests are passing/failing for a given Python version\n[Python SDK Test/test]   \ud83d\udc33  docker exec cmd=[bash --noprofile --norc -e -o pipefail /var/run/act/workflow/4.sh] user= workdir=\n[Python SDK Test/test]   | curl: no URL specified!\n[Python SDK Test/test]   | curl: try 'curl --help' or 'curl --manual' for more information\n[Python SDK Test/test]   \u274c  Failure - Main Send a Slack notification saying if tests are passing/failing for a given Python version\n[Python SDK Test/test] exitcode '2': failure\n[Python SDK Test/test] \ud83c\udfc1  Job failed\n",
    "actions_stderr": "Error: Job 'test' failed\n"
}