{
    "repository": "retep998/winapi-rs",
    "clone_url": "https://github.com/retep998/winapi-rs.git",
    "timestamp": "2023-05-30T08:27:21.306241Z",
    "clone_success": true,
    "number of actions": 1,
    "number_of_test_actions": 1,
    "actions_successful": false,
    "actions_stdout": "[Rust/Lin ] \ud83d\ude80  Start image=crawlergpt:latest\n[Rust/WinX] \ud83d\ude80  Start image=crawlergpt:latest\n[Rust/Win ] \ud83d\ude80  Start image=crawlergpt:latest\n[Rust/LinX] \ud83d\ude80  Start image=crawlergpt:latest\n[Rust/Lin ]   \ud83d\udc33  docker pull image=crawlergpt:latest platform= username= forcePull=false\n[Rust/Win ]   \ud83d\udc33  docker pull image=crawlergpt:latest platform= username= forcePull=false\n[Rust/LinX]   \ud83d\udc33  docker pull image=crawlergpt:latest platform= username= forcePull=false\n[Rust/WinX]   \ud83d\udc33  docker pull image=crawlergpt:latest platform= username= forcePull=false\n[Rust/LinX]   \ud83d\udc33  docker create image=crawlergpt:latest platform= entrypoint=[\"tail\" \"-f\" \"/dev/null\"] cmd=[]\n[Rust/Win ]   \ud83d\udc33  docker create image=crawlergpt:latest platform= entrypoint=[\"tail\" \"-f\" \"/dev/null\"] cmd=[]\n[Rust/Lin ]   \ud83d\udc33  docker create image=crawlergpt:latest platform= entrypoint=[\"tail\" \"-f\" \"/dev/null\"] cmd=[]\n[Rust/WinX]   \ud83d\udc33  docker create image=crawlergpt:latest platform= entrypoint=[\"tail\" \"-f\" \"/dev/null\"] cmd=[]\n[Rust/LinX]   \ud83d\udc33  docker run image=crawlergpt:latest platform= entrypoint=[\"tail\" \"-f\" \"/dev/null\"] cmd=[]\n[Rust/WinX]   \ud83d\udc33  docker run image=crawlergpt:latest platform= entrypoint=[\"tail\" \"-f\" \"/dev/null\"] cmd=[]\n[Rust/Lin ]   \ud83d\udc33  docker run image=crawlergpt:latest platform= entrypoint=[\"tail\" \"-f\" \"/dev/null\"] cmd=[]\n[Rust/Win ]   \ud83d\udc33  docker run image=crawlergpt:latest platform= entrypoint=[\"tail\" \"-f\" \"/dev/null\"] cmd=[]\n[Rust/LinX]   \ud83d\udc33  docker exec cmd=[chown -R 1012:1000 /tmp/c1e8dd3a-fec2-11ed-a890-af2cc187fc11/retep998-winapi-rs] user=0 workdir=\n[Rust/LinX]   \u2601  git clone 'https://github.com/actions-rs/toolchain' # ref=v1\n[Rust/LinX] \ud83e\uddea  Matrix: map[target:x86_64-pc-windows-msvc]\n[Rust/LinX] \u2b50 Run Main actions/checkout@v2\n[Rust/LinX]   \u2705  Success - Main actions/checkout@v2\n[Rust/LinX] \u2b50 Run Main actions-rs/toolchain@v1\n[Rust/LinX]   \ud83d\udc33  docker cp src=/home/andre-silva/.cache/act/actions-rs-toolchain@v1/ dst=/var/run/act/actions/actions-rs-toolchain@v1/\n[Rust/LinX]   \ud83d\udc33  docker exec cmd=[chown -R 1012:1000 /var/run/act/actions/actions-rs-toolchain@v1/] user=0 workdir=\n[Rust/LinX]   \ud83d\udc33  docker exec cmd=[node /var/run/act/actions/actions-rs-toolchain@v1/dist/index.js] user= workdir=\n[Rust/Win ]   \ud83d\udc33  docker exec cmd=[chown -R 1012:1000 /tmp/c1e8dd3a-fec2-11ed-a890-af2cc187fc11/retep998-winapi-rs] user=0 workdir=\n[Rust/Lin ]   \ud83d\udc33  docker exec cmd=[chown -R 1012:1000 /tmp/c1e8dd3a-fec2-11ed-a890-af2cc187fc11/retep998-winapi-rs] user=0 workdir=\n[Rust/LinX]   \ud83d\udcac  ::debug::using toolchain from input: nightly\n[Rust/LinX]   \ud83d\udcac  ::debug::Unable to find \"rustup\" executable, installing it now. Reason: Error: Unable to locate executable file: rustup. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.\n[Rust/LinX]   \ud83d\udcac  ::debug::Downloading https://sh.rustup.rs\n[Rust/LinX]   \ud83d\udcac  ::debug::Destination /tmp/b0435816-1e52-4654-a81f-a93f76c72fa7\n[Rust/WinX]   \ud83d\udc33  docker exec cmd=[chown -R 1012:1000 /tmp/c1e8dd3a-fec2-11ed-a890-af2cc187fc11/retep998-winapi-rs] user=0 workdir=\n[Rust/LinX]   \ud83d\udcac  ::debug::download complete\n[Rust/LinX]   \ud83d\udcac  ::debug::Executing chmod 755 on the /tmp/b0435816-1e52-4654-a81f-a93f76c72fa7\n[Rust/LinX]   | [command]/tmp/b0435816-1e52-4654-a81f-a93f76c72fa7 --default-toolchain none -y\n[Rust/LinX]   | info: downloading installer\n[Rust/LinX]   | info: profile set to 'default'\n[Rust/LinX]   | info: default host triple is x86_64-unknown-linux-gnu\n[Rust/LinX]   | info: skipping toolchain installation\n[Rust/LinX]   | \n[Rust/LinX]   | \n[Rust/LinX]   | Rust is installed now. Great!\n[Rust/LinX]   | \n[Rust/LinX]   | To get started you may need to restart your current shell.\n[Rust/LinX]   | This would reload your PATH environment variable to include\n[Rust/LinX]   | Cargo's bin directory ($HOME/.cargo/bin).\n[Rust/LinX]   | \n[Rust/LinX]   | To configure your current shell, run:\n[Rust/LinX]   | source \"$HOME/.cargo/env\"\n[Rust/LinX]   | [command]/home/runneradmin/.cargo/bin/rustup show\n[Rust/LinX]   | Default host: x86_64-unknown-linux-gnu\n[Rust/LinX]   | rustup home:  /home/runneradmin/.rustup\n[Rust/LinX]   | \n[Rust/LinX]   | no active toolchain\n[Rust/LinX]   | [command]/home/runneradmin/.cargo/bin/rustup -V\n[Rust/LinX]   | rustup 1.26.0 (5af9b9484 2023-04-05)\n[Rust/LinX]   | info: This is the version for the rustup toolchain manager, not the rustc compiler.\n[Rust/LinX]   | Installed rustup 1.26.0 support profiles\n[Rust/LinX]   | [command]/home/runneradmin/.cargo/bin/rustup set profile minimal\n[Rust/LinX]   | info: profile set to 'minimal'\n[Rust/LinX]   | [command]/home/runneradmin/.cargo/bin/rustup toolchain install nightly\n[Rust/LinX]   | info: syncing channel updates for 'nightly-x86_64-unknown-linux-gnu'\n[Rust/LinX]   | info: latest update on 2023-05-30, rust version 1.72.0-nightly (498553fc0 2023-05-29)\n[Rust/LinX]   | info: downloading component 'cargo'\n[Rust/LinX]   | info: downloading component 'rust-std'\n[Rust/LinX]   | info: downloading component 'rustc'\n[Rust/Win ]   \u2601  git clone 'https://github.com/actions-rs/toolchain' # ref=v1\n[Rust/Win ] \ud83e\uddea  Matrix: map[toolchain:nightly-x86_64-msvc]\n[Rust/LinX]   | info: installing component 'cargo'\n[Rust/WinX]   \u2601  git clone 'https://github.com/actions-rs/toolchain' # ref=v1\n[Rust/LinX]   | info: installing component 'rust-std'\n[Rust/Lin ]   \u2601  git clone 'https://github.com/actions-rs/toolchain' # ref=v1\n[Rust/WinX] \ud83e\uddea  Matrix: map[target:i686-pc-windows-msvc]\n[Rust/Win ] \u2b50 Run Main actions/checkout@v2\n[Rust/Lin ] \ud83e\uddea  Matrix: map[toolchain:nightly]\n[Rust/WinX] \u2b50 Run Main actions/checkout@v2\n[Rust/Win ]   \u2705  Success - Main actions/checkout@v2\n[Rust/WinX]   \u2705  Success - Main actions/checkout@v2\n[Rust/LinX]   | info: installing component 'rustc'\n[Rust/Lin ] \u2b50 Run Main actions/checkout@v2\n[Rust/Lin ]   \u2705  Success - Main actions/checkout@v2\n[Rust/Win ] \u2b50 Run Main actions-rs/toolchain@v1\n[Rust/LinX]   | \n[Rust/LinX]   |   nightly-x86_64-unknown-linux-gnu installed - rustc 1.72.0-nightly (498553fc0 2023-05-29)\n[Rust/LinX]   | \n[Rust/LinX]   | info: default toolchain set to 'nightly-x86_64-unknown-linux-gnu'\n[Rust/LinX]   | info: checking for self-update\n[Rust/LinX]   | [command]/home/runneradmin/.cargo/bin/rustup default nightly\n[Rust/LinX]   | info: using existing install for 'nightly-x86_64-unknown-linux-gnu'\n[Rust/LinX]   | info: default toolchain set to 'nightly-x86_64-unknown-linux-gnu'\n[Rust/LinX]   | \n[Rust/WinX] \u2b50 Run Main actions-rs/toolchain@v1\n[Rust/LinX]   |   nightly-x86_64-unknown-linux-gnu unchanged - rustc 1.72.0-nightly (498553fc0 2023-05-29)\n[Rust/LinX]   | \n[Rust/LinX]   | [command]/home/runneradmin/.cargo/bin/rustup target add --toolchain nightly x86_64-pc-windows-msvc\n[Rust/LinX]   | info: downloading component 'rust-std' for 'x86_64-pc-windows-msvc'\n[Rust/Win ]   \ud83d\udc33  docker cp src=/home/andre-silva/.cache/act/actions-rs-toolchain@v1/ dst=/var/run/act/actions/actions-rs-toolchain@v1/\n[Rust/LinX]   | info: installing component 'rust-std' for 'x86_64-pc-windows-msvc'\n[Rust/Win ]   \ud83d\udc33  docker exec cmd=[chown -R 1012:1000 /var/run/act/actions/actions-rs-toolchain@v1/] user=0 workdir=\n[Rust/WinX]   \ud83d\udc33  docker cp src=/home/andre-silva/.cache/act/actions-rs-toolchain@v1/ dst=/var/run/act/actions/actions-rs-toolchain@v1/\n[Rust/Lin ] \u2b50 Run Main actions-rs/toolchain@v1\n[Rust/WinX]   \ud83d\udc33  docker exec cmd=[chown -R 1012:1000 /var/run/act/actions/actions-rs-toolchain@v1/] user=0 workdir=\n[Rust/LinX]   \u2753  ::group::Gathering installed versions\n[Rust/LinX]   | [command]/home/runneradmin/.cargo/bin/rustc -V\n[Rust/LinX]   | rustc 1.72.0-nightly (498553fc0 2023-05-29)\n[Rust/LinX]   \u2699  ::set-output:: rustc=1.72.0-nightly (498553fc0 2023-05-29)\n[Rust/LinX]   \u2699  ::set-output:: rustc_hash=498553fc0\n[Rust/LinX]   | [command]/home/runneradmin/.cargo/bin/cargo -V\n[Rust/LinX]   | cargo 1.72.0-nightly (64fb38c97 2023-05-23)\n[Rust/LinX]   \u2699  ::set-output:: cargo=1.72.0-nightly (64fb38c97 2023-05-23)\n[Rust/LinX]   | [command]/home/runneradmin/.cargo/bin/rustup -V\n[Rust/LinX]   | rustup 1.26.0 (5af9b9484 2023-04-05)\n[Rust/LinX]   | info: This is the version for the rustup toolchain manager, not the rustc compiler.\n[Rust/LinX]   | info: The currently active `rustc` version is `rustc 1.72.0-nightly (498553fc0 2023-05-29)`\n[Rust/LinX]   \u2699  ::set-output:: rustup=1.26.0 (5af9b9484 2023-04-05)\n[Rust/LinX]   \u2753  ::endgroup::\n[Rust/LinX]   \u2705  Success - Main actions-rs/toolchain@v1\n[Rust/Lin ]   \ud83d\udc33  docker cp src=/home/andre-silva/.cache/act/actions-rs-toolchain@v1/ dst=/var/run/act/actions/actions-rs-toolchain@v1/\n[Rust/Lin ]   \ud83d\udc33  docker exec cmd=[chown -R 1012:1000 /var/run/act/actions/actions-rs-toolchain@v1/] user=0 workdir=\n[Rust/LinX]   \u2699  ::add-path:: /home/runneradmin/.cargo/bin\n[Rust/LinX] \u2b50 Run Main Build\n[Rust/LinX]   \ud83d\udc33  docker exec cmd=[bash --noprofile --norc -e -o pipefail /var/run/act/workflow/2] user= workdir=\n[Rust/Lin ]   \ud83d\udc33  docker exec cmd=[node /var/run/act/actions/actions-rs-toolchain@v1/dist/index.js] user= workdir=\n[Rust/Win ]   \ud83d\udc33  docker exec cmd=[node /var/run/act/actions/actions-rs-toolchain@v1/dist/index.js] user= workdir=\n[Rust/WinX]   \ud83d\udc33  docker exec cmd=[node /var/run/act/actions/actions-rs-toolchain@v1/dist/index.js] user= workdir=\n[Rust/LinX]   |    Compiling winapi v0.3.9 (/tmp/c1e8dd3a-fec2-11ed-a890-af2cc187fc11/retep998-winapi-rs)\n[Rust/WinX]   \ud83d\udcac  ::debug::using toolchain from input: nightly-x86_64-msvc\n[Rust/WinX]   \ud83d\udcac  ::debug::Unable to find \"rustup\" executable, installing it now. Reason: Error: Unable to locate executable file: rustup. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.\n[Rust/WinX]   \ud83d\udcac  ::debug::Downloading https://sh.rustup.rs\n[Rust/WinX]   \ud83d\udcac  ::debug::Destination /tmp/9229d682-788e-47dc-9a9a-0b6d2e54360b\n[Rust/WinX]   \ud83d\udcac  ::debug::download complete\n[Rust/WinX]   \ud83d\udcac  ::debug::Executing chmod 755 on the /tmp/9229d682-788e-47dc-9a9a-0b6d2e54360b\n[Rust/WinX]   | [command]/tmp/9229d682-788e-47dc-9a9a-0b6d2e54360b --default-toolchain none -y\n[Rust/LinX]   |     Finished dev [unoptimized + debuginfo] target(s) in 1.75s\n[Rust/WinX]   | info: downloading installer\n[Rust/LinX]   |    Compiling winapi v0.3.9 (/tmp/c1e8dd3a-fec2-11ed-a890-af2cc187fc11/retep998-winapi-rs)\n[Rust/Win ]   \ud83d\udcac  ::debug::using toolchain from input: nightly-x86_64-msvc\n[Rust/Lin ]   \ud83d\udcac  ::debug::using toolchain from input: nightly\n[Rust/Lin ]   \ud83d\udcac  ::debug::Unable to find \"rustup\" executable, installing it now. Reason: Error: Unable to locate executable file: rustup. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.\n[Rust/Lin ]   \ud83d\udcac  ::debug::Downloading https://sh.rustup.rs\n[Rust/Lin ]   \ud83d\udcac  ::debug::Destination /tmp/519f768e-4836-4ee1-a76c-c4092956e3b6\n[Rust/Win ]   \ud83d\udcac  ::debug::Unable to find \"rustup\" executable, installing it now. Reason: Error: Unable to locate executable file: rustup. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.\n[Rust/Win ]   \ud83d\udcac  ::debug::Downloading https://sh.rustup.rs\n[Rust/Win ]   \ud83d\udcac  ::debug::Destination /tmp/2154c76f-246e-4897-8bfd-c5b75106c450\n[Rust/Lin ]   \ud83d\udcac  ::debug::download complete\n[Rust/Lin ]   \ud83d\udcac  ::debug::Executing chmod 755 on the /tmp/519f768e-4836-4ee1-a76c-c4092956e3b6\n[Rust/Lin ]   | [command]/tmp/519f768e-4836-4ee1-a76c-c4092956e3b6 --default-toolchain none -y\n[Rust/Win ]   \ud83d\udcac  ::debug::download complete\n[Rust/Win ]   \ud83d\udcac  ::debug::Executing chmod 755 on the /tmp/2154c76f-246e-4897-8bfd-c5b75106c450\n[Rust/Win ]   | [command]/tmp/2154c76f-246e-4897-8bfd-c5b75106c450 --default-toolchain none -y\n[Rust/Win ]   | info: downloading installer\n[Rust/Lin ]   | info: downloading installer\n[Rust/WinX]   | info: profile set to 'default'\n[Rust/WinX]   | info: default host triple is x86_64-unknown-linux-gnu\n[Rust/WinX]   | info: skipping toolchain installation\n[Rust/WinX]   | \n[Rust/WinX]   | \n[Rust/WinX]   | Rust is installed now. Great!\n[Rust/WinX]   | \n[Rust/WinX]   | To get started you may need to restart your current shell.\n[Rust/WinX]   | This would reload your PATH environment variable to include\n[Rust/WinX]   | Cargo's bin directory ($HOME/.cargo/bin).\n[Rust/WinX]   | \n[Rust/WinX]   | To configure your current shell, run:\n[Rust/WinX]   | source \"$HOME/.cargo/env\"\n[Rust/WinX]   | [command]/home/runneradmin/.cargo/bin/rustup show\n[Rust/WinX]   | Default host: x86_64-unknown-linux-gnu\n[Rust/WinX]   | rustup home:  /home/runneradmin/.rustup\n[Rust/WinX]   | \n[Rust/WinX]   | no active toolchain\n[Rust/WinX]   | [command]/home/runneradmin/.cargo/bin/rustup -V\n[Rust/WinX]   | rustup 1.26.0 (5af9b9484 2023-04-05)\n[Rust/WinX]   | info: This is the version for the rustup toolchain manager, not the rustc compiler.\n[Rust/WinX]   | Installed rustup 1.26.0 support profiles\n[Rust/WinX]   | [command]/home/runneradmin/.cargo/bin/rustup set profile minimal\n[Rust/WinX]   | info: profile set to 'minimal'\n[Rust/WinX]   | [command]/home/runneradmin/.cargo/bin/rustup toolchain install nightly-x86_64-msvc\n[Rust/WinX]   | error: DEPRECATED: future versions of rustup will require --force-non-host to install a non-host toolchain as the default.\n[Rust/WinX]   | warning: toolchain 'nightly-x86_64-msvc' may not be able to run on this system.\n[Rust/WinX]   | warning: If you meant to build software to target that platform, perhaps try `rustup target add x86_64-unknown-linux-msvc` instead?\n[Rust/WinX]   | info: syncing channel updates for 'nightly-x86_64-unknown-linux-msvc'\n[Rust/WinX]   | info: latest update on 2023-05-30, rust version 1.72.0-nightly (498553fc0 2023-05-29)\n[Rust/WinX]   | error: target 'x86_64-unknown-linux-msvc' not found in channel.  Perhaps check https://doc.rust-lang.org/nightly/rustc/platform-support.html for available targets\n[Rust/WinX]   \u2757  ::error::The process '/home/runneradmin/.cargo/bin/rustup' failed with exit code 1\n[Rust/WinX]   \u274c  Failure - Main actions-rs/toolchain@v1\n[Rust/Lin ]   | info: profile set to 'default'\n[Rust/Lin ]   | info: default host triple is x86_64-unknown-linux-gnu\n[Rust/Lin ]   | info: skipping toolchain installation\n[Rust/Lin ]   | \n[Rust/Lin ]   | \n[Rust/Lin ]   | Rust is installed now. Great!\n[Rust/Lin ]   | \n[Rust/Lin ]   | To get started you may need to restart your current shell.\n[Rust/Lin ]   | This would reload your PATH environment variable to include\n[Rust/Lin ]   | Cargo's bin directory ($HOME/.cargo/bin).\n[Rust/Lin ]   | \n[Rust/Lin ]   | To configure your current shell, run:\n[Rust/Lin ]   | source \"$HOME/.cargo/env\"\n[Rust/Lin ]   | [command]/home/runneradmin/.cargo/bin/rustup show\n[Rust/Lin ]   | Default host: x86_64-unknown-linux-gnu\n[Rust/Lin ]   | rustup home:  /home/runneradmin/.rustup\n[Rust/Lin ]   | \n[Rust/Lin ]   | no active toolchain\n[Rust/Lin ]   | [command]/home/runneradmin/.cargo/bin/rustup -V\n[Rust/Lin ]   | rustup 1.26.0 (5af9b9484 2023-04-05)\n[Rust/Lin ]   | info: This is the version for the rustup toolchain manager, not the rustc compiler.\n[Rust/Lin ]   | Installed rustup 1.26.0 support profiles\n[Rust/Lin ]   | [command]/home/runneradmin/.cargo/bin/rustup set profile minimal\n[Rust/Lin ]   | info: profile set to 'minimal'\n[Rust/Lin ]   | [command]/home/runneradmin/.cargo/bin/rustup toolchain install nightly\n[Rust/Lin ]   | info: syncing channel updates for 'nightly-x86_64-unknown-linux-gnu'\n[Rust/Lin ]   | info: latest update on 2023-05-30, rust version 1.72.0-nightly (498553fc0 2023-05-29)\n[Rust/Lin ]   | info: downloading component 'cargo'\n[Rust/WinX]   \u2699  ::add-path:: /home/runneradmin/.cargo/bin\n[Rust/WinX] exitcode '1': failure\n[Rust/Win ]   | info: profile set to 'default'\n[Rust/Win ]   | info: default host triple is x86_64-unknown-linux-gnu\n[Rust/Win ]   | info: skipping toolchain installation\n[Rust/Win ]   | \n[Rust/Win ]   | \n[Rust/Win ]   | Rust is installed now. Great!\n[Rust/Win ]   | \n[Rust/Win ]   | To get started you may need to restart your current shell.\n[Rust/Win ]   | This would reload your PATH environment variable to include\n[Rust/Win ]   | Cargo's bin directory ($HOME/.cargo/bin).\n[Rust/Win ]   | \n[Rust/Win ]   | To configure your current shell, run:\n[Rust/Win ]   | source \"$HOME/.cargo/env\"\n[Rust/Win ]   | [command]/home/runneradmin/.cargo/bin/rustup show\n[Rust/Win ]   | Default host: x86_64-unknown-linux-gnu\n[Rust/Win ]   | rustup home:  /home/runneradmin/.rustup\n[Rust/Win ]   | \n[Rust/Win ]   | no active toolchain\n[Rust/Win ]   | [command]/home/runneradmin/.cargo/bin/rustup -V\n[Rust/Win ]   | rustup 1.26.0 (5af9b9484 2023-04-05)\n[Rust/Win ]   | info: This is the version for the rustup toolchain manager, not the rustc compiler.\n[Rust/Win ]   | Installed rustup 1.26.0 support profiles\n[Rust/Win ]   | [command]/home/runneradmin/.cargo/bin/rustup set profile minimal\n[Rust/Win ]   | info: profile set to 'minimal'\n[Rust/Lin ]   | info: downloading component 'rust-std'\n[Rust/Win ]   | [command]/home/runneradmin/.cargo/bin/rustup toolchain install nightly-x86_64-msvc\n[Rust/Win ]   | error: DEPRECATED: future versions of rustup will require --force-non-host to install a non-host toolchain as the default.\n[Rust/Win ]   | warning: toolchain 'nightly-x86_64-msvc' may not be able to run on this system.\n[Rust/Win ]   | warning: If you meant to build software to target that platform, perhaps try `rustup target add x86_64-unknown-linux-msvc` instead?\n[Rust/Win ]   | info: syncing channel updates for 'nightly-x86_64-unknown-linux-msvc'\n[Rust/LinX]   | warning: the type `D2D_SIZE_F` does not permit being left uninitialized\n[Rust/LinX]   |    --> src/macros.rs:222:27\n[Rust/LinX]   |     |\n[Rust/LinX]   | 222 |               let mut ret = $crate::_core::mem::uninitialized();\n[Rust/LinX]   |     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |                             |\n[Rust/LinX]   |     |                             this code causes undefined behavior when executed\n[Rust/LinX]   |     |                             help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n[Rust/LinX]   |     |\n[Rust/LinX]   |    ::: src/um/d2d1.rs:295:1\n[Rust/LinX]   |     |\n[Rust/LinX]   | 295 | / RIDL!{#[uuid(0xa2296057, 0xea42, 0x4099, 0x98, 0x3b, 0x53, 0x9f, 0xb6, 0x50, 0x54, 0x26)]\n[Rust/LinX]   | 296 | | interface ID2D1Bitmap(ID2D1BitmapVtbl): ID2D1Image(ID2D1ImageVtbl) {\n[Rust/LinX]   | 297 | |     #[fixme] fn GetSize() -> D2D1_SIZE_F,\n[Rust/LinX]   | 298 | |     #[fixme] fn GetPixelSize() -> D2D1_SIZE_U,\n[Rust/LinX]   | ...   |\n[Rust/LinX]   | 318 | |     ) -> HRESULT,\n[Rust/LinX]   | 319 | | }}\n[Rust/LinX]   |     | |__- in this macro invocation\n[Rust/LinX]   |     |\n[Rust/LinX]   | note: floats must be initialized (in this struct field)\n[Rust/LinX]   |    --> src/macros.rs:391:15\n[Rust/LinX]   |     |\n[Rust/LinX]   | 391 |               $(pub $field: $ftype,)+\n[Rust/LinX]   |     |                 ^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |\n[Rust/LinX]   |    ::: src/um/dcommon.rs:86:1\n[Rust/LinX]   |     |\n[Rust/LinX]   | 86  | / STRUCT!{struct D2D_SIZE_F {\n[Rust/LinX]   | 87  | |     width: FLOAT,\n[Rust/LinX]   | 88  | |     height: FLOAT,\n[Rust/LinX]   | 89  | | }}\n[Rust/LinX]   |     | |__- in this macro invocation\n[Rust/LinX]   |     = note: `#[warn(invalid_value)]` on by default\n[Rust/LinX]   |     = note: this warning originates in the macro `RIDL` which comes from the expansion of the macro `STRUCT` (in Nightly builds, run with -Z macro-backtrace for more info)\n[Rust/LinX]   | \n[Rust/LinX]   | warning: the type `D2D_SIZE_U` does not permit being left uninitialized\n[Rust/LinX]   |    --> src/macros.rs:222:27\n[Rust/LinX]   |     |\n[Rust/LinX]   | 222 |               let mut ret = $crate::_core::mem::uninitialized();\n[Rust/LinX]   |     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |                             |\n[Rust/LinX]   |     |                             this code causes undefined behavior when executed\n[Rust/LinX]   |     |                             help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n[Rust/LinX]   |     |\n[Rust/LinX]   |    ::: src/um/d2d1.rs:295:1\n[Rust/LinX]   |     |\n[Rust/LinX]   | 295 | / RIDL!{#[uuid(0xa2296057, 0xea42, 0x4099, 0x98, 0x3b, 0x53, 0x9f, 0xb6, 0x50, 0x54, 0x26)]\n[Rust/LinX]   | 296 | | interface ID2D1Bitmap(ID2D1BitmapVtbl): ID2D1Image(ID2D1ImageVtbl) {\n[Rust/LinX]   | 297 | |     #[fixme] fn GetSize() -> D2D1_SIZE_F,\n[Rust/LinX]   | 298 | |     #[fixme] fn GetPixelSize() -> D2D1_SIZE_U,\n[Rust/LinX]   | ...   |\n[Rust/LinX]   | 318 | |     ) -> HRESULT,\n[Rust/LinX]   | 319 | | }}\n[Rust/LinX]   |     | |__- in this macro invocation\n[Rust/LinX]   |     |\n[Rust/LinX]   | note: integers must be initialized (in this struct field)\n[Rust/LinX]   |    --> src/macros.rs:391:15\n[Rust/LinX]   |     |\n[Rust/LinX]   | 391 |               $(pub $field: $ftype,)+\n[Rust/LinX]   |     |                 ^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |\n[Rust/LinX]   |    ::: src/um/dcommon.rs:90:1\n[Rust/LinX]   |     |\n[Rust/LinX]   | 90  | / STRUCT!{struct D2D_SIZE_U {\n[Rust/LinX]   | 91  | |     width: UINT32,\n[Rust/LinX]   | 92  | |     height: UINT32,\n[Rust/LinX]   | 93  | | }}\n[Rust/LinX]   |     | |__- in this macro invocation\n[Rust/LinX]   |     = note: this warning originates in the macro `RIDL` which comes from the expansion of the macro `STRUCT` (in Nightly builds, run with -Z macro-backtrace for more info)\n[Rust/LinX]   | \n[Rust/LinX]   | warning: the type `D2D1_PIXEL_FORMAT` does not permit being left uninitialized\n[Rust/LinX]   |    --> src/macros.rs:222:27\n[Rust/LinX]   |     |\n[Rust/LinX]   | 222 |               let mut ret = $crate::_core::mem::uninitialized();\n[Rust/LinX]   |     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |                             |\n[Rust/LinX]   |     |                             this code causes undefined behavior when executed\n[Rust/LinX]   |     |                             help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n[Rust/LinX]   |     |\n[Rust/LinX]   |    ::: src/um/d2d1.rs:295:1\n[Rust/LinX]   |     |\n[Rust/LinX]   | 295 | / RIDL!{#[uuid(0xa2296057, 0xea42, 0x4099, 0x98, 0x3b, 0x53, 0x9f, 0xb6, 0x50, 0x54, 0x26)]\n[Rust/LinX]   | 296 | | interface ID2D1Bitmap(ID2D1BitmapVtbl): ID2D1Image(ID2D1ImageVtbl) {\n[Rust/LinX]   | 297 | |     #[fixme] fn GetSize() -> D2D1_SIZE_F,\n[Rust/LinX]   | 298 | |     #[fixme] fn GetPixelSize() -> D2D1_SIZE_U,\n[Rust/LinX]   | ...   |\n[Rust/LinX]   | 318 | |     ) -> HRESULT,\n[Rust/LinX]   | 319 | | }}\n[Rust/LinX]   |     | |__- in this macro invocation\n[Rust/LinX]   |     |\n[Rust/LinX]   | note: integers must be initialized (in this struct field)\n[Rust/LinX]   |    --> src/macros.rs:391:15\n[Rust/LinX]   |     |\n[Rust/LinX]   | 391 |               $(pub $field: $ftype,)+\n[Rust/LinX]   |     |                 ^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |\n[Rust/LinX]   |    ::: src/um/dcommon.rs:45:1\n[Rust/LinX]   |     |\n[Rust/LinX]   | 45  | / STRUCT!{struct D2D1_PIXEL_FORMAT {\n[Rust/LinX]   | 46  | |     format: DXGI_FORMAT,\n[Rust/LinX]   | 47  | |     alphaMode: D2D1_ALPHA_MODE,\n[Rust/LinX]   | 48  | | }}\n[Rust/LinX]   |     | |__- in this macro invocation\n[Rust/LinX]   |     = note: this warning originates in the macro `RIDL` which comes from the expansion of the macro `STRUCT` (in Nightly builds, run with -Z macro-backtrace for more info)\n[Rust/LinX]   | \n[Rust/LinX]   | warning: the type `D3DCOLORVALUE` does not permit being left uninitialized\n[Rust/LinX]   |    --> src/macros.rs:222:27\n[Rust/LinX]   |     |\n[Rust/LinX]   | 222 |               let mut ret = $crate::_core::mem::uninitialized();\n[Rust/LinX]   |     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |                             |\n[Rust/LinX]   |     |                             this code causes undefined behavior when executed\n[Rust/LinX]   |     |                             help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n[Rust/LinX]   |     |\n[Rust/LinX]   |    ::: src/um/d2d1.rs:365:1\n[Rust/LinX]   |     |\n[Rust/LinX]   | 365 | / RIDL!{#[uuid(0x2cd906a9, 0x12e2, 0x11dc, 0x9f, 0xed, 0x00, 0x11, 0x43, 0xa0, 0x55, 0xf9)]\n[Rust/LinX]   | 366 | | interface ID2D1SolidColorBrush(ID2D1SolidColorBrushVtbl): ID2D1Brush(ID2D1BrushVtbl) {\n[Rust/LinX]   | 367 | |     fn SetColor(\n[Rust/LinX]   | 368 | |         color: *const D2D1_COLOR_F,\n[Rust/LinX]   | 369 | |     ) -> (),\n[Rust/LinX]   | 370 | |     #[fixme] fn GetColor() -> D2D1_COLOR_F,\n[Rust/LinX]   | 371 | | }}\n[Rust/LinX]   |     | |__- in this macro invocation\n[Rust/LinX]   |     |\n[Rust/LinX]   | note: floats must be initialized (in this struct field)\n[Rust/LinX]   |    --> src/macros.rs:391:15\n[Rust/LinX]   |     |\n[Rust/LinX]   | 391 |               $(pub $field: $ftype,)+\n[Rust/LinX]   |     |                 ^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |\n[Rust/LinX]   |    ::: src/shared/d3d9types.rs:48:1\n[Rust/LinX]   |     |\n[Rust/LinX]   | 48  | / STRUCT!{struct D3DCOLORVALUE {\n[Rust/LinX]   | 49  | |     r: c_float,\n[Rust/LinX]   | 50  | |     g: c_float,\n[Rust/LinX]   | 51  | |     b: c_float,\n[Rust/LinX]   | 52  | |     a: c_float,\n[Rust/LinX]   | 53  | | }}\n[Rust/LinX]   |     | |__- in this macro invocation\n[Rust/LinX]   |     = note: this warning originates in the macro `RIDL` which comes from the expansion of the macro `STRUCT` (in Nightly builds, run with -Z macro-backtrace for more info)\n[Rust/LinX]   | \n[Rust/LinX]   | warning: the type `D2D_POINT_2F` does not permit being left uninitialized\n[Rust/LinX]   |    --> src/macros.rs:222:27\n[Rust/LinX]   |     |\n[Rust/LinX]   | 222 |               let mut ret = $crate::_core::mem::uninitialized();\n[Rust/LinX]   |     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |                             |\n[Rust/LinX]   |     |                             this code causes undefined behavior when executed\n[Rust/LinX]   |     |                             help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n[Rust/LinX]   |     |\n[Rust/LinX]   |    ::: src/um/d2d1.rs:372:1\n[Rust/LinX]   |     |\n[Rust/LinX]   | 372 | / RIDL!{#[uuid(0x2cd906ab, 0x12e2, 0x11dc, 0x9f, 0xed, 0x00, 0x11, 0x43, 0xa0, 0x55, 0xf9)]\n[Rust/LinX]   | 373 | | interface ID2D1LinearGradientBrush(ID2D1LinearGradientBrushVtbl): ID2D1Brush(ID2D1BrushVtbl) {\n[Rust/LinX]   | 374 | |     fn SetStartPoint(\n[Rust/LinX]   | 375 | |         startPoint: D2D1_POINT_2F,\n[Rust/LinX]   | ...   |\n[Rust/LinX]   | 384 | |     ) -> (),\n[Rust/LinX]   | 385 | | }}\n[Rust/LinX]   |     | |__- in this macro invocation\n[Rust/LinX]   |     |\n[Rust/LinX]   | note: floats must be initialized (in this struct field)\n[Rust/LinX]   |    --> src/macros.rs:391:15\n[Rust/LinX]   |     |\n[Rust/LinX]   | 391 |               $(pub $field: $ftype,)+\n[Rust/LinX]   |     |                 ^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |\n[Rust/LinX]   |    ::: src/um/dcommon.rs:53:1\n[Rust/LinX]   |     |\n[Rust/LinX]   | 53  | / STRUCT!{struct D2D_POINT_2F {\n[Rust/LinX]   | 54  | |     x: FLOAT,\n[Rust/LinX]   | 55  | |     y: FLOAT,\n[Rust/LinX]   | 56  | | }}\n[Rust/LinX]   |     | |__- in this macro invocation\n[Rust/LinX]   |     = note: this warning originates in the macro `RIDL` which comes from the expansion of the macro `STRUCT` (in Nightly builds, run with -Z macro-backtrace for more info)\n[Rust/LinX]   | \n[Rust/LinX]   | warning: the type `D2D_POINT_2F` does not permit being left uninitialized\n[Rust/LinX]   |    --> src/macros.rs:222:27\n[Rust/LinX]   |     |\n[Rust/LinX]   | 222 |               let mut ret = $crate::_core::mem::uninitialized();\n[Rust/LinX]   |     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |                             |\n[Rust/LinX]   |     |                             this code causes undefined behavior when executed\n[Rust/LinX]   |     |                             help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n[Rust/LinX]   |     |\n[Rust/LinX]   |    ::: src/um/d2d1.rs:386:1\n[Rust/LinX]   |     |\n[Rust/LinX]   | 386 | / RIDL!{#[uuid(0x2cd906ac, 0x12e2, 0x11dc, 0x9f, 0xed, 0x00, 0x11, 0x43, 0xa0, 0x55, 0xf9)]\n[Rust/LinX]   | 387 | | interface ID2D1RadialGradientBrush(ID2D1RadialGradientBrushVtbl): ID2D1Brush(ID2D1BrushVtbl) {\n[Rust/LinX]   | 388 | |     fn SetCenter(\n[Rust/LinX]   | 389 | |         center: D2D1_POINT_2F,\n[Rust/LinX]   | ...   |\n[Rust/LinX]   | 406 | |     ) -> (),\n[Rust/LinX]   | 407 | | }}\n[Rust/LinX]   |     | |__- in this macro invocation\n[Rust/LinX]   |     |\n[Rust/LinX]   | note: floats must be initialized (in this struct field)\n[Rust/LinX]   |    --> src/macros.rs:391:15\n[Rust/LinX]   |     |\n[Rust/LinX]   | 391 |               $(pub $field: $ftype,)+\n[Rust/LinX]   |     |                 ^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |\n[Rust/LinX]   |    ::: src/um/dcommon.rs:53:1\n[Rust/LinX]   |     |\n[Rust/LinX]   | 53  | / STRUCT!{struct D2D_POINT_2F {\n[Rust/LinX]   | 54  | |     x: FLOAT,\n[Rust/LinX]   | 55  | |     y: FLOAT,\n[Rust/LinX]   | 56  | | }}\n[Rust/LinX]   |     | |__- in this macro invocation\n[Rust/LinX]   |     = note: this warning originates in the macro `RIDL` which comes from the expansion of the macro `STRUCT` (in Nightly builds, run with -Z macro-backtrace for more info)\n[Rust/LinX]   | \n[Rust/LinX]   | warning: the type `D2D_SIZE_F` does not permit being left uninitialized\n[Rust/LinX]   |    --> src/macros.rs:222:27\n[Rust/LinX]   |     |\n[Rust/LinX]   | 222 |               let mut ret = $crate::_core::mem::uninitialized();\n[Rust/LinX]   |     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |                             |\n[Rust/LinX]   |     |                             this code causes undefined behavior when executed\n[Rust/LinX]   |     |                             help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n[Rust/LinX]   |     |\n[Rust/LinX]   |    ::: src/um/d2d1.rs:616:1\n[Rust/LinX]   |     |\n[Rust/LinX]   | 616 | / RIDL!{#[uuid(0x2cd9069b, 0x12e2, 0x11dc, 0x9f, 0xed, 0x00, 0x11, 0x43, 0xa0, 0x55, 0xf9)]\n[Rust/LinX]   | 617 | | interface ID2D1Layer(ID2D1LayerVtbl): ID2D1Resource(ID2D1ResourceVtbl) {\n[Rust/LinX]   | 618 | |     #[fixme] fn GetSize() -> D2D1_SIZE_F,\n[Rust/LinX]   | 619 | | }}\n[Rust/LinX]   |     | |__- in this macro invocation\n[Rust/LinX]   |     |\n[Rust/LinX]   | note: floats must be initialized (in this struct field)\n[Rust/LinX]   |    --> src/macros.rs:391:15\n[Rust/LinX]   |     |\n[Rust/LinX]   | 391 |               $(pub $field: $ftype,)+\n[Rust/LinX]   |     |                 ^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |\n[Rust/LinX]   |    ::: src/um/dcommon.rs:86:1\n[Rust/LinX]   |     |\n[Rust/LinX]   | 86  | / STRUCT!{struct D2D_SIZE_F {\n[Rust/LinX]   | 87  | |     width: FLOAT,\n[Rust/LinX]   | 88  | |     height: FLOAT,\n[Rust/LinX]   | 89  | | }}\n[Rust/LinX]   |     | |__- in this macro invocation\n[Rust/LinX]   |     = note: this warning originates in the macro `RIDL` which comes from the expansion of the macro `STRUCT` (in Nightly builds, run with -Z macro-backtrace for more info)\n[Rust/LinX]   | \n[Rust/LinX]   | warning: the type `D2D1_PIXEL_FORMAT` does not permit being left uninitialized\n[Rust/LinX]   |    --> src/macros.rs:222:27\n[Rust/LinX]   |     |\n[Rust/LinX]   | 222 |               let mut ret = $crate::_core::mem::uninitialized();\n[Rust/LinX]   |     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |                             |\n[Rust/LinX]   |     |                             this code causes undefined behavior when executed\n[Rust/LinX]   |     |                             help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n[Rust/LinX]   |     |\n[Rust/LinX]   |    ::: src/um/d2d1.rs:635:1\n[Rust/LinX]   |     |\n[Rust/LinX]   | 635 | / RIDL!{#[uuid(0x2cd90694, 0x12e2, 0x11dc, 0x9f, 0xed, 0x00, 0x11, 0x43, 0xa0, 0x55, 0xf9)]\n[Rust/LinX]   | 636 | | interface ID2D1RenderTarget(ID2D1RenderTargetVtbl): ID2D1Resource(ID2D1ResourceVtbl) {\n[Rust/LinX]   | 637 | |     fn CreateBitmap(\n[Rust/LinX]   | 638 | |         size: D2D1_SIZE_U,\n[Rust/LinX]   | ...   |\n[Rust/LinX]   | 856 | |     ) -> BOOL,\n[Rust/LinX]   | 857 | | }}\n[Rust/LinX]   |     | |__- in this macro invocation\n[Rust/LinX]   |     |\n[Rust/LinX]   | note: integers must be initialized (in this struct field)\n[Rust/LinX]   |    --> src/macros.rs:391:15\n[Rust/LinX]   |     |\n[Rust/LinX]   | 391 |               $(pub $field: $ftype,)+\n[Rust/LinX]   |     |                 ^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |\n[Rust/LinX]   |    ::: src/um/dcommon.rs:45:1\n[Rust/LinX]   |     |\n[Rust/LinX]   | 45  | / STRUCT!{struct D2D1_PIXEL_FORMAT {\n[Rust/LinX]   | 46  | |     format: DXGI_FORMAT,\n[Rust/LinX]   | 47  | |     alphaMode: D2D1_ALPHA_MODE,\n[Rust/LinX]   | 48  | | }}\n[Rust/LinX]   |     | |__- in this macro invocation\n[Rust/LinX]   |     = note: this warning originates in the macro `RIDL` which comes from the expansion of the macro `STRUCT` (in Nightly builds, run with -Z macro-backtrace for more info)\n[Rust/LinX]   | \n[Rust/LinX]   | warning: the type `D2D_SIZE_F` does not permit being left uninitialized\n[Rust/LinX]   |    --> src/macros.rs:222:27\n[Rust/LinX]   |     |\n[Rust/LinX]   | 222 |               let mut ret = $crate::_core::mem::uninitialized();\n[Rust/LinX]   |     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |                             |\n[Rust/LinX]   |     |                             this code causes undefined behavior when executed\n[Rust/LinX]   |     |                             help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n[Rust/LinX]   |     |\n[Rust/LinX]   |    ::: src/um/d2d1.rs:635:1\n[Rust/LinX]   |     |\n[Rust/LinX]   | 635 | / RIDL!{#[uuid(0x2cd90694, 0x12e2, 0x11dc, 0x9f, 0xed, 0x00, 0x11, 0x43, 0xa0, 0x55, 0xf9)]\n[Rust/LinX]   | 636 | | interface ID2D1RenderTarget(ID2D1RenderTargetVtbl): ID2D1Resource(ID2D1ResourceVtbl) {\n[Rust/LinX]   | 637 | |     fn CreateBitmap(\n[Rust/LinX]   | 638 | |         size: D2D1_SIZE_U,\n[Rust/LinX]   | ...   |\n[Rust/LinX]   | 856 | |     ) -> BOOL,\n[Rust/LinX]   | 857 | | }}\n[Rust/LinX]   |     | |__- in this macro invocation\n[Rust/LinX]   |     |\n[Rust/LinX]   | note: floats must be initialized (in this struct field)\n[Rust/LinX]   |    --> src/macros.rs:391:15\n[Rust/LinX]   |     |\n[Rust/LinX]   | 391 |               $(pub $field: $ftype,)+\n[Rust/LinX]   |     |                 ^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |\n[Rust/LinX]   |    ::: src/um/dcommon.rs:86:1\n[Rust/LinX]   |     |\n[Rust/LinX]   | 86  | / STRUCT!{struct D2D_SIZE_F {\n[Rust/LinX]   | 87  | |     width: FLOAT,\n[Rust/LinX]   | 88  | |     height: FLOAT,\n[Rust/LinX]   | 89  | | }}\n[Rust/LinX]   |     | |__- in this macro invocation\n[Rust/LinX]   |     = note: this warning originates in the macro `RIDL` which comes from the expansion of the macro `STRUCT` (in Nightly builds, run with -Z macro-backtrace for more info)\n[Rust/LinX]   | \n[Rust/LinX]   | warning: the type `D2D_SIZE_U` does not permit being left uninitialized\n[Rust/LinX]   |    --> src/macros.rs:222:27\n[Rust/LinX]   |     |\n[Rust/LinX]   | 222 |               let mut ret = $crate::_core::mem::uninitialized();\n[Rust/LinX]   |     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |                             |\n[Rust/LinX]   |     |                             this code causes undefined behavior when executed\n[Rust/LinX]   |     |                             help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n[Rust/LinX]   |     |\n[Rust/LinX]   |    ::: src/um/d2d1.rs:635:1\n[Rust/LinX]   |     |\n[Rust/LinX]   | 635 | / RIDL!{#[uuid(0x2cd90694, 0x12e2, 0x11dc, 0x9f, 0xed, 0x00, 0x11, 0x43, 0xa0, 0x55, 0xf9)]\n[Rust/LinX]   | 636 | | interface ID2D1RenderTarget(ID2D1RenderTargetVtbl): ID2D1Resource(ID2D1ResourceVtbl) {\n[Rust/LinX]   | 637 | |     fn CreateBitmap(\n[Rust/LinX]   | 638 | |         size: D2D1_SIZE_U,\n[Rust/LinX]   | ...   |\n[Rust/LinX]   | 856 | |     ) -> BOOL,\n[Rust/LinX]   | 857 | | }}\n[Rust/LinX]   |     | |__- in this macro invocation\n[Rust/LinX]   |     |\n[Rust/LinX]   | note: integers must be initialized (in this struct field)\n[Rust/LinX]   |    --> src/macros.rs:391:15\n[Rust/LinX]   |     |\n[Rust/LinX]   | 391 |               $(pub $field: $ftype,)+\n[Rust/LinX]   |     |                 ^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |\n[Rust/LinX]   |    ::: src/um/dcommon.rs:90:1\n[Rust/LinX]   |     |\n[Rust/LinX]   | 90  | / STRUCT!{struct D2D_SIZE_U {\n[Rust/LinX]   | 91  | |     width: UINT32,\n[Rust/LinX]   | 92  | |     height: UINT32,\n[Rust/LinX]   | 93  | | }}\n[Rust/LinX]   |     | |__- in this macro invocation\n[Rust/LinX]   |     = note: this warning originates in the macro `RIDL` which comes from the expansion of the macro `STRUCT` (in Nightly builds, run with -Z macro-backtrace for more info)\n[Rust/LinX]   | \n[Rust/LinX]   | warning: the type `D3D12_HEAP_DESC` does not permit being left uninitialized\n[Rust/LinX]   |     --> src/macros.rs:222:27\n[Rust/LinX]   |      |\n[Rust/LinX]   | 222  |               let mut ret = $crate::_core::mem::uninitialized();\n[Rust/LinX]   |      |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |      |                             |\n[Rust/LinX]   |      |                             this code causes undefined behavior when executed\n[Rust/LinX]   |      |                             help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n[Rust/LinX]   |      |\n[Rust/LinX]   |     ::: src/um/d3d12.rs:1933:1\n[Rust/LinX]   |      |\n[Rust/LinX]   | 1933 | / RIDL!{#[uuid(0x6b3b2502, 0x6e51, 0x45b3, 0x90, 0xee, 0x98, 0x84, 0x26, 0x5e, 0x8d, 0xf3)]\n[Rust/LinX]   | 1934 | | interface ID3D12Heap(ID3D12HeapVtbl): ID3D12Pageable(ID3D12PageableVtbl) {\n[Rust/LinX]   | 1935 | |     #[fixme] fn GetDesc() -> D3D12_HEAP_DESC,\n[Rust/LinX]   | 1936 | | }}\n[Rust/LinX]   |      | |__- in this macro invocation\n[Rust/LinX]   |      |\n[Rust/LinX]   | note: integers must be initialized (in this struct field)\n[Rust/LinX]   |     --> src/macros.rs:391:15\n[Rust/LinX]   |      |\n[Rust/LinX]   | 391  |               $(pub $field: $ftype,)+\n[Rust/LinX]   |      |                 ^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |      |\n[Rust/LinX]   |     ::: src/um/d3d12.rs:963:1\n[Rust/LinX]   |      |\n[Rust/LinX]   | 963  | / STRUCT!{struct D3D12_HEAP_DESC {\n[Rust/LinX]   | 964  | |     SizeInBytes: UINT64,\n[Rust/LinX]   | 965  | |     Properties: D3D12_HEAP_PROPERTIES,\n[Rust/LinX]   | 966  | |     Alignment: UINT64,\n[Rust/LinX]   | 967  | |     Flags: D3D12_HEAP_FLAGS,\n[Rust/LinX]   | 968  | | }}\n[Rust/LinX]   |      | |__- in this macro invocation\n[Rust/LinX]   |      = note: this warning originates in the macro `RIDL` which comes from the expansion of the macro `STRUCT` (in Nightly builds, run with -Z macro-backtrace for more info)\n[Rust/LinX]   | \n[Rust/LinX]   | warning: the type `D3D12_RESOURCE_DESC` does not permit being left uninitialized\n[Rust/LinX]   |     --> src/macros.rs:222:27\n[Rust/LinX]   |      |\n[Rust/LinX]   | 222  |               let mut ret = $crate::_core::mem::uninitialized();\n[Rust/LinX]   |      |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |      |                             |\n[Rust/LinX]   |      |                             this code causes undefined behavior when executed\n[Rust/LinX]   |      |                             help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n[Rust/LinX]   |      |\n[Rust/LinX]   |     ::: src/um/d3d12.rs:1937:1\n[Rust/LinX]   |      |\n[Rust/LinX]   | 1937 | / RIDL!{#[uuid(0x696442be, 0xa72e, 0x4059, 0xbc, 0x79, 0x5b, 0x5c, 0x98, 0x04, 0x0f, 0xad)]\n[Rust/LinX]   | 1938 | | interface ID3D12Resource(ID3D12ResourceVtbl): ID3D12Pageable(ID3D12PageableVtbl) {\n[Rust/LinX]   | 1939 | |     fn Map(\n[Rust/LinX]   | 1940 | |         Subresource: UINT,\n[Rust/LinX]   | ...    |\n[Rust/LinX]   | 1967 | |     ) -> HRESULT,\n[Rust/LinX]   | 1968 | | }}\n[Rust/LinX]   |      | |__- in this macro invocation\n[Rust/LinX]   |      |\n[Rust/LinX]   | note: integers must be initialized (in this struct field)\n[Rust/LinX]   |     --> src/macros.rs:391:15\n[Rust/LinX]   |      |\n[Rust/LinX]   | 391  |               $(pub $field: $ftype,)+\n[Rust/LinX]   |      |                 ^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |      |\n[Rust/LinX]   |     ::: src/um/d3d12.rs:991:1\n[Rust/LinX]   |      |\n[Rust/LinX]   | 991  | / STRUCT!{struct D3D12_RESOURCE_DESC {\n[Rust/LinX]   | 992  | |     Dimension: D3D12_RESOURCE_DIMENSION,\n[Rust/LinX]   | 993  | |     Alignment: UINT64,\n[Rust/LinX]   | 994  | |     Width: UINT64,\n[Rust/LinX]   | ...    |\n[Rust/LinX]   | 1001 | |     Flags: D3D12_RESOURCE_FLAGS,\n[Rust/LinX]   | 1002 | | }}\n[Rust/LinX]   |      | |__- in this macro invocation\n[Rust/LinX]   |      = note: this warning originates in the macro `RIDL` which comes from the expansion of the macro `STRUCT` (in Nightly builds, run with -Z macro-backtrace for more info)\n[Rust/LinX]   | \n[Rust/LinX]   | warning: the type `D3D12_DESCRIPTOR_HEAP_DESC` does not permit being left uninitialized\n[Rust/LinX]   |     --> src/macros.rs:222:27\n[Rust/LinX]   |      |\n[Rust/LinX]   | 222  |               let mut ret = $crate::_core::mem::uninitialized();\n[Rust/LinX]   |      |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |      |                             |\n[Rust/LinX]   |      |                             this code causes undefined behavior when executed\n[Rust/LinX]   |      |                             help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n[Rust/LinX]   |      |\n[Rust/LinX]   |     ::: src/um/d3d12.rs:1990:1\n[Rust/LinX]   |      |\n[Rust/LinX]   | 1990 | / RIDL!{#[uuid(0x8efb471d, 0x616c, 0x4f49, 0x90, 0xf7, 0x12, 0x7b, 0xb7, 0x63, 0xfa, 0x51)]\n[Rust/LinX]   | 1991 | | interface ID3D12DescriptorHeap(ID3D12DescriptorHeapVtbl): ID3D12Pageable(ID3D12PageableVtbl) {\n[Rust/LinX]   | 1992 | |     #[fixme] fn GetDesc() -> D3D12_DESCRIPTOR_HEAP_DESC,\n[Rust/LinX]   | 1993 | |     #[fixme] fn GetCPUDescriptorHandleForHeapStart() -> D3D12_CPU_DESCRIPTOR_HANDLE,\n[Rust/LinX]   | 1994 | |     #[fixme] fn GetGPUDescriptorHandleForHeapStart() -> D3D12_GPU_DESCRIPTOR_HANDLE,\n[Rust/LinX]   | 1995 | | }}\n[Rust/LinX]   |      | |__- in this macro invocation\n[Rust/LinX]   |      |\n[Rust/LinX]   | note: integers must be initialized (in this struct field)\n[Rust/LinX]   |     --> src/macros.rs:391:15\n[Rust/LinX]   |      |\n[Rust/LinX]   | 391  |               $(pub $field: $ftype,)+\n[Rust/LinX]   |      |                 ^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |      |\n[Rust/LinX]   |     ::: src/um/d3d12.rs:1551:1\n[Rust/LinX]   |      |\n[Rust/LinX]   | 1551 | / STRUCT!{struct D3D12_DESCRIPTOR_HEAP_DESC {\n[Rust/LinX]   | 1552 | |     Type: D3D12_DESCRIPTOR_HEAP_TYPE,\n[Rust/LinX]   | 1553 | |     NumDescriptors: UINT,\n[Rust/LinX]   | 1554 | |     Flags: D3D12_DESCRIPTOR_HEAP_FLAGS,\n[Rust/LinX]   | 1555 | |     NodeMask: UINT,\n[Rust/LinX]   | 1556 | | }}\n[Rust/LinX]   |      | |__- in this macro invocation\n[Rust/LinX]   |      = note: this warning originates in the macro `RIDL` which comes from the expansion of the macro `STRUCT` (in Nightly builds, run with -Z macro-backtrace for more info)\n[Rust/LinX]   | \n[Rust/LinX]   | warning: the type `D3D12_CPU_DESCRIPTOR_HANDLE` does not permit being left uninitialized\n[Rust/LinX]   |     --> src/macros.rs:222:27\n[Rust/LinX]   |      |\n[Rust/LinX]   | 222  |               let mut ret = $crate::_core::mem::uninitialized();\n[Rust/LinX]   |      |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |      |                             |\n[Rust/LinX]   |      |                             this code causes undefined behavior when executed\n[Rust/LinX]   |      |                             help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n[Rust/LinX]   |      |\n[Rust/LinX]   |     ::: src/um/d3d12.rs:1990:1\n[Rust/LinX]   |      |\n[Rust/LinX]   | 1990 | / RIDL!{#[uuid(0x8efb471d, 0x616c, 0x4f49, 0x90, 0xf7, 0x12, 0x7b, 0xb7, 0x63, 0xfa, 0x51)]\n[Rust/LinX]   | 1991 | | interface ID3D12DescriptorHeap(ID3D12DescriptorHeapVtbl): ID3D12Pageable(ID3D12PageableVtbl) {\n[Rust/LinX]   | 1992 | |     #[fixme] fn GetDesc() -> D3D12_DESCRIPTOR_HEAP_DESC,\n[Rust/LinX]   | 1993 | |     #[fixme] fn GetCPUDescriptorHandleForHeapStart() -> D3D12_CPU_DESCRIPTOR_HANDLE,\n[Rust/LinX]   | 1994 | |     #[fixme] fn GetGPUDescriptorHandleForHeapStart() -> D3D12_GPU_DESCRIPTOR_HANDLE,\n[Rust/LinX]   | 1995 | | }}\n[Rust/LinX]   |      | |__- in this macro invocation\n[Rust/LinX]   |      |\n[Rust/LinX]   | note: integers must be initialized (in this struct field)\n[Rust/LinX]   |     --> src/macros.rs:391:15\n[Rust/LinX]   |      |\n[Rust/LinX]   | 391  |               $(pub $field: $ftype,)+\n[Rust/LinX]   |      |                 ^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |      |\n[Rust/LinX]   |     ::: src/um/d3d12.rs:1771:1\n[Rust/LinX]   |      |\n[Rust/LinX]   | 1771 | / STRUCT!{struct D3D12_CPU_DESCRIPTOR_HANDLE {\n[Rust/LinX]   | 1772 | |     ptr: SIZE_T,\n[Rust/LinX]   | 1773 | | }}\n[Rust/LinX]   |      | |__- in this macro invocation\n[Rust/LinX]   |      = note: this warning originates in the macro `RIDL` which comes from the expansion of the macro `STRUCT` (in Nightly builds, run with -Z macro-backtrace for more info)\n[Rust/LinX]   | \n[Rust/LinX]   | warning: the type `D3D12_GPU_DESCRIPTOR_HANDLE` does not permit being left uninitialized\n[Rust/LinX]   |     --> src/macros.rs:222:27\n[Rust/LinX]   |      |\n[Rust/LinX]   | 222  |               let mut ret = $crate::_core::mem::uninitialized();\n[Rust/LinX]   |      |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |      |                             |\n[Rust/LinX]   |      |                             this code causes undefined behavior when executed\n[Rust/LinX]   |      |                             help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n[Rust/LinX]   |      |\n[Rust/LinX]   |     ::: src/um/d3d12.rs:1990:1\n[Rust/LinX]   |      |\n[Rust/LinX]   | 1990 | / RIDL!{#[uuid(0x8efb471d, 0x616c, 0x4f49, 0x90, 0xf7, 0x12, 0x7b, 0xb7, 0x63, 0xfa, 0x51)]\n[Rust/LinX]   | 1991 | | interface ID3D12DescriptorHeap(ID3D12DescriptorHeapVtbl): ID3D12Pageable(ID3D12PageableVtbl) {\n[Rust/LinX]   | 1992 | |     #[fixme] fn GetDesc() -> D3D12_DESCRIPTOR_HEAP_DESC,\n[Rust/LinX]   | 1993 | |     #[fixme] fn GetCPUDescriptorHandleForHeapStart() -> D3D12_CPU_DESCRIPTOR_HANDLE,\n[Rust/LinX]   | 1994 | |     #[fixme] fn GetGPUDescriptorHandleForHeapStart() -> D3D12_GPU_DESCRIPTOR_HANDLE,\n[Rust/LinX]   | 1995 | | }}\n[Rust/LinX]   |      | |__- in this macro invocation\n[Rust/LinX]   |      |\n[Rust/LinX]   | note: integers must be initialized (in this struct field)\n[Rust/LinX]   |     --> src/macros.rs:391:15\n[Rust/LinX]   |      |\n[Rust/LinX]   | 391  |               $(pub $field: $ftype,)+\n[Rust/LinX]   |      |                 ^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |      |\n[Rust/LinX]   |     ::: src/um/d3d12.rs:1774:1\n[Rust/LinX]   |      |\n[Rust/LinX]   | 1774 | / STRUCT!{struct D3D12_GPU_DESCRIPTOR_HANDLE {\n[Rust/LinX]   | 1775 | |     ptr: UINT64,\n[Rust/LinX]   | 1776 | | }}\n[Rust/LinX]   |      | |__- in this macro invocation\n[Rust/LinX]   |      = note: this warning originates in the macro `RIDL` which comes from the expansion of the macro `STRUCT` (in Nightly builds, run with -Z macro-backtrace for more info)\n[Rust/LinX]   | \n[Rust/LinX]   | warning: the type `D3D12_COMMAND_QUEUE_DESC` does not permit being left uninitialized\n[Rust/LinX]   |     --> src/macros.rs:222:27\n[Rust/LinX]   |      |\n[Rust/LinX]   | 222  |               let mut ret = $crate::_core::mem::uninitialized();\n[Rust/LinX]   |      |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |      |                             |\n[Rust/LinX]   |      |                             this code causes undefined behavior when executed\n[Rust/LinX]   |      |                             help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n[Rust/LinX]   |      |\n[Rust/LinX]   |     ::: src/um/d3d12.rs:2297:1\n[Rust/LinX]   |      |\n[Rust/LinX]   | 2297 | / RIDL!{#[uuid(0x0ec870a6, 0x5d7e, 0x4c22, 0x8c, 0xfc, 0x5b, 0xaa, 0xe0, 0x76, 0x16, 0xed)]\n[Rust/LinX]   | 2298 | | interface ID3D12CommandQueue(ID3D12CommandQueueVtbl): ID3D12Pageable(ID3D12PageableVtbl) {\n[Rust/LinX]   | 2299 | |     fn UpdateTileMappings(\n[Rust/LinX]   | 2300 | |         pResource: *mut ID3D12Resource,\n[Rust/LinX]   | ...    |\n[Rust/LinX]   | 2349 | |     #[fixme] fn GetDesc() -> D3D12_COMMAND_QUEUE_DESC,\n[Rust/LinX]   | 2350 | | }}\n[Rust/LinX]   |      | |__- in this macro invocation\n[Rust/LinX]   |      |\n[Rust/LinX]   | note: integers must be initialized (in this struct field)\n[Rust/LinX]   |     --> src/macros.rs:391:15\n[Rust/LinX]   |      |\n[Rust/LinX]   | 391  |               $(pub $field: $ftype,)+\n[Rust/LinX]   |      |                 ^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |      |\n[Rust/LinX]   |     ::: src/um/d3d12.rs:428:1\n[Rust/LinX]   |      |\n[Rust/LinX]   | 428  | / STRUCT!{struct D3D12_COMMAND_QUEUE_DESC {\n[Rust/LinX]   | 429  | |     Type: D3D12_COMMAND_LIST_TYPE,\n[Rust/LinX]   | 430  | |     Priority: INT,\n[Rust/LinX]   | 431  | |     Flags: D3D12_COMMAND_QUEUE_FLAGS,\n[Rust/LinX]   | 432  | |     NodeMask: UINT,\n[Rust/LinX]   | 433  | | }}\n[Rust/LinX]   |      | |__- in this macro invocation\n[Rust/LinX]   |      = note: this warning originates in the macro `RIDL` which comes from the expansion of the macro `STRUCT` (in Nightly builds, run with -Z macro-backtrace for more info)\n[Rust/LinX]   | \n[Rust/LinX]   | warning: the type `D3D12_RESOURCE_ALLOCATION_INFO` does not permit being left uninitialized\n[Rust/LinX]   |     --> src/macros.rs:222:27\n[Rust/LinX]   |      |\n[Rust/LinX]   | 222  |               let mut ret = $crate::_core::mem::uninitialized();\n[Rust/LinX]   |      |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |      |                             |\n[Rust/LinX]   |      |                             this code causes undefined behavior when executed\n[Rust/LinX]   |      |                             help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n[Rust/LinX]   |      |\n[Rust/LinX]   |     ::: src/um/d3d12.rs:2351:1\n[Rust/LinX]   |      |\n[Rust/LinX]   | 2351 | / RIDL!{#[uuid(0x189819f1, 0x1db6, 0x4b57, 0xbe, 0x54, 0x18, 0x21, 0x33, 0x9b, 0x85, 0xf7)]\n[Rust/LinX]   | 2352 | | interface ID3D12Device(ID3D12DeviceVtbl): ID3D12Object(ID3D12ObjectVtbl) {\n[Rust/LinX]   | 2353 | |     fn GetNodeCount() -> UINT,\n[Rust/LinX]   | 2354 | |     fn CreateCommandQueue(\n[Rust/LinX]   | ...    |\n[Rust/LinX]   | 2550 | |     #[fixme] fn GetAdapterLuid() -> LUID,\n[Rust/LinX]   | 2551 | | }}\n[Rust/LinX]   |      | |__- in this macro invocation\n[Rust/LinX]   |      |\n[Rust/LinX]   | note: integers must be initialized (in this struct field)\n[Rust/LinX]   |     --> src/macros.rs:391:15\n[Rust/LinX]   |      |\n[Rust/LinX]   | 391  |               $(pub $field: $ftype,)+\n[Rust/LinX]   |      |                 ^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |      |\n[Rust/LinX]   |     ::: src/um/d3d12.rs:920:1\n[Rust/LinX]   |      |\n[Rust/LinX]   | 920  | / STRUCT!{struct D3D12_RESOURCE_ALLOCATION_INFO {\n[Rust/LinX]   | 921  | |     SizeInBytes: UINT64,\n[Rust/LinX]   | 922  | |     Alignment: UINT64,\n[Rust/LinX]   | 923  | | }}\n[Rust/LinX]   |      | |__- in this macro invocation\n[Rust/LinX]   |      = note: this warning originates in the macro `RIDL` which comes from the expansion of the macro `STRUCT` (in Nightly builds, run with -Z macro-backtrace for more info)\n[Rust/LinX]   | \n[Rust/LinX]   | warning: the type `D3D12_HEAP_PROPERTIES` does not permit being left uninitialized\n[Rust/LinX]   |     --> src/macros.rs:222:27\n[Rust/LinX]   |      |\n[Rust/LinX]   | 222  |               let mut ret = $crate::_core::mem::uninitialized();\n[Rust/LinX]   |      |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |      |                             |\n[Rust/LinX]   |      |                             this code causes undefined behavior when executed\n[Rust/LinX]   |      |                             help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n[Rust/LinX]   |      |\n[Rust/LinX]   |     ::: src/um/d3d12.rs:2351:1\n[Rust/LinX]   |      |\n[Rust/LinX]   | 2351 | / RIDL!{#[uuid(0x189819f1, 0x1db6, 0x4b57, 0xbe, 0x54, 0x18, 0x21, 0x33, 0x9b, 0x85, 0xf7)]\n[Rust/LinX]   | 2352 | | interface ID3D12Device(ID3D12DeviceVtbl): ID3D12Object(ID3D12ObjectVtbl) {\n[Rust/LinX]   | 2353 | |     fn GetNodeCount() -> UINT,\n[Rust/LinX]   | 2354 | |     fn CreateCommandQueue(\n[Rust/LinX]   | ...    |\n[Rust/LinX]   | 2550 | |     #[fixme] fn GetAdapterLuid() -> LUID,\n[Rust/LinX]   | 2551 | | }}\n[Rust/LinX]   |      | |__- in this macro invocation\n[Rust/LinX]   |      |\n[Rust/LinX]   | note: integers must be initialized (in this struct field)\n[Rust/LinX]   |     --> src/macros.rs:391:15\n[Rust/LinX]   |      |\n[Rust/LinX]   | 391  |               $(pub $field: $ftype,)+\n[Rust/LinX]   |      |                 ^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |      |\n[Rust/LinX]   |     ::: src/um/d3d12.rs:941:1\n[Rust/LinX]   |      |\n[Rust/LinX]   | 941  | / STRUCT!{struct D3D12_HEAP_PROPERTIES {\n[Rust/LinX]   | 942  | |     Type: D3D12_HEAP_TYPE,\n[Rust/LinX]   | 943  | |     CPUPageProperty: D3D12_CPU_PAGE_PROPERTY,\n[Rust/LinX]   | 944  | |     MemoryPoolPreference: D3D12_MEMORY_POOL,\n[Rust/LinX]   | 945  | |     CreationNodeMask: UINT,\n[Rust/LinX]   | 946  | |     VisibleNodeMask: UINT,\n[Rust/LinX]   | 947  | | }}\n[Rust/LinX]   |      | |__- in this macro invocation\n[Rust/LinX]   |      = note: this warning originates in the macro `RIDL` which comes from the expansion of the macro `STRUCT` (in Nightly builds, run with -Z macro-backtrace for more info)\n[Rust/LinX]   | \n[Rust/LinX]   | warning: the type `ntdef::LUID` does not permit being left uninitialized\n[Rust/LinX]   |     --> src/macros.rs:222:27\n[Rust/LinX]   |      |\n[Rust/LinX]   | 222  |               let mut ret = $crate::_core::mem::uninitialized();\n[Rust/LinX]   |      |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |      |                             |\n[Rust/LinX]   |      |                             this code causes undefined behavior when executed\n[Rust/LinX]   |      |                             help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n[Rust/LinX]   |      |\n[Rust/LinX]   |     ::: src/um/d3d12.rs:2351:1\n[Rust/LinX]   |      |\n[Rust/LinX]   | 2351 | / RIDL!{#[uuid(0x189819f1, 0x1db6, 0x4b57, 0xbe, 0x54, 0x18, 0x21, 0x33, 0x9b, 0x85, 0xf7)]\n[Rust/LinX]   | 2352 | | interface ID3D12Device(ID3D12DeviceVtbl): ID3D12Object(ID3D12ObjectVtbl) {\n[Rust/LinX]   | 2353 | |     fn GetNodeCount() -> UINT,\n[Rust/LinX]   | 2354 | |     fn CreateCommandQueue(\n[Rust/LinX]   | ...    |\n[Rust/LinX]   | 2550 | |     #[fixme] fn GetAdapterLuid() -> LUID,\n[Rust/LinX]   | 2551 | | }}\n[Rust/LinX]   |      | |__- in this macro invocation\n[Rust/LinX]   |      |\n[Rust/LinX]   | note: integers must be initialized (in this struct field)\n[Rust/LinX]   |     --> src/macros.rs:391:15\n[Rust/LinX]   |      |\n[Rust/LinX]   | 391  |               $(pub $field: $ftype,)+\n[Rust/LinX]   |      |                 ^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |      |\n[Rust/LinX]   |     ::: src/shared/ntdef.rs:230:1\n[Rust/LinX]   |      |\n[Rust/LinX]   | 230  | / STRUCT!{struct LUID {\n[Rust/LinX]   | 231  | |     LowPart: ULONG,\n[Rust/LinX]   | 232  | |     HighPart: LONG,\n[Rust/LinX]   | 233  | | }}\n[Rust/LinX]   |      | |__- in this macro invocation\n[Rust/LinX]   |      = note: this warning originates in the macro `RIDL` which comes from the expansion of the macro `STRUCT` (in Nightly builds, run with -Z macro-backtrace for more info)\n[Rust/LinX]   | \n[Rust/LinX]   | warning: the type `DXVA2_Fixed32` does not permit being left uninitialized\n[Rust/LinX]   |    --> src/um/dxva2api.rs:677:42\n[Rust/LinX]   |     |\n[Rust/LinX]   | 677 |         let mut _fixed_: DXVA2_Fixed32 = ::core::mem::uninitialized();\n[Rust/LinX]   |     |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |                                          |\n[Rust/LinX]   |     |                                          this code causes undefined behavior when executed\n[Rust/LinX]   |     |                                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n[Rust/LinX]   |     |\n[Rust/LinX]   | note: integers must be initialized (in this struct field)\n[Rust/LinX]   |    --> src/macros.rs:286:26\n[Rust/LinX]   |     |\n[Rust/LinX]   | 286 |           pub struct $name([$stype; $ssize]);\n[Rust/LinX]   |     |                            ^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |\n[Rust/LinX]   |    ::: src/um/dxva2api.rs:334:1\n[Rust/LinX]   |     |\n[Rust/LinX]   | 334 | / UNION!{union DXVA2_Fixed32 {\n[Rust/LinX]   | 335 | |     [u32; 1],\n[Rust/LinX]   | 336 | |     s s_mut: DXVA2_Fixed32_s,\n[Rust/LinX]   | 337 | |     ll s_ll: LONG,\n[Rust/LinX]   | 338 | | }}\n[Rust/LinX]   |     | |__- in this macro invocation\n[Rust/LinX]   |     = note: this warning originates in the macro `UNION` (in Nightly builds, run with -Z macro-backtrace for more info)\n[Rust/LinX]   | \n[Rust/LinX]   | warning: the type `DXVA2_Fixed32` does not permit being left uninitialized\n[Rust/LinX]   |    --> src/um/dxva2api.rs:692:42\n[Rust/LinX]   |     |\n[Rust/LinX]   | 692 |         let mut _fixed_: DXVA2_Fixed32 = ::core::mem::uninitialized();\n[Rust/LinX]   |     |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |                                          |\n[Rust/LinX]   |     |                                          this code causes undefined behavior when executed\n[Rust/LinX]   |     |                                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n[Rust/LinX]   |     |\n[Rust/LinX]   | note: integers must be initialized (in this struct field)\n[Rust/LinX]   |    --> src/macros.rs:286:26\n[Rust/LinX]   |     |\n[Rust/LinX]   | 286 |           pub struct $name([$stype; $ssize]);\n[Rust/LinX]   |     |                            ^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |\n[Rust/LinX]   |    ::: src/um/dxva2api.rs:334:1\n[Rust/LinX]   |     |\n[Rust/LinX]   | 334 | / UNION!{union DXVA2_Fixed32 {\n[Rust/LinX]   | 335 | |     [u32; 1],\n[Rust/LinX]   | 336 | |     s s_mut: DXVA2_Fixed32_s,\n[Rust/LinX]   | 337 | |     ll s_ll: LONG,\n[Rust/LinX]   | 338 | | }}\n[Rust/LinX]   |     | |__- in this macro invocation\n[Rust/LinX]   |     = note: this warning originates in the macro `UNION` (in Nightly builds, run with -Z macro-backtrace for more info)\n[Rust/LinX]   | \n[Rust/LinX]   | warning: the type `DXVA2_Fixed32` does not permit being left uninitialized\n[Rust/LinX]   |    --> src/um/dxva2api.rs:701:42\n[Rust/LinX]   |     |\n[Rust/LinX]   | 701 |         let mut _fixed_: DXVA2_Fixed32 = ::core::mem::uninitialized();\n[Rust/LinX]   |     |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |                                          |\n[Rust/LinX]   |     |                                          this code causes undefined behavior when executed\n[Rust/LinX]   |     |                                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n[Rust/LinX]   |     |\n[Rust/LinX]   | note: integers must be initialized (in this struct field)\n[Rust/LinX]   |    --> src/macros.rs:286:26\n[Rust/LinX]   |     |\n[Rust/LinX]   | 286 |           pub struct $name([$stype; $ssize]);\n[Rust/LinX]   |     |                            ^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |\n[Rust/LinX]   |    ::: src/um/dxva2api.rs:334:1\n[Rust/LinX]   |     |\n[Rust/LinX]   | 334 | / UNION!{union DXVA2_Fixed32 {\n[Rust/LinX]   | 335 | |     [u32; 1],\n[Rust/LinX]   | 336 | |     s s_mut: DXVA2_Fixed32_s,\n[Rust/LinX]   | 337 | |     ll s_ll: LONG,\n[Rust/LinX]   | 338 | | }}\n[Rust/LinX]   |     | |__- in this macro invocation\n[Rust/LinX]   |     = note: this warning originates in the macro `UNION` (in Nightly builds, run with -Z macro-backtrace for more info)\n[Rust/LinX]   | \n[Rust/Lin ]   | info: downloading component 'rustc'\n[Rust/Win ]   | info: latest update on 2023-05-30, rust version 1.72.0-nightly (498553fc0 2023-05-29)\n[Rust/Win ]   | error: target 'x86_64-unknown-linux-msvc' not found in channel.  Perhaps check https://doc.rust-lang.org/nightly/rustc/platform-support.html for available targets\n[Rust/Win ]   \u2757  ::error::The process '/home/runneradmin/.cargo/bin/rustup' failed with exit code 1\n[Rust/Win ]   \u274c  Failure - Main actions-rs/toolchain@v1\n[Rust/LinX]   | warning: `winapi` (lib) generated 24 warnings (2 duplicates)\n[Rust/LinX]   |     Finished dev [unoptimized + debuginfo] target(s) in 15.58s\n[Rust/LinX]   |    Compiling winapi v0.3.9 (/tmp/c1e8dd3a-fec2-11ed-a890-af2cc187fc11/retep998-winapi-rs)\n[Rust/Win ]   \u2699  ::add-path:: /home/runneradmin/.cargo/bin\n[Rust/Win ] exitcode '1': failure\n[Rust/Lin ]   | info: installing component 'cargo'\n[Rust/LinX]   | warning: the type `D2D_SIZE_F` does not permit being left uninitialized\n[Rust/LinX]   |    --> src/macros.rs:222:27\n[Rust/LinX]   |     |\n[Rust/LinX]   | 222 |               let mut ret = $crate::_core::mem::uninitialized();\n[Rust/LinX]   |     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |                             |\n[Rust/LinX]   |     |                             this code causes undefined behavior when executed\n[Rust/LinX]   |     |                             help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n[Rust/LinX]   |     |\n[Rust/LinX]   |    ::: src/um/d2d1.rs:295:1\n[Rust/LinX]   |     |\n[Rust/LinX]   | 295 | / RIDL!{#[uuid(0xa2296057, 0xea42, 0x4099, 0x98, 0x3b, 0x53, 0x9f, 0xb6, 0x50, 0x54, 0x26)]\n[Rust/LinX]   | 296 | | interface ID2D1Bitmap(ID2D1BitmapVtbl): ID2D1Image(ID2D1ImageVtbl) {\n[Rust/LinX]   | 297 | |     #[fixme] fn GetSize() -> D2D1_SIZE_F,\n[Rust/LinX]   | 298 | |     #[fixme] fn GetPixelSize() -> D2D1_SIZE_U,\n[Rust/LinX]   | ...   |\n[Rust/LinX]   | 318 | |     ) -> HRESULT,\n[Rust/LinX]   | 319 | | }}\n[Rust/LinX]   |     | |__- in this macro invocation\n[Rust/LinX]   |     |\n[Rust/LinX]   | note: floats must be initialized (in this struct field)\n[Rust/LinX]   |    --> src/macros.rs:391:15\n[Rust/LinX]   |     |\n[Rust/LinX]   | 391 |               $(pub $field: $ftype,)+\n[Rust/LinX]   |     |                 ^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |\n[Rust/LinX]   |    ::: src/um/dcommon.rs:86:1\n[Rust/LinX]   |     |\n[Rust/LinX]   | 86  | / STRUCT!{struct D2D_SIZE_F {\n[Rust/LinX]   | 87  | |     width: FLOAT,\n[Rust/LinX]   | 88  | |     height: FLOAT,\n[Rust/LinX]   | 89  | | }}\n[Rust/LinX]   |     | |__- in this macro invocation\n[Rust/LinX]   |     = note: `#[warn(invalid_value)]` on by default\n[Rust/LinX]   |     = note: this warning originates in the macro `RIDL` which comes from the expansion of the macro `STRUCT` (in Nightly builds, run with -Z macro-backtrace for more info)\n[Rust/LinX]   | \n[Rust/LinX]   | warning: the type `D2D_SIZE_U` does not permit being left uninitialized\n[Rust/LinX]   |    --> src/macros.rs:222:27\n[Rust/LinX]   |     |\n[Rust/LinX]   | 222 |               let mut ret = $crate::_core::mem::uninitialized();\n[Rust/LinX]   |     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |                             |\n[Rust/LinX]   |     |                             this code causes undefined behavior when executed\n[Rust/LinX]   |     |                             help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n[Rust/LinX]   |     |\n[Rust/LinX]   |    ::: src/um/d2d1.rs:295:1\n[Rust/LinX]   |     |\n[Rust/LinX]   | 295 | / RIDL!{#[uuid(0xa2296057, 0xea42, 0x4099, 0x98, 0x3b, 0x53, 0x9f, 0xb6, 0x50, 0x54, 0x26)]\n[Rust/LinX]   | 296 | | interface ID2D1Bitmap(ID2D1BitmapVtbl): ID2D1Image(ID2D1ImageVtbl) {\n[Rust/LinX]   | 297 | |     #[fixme] fn GetSize() -> D2D1_SIZE_F,\n[Rust/LinX]   | 298 | |     #[fixme] fn GetPixelSize() -> D2D1_SIZE_U,\n[Rust/LinX]   | ...   |\n[Rust/LinX]   | 318 | |     ) -> HRESULT,\n[Rust/LinX]   | 319 | | }}\n[Rust/LinX]   |     | |__- in this macro invocation\n[Rust/LinX]   |     |\n[Rust/LinX]   | note: integers must be initialized (in this struct field)\n[Rust/LinX]   |    --> src/macros.rs:391:15\n[Rust/LinX]   |     |\n[Rust/LinX]   | 391 |               $(pub $field: $ftype,)+\n[Rust/LinX]   |     |                 ^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |\n[Rust/LinX]   |    ::: src/um/dcommon.rs:90:1\n[Rust/LinX]   |     |\n[Rust/LinX]   | 90  | / STRUCT!{struct D2D_SIZE_U {\n[Rust/LinX]   | 91  | |     width: UINT32,\n[Rust/LinX]   | 92  | |     height: UINT32,\n[Rust/LinX]   | 93  | | }}\n[Rust/LinX]   |     | |__- in this macro invocation\n[Rust/LinX]   |     = note: this warning originates in the macro `RIDL` which comes from the expansion of the macro `STRUCT` (in Nightly builds, run with -Z macro-backtrace for more info)\n[Rust/LinX]   | \n[Rust/LinX]   | warning: the type `D2D1_PIXEL_FORMAT` does not permit being left uninitialized\n[Rust/LinX]   |    --> src/macros.rs:222:27\n[Rust/LinX]   |     |\n[Rust/LinX]   | 222 |               let mut ret = $crate::_core::mem::uninitialized();\n[Rust/LinX]   |     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |                             |\n[Rust/LinX]   |     |                             this code causes undefined behavior when executed\n[Rust/LinX]   |     |                             help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n[Rust/LinX]   |     |\n[Rust/LinX]   |    ::: src/um/d2d1.rs:295:1\n[Rust/LinX]   |     |\n[Rust/LinX]   | 295 | / RIDL!{#[uuid(0xa2296057, 0xea42, 0x4099, 0x98, 0x3b, 0x53, 0x9f, 0xb6, 0x50, 0x54, 0x26)]\n[Rust/LinX]   | 296 | | interface ID2D1Bitmap(ID2D1BitmapVtbl): ID2D1Image(ID2D1ImageVtbl) {\n[Rust/LinX]   | 297 | |     #[fixme] fn GetSize() -> D2D1_SIZE_F,\n[Rust/LinX]   | 298 | |     #[fixme] fn GetPixelSize() -> D2D1_SIZE_U,\n[Rust/LinX]   | ...   |\n[Rust/LinX]   | 318 | |     ) -> HRESULT,\n[Rust/LinX]   | 319 | | }}\n[Rust/LinX]   |     | |__- in this macro invocation\n[Rust/LinX]   |     |\n[Rust/LinX]   | note: integers must be initialized (in this struct field)\n[Rust/LinX]   |    --> src/macros.rs:391:15\n[Rust/LinX]   |     |\n[Rust/LinX]   | 391 |               $(pub $field: $ftype,)+\n[Rust/LinX]   |     |                 ^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |\n[Rust/LinX]   |    ::: src/um/dcommon.rs:45:1\n[Rust/LinX]   |     |\n[Rust/LinX]   | 45  | / STRUCT!{struct D2D1_PIXEL_FORMAT {\n[Rust/LinX]   | 46  | |     format: DXGI_FORMAT,\n[Rust/LinX]   | 47  | |     alphaMode: D2D1_ALPHA_MODE,\n[Rust/LinX]   | 48  | | }}\n[Rust/LinX]   |     | |__- in this macro invocation\n[Rust/LinX]   |     = note: this warning originates in the macro `RIDL` which comes from the expansion of the macro `STRUCT` (in Nightly builds, run with -Z macro-backtrace for more info)\n[Rust/LinX]   | \n[Rust/LinX]   | warning: the type `D3DCOLORVALUE` does not permit being left uninitialized\n[Rust/LinX]   |    --> src/macros.rs:222:27\n[Rust/LinX]   |     |\n[Rust/LinX]   | 222 |               let mut ret = $crate::_core::mem::uninitialized();\n[Rust/LinX]   |     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |                             |\n[Rust/LinX]   |     |                             this code causes undefined behavior when executed\n[Rust/LinX]   |     |                             help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n[Rust/LinX]   |     |\n[Rust/LinX]   |    ::: src/um/d2d1.rs:365:1\n[Rust/LinX]   |     |\n[Rust/LinX]   | 365 | / RIDL!{#[uuid(0x2cd906a9, 0x12e2, 0x11dc, 0x9f, 0xed, 0x00, 0x11, 0x43, 0xa0, 0x55, 0xf9)]\n[Rust/LinX]   | 366 | | interface ID2D1SolidColorBrush(ID2D1SolidColorBrushVtbl): ID2D1Brush(ID2D1BrushVtbl) {\n[Rust/LinX]   | 367 | |     fn SetColor(\n[Rust/LinX]   | 368 | |         color: *const D2D1_COLOR_F,\n[Rust/LinX]   | 369 | |     ) -> (),\n[Rust/LinX]   | 370 | |     #[fixme] fn GetColor() -> D2D1_COLOR_F,\n[Rust/LinX]   | 371 | | }}\n[Rust/LinX]   |     | |__- in this macro invocation\n[Rust/LinX]   |     |\n[Rust/LinX]   | note: floats must be initialized (in this struct field)\n[Rust/LinX]   |    --> src/macros.rs:391:15\n[Rust/LinX]   |     |\n[Rust/LinX]   | 391 |               $(pub $field: $ftype,)+\n[Rust/LinX]   |     |                 ^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |\n[Rust/LinX]   |    ::: src/shared/d3d9types.rs:48:1\n[Rust/LinX]   |     |\n[Rust/LinX]   | 48  | / STRUCT!{struct D3DCOLORVALUE {\n[Rust/LinX]   | 49  | |     r: c_float,\n[Rust/LinX]   | 50  | |     g: c_float,\n[Rust/LinX]   | 51  | |     b: c_float,\n[Rust/LinX]   | 52  | |     a: c_float,\n[Rust/LinX]   | 53  | | }}\n[Rust/LinX]   |     | |__- in this macro invocation\n[Rust/LinX]   |     = note: this warning originates in the macro `RIDL` which comes from the expansion of the macro `STRUCT` (in Nightly builds, run with -Z macro-backtrace for more info)\n[Rust/LinX]   | \n[Rust/LinX]   | warning: the type `D2D_POINT_2F` does not permit being left uninitialized\n[Rust/LinX]   |    --> src/macros.rs:222:27\n[Rust/LinX]   |     |\n[Rust/LinX]   | 222 |               let mut ret = $crate::_core::mem::uninitialized();\n[Rust/LinX]   |     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |                             |\n[Rust/LinX]   |     |                             this code causes undefined behavior when executed\n[Rust/LinX]   |     |                             help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n[Rust/LinX]   |     |\n[Rust/LinX]   |    ::: src/um/d2d1.rs:372:1\n[Rust/LinX]   |     |\n[Rust/LinX]   | 372 | / RIDL!{#[uuid(0x2cd906ab, 0x12e2, 0x11dc, 0x9f, 0xed, 0x00, 0x11, 0x43, 0xa0, 0x55, 0xf9)]\n[Rust/LinX]   | 373 | | interface ID2D1LinearGradientBrush(ID2D1LinearGradientBrushVtbl): ID2D1Brush(ID2D1BrushVtbl) {\n[Rust/LinX]   | 374 | |     fn SetStartPoint(\n[Rust/LinX]   | 375 | |         startPoint: D2D1_POINT_2F,\n[Rust/LinX]   | ...   |\n[Rust/LinX]   | 384 | |     ) -> (),\n[Rust/LinX]   | 385 | | }}\n[Rust/LinX]   |     | |__- in this macro invocation\n[Rust/LinX]   |     |\n[Rust/LinX]   | note: floats must be initialized (in this struct field)\n[Rust/LinX]   |    --> src/macros.rs:391:15\n[Rust/LinX]   |     |\n[Rust/LinX]   | 391 |               $(pub $field: $ftype,)+\n[Rust/LinX]   |     |                 ^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |\n[Rust/LinX]   |    ::: src/um/dcommon.rs:53:1\n[Rust/LinX]   |     |\n[Rust/LinX]   | 53  | / STRUCT!{struct D2D_POINT_2F {\n[Rust/LinX]   | 54  | |     x: FLOAT,\n[Rust/LinX]   | 55  | |     y: FLOAT,\n[Rust/LinX]   | 56  | | }}\n[Rust/LinX]   |     | |__- in this macro invocation\n[Rust/LinX]   |     = note: this warning originates in the macro `RIDL` which comes from the expansion of the macro `STRUCT` (in Nightly builds, run with -Z macro-backtrace for more info)\n[Rust/LinX]   | \n[Rust/LinX]   | warning: the type `D2D_POINT_2F` does not permit being left uninitialized\n[Rust/LinX]   |    --> src/macros.rs:222:27\n[Rust/LinX]   |     |\n[Rust/LinX]   | 222 |               let mut ret = $crate::_core::mem::uninitialized();\n[Rust/LinX]   |     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |                             |\n[Rust/LinX]   |     |                             this code causes undefined behavior when executed\n[Rust/LinX]   |     |                             help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n[Rust/LinX]   |     |\n[Rust/LinX]   |    ::: src/um/d2d1.rs:386:1\n[Rust/LinX]   |     |\n[Rust/LinX]   | 386 | / RIDL!{#[uuid(0x2cd906ac, 0x12e2, 0x11dc, 0x9f, 0xed, 0x00, 0x11, 0x43, 0xa0, 0x55, 0xf9)]\n[Rust/LinX]   | 387 | | interface ID2D1RadialGradientBrush(ID2D1RadialGradientBrushVtbl): ID2D1Brush(ID2D1BrushVtbl) {\n[Rust/LinX]   | 388 | |     fn SetCenter(\n[Rust/LinX]   | 389 | |         center: D2D1_POINT_2F,\n[Rust/LinX]   | ...   |\n[Rust/LinX]   | 406 | |     ) -> (),\n[Rust/LinX]   | 407 | | }}\n[Rust/LinX]   |     | |__- in this macro invocation\n[Rust/LinX]   |     |\n[Rust/LinX]   | note: floats must be initialized (in this struct field)\n[Rust/LinX]   |    --> src/macros.rs:391:15\n[Rust/LinX]   |     |\n[Rust/LinX]   | 391 |               $(pub $field: $ftype,)+\n[Rust/LinX]   |     |                 ^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |\n[Rust/LinX]   |    ::: src/um/dcommon.rs:53:1\n[Rust/LinX]   |     |\n[Rust/LinX]   | 53  | / STRUCT!{struct D2D_POINT_2F {\n[Rust/LinX]   | 54  | |     x: FLOAT,\n[Rust/LinX]   | 55  | |     y: FLOAT,\n[Rust/LinX]   | 56  | | }}\n[Rust/LinX]   |     | |__- in this macro invocation\n[Rust/LinX]   |     = note: this warning originates in the macro `RIDL` which comes from the expansion of the macro `STRUCT` (in Nightly builds, run with -Z macro-backtrace for more info)\n[Rust/LinX]   | \n[Rust/LinX]   | warning: the type `D2D_SIZE_F` does not permit being left uninitialized\n[Rust/LinX]   |    --> src/macros.rs:222:27\n[Rust/LinX]   |     |\n[Rust/LinX]   | 222 |               let mut ret = $crate::_core::mem::uninitialized();\n[Rust/LinX]   |     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |                             |\n[Rust/LinX]   |     |                             this code causes undefined behavior when executed\n[Rust/LinX]   |     |                             help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n[Rust/LinX]   |     |\n[Rust/LinX]   |    ::: src/um/d2d1.rs:616:1\n[Rust/LinX]   |     |\n[Rust/LinX]   | 616 | / RIDL!{#[uuid(0x2cd9069b, 0x12e2, 0x11dc, 0x9f, 0xed, 0x00, 0x11, 0x43, 0xa0, 0x55, 0xf9)]\n[Rust/LinX]   | 617 | | interface ID2D1Layer(ID2D1LayerVtbl): ID2D1Resource(ID2D1ResourceVtbl) {\n[Rust/LinX]   | 618 | |     #[fixme] fn GetSize() -> D2D1_SIZE_F,\n[Rust/LinX]   | 619 | | }}\n[Rust/LinX]   |     | |__- in this macro invocation\n[Rust/LinX]   |     |\n[Rust/LinX]   | note: floats must be initialized (in this struct field)\n[Rust/LinX]   |    --> src/macros.rs:391:15\n[Rust/LinX]   |     |\n[Rust/LinX]   | 391 |               $(pub $field: $ftype,)+\n[Rust/LinX]   |     |                 ^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |\n[Rust/LinX]   |    ::: src/um/dcommon.rs:86:1\n[Rust/LinX]   |     |\n[Rust/LinX]   | 86  | / STRUCT!{struct D2D_SIZE_F {\n[Rust/LinX]   | 87  | |     width: FLOAT,\n[Rust/LinX]   | 88  | |     height: FLOAT,\n[Rust/LinX]   | 89  | | }}\n[Rust/LinX]   |     | |__- in this macro invocation\n[Rust/LinX]   |     = note: this warning originates in the macro `RIDL` which comes from the expansion of the macro `STRUCT` (in Nightly builds, run with -Z macro-backtrace for more info)\n[Rust/LinX]   | \n[Rust/LinX]   | warning: the type `D2D1_PIXEL_FORMAT` does not permit being left uninitialized\n[Rust/LinX]   |    --> src/macros.rs:222:27\n[Rust/LinX]   |     |\n[Rust/LinX]   | 222 |               let mut ret = $crate::_core::mem::uninitialized();\n[Rust/LinX]   |     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |                             |\n[Rust/LinX]   |     |                             this code causes undefined behavior when executed\n[Rust/LinX]   |     |                             help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n[Rust/LinX]   |     |\n[Rust/LinX]   |    ::: src/um/d2d1.rs:635:1\n[Rust/LinX]   |     |\n[Rust/LinX]   | 635 | / RIDL!{#[uuid(0x2cd90694, 0x12e2, 0x11dc, 0x9f, 0xed, 0x00, 0x11, 0x43, 0xa0, 0x55, 0xf9)]\n[Rust/LinX]   | 636 | | interface ID2D1RenderTarget(ID2D1RenderTargetVtbl): ID2D1Resource(ID2D1ResourceVtbl) {\n[Rust/LinX]   | 637 | |     fn CreateBitmap(\n[Rust/LinX]   | 638 | |         size: D2D1_SIZE_U,\n[Rust/LinX]   | ...   |\n[Rust/LinX]   | 856 | |     ) -> BOOL,\n[Rust/LinX]   | 857 | | }}\n[Rust/LinX]   |     | |__- in this macro invocation\n[Rust/LinX]   |     |\n[Rust/LinX]   | note: integers must be initialized (in this struct field)\n[Rust/LinX]   |    --> src/macros.rs:391:15\n[Rust/LinX]   |     |\n[Rust/LinX]   | 391 |               $(pub $field: $ftype,)+\n[Rust/LinX]   |     |                 ^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |\n[Rust/LinX]   |    ::: src/um/dcommon.rs:45:1\n[Rust/LinX]   |     |\n[Rust/LinX]   | 45  | / STRUCT!{struct D2D1_PIXEL_FORMAT {\n[Rust/LinX]   | 46  | |     format: DXGI_FORMAT,\n[Rust/LinX]   | 47  | |     alphaMode: D2D1_ALPHA_MODE,\n[Rust/LinX]   | 48  | | }}\n[Rust/LinX]   |     | |__- in this macro invocation\n[Rust/LinX]   |     = note: this warning originates in the macro `RIDL` which comes from the expansion of the macro `STRUCT` (in Nightly builds, run with -Z macro-backtrace for more info)\n[Rust/LinX]   | \n[Rust/LinX]   | warning: the type `D2D_SIZE_F` does not permit being left uninitialized\n[Rust/LinX]   |    --> src/macros.rs:222:27\n[Rust/LinX]   |     |\n[Rust/LinX]   | 222 |               let mut ret = $crate::_core::mem::uninitialized();\n[Rust/LinX]   |     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |                             |\n[Rust/LinX]   |     |                             this code causes undefined behavior when executed\n[Rust/LinX]   |     |                             help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n[Rust/LinX]   |     |\n[Rust/LinX]   |    ::: src/um/d2d1.rs:635:1\n[Rust/LinX]   |     |\n[Rust/LinX]   | 635 | / RIDL!{#[uuid(0x2cd90694, 0x12e2, 0x11dc, 0x9f, 0xed, 0x00, 0x11, 0x43, 0xa0, 0x55, 0xf9)]\n[Rust/LinX]   | 636 | | interface ID2D1RenderTarget(ID2D1RenderTargetVtbl): ID2D1Resource(ID2D1ResourceVtbl) {\n[Rust/LinX]   | 637 | |     fn CreateBitmap(\n[Rust/LinX]   | 638 | |         size: D2D1_SIZE_U,\n[Rust/LinX]   | ...   |\n[Rust/LinX]   | 856 | |     ) -> BOOL,\n[Rust/LinX]   | 857 | | }}\n[Rust/LinX]   |     | |__- in this macro invocation\n[Rust/LinX]   |     |\n[Rust/LinX]   | note: floats must be initialized (in this struct field)\n[Rust/LinX]   |    --> src/macros.rs:391:15\n[Rust/LinX]   |     |\n[Rust/LinX]   | 391 |               $(pub $field: $ftype,)+\n[Rust/LinX]   |     |                 ^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |\n[Rust/LinX]   |    ::: src/um/dcommon.rs:86:1\n[Rust/LinX]   |     |\n[Rust/LinX]   | 86  | / STRUCT!{struct D2D_SIZE_F {\n[Rust/LinX]   | 87  | |     width: FLOAT,\n[Rust/LinX]   | 88  | |     height: FLOAT,\n[Rust/LinX]   | 89  | | }}\n[Rust/LinX]   |     | |__- in this macro invocation\n[Rust/LinX]   |     = note: this warning originates in the macro `RIDL` which comes from the expansion of the macro `STRUCT` (in Nightly builds, run with -Z macro-backtrace for more info)\n[Rust/LinX]   | \n[Rust/LinX]   | warning: the type `D2D_SIZE_U` does not permit being left uninitialized\n[Rust/LinX]   |    --> src/macros.rs:222:27\n[Rust/LinX]   |     |\n[Rust/LinX]   | 222 |               let mut ret = $crate::_core::mem::uninitialized();\n[Rust/LinX]   |     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |                             |\n[Rust/LinX]   |     |                             this code causes undefined behavior when executed\n[Rust/LinX]   |     |                             help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n[Rust/LinX]   |     |\n[Rust/LinX]   |    ::: src/um/d2d1.rs:635:1\n[Rust/LinX]   |     |\n[Rust/LinX]   | 635 | / RIDL!{#[uuid(0x2cd90694, 0x12e2, 0x11dc, 0x9f, 0xed, 0x00, 0x11, 0x43, 0xa0, 0x55, 0xf9)]\n[Rust/LinX]   | 636 | | interface ID2D1RenderTarget(ID2D1RenderTargetVtbl): ID2D1Resource(ID2D1ResourceVtbl) {\n[Rust/LinX]   | 637 | |     fn CreateBitmap(\n[Rust/LinX]   | 638 | |         size: D2D1_SIZE_U,\n[Rust/LinX]   | ...   |\n[Rust/LinX]   | 856 | |     ) -> BOOL,\n[Rust/LinX]   | 857 | | }}\n[Rust/LinX]   |     | |__- in this macro invocation\n[Rust/LinX]   |     |\n[Rust/LinX]   | note: integers must be initialized (in this struct field)\n[Rust/LinX]   |    --> src/macros.rs:391:15\n[Rust/LinX]   |     |\n[Rust/LinX]   | 391 |               $(pub $field: $ftype,)+\n[Rust/LinX]   |     |                 ^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |\n[Rust/LinX]   |    ::: src/um/dcommon.rs:90:1\n[Rust/LinX]   |     |\n[Rust/LinX]   | 90  | / STRUCT!{struct D2D_SIZE_U {\n[Rust/LinX]   | 91  | |     width: UINT32,\n[Rust/LinX]   | 92  | |     height: UINT32,\n[Rust/LinX]   | 93  | | }}\n[Rust/LinX]   |     | |__- in this macro invocation\n[Rust/LinX]   |     = note: this warning originates in the macro `RIDL` which comes from the expansion of the macro `STRUCT` (in Nightly builds, run with -Z macro-backtrace for more info)\n[Rust/LinX]   | \n[Rust/LinX]   | warning: the type `D3D12_HEAP_DESC` does not permit being left uninitialized\n[Rust/LinX]   |     --> src/macros.rs:222:27\n[Rust/LinX]   |      |\n[Rust/LinX]   | 222  |               let mut ret = $crate::_core::mem::uninitialized();\n[Rust/LinX]   |      |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |      |                             |\n[Rust/LinX]   |      |                             this code causes undefined behavior when executed\n[Rust/LinX]   |      |                             help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n[Rust/LinX]   |      |\n[Rust/LinX]   |     ::: src/um/d3d12.rs:1933:1\n[Rust/LinX]   |      |\n[Rust/LinX]   | 1933 | / RIDL!{#[uuid(0x6b3b2502, 0x6e51, 0x45b3, 0x90, 0xee, 0x98, 0x84, 0x26, 0x5e, 0x8d, 0xf3)]\n[Rust/LinX]   | 1934 | | interface ID3D12Heap(ID3D12HeapVtbl): ID3D12Pageable(ID3D12PageableVtbl) {\n[Rust/LinX]   | 1935 | |     #[fixme] fn GetDesc() -> D3D12_HEAP_DESC,\n[Rust/LinX]   | 1936 | | }}\n[Rust/LinX]   |      | |__- in this macro invocation\n[Rust/LinX]   |      |\n[Rust/LinX]   | note: integers must be initialized (in this struct field)\n[Rust/LinX]   |     --> src/macros.rs:391:15\n[Rust/LinX]   |      |\n[Rust/LinX]   | 391  |               $(pub $field: $ftype,)+\n[Rust/LinX]   |      |                 ^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |      |\n[Rust/LinX]   |     ::: src/um/d3d12.rs:963:1\n[Rust/LinX]   |      |\n[Rust/LinX]   | 963  | / STRUCT!{struct D3D12_HEAP_DESC {\n[Rust/LinX]   | 964  | |     SizeInBytes: UINT64,\n[Rust/LinX]   | 965  | |     Properties: D3D12_HEAP_PROPERTIES,\n[Rust/LinX]   | 966  | |     Alignment: UINT64,\n[Rust/LinX]   | 967  | |     Flags: D3D12_HEAP_FLAGS,\n[Rust/LinX]   | 968  | | }}\n[Rust/LinX]   |      | |__- in this macro invocation\n[Rust/LinX]   |      = note: this warning originates in the macro `RIDL` which comes from the expansion of the macro `STRUCT` (in Nightly builds, run with -Z macro-backtrace for more info)\n[Rust/LinX]   | \n[Rust/LinX]   | warning: the type `D3D12_RESOURCE_DESC` does not permit being left uninitialized\n[Rust/LinX]   |     --> src/macros.rs:222:27\n[Rust/LinX]   |      |\n[Rust/LinX]   | 222  |               let mut ret = $crate::_core::mem::uninitialized();\n[Rust/LinX]   |      |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |      |                             |\n[Rust/LinX]   |      |                             this code causes undefined behavior when executed\n[Rust/LinX]   |      |                             help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n[Rust/LinX]   |      |\n[Rust/LinX]   |     ::: src/um/d3d12.rs:1937:1\n[Rust/LinX]   |      |\n[Rust/LinX]   | 1937 | / RIDL!{#[uuid(0x696442be, 0xa72e, 0x4059, 0xbc, 0x79, 0x5b, 0x5c, 0x98, 0x04, 0x0f, 0xad)]\n[Rust/LinX]   | 1938 | | interface ID3D12Resource(ID3D12ResourceVtbl): ID3D12Pageable(ID3D12PageableVtbl) {\n[Rust/LinX]   | 1939 | |     fn Map(\n[Rust/LinX]   | 1940 | |         Subresource: UINT,\n[Rust/LinX]   | ...    |\n[Rust/LinX]   | 1967 | |     ) -> HRESULT,\n[Rust/LinX]   | 1968 | | }}\n[Rust/LinX]   |      | |__- in this macro invocation\n[Rust/LinX]   |      |\n[Rust/LinX]   | note: integers must be initialized (in this struct field)\n[Rust/LinX]   |     --> src/macros.rs:391:15\n[Rust/LinX]   |      |\n[Rust/LinX]   | 391  |               $(pub $field: $ftype,)+\n[Rust/LinX]   |      |                 ^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |      |\n[Rust/LinX]   |     ::: src/um/d3d12.rs:991:1\n[Rust/LinX]   |      |\n[Rust/LinX]   | 991  | / STRUCT!{struct D3D12_RESOURCE_DESC {\n[Rust/LinX]   | 992  | |     Dimension: D3D12_RESOURCE_DIMENSION,\n[Rust/LinX]   | 993  | |     Alignment: UINT64,\n[Rust/LinX]   | 994  | |     Width: UINT64,\n[Rust/LinX]   | ...    |\n[Rust/LinX]   | 1001 | |     Flags: D3D12_RESOURCE_FLAGS,\n[Rust/LinX]   | 1002 | | }}\n[Rust/LinX]   |      | |__- in this macro invocation\n[Rust/LinX]   |      = note: this warning originates in the macro `RIDL` which comes from the expansion of the macro `STRUCT` (in Nightly builds, run with -Z macro-backtrace for more info)\n[Rust/LinX]   | \n[Rust/LinX]   | warning: the type `D3D12_DESCRIPTOR_HEAP_DESC` does not permit being left uninitialized\n[Rust/LinX]   |     --> src/macros.rs:222:27\n[Rust/LinX]   |      |\n[Rust/LinX]   | 222  |               let mut ret = $crate::_core::mem::uninitialized();\n[Rust/LinX]   |      |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |      |                             |\n[Rust/LinX]   |      |                             this code causes undefined behavior when executed\n[Rust/LinX]   |      |                             help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n[Rust/LinX]   |      |\n[Rust/LinX]   |     ::: src/um/d3d12.rs:1990:1\n[Rust/LinX]   |      |\n[Rust/LinX]   | 1990 | / RIDL!{#[uuid(0x8efb471d, 0x616c, 0x4f49, 0x90, 0xf7, 0x12, 0x7b, 0xb7, 0x63, 0xfa, 0x51)]\n[Rust/LinX]   | 1991 | | interface ID3D12DescriptorHeap(ID3D12DescriptorHeapVtbl): ID3D12Pageable(ID3D12PageableVtbl) {\n[Rust/LinX]   | 1992 | |     #[fixme] fn GetDesc() -> D3D12_DESCRIPTOR_HEAP_DESC,\n[Rust/LinX]   | 1993 | |     #[fixme] fn GetCPUDescriptorHandleForHeapStart() -> D3D12_CPU_DESCRIPTOR_HANDLE,\n[Rust/LinX]   | 1994 | |     #[fixme] fn GetGPUDescriptorHandleForHeapStart() -> D3D12_GPU_DESCRIPTOR_HANDLE,\n[Rust/LinX]   | 1995 | | }}\n[Rust/LinX]   |      | |__- in this macro invocation\n[Rust/LinX]   |      |\n[Rust/LinX]   | note: integers must be initialized (in this struct field)\n[Rust/LinX]   |     --> src/macros.rs:391:15\n[Rust/LinX]   |      |\n[Rust/LinX]   | 391  |               $(pub $field: $ftype,)+\n[Rust/LinX]   |      |                 ^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |      |\n[Rust/LinX]   |     ::: src/um/d3d12.rs:1551:1\n[Rust/LinX]   |      |\n[Rust/LinX]   | 1551 | / STRUCT!{struct D3D12_DESCRIPTOR_HEAP_DESC {\n[Rust/LinX]   | 1552 | |     Type: D3D12_DESCRIPTOR_HEAP_TYPE,\n[Rust/LinX]   | 1553 | |     NumDescriptors: UINT,\n[Rust/LinX]   | 1554 | |     Flags: D3D12_DESCRIPTOR_HEAP_FLAGS,\n[Rust/LinX]   | 1555 | |     NodeMask: UINT,\n[Rust/LinX]   | 1556 | | }}\n[Rust/LinX]   |      | |__- in this macro invocation\n[Rust/LinX]   |      = note: this warning originates in the macro `RIDL` which comes from the expansion of the macro `STRUCT` (in Nightly builds, run with -Z macro-backtrace for more info)\n[Rust/LinX]   | \n[Rust/LinX]   | warning: the type `D3D12_CPU_DESCRIPTOR_HANDLE` does not permit being left uninitialized\n[Rust/LinX]   |     --> src/macros.rs:222:27\n[Rust/LinX]   |      |\n[Rust/LinX]   | 222  |               let mut ret = $crate::_core::mem::uninitialized();\n[Rust/LinX]   |      |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |      |                             |\n[Rust/LinX]   |      |                             this code causes undefined behavior when executed\n[Rust/LinX]   |      |                             help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n[Rust/LinX]   |      |\n[Rust/LinX]   |     ::: src/um/d3d12.rs:1990:1\n[Rust/LinX]   |      |\n[Rust/LinX]   | 1990 | / RIDL!{#[uuid(0x8efb471d, 0x616c, 0x4f49, 0x90, 0xf7, 0x12, 0x7b, 0xb7, 0x63, 0xfa, 0x51)]\n[Rust/LinX]   | 1991 | | interface ID3D12DescriptorHeap(ID3D12DescriptorHeapVtbl): ID3D12Pageable(ID3D12PageableVtbl) {\n[Rust/LinX]   | 1992 | |     #[fixme] fn GetDesc() -> D3D12_DESCRIPTOR_HEAP_DESC,\n[Rust/LinX]   | 1993 | |     #[fixme] fn GetCPUDescriptorHandleForHeapStart() -> D3D12_CPU_DESCRIPTOR_HANDLE,\n[Rust/LinX]   | 1994 | |     #[fixme] fn GetGPUDescriptorHandleForHeapStart() -> D3D12_GPU_DESCRIPTOR_HANDLE,\n[Rust/LinX]   | 1995 | | }}\n[Rust/LinX]   |      | |__- in this macro invocation\n[Rust/LinX]   |      |\n[Rust/LinX]   | note: integers must be initialized (in this struct field)\n[Rust/LinX]   |     --> src/macros.rs:391:15\n[Rust/LinX]   |      |\n[Rust/LinX]   | 391  |               $(pub $field: $ftype,)+\n[Rust/LinX]   |      |                 ^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |      |\n[Rust/LinX]   |     ::: src/um/d3d12.rs:1771:1\n[Rust/LinX]   |      |\n[Rust/LinX]   | 1771 | / STRUCT!{struct D3D12_CPU_DESCRIPTOR_HANDLE {\n[Rust/LinX]   | 1772 | |     ptr: SIZE_T,\n[Rust/LinX]   | 1773 | | }}\n[Rust/LinX]   |      | |__- in this macro invocation\n[Rust/LinX]   |      = note: this warning originates in the macro `RIDL` which comes from the expansion of the macro `STRUCT` (in Nightly builds, run with -Z macro-backtrace for more info)\n[Rust/LinX]   | \n[Rust/LinX]   | warning: the type `D3D12_GPU_DESCRIPTOR_HANDLE` does not permit being left uninitialized\n[Rust/LinX]   |     --> src/macros.rs:222:27\n[Rust/LinX]   |      |\n[Rust/LinX]   | 222  |               let mut ret = $crate::_core::mem::uninitialized();\n[Rust/LinX]   |      |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |      |                             |\n[Rust/LinX]   |      |                             this code causes undefined behavior when executed\n[Rust/LinX]   |      |                             help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n[Rust/LinX]   |      |\n[Rust/LinX]   |     ::: src/um/d3d12.rs:1990:1\n[Rust/LinX]   |      |\n[Rust/LinX]   | 1990 | / RIDL!{#[uuid(0x8efb471d, 0x616c, 0x4f49, 0x90, 0xf7, 0x12, 0x7b, 0xb7, 0x63, 0xfa, 0x51)]\n[Rust/LinX]   | 1991 | | interface ID3D12DescriptorHeap(ID3D12DescriptorHeapVtbl): ID3D12Pageable(ID3D12PageableVtbl) {\n[Rust/LinX]   | 1992 | |     #[fixme] fn GetDesc() -> D3D12_DESCRIPTOR_HEAP_DESC,\n[Rust/LinX]   | 1993 | |     #[fixme] fn GetCPUDescriptorHandleForHeapStart() -> D3D12_CPU_DESCRIPTOR_HANDLE,\n[Rust/LinX]   | 1994 | |     #[fixme] fn GetGPUDescriptorHandleForHeapStart() -> D3D12_GPU_DESCRIPTOR_HANDLE,\n[Rust/LinX]   | 1995 | | }}\n[Rust/LinX]   |      | |__- in this macro invocation\n[Rust/LinX]   |      |\n[Rust/LinX]   | note: integers must be initialized (in this struct field)\n[Rust/LinX]   |     --> src/macros.rs:391:15\n[Rust/LinX]   |      |\n[Rust/LinX]   | 391  |               $(pub $field: $ftype,)+\n[Rust/LinX]   |      |                 ^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |      |\n[Rust/LinX]   |     ::: src/um/d3d12.rs:1774:1\n[Rust/LinX]   |      |\n[Rust/LinX]   | 1774 | / STRUCT!{struct D3D12_GPU_DESCRIPTOR_HANDLE {\n[Rust/LinX]   | 1775 | |     ptr: UINT64,\n[Rust/LinX]   | 1776 | | }}\n[Rust/LinX]   |      | |__- in this macro invocation\n[Rust/LinX]   |      = note: this warning originates in the macro `RIDL` which comes from the expansion of the macro `STRUCT` (in Nightly builds, run with -Z macro-backtrace for more info)\n[Rust/LinX]   | \n[Rust/LinX]   | warning: the type `D3D12_COMMAND_QUEUE_DESC` does not permit being left uninitialized\n[Rust/LinX]   |     --> src/macros.rs:222:27\n[Rust/LinX]   |      |\n[Rust/LinX]   | 222  |               let mut ret = $crate::_core::mem::uninitialized();\n[Rust/LinX]   |      |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |      |                             |\n[Rust/LinX]   |      |                             this code causes undefined behavior when executed\n[Rust/LinX]   |      |                             help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n[Rust/LinX]   |      |\n[Rust/LinX]   |     ::: src/um/d3d12.rs:2297:1\n[Rust/LinX]   |      |\n[Rust/LinX]   | 2297 | / RIDL!{#[uuid(0x0ec870a6, 0x5d7e, 0x4c22, 0x8c, 0xfc, 0x5b, 0xaa, 0xe0, 0x76, 0x16, 0xed)]\n[Rust/LinX]   | 2298 | | interface ID3D12CommandQueue(ID3D12CommandQueueVtbl): ID3D12Pageable(ID3D12PageableVtbl) {\n[Rust/LinX]   | 2299 | |     fn UpdateTileMappings(\n[Rust/LinX]   | 2300 | |         pResource: *mut ID3D12Resource,\n[Rust/LinX]   | ...    |\n[Rust/LinX]   | 2349 | |     #[fixme] fn GetDesc() -> D3D12_COMMAND_QUEUE_DESC,\n[Rust/LinX]   | 2350 | | }}\n[Rust/LinX]   |      | |__- in this macro invocation\n[Rust/LinX]   |      |\n[Rust/LinX]   | note: integers must be initialized (in this struct field)\n[Rust/LinX]   |     --> src/macros.rs:391:15\n[Rust/LinX]   |      |\n[Rust/LinX]   | 391  |               $(pub $field: $ftype,)+\n[Rust/LinX]   |      |                 ^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |      |\n[Rust/LinX]   |     ::: src/um/d3d12.rs:428:1\n[Rust/LinX]   |      |\n[Rust/LinX]   | 428  | / STRUCT!{struct D3D12_COMMAND_QUEUE_DESC {\n[Rust/LinX]   | 429  | |     Type: D3D12_COMMAND_LIST_TYPE,\n[Rust/LinX]   | 430  | |     Priority: INT,\n[Rust/LinX]   | 431  | |     Flags: D3D12_COMMAND_QUEUE_FLAGS,\n[Rust/LinX]   | 432  | |     NodeMask: UINT,\n[Rust/LinX]   | 433  | | }}\n[Rust/LinX]   |      | |__- in this macro invocation\n[Rust/LinX]   |      = note: this warning originates in the macro `RIDL` which comes from the expansion of the macro `STRUCT` (in Nightly builds, run with -Z macro-backtrace for more info)\n[Rust/LinX]   | \n[Rust/LinX]   | warning: the type `D3D12_RESOURCE_ALLOCATION_INFO` does not permit being left uninitialized\n[Rust/LinX]   |     --> src/macros.rs:222:27\n[Rust/LinX]   |      |\n[Rust/LinX]   | 222  |               let mut ret = $crate::_core::mem::uninitialized();\n[Rust/LinX]   |      |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |      |                             |\n[Rust/LinX]   |      |                             this code causes undefined behavior when executed\n[Rust/LinX]   |      |                             help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n[Rust/LinX]   |      |\n[Rust/LinX]   |     ::: src/um/d3d12.rs:2351:1\n[Rust/LinX]   |      |\n[Rust/LinX]   | 2351 | / RIDL!{#[uuid(0x189819f1, 0x1db6, 0x4b57, 0xbe, 0x54, 0x18, 0x21, 0x33, 0x9b, 0x85, 0xf7)]\n[Rust/LinX]   | 2352 | | interface ID3D12Device(ID3D12DeviceVtbl): ID3D12Object(ID3D12ObjectVtbl) {\n[Rust/LinX]   | 2353 | |     fn GetNodeCount() -> UINT,\n[Rust/LinX]   | 2354 | |     fn CreateCommandQueue(\n[Rust/LinX]   | ...    |\n[Rust/LinX]   | 2550 | |     #[fixme] fn GetAdapterLuid() -> LUID,\n[Rust/LinX]   | 2551 | | }}\n[Rust/LinX]   |      | |__- in this macro invocation\n[Rust/LinX]   |      |\n[Rust/LinX]   | note: integers must be initialized (in this struct field)\n[Rust/LinX]   |     --> src/macros.rs:391:15\n[Rust/LinX]   |      |\n[Rust/LinX]   | 391  |               $(pub $field: $ftype,)+\n[Rust/LinX]   |      |                 ^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |      |\n[Rust/LinX]   |     ::: src/um/d3d12.rs:920:1\n[Rust/LinX]   |      |\n[Rust/LinX]   | 920  | / STRUCT!{struct D3D12_RESOURCE_ALLOCATION_INFO {\n[Rust/LinX]   | 921  | |     SizeInBytes: UINT64,\n[Rust/LinX]   | 922  | |     Alignment: UINT64,\n[Rust/LinX]   | 923  | | }}\n[Rust/LinX]   |      | |__- in this macro invocation\n[Rust/LinX]   |      = note: this warning originates in the macro `RIDL` which comes from the expansion of the macro `STRUCT` (in Nightly builds, run with -Z macro-backtrace for more info)\n[Rust/LinX]   | \n[Rust/LinX]   | warning: the type `D3D12_HEAP_PROPERTIES` does not permit being left uninitialized\n[Rust/LinX]   |     --> src/macros.rs:222:27\n[Rust/LinX]   |      |\n[Rust/LinX]   | 222  |               let mut ret = $crate::_core::mem::uninitialized();\n[Rust/LinX]   |      |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |      |                             |\n[Rust/LinX]   |      |                             this code causes undefined behavior when executed\n[Rust/LinX]   |      |                             help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n[Rust/LinX]   |      |\n[Rust/LinX]   |     ::: src/um/d3d12.rs:2351:1\n[Rust/LinX]   |      |\n[Rust/LinX]   | 2351 | / RIDL!{#[uuid(0x189819f1, 0x1db6, 0x4b57, 0xbe, 0x54, 0x18, 0x21, 0x33, 0x9b, 0x85, 0xf7)]\n[Rust/LinX]   | 2352 | | interface ID3D12Device(ID3D12DeviceVtbl): ID3D12Object(ID3D12ObjectVtbl) {\n[Rust/LinX]   | 2353 | |     fn GetNodeCount() -> UINT,\n[Rust/LinX]   | 2354 | |     fn CreateCommandQueue(\n[Rust/LinX]   | ...    |\n[Rust/LinX]   | 2550 | |     #[fixme] fn GetAdapterLuid() -> LUID,\n[Rust/LinX]   | 2551 | | }}\n[Rust/LinX]   |      | |__- in this macro invocation\n[Rust/LinX]   |      |\n[Rust/LinX]   | note: integers must be initialized (in this struct field)\n[Rust/LinX]   |     --> src/macros.rs:391:15\n[Rust/LinX]   |      |\n[Rust/LinX]   | 391  |               $(pub $field: $ftype,)+\n[Rust/LinX]   |      |                 ^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |      |\n[Rust/LinX]   |     ::: src/um/d3d12.rs:941:1\n[Rust/LinX]   |      |\n[Rust/LinX]   | 941  | / STRUCT!{struct D3D12_HEAP_PROPERTIES {\n[Rust/LinX]   | 942  | |     Type: D3D12_HEAP_TYPE,\n[Rust/LinX]   | 943  | |     CPUPageProperty: D3D12_CPU_PAGE_PROPERTY,\n[Rust/LinX]   | 944  | |     MemoryPoolPreference: D3D12_MEMORY_POOL,\n[Rust/LinX]   | 945  | |     CreationNodeMask: UINT,\n[Rust/LinX]   | 946  | |     VisibleNodeMask: UINT,\n[Rust/LinX]   | 947  | | }}\n[Rust/LinX]   |      | |__- in this macro invocation\n[Rust/LinX]   |      = note: this warning originates in the macro `RIDL` which comes from the expansion of the macro `STRUCT` (in Nightly builds, run with -Z macro-backtrace for more info)\n[Rust/LinX]   | \n[Rust/LinX]   | warning: the type `ntdef::LUID` does not permit being left uninitialized\n[Rust/LinX]   |     --> src/macros.rs:222:27\n[Rust/LinX]   |      |\n[Rust/LinX]   | 222  |               let mut ret = $crate::_core::mem::uninitialized();\n[Rust/LinX]   |      |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |      |                             |\n[Rust/LinX]   |      |                             this code causes undefined behavior when executed\n[Rust/LinX]   |      |                             help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n[Rust/LinX]   |      |\n[Rust/LinX]   |     ::: src/um/d3d12.rs:2351:1\n[Rust/LinX]   |      |\n[Rust/LinX]   | 2351 | / RIDL!{#[uuid(0x189819f1, 0x1db6, 0x4b57, 0xbe, 0x54, 0x18, 0x21, 0x33, 0x9b, 0x85, 0xf7)]\n[Rust/LinX]   | 2352 | | interface ID3D12Device(ID3D12DeviceVtbl): ID3D12Object(ID3D12ObjectVtbl) {\n[Rust/LinX]   | 2353 | |     fn GetNodeCount() -> UINT,\n[Rust/LinX]   | 2354 | |     fn CreateCommandQueue(\n[Rust/LinX]   | ...    |\n[Rust/LinX]   | 2550 | |     #[fixme] fn GetAdapterLuid() -> LUID,\n[Rust/LinX]   | 2551 | | }}\n[Rust/LinX]   |      | |__- in this macro invocation\n[Rust/LinX]   |      |\n[Rust/LinX]   | note: integers must be initialized (in this struct field)\n[Rust/LinX]   |     --> src/macros.rs:391:15\n[Rust/LinX]   |      |\n[Rust/LinX]   | 391  |               $(pub $field: $ftype,)+\n[Rust/LinX]   |      |                 ^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |      |\n[Rust/LinX]   |     ::: src/shared/ntdef.rs:230:1\n[Rust/LinX]   |      |\n[Rust/LinX]   | 230  | / STRUCT!{struct LUID {\n[Rust/LinX]   | 231  | |     LowPart: ULONG,\n[Rust/LinX]   | 232  | |     HighPart: LONG,\n[Rust/LinX]   | 233  | | }}\n[Rust/LinX]   |      | |__- in this macro invocation\n[Rust/LinX]   |      = note: this warning originates in the macro `RIDL` which comes from the expansion of the macro `STRUCT` (in Nightly builds, run with -Z macro-backtrace for more info)\n[Rust/LinX]   | \n[Rust/LinX]   | warning: the type `DXVA2_Fixed32` does not permit being left uninitialized\n[Rust/LinX]   |    --> src/um/dxva2api.rs:677:42\n[Rust/LinX]   |     |\n[Rust/LinX]   | 677 |         let mut _fixed_: DXVA2_Fixed32 = ::core::mem::uninitialized();\n[Rust/LinX]   |     |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |                                          |\n[Rust/LinX]   |     |                                          this code causes undefined behavior when executed\n[Rust/LinX]   |     |                                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n[Rust/LinX]   |     |\n[Rust/LinX]   | note: integers must be initialized (in this struct field)\n[Rust/LinX]   |    --> src/macros.rs:286:26\n[Rust/LinX]   |     |\n[Rust/LinX]   | 286 |           pub struct $name([$stype; $ssize]);\n[Rust/LinX]   |     |                            ^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |\n[Rust/LinX]   |    ::: src/um/dxva2api.rs:334:1\n[Rust/LinX]   |     |\n[Rust/LinX]   | 334 | / UNION!{union DXVA2_Fixed32 {\n[Rust/LinX]   | 335 | |     [u32; 1],\n[Rust/LinX]   | 336 | |     s s_mut: DXVA2_Fixed32_s,\n[Rust/LinX]   | 337 | |     ll s_ll: LONG,\n[Rust/LinX]   | 338 | | }}\n[Rust/LinX]   |     | |__- in this macro invocation\n[Rust/LinX]   |     = note: this warning originates in the macro `UNION` (in Nightly builds, run with -Z macro-backtrace for more info)\n[Rust/LinX]   | \n[Rust/LinX]   | warning: the type `DXVA2_Fixed32` does not permit being left uninitialized\n[Rust/LinX]   |    --> src/um/dxva2api.rs:692:42\n[Rust/LinX]   |     |\n[Rust/LinX]   | 692 |         let mut _fixed_: DXVA2_Fixed32 = ::core::mem::uninitialized();\n[Rust/LinX]   |     |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |                                          |\n[Rust/LinX]   |     |                                          this code causes undefined behavior when executed\n[Rust/LinX]   |     |                                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n[Rust/LinX]   |     |\n[Rust/LinX]   | note: integers must be initialized (in this struct field)\n[Rust/LinX]   |    --> src/macros.rs:286:26\n[Rust/LinX]   |     |\n[Rust/LinX]   | 286 |           pub struct $name([$stype; $ssize]);\n[Rust/LinX]   |     |                            ^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |\n[Rust/LinX]   |    ::: src/um/dxva2api.rs:334:1\n[Rust/LinX]   |     |\n[Rust/LinX]   | 334 | / UNION!{union DXVA2_Fixed32 {\n[Rust/LinX]   | 335 | |     [u32; 1],\n[Rust/LinX]   | 336 | |     s s_mut: DXVA2_Fixed32_s,\n[Rust/LinX]   | 337 | |     ll s_ll: LONG,\n[Rust/LinX]   | 338 | | }}\n[Rust/LinX]   |     | |__- in this macro invocation\n[Rust/LinX]   |     = note: this warning originates in the macro `UNION` (in Nightly builds, run with -Z macro-backtrace for more info)\n[Rust/LinX]   | \n[Rust/LinX]   | warning: the type `DXVA2_Fixed32` does not permit being left uninitialized\n[Rust/LinX]   |    --> src/um/dxva2api.rs:701:42\n[Rust/LinX]   |     |\n[Rust/LinX]   | 701 |         let mut _fixed_: DXVA2_Fixed32 = ::core::mem::uninitialized();\n[Rust/LinX]   |     |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |                                          |\n[Rust/LinX]   |     |                                          this code causes undefined behavior when executed\n[Rust/LinX]   |     |                                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n[Rust/LinX]   |     |\n[Rust/LinX]   | note: integers must be initialized (in this struct field)\n[Rust/LinX]   |    --> src/macros.rs:286:26\n[Rust/LinX]   |     |\n[Rust/LinX]   | 286 |           pub struct $name([$stype; $ssize]);\n[Rust/LinX]   |     |                            ^^^^^^^^^^^^^^^^\n[Rust/LinX]   |     |\n[Rust/LinX]   |    ::: src/um/dxva2api.rs:334:1\n[Rust/LinX]   |     |\n[Rust/LinX]   | 334 | / UNION!{union DXVA2_Fixed32 {\n[Rust/LinX]   | 335 | |     [u32; 1],\n[Rust/LinX]   | 336 | |     s s_mut: DXVA2_Fixed32_s,\n[Rust/LinX]   | 337 | |     ll s_ll: LONG,\n[Rust/LinX]   | 338 | | }}\n[Rust/LinX]   |     | |__- in this macro invocation\n[Rust/LinX]   |     = note: this warning originates in the macro `UNION` (in Nightly builds, run with -Z macro-backtrace for more info)\n[Rust/LinX]   | \n[Rust/Lin ]   | info: installing component 'rust-std'\n[Rust/Lin ]   | info: installing component 'rustc'\n[Rust/LinX]   | warning: `winapi` (lib) generated 24 warnings (2 duplicates)\n[Rust/LinX]   |     Finished release [optimized] target(s) in 17.44s\n[Rust/LinX]   \u2705  Success - Main Build\n[Rust/LinX] \ud83c\udfc1  Job succeeded\n[Rust/Lin ]   | \n[Rust/Lin ]   |   nightly-x86_64-unknown-linux-gnu installed - rustc 1.72.0-nightly (498553fc0 2023-05-29)\n[Rust/Lin ]   | \n[Rust/Lin ]   | info: default toolchain set to 'nightly-x86_64-unknown-linux-gnu'\n[Rust/Lin ]   | info: checking for self-update\n[Rust/Lin ]   | [command]/home/runneradmin/.cargo/bin/rustup default nightly\n[Rust/Lin ]   | info: using existing install for 'nightly-x86_64-unknown-linux-gnu'\n[Rust/Lin ]   | info: default toolchain set to 'nightly-x86_64-unknown-linux-gnu'\n[Rust/Lin ]   | \n[Rust/Lin ]   |   nightly-x86_64-unknown-linux-gnu unchanged - rustc 1.72.0-nightly (498553fc0 2023-05-29)\n[Rust/Lin ]   | \n[Rust/Lin ]   \u2753  ::group::Gathering installed versions\n[Rust/Lin ]   | [command]/home/runneradmin/.cargo/bin/rustc -V\n[Rust/Lin ]   | rustc 1.72.0-nightly (498553fc0 2023-05-29)\n[Rust/Lin ]   \u2699  ::set-output:: rustc=1.72.0-nightly (498553fc0 2023-05-29)\n[Rust/Lin ]   \u2699  ::set-output:: rustc_hash=498553fc0\n[Rust/Lin ]   | [command]/home/runneradmin/.cargo/bin/cargo -V\n[Rust/Lin ]   | cargo 1.72.0-nightly (64fb38c97 2023-05-23)\n[Rust/Lin ]   \u2699  ::set-output:: cargo=1.72.0-nightly (64fb38c97 2023-05-23)\n[Rust/Lin ]   | [command]/home/runneradmin/.cargo/bin/rustup -V\n[Rust/Lin ]   | rustup 1.26.0 (5af9b9484 2023-04-05)\n[Rust/Lin ]   | info: This is the version for the rustup toolchain manager, not the rustc compiler.\n[Rust/Lin ]   | info: The currently active `rustc` version is `rustc 1.72.0-nightly (498553fc0 2023-05-29)`\n[Rust/Lin ]   \u2699  ::set-output:: rustup=1.26.0 (5af9b9484 2023-04-05)\n[Rust/Lin ]   \u2753  ::endgroup::\n[Rust/Lin ]   \u2705  Success - Main actions-rs/toolchain@v1\n[Rust/Lin ]   \u2699  ::add-path:: /home/runneradmin/.cargo/bin\n[Rust/Lin ] \u2b50 Run Main Build\n[Rust/Lin ]   \ud83d\udc33  docker exec cmd=[bash --noprofile --norc -e -o pipefail /var/run/act/workflow/2] user= workdir=\n[Rust/WinX] failed to remove container: Delete \"http://%2Fvar%2Frun%2Fdocker.sock/v1.41/containers/c71faef937501e972c033c77808ebdf4b0815d9a5155962bdf0744858aa30453?force=1&v=1\": context deadline exceeded\n[Rust/WinX] \ud83c\udfc1  Job failed\n[Rust/Win ] failed to remove container: Delete \"http://%2Fvar%2Frun%2Fdocker.sock/v1.41/containers/7fce23cfdf7ddc7311c74ae6b087a9b6bf69bcc17d70bfae0ed373eb94b5e9dc?force=1&v=1\": context deadline exceeded\n[Rust/Win ] \ud83c\udfc1  Job failed\n[Rust/Lin ]   |    Compiling winapi v0.3.9 (/tmp/c1e8dd3a-fec2-11ed-a890-af2cc187fc11/retep998-winapi-rs)\n[Rust/Lin ]   |     Finished dev [unoptimized + debuginfo] target(s) in 1.21s\n[Rust/Lin ]   |    Compiling winapi v0.3.9 (/tmp/c1e8dd3a-fec2-11ed-a890-af2cc187fc11/retep998-winapi-rs)\n[Rust/Lin ]   |     Finished dev [unoptimized + debuginfo] target(s) in 1.18s\n[Rust/Lin ]   |    Compiling winapi v0.3.9 (/tmp/c1e8dd3a-fec2-11ed-a890-af2cc187fc11/retep998-winapi-rs)\n[Rust/Lin ]   |     Finished release [optimized] target(s) in 1.25s\n[Rust/Lin ]   \u2705  Success - Main Build\n[Rust/Lin ] \ud83c\udfc1  Job succeeded\n",
    "actions_stderr": "Error: Error occurred running finally: Error occurred running finally: context deadline exceeded (original error: <nil>) (original error: <nil>)\n"
}